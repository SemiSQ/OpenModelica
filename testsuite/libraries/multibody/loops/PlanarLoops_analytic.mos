// name:     Modelica3.x.Mechanics.MultiBody.Examples.Loops.PlanarLoops_analytic
// keywords: multibody, balancing, instantiation
// status:   correct
// teardown_command: rm -f *.so *.dll *.log *.c* *.makefile *.libs
// 
//  Modelica MultiBody 3.x: instantiation and balance checking
//

loadFile("_LoopsTotal.mo");
getErrorString();
instantiateModel(Modelica.Mechanics.MultiBody.Examples.Loops.PlanarLoops_analytic);
getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Examples.Loops.PlanarLoops_analytic);
getErrorString();

// Result:
// true
// ""
// "function Modelica.Math.Vectors.length
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize
//   input Real[:] v \"Vector\";
//   input Real eps = 1e-13 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
// external \"C\";
// end Modelica.Math.asin;
// 
// function Modelica.Math.atan2
//   input Real u1;
//   input Real u2;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
// external \"C\";
// end Modelica.Math.atan2;
// 
// function Modelica.Math.cos
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
// external \"C\";
// end Modelica.Math.cos;
// 
// function Modelica.Math.sin
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
// external \"C\";
// end Modelica.Math.sin;
// 
// function Modelica.Mechanics.MultiBody.Frames.Internal.maxWithoutEvent
//   input Real u1;
//   input Real u2;
//   output Real y;
//   protected Integer dummy;
// algorithm
//   y := if u1 > u2 then u1 else u2;
//   dummy := 0;
// end Modelica.Mechanics.MultiBody.Frames.Internal.maxWithoutEvent;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
// input Real[3, 3] T;
// input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
// output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation.equalityConstraint \"Inline before index reduction\"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R1 \"Orientation object to rotate frame 0 into frame 1\";
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R2 \"Orientation object to rotate frame 0 into frame 2\";
//   output Real[3] residue \"The rotation angles around x-, y-, and z-axis of frame 1 to rotate frame 1 into frame 2 for a small rotation (should be zero)\";
// algorithm
//   residue := {atan2((R1.T[1,2] * R1.T[2,3] - R1.T[1,3] * R1.T[2,2]) * R2.T[2,1] + (R1.T[1,3] * R1.T[2,1] - R1.T[1,1] * R1.T[2,3]) * R2.T[2,2] + (R1.T[1,1] * R1.T[2,2] - R1.T[1,2] * R1.T[2,1]) * R2.T[2,3],R1.T[1,1] * R2.T[1,1] + R1.T[1,2] * R2.T[1,2] + R1.T[1,3] * R2.T[1,3]),atan2((R1.T[1,3] * R1.T[2,2] - R1.T[1,2] * R1.T[2,3]) * R2.T[1,1] + (R1.T[1,1] * R1.T[2,3] - R1.T[1,3] * R1.T[2,1]) * R2.T[1,2] + (R1.T[1,2] * R1.T[2,1] - R1.T[1,1] * R1.T[2,2]) * R2.T[1,3],R1.T[2,1] * R2.T[2,1] + R1.T[2,2] * R2.T[2,2] + R1.T[2,3] * R2.T[2,3]),atan2(R1.T[2,1] * R2.T[1,1] + R1.T[2,2] * R2.T[1,2] + R1.T[2,3] * R2.T[1,3],R1.T[3,1] * R2.T[3,1] + R1.T[3,2] * R2.T[3,2] + R1.T[3,3] * R2.T[3,3])};
// end Modelica.Mechanics.MultiBody.Frames.Orientation.equalityConstraint;
// 
// function Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2
//   input Real[4] Q \"Quaternions orientation object to rotate frame 1 into frame 2\";
//   input Real[4] der_Q(unit = \"1/s\") \"Derivative of Q\";
//   output Real[3] w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity of frame 2 with respect to frame 1 resolved in frame 2\";
// algorithm
//   w := {2.0 * (Q[4] * der_Q[1] + Q[3] * der_Q[2] + -Q[2] * der_Q[3] + -Q[1] * der_Q[4]),2.0 * (-Q[3] * der_Q[1] + Q[4] * der_Q[2] + Q[1] * der_Q[3] + -Q[2] * der_Q[4]),2.0 * (Q[2] * der_Q[1] + -Q[1] * der_Q[2] + Q[4] * der_Q[3] + -Q[3] * der_Q[4])};
// end Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2;
// 
// function Modelica.Mechanics.MultiBody.Frames.Quaternions.from_T
//   input Real[3, 3] T \"Transformation matrix to transform vector from frame 1 to frame 2 (v2=T*v1)\";
//   input Real[4] Q_guess = {0.0,0.0,0.0,1.0} \"Guess value for Q (there are 2 solutions; the one close to Q_guess is used\";
//   output Real[4] Q \"Quaternions orientation object to rotate frame 1 into frame 2 (Q and -Q have same transformation matrix)\";
//   protected Real paux;
//   protected Real paux4;
//   protected Real c1;
//   protected Real c2;
//   protected Real c3;
//   protected Real c4;
//   protected constant Real p4limit = 0.1;
//   protected constant Real c4limit = 0.04;
// algorithm
//   c1 := (1.0 + T[1,1]) - T[2,2] - T[3,3];
//   c2 := (1.0 + T[2,2]) - T[1,1] - T[3,3];
//   c3 := (1.0 + T[3,3]) - T[1,1] - T[2,2];
//   c4 := 1.0 + T[1,1] + T[2,2] + T[3,3];
//   if c4 > 0.04 OR c4 > c1 AND c4 > c2 AND c4 > c3 then
//     paux := sqrt(c4) / 2.0;
//     paux4 := 4.0 * paux;
//     Q := {(T[2,3] - T[3,2]) / paux4,(T[3,1] - T[1,3]) / paux4,(T[1,2] - T[2,1]) / paux4,paux};
//   elseif c1 > c2 AND c1 > c3 AND c1 > c4 then
//     paux := sqrt(c1) / 2.0;
//     paux4 := 4.0 * paux;
//     Q := {paux,(T[1,2] + T[2,1]) / paux4,(T[1,3] + T[3,1]) / paux4,(T[2,3] - T[3,2]) / paux4};
//   elseif c2 > c1 AND c2 > c3 AND c2 > c4 then
//     paux := sqrt(c2) / 2.0;
//     paux4 := 4.0 * paux;
//     Q := {(T[1,2] + T[2,1]) / paux4,paux,(T[2,3] + T[3,2]) / paux4,(T[3,1] - T[1,3]) / paux4};
//   else
//     paux := sqrt(c3) / 2.0;
//     paux4 := 4.0 * paux;
//     Q := {(T[1,3] + T[3,1]) / paux4,(T[2,3] + T[3,2]) / paux4,paux,(T[1,2] - T[2,1]) / paux4};
//   end if;
//   if Q[1] * Q_guess[1] + Q[2] * Q_guess[2] + Q[3] * Q_guess[3] + Q[4] * Q_guess[4] < 0.0 then
//     Q := -{Q[1],Q[2],Q[3],Q[4]};
//   end if;
// end Modelica.Mechanics.MultiBody.Frames.Quaternions.from_T;
// 
// function Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation
//   output Real[4] Q \"Quaternions orientation object to rotate frame 1 into frame 2\";
// algorithm
//   Q := {0.0,0.0,0.0,1.0};
// end Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint \"Inline before index reduction\"
//   input Real[4] Q \"Quaternions orientation object to rotate frame 1 into frame 2\";
//   output Real[1] residue \"Residue constraint (shall be zero)\";
// algorithm
//   residue := {(Q[1] ^ 2.0 + Q[2] ^ 2.0 + Q[3] ^ 2.0 + Q[4] ^ 2.0) - 1.0};
// end Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation
//   input Real[3, 3] T1 \"Orientation object to rotate frame 0 into frame 1\";
//   input Real[3, 3] T_rel \"Orientation object to rotate frame 1 into frame 2\";
//   output Real[3, 3] T2 \"Orientation object to rotate frame 0 into frame 2\";
// algorithm
//   T2 := <matrix>[T_rel[1,1] * T1[1,1] + T_rel[1,2] * T1[2,1] + T_rel[1,3] * T1[3,1],T_rel[1,1] * T1[1,2] + T_rel[1,2] * T1[2,2] + T_rel[1,3] * T1[3,2],T_rel[1,1] * T1[1,3] + T_rel[1,2] * T1[2,3] + T_rel[1,3] * T1[3,3];T_rel[2,1] * T1[1,1] + T_rel[2,2] * T1[2,1] + T_rel[2,3] * T1[3,1],T_rel[2,1] * T1[1,2] + T_rel[2,2] * T1[2,2] + T_rel[2,3] * T1[3,2],T_rel[2,1] * T1[1,3] + T_rel[2,2] * T1[2,3] + T_rel[2,3] * T1[3,3];T_rel[3,1] * T1[1,1] + T_rel[3,2] * T1[2,1] + T_rel[3,3] * T1[3,1],T_rel[3,1] * T1[1,2] + T_rel[3,2] * T1[2,2] + T_rel[3,3] * T1[3,2],T_rel[3,1] * T1[1,3] + T_rel[3,2] * T1[2,3] + T_rel[3,3] * T1[3,3]];
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation
//   input Integer axis(min = 1, max = 3) \"Rotate around 'axis' of frame 1\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along 'axis' of frame 1\";
//   output Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   T := if axis == 1 then <matrix>[1.0,0.0,0.0;0.0,cos(angle),sin(angle);0.0,-sin(angle),cos(angle)] else if axis == 2 then <matrix>[cos(angle),0.0,-sin(angle);0.0,1.0,0.0;sin(angle),0.0,cos(angle)] else <matrix>[cos(angle),sin(angle),0.0;-sin(angle),cos(angle),0.0;0.0,0.0,1.0];
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy
//   input Real[3] n_x(unit = \"1\") \"Vector in direction of x-axis of frame 2, resolved in frame 1\";
//   input Real[3] n_y(unit = \"1\") \"Vector in direction of y-axis of frame 2, resolved in frame 1\";
//   output Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   protected Real abs_n_x = sqrt(n_x[1] ^ 2.0 + (n_x[2] ^ 2.0 + n_x[3] ^ 2.0));
//   protected Real[3] e_x(unit = \"1\") = if abs_n_x < 1e-10 then {1.0,0.0,0.0} else {n_x[1] / abs_n_x,n_x[2] / abs_n_x,n_x[3] / abs_n_x};
//   protected Real[3] n_z_aux(unit = \"1\") = {e_x[2] * n_y[3] - e_x[3] * n_y[2],e_x[3] * n_y[1] - e_x[1] * n_y[3],e_x[1] * n_y[2] - e_x[2] * n_y[1]};
//   protected Real[3] n_y_aux(unit = \"1\") = if n_z_aux[1] ^ 2.0 + (n_z_aux[2] ^ 2.0 + n_z_aux[3] ^ 2.0) > 1e-06 then {n_y[1],n_y[2],n_y[3]} else DAE.CAST(/tp:REAL[3]/, if abs(e_x[1]) > 1e-06 then {0,1,0} else {1,0,0});
//   protected Real[3] e_z_aux(unit = \"1\") = {e_x[2] * n_y_aux[3] - e_x[3] * n_y_aux[2],e_x[3] * n_y_aux[1] - e_x[1] * n_y_aux[3],e_x[1] * n_y_aux[2] - e_x[2] * n_y_aux[1]};
//   protected Real[3] e_z(unit = \"1\") = {e_z_aux[1] / sqrt(e_z_aux[1] ^ 2.0 + (e_z_aux[2] ^ 2.0 + e_z_aux[3] ^ 2.0)),e_z_aux[2] / sqrt(e_z_aux[1] ^ 2.0 + (e_z_aux[2] ^ 2.0 + e_z_aux[3] ^ 2.0)),e_z_aux[3] / sqrt(e_z_aux[1] ^ 2.0 + (e_z_aux[2] ^ 2.0 + e_z_aux[3] ^ 2.0))};
// algorithm
//   T := <matrix>[e_x[1],e_x[2],e_x[3];e_z[2] * e_x[3] - e_z[3] * e_x[2],e_z[3] * e_x[1] - e_z[1] * e_x[3],e_z[1] * e_x[2] - e_z[2] * e_x[1];e_z[1],e_z[2],e_z[3]];
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.planarRotation
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation (must have length=1)\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e\";
//   output Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   T := <matrix>[e[1] ^ 2.0 + cos(angle) * (1.0 - e[1] ^ 2.0),(e[1] * e[2] + cos(angle) * -e[1] * e[2]) - -sin(angle) * e[3],(e[1] * e[3] + cos(angle) * -e[1] * e[3]) - sin(angle) * e[2];(e[2] * e[1] + cos(angle) * -e[2] * e[1]) - sin(angle) * e[3],e[2] ^ 2.0 + cos(angle) * (1.0 - e[2] ^ 2.0),(e[2] * e[3] + cos(angle) * -e[2] * e[3]) - -sin(angle) * e[1];(e[3] * e[1] + cos(angle) * -e[3] * e[1]) - -sin(angle) * e[2],(e[3] * e[2] + cos(angle) * -e[3] * e[2]) - sin(angle) * e[1],e[3] ^ 2.0 + cos(angle) * (1.0 - e[3] ^ 2.0)];
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.planarRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v1 \"Vector in frame 1\";
//   output Real[3] v2 \"Vector in frame 2\";
// algorithm
//   v2 := {T[1,1] * v1[1] + T[1,2] * v1[2] + T[1,3] * v1[3],T[2,1] * v1[1] + T[2,2] * v1[2] + T[2,3] * v1[3],T[3,1] * v1[1] + T[3,2] * v1[2] + T[3,3] * v1[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2;
// 
// function Modelica.Mechanics.MultiBody.Frames.absoluteRotation
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R1 \"Orientation object to rotate frame 0 into frame 1\";
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R_rel \"Orientation object to rotate frame 1 into frame 2\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R2 \"Orientation object to rotate frame 0 into frame 2\";
// algorithm
//   R2 := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[R_rel.T[1,1] * R1.T[1,1] + R_rel.T[1,2] * R1.T[2,1] + R_rel.T[1,3] * R1.T[3,1],R_rel.T[1,1] * R1.T[1,2] + R_rel.T[1,2] * R1.T[2,2] + R_rel.T[1,3] * R1.T[3,2],R_rel.T[1,1] * R1.T[1,3] + R_rel.T[1,2] * R1.T[2,3] + R_rel.T[1,3] * R1.T[3,3];R_rel.T[2,1] * R1.T[1,1] + R_rel.T[2,2] * R1.T[2,1] + R_rel.T[2,3] * R1.T[3,1],R_rel.T[2,1] * R1.T[1,2] + R_rel.T[2,2] * R1.T[2,2] + R_rel.T[2,3] * R1.T[3,2],R_rel.T[2,1] * R1.T[1,3] + R_rel.T[2,2] * R1.T[2,3] + R_rel.T[2,3] * R1.T[3,3];R_rel.T[3,1] * R1.T[1,1] + R_rel.T[3,2] * R1.T[2,1] + R_rel.T[3,3] * R1.T[3,1],R_rel.T[3,1] * R1.T[1,2] + R_rel.T[3,2] * R1.T[2,2] + R_rel.T[3,3] * R1.T[3,2],R_rel.T[3,1] * R1.T[1,3] + R_rel.T[3,2] * R1.T[2,3] + R_rel.T[3,3] * R1.T[3,3]],Modelica.Mechanics.MultiBody.Frames.resolve2(R_rel,{R1.w[1],R1.w[2],R1.w[3]}) + {R_rel.w[1],R_rel.w[2],R_rel.w[3]});
// end Modelica.Mechanics.MultiBody.Frames.absoluteRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.angularVelocity2 \"Inline before index reduction\"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   output Real[3] w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity of frame 2 with respect to frame 1 resolved in frame 2\";
// algorithm
//   w := {R.w[1],R.w[2],R.w[3]};
// end Modelica.Mechanics.MultiBody.Frames.angularVelocity2;
// 
// function Modelica.Mechanics.MultiBody.Frames.axesRotations
//   input Integer[3] sequence = {1,2,3} \"Sequence of rotations from frame 1 to frame 2 along axis sequence[i]\";
//   input Real[3] angles(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angles around the axes defined in 'sequence'\";
//   input Real[3] der_angles(quantity = \"AngularVelocity\", unit = \"rad/s\") \"= der(angles)\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[3],angles[3]) * Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[2],angles[2]) * Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[1],angles[1]),Modelica.Mechanics.MultiBody.Frames.axis(sequence[3]) * der_angles[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[3],angles[3]),Modelica.Mechanics.MultiBody.Frames.axis(sequence[2]) * der_angles[2]) + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[3],angles[3]) * Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[2],angles[2]),Modelica.Mechanics.MultiBody.Frames.axis(sequence[1]) * der_angles[1]));
// end Modelica.Mechanics.MultiBody.Frames.axesRotations;
// 
// function Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   input Integer[3] sequence = {1,2,3} \"Sequence of rotations from frame 1 to frame 2 along axis sequence[i]\";
//   input Real guessAngle1(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Select angles[1] such that |angles[1] - guessAngle1| is a minimum\";
//   output Real[3] angles(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angles around the axes defined in 'sequence' such that R=Frames.axesRotation(sequence,angles); -pi < angles[i] <= pi\";
//   protected Real[3] e1_1(unit = \"1\") \"First rotation axis, resolved in frame 1\";
//   protected Real[3] e2_1a(unit = \"1\") \"Second rotation axis, resolved in frame 1a\";
//   protected Real[3] e3_1(unit = \"1\") \"Third rotation axis, resolved in frame 1\";
//   protected Real[3] e3_2(unit = \"1\") \"Third rotation axis, resolved in frame 2\";
//   protected Real A \"Coefficient A in the equation A*cos(angles[1])+B*sin(angles[1]) = 0\";
//   protected Real B \"Coefficient B in the equation A*cos(angles[1])+B*sin(angles[1]) = 0\";
//   protected Real angle_1a(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Solution 1 for angles[1]\";
//   protected Real angle_1b(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Solution 2 for angles[1]\";
//   protected Real[3, 3] T_1a \"Orientation object to rotate frame 1 into frame 1a\";
// algorithm
//   assert( sequence[1] <> sequence[2] AND sequence[2] <> sequence[3], \"input argument 'sequence[1:3]' is not valid\");
//   e1_1 := /*/tp:REAL[3]/*/(if sequence[1] == 1 then {1,0,0} else if sequence[1] == 2 then {0,1,0} else {0,0,1});
//   e2_1a := /*/tp:REAL[3]/*/(if sequence[2] == 1 then {1,0,0} else if sequence[2] == 2 then {0,1,0} else {0,0,1});
//   e3_1 := {R.T[sequence[3],1],R.T[sequence[3],2],R.T[sequence[3],3]};
//   e3_2 := /*/tp:REAL[3]/*/(if sequence[3] == 1 then {1,0,0} else if sequence[3] == 2 then {0,1,0} else {0,0,1});
//   A := e2_1a[1] * e3_1[1] + e2_1a[2] * e3_1[2] + e2_1a[3] * e3_1[3];
//   B := (e1_1[2] * e2_1a[3] - e1_1[3] * e2_1a[2]) * e3_1[1] + (e1_1[3] * e2_1a[1] - e1_1[1] * e2_1a[3]) * e3_1[2] + (e1_1[1] * e2_1a[2] - e1_1[2] * e2_1a[1]) * e3_1[3];
//   if abs(A) <= 1e-12 AND abs(B) <= 1e-12 then
//     angles[1] := guessAngle1;
//   else
//     angle_1a := atan2(A,-B);
//     angle_1b := atan2(-A,B);
//     angles[1] := if abs(angle_1a - guessAngle1) <= abs(angle_1b - guessAngle1) then angle_1a else angle_1b;
//   end if;
//   T_1a := Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.planarRotation({e1_1[1],e1_1[2],e1_1[3]},angles[1]);
//   angles[2] := Modelica.Mechanics.MultiBody.Frames.planarRotationAngle({e2_1a[1],e2_1a[2],e2_1a[3]},Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2(<matrix>[T_1a[1,1],T_1a[1,2],T_1a[1,3];T_1a[2,1],T_1a[2,2],T_1a[2,3];T_1a[3,1],T_1a[3,2],T_1a[3,3]],{e3_1[1],e3_1[2],e3_1[3]}),{e3_2[1],e3_2[2],e3_2[3]});
//   angles[3] := Modelica.Mechanics.MultiBody.Frames.planarRotationAngle({e3_2[1],e3_2[2],e3_2[3]},{e2_1a[1],e2_1a[2],e2_1a[3]},Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2(<matrix>[R.T[1,1],R.T[1,2],R.T[1,3];R.T[2,1],R.T[2,2],R.T[2,3];R.T[3,1],R.T[3,2],R.T[3,3]],Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1(<matrix>[T_1a[1,1],T_1a[1,2],T_1a[1,3];T_1a[2,1],T_1a[2,2],T_1a[2,3];T_1a[3,1],T_1a[3,2],T_1a[3,3]],{e2_1a[1],e2_1a[2],e2_1a[3]})));
// end Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles;
// 
// function Modelica.Mechanics.MultiBody.Frames.axis
//   input Integer axis(min = 1, max = 3) \"Axis vector to be returned\";
//   output Real[3] e(unit = \"1\") \"Unit axis vector\";
// algorithm
//   e := /*/tp:REAL[3]/*/(if axis == 1 then {1,0,0} else if axis == 2 then {0,1,0} else {0,0,1});
// end Modelica.Mechanics.MultiBody.Frames.axis;
// 
// function Modelica.Mechanics.MultiBody.Frames.from_Q
//   input Real[4] Q \"Quaternions orientation object to rotate frame 1 into frame 2\";
//   input Real[3] w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity from frame 2 with respect to frame 1, resolved in frame 2\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[2.0 * (Q[1] ^ 2.0 + Q[4] ^ 2.0) - 1.0,2.0 * (Q[1] * Q[2] + Q[3] * Q[4]),2.0 * (Q[1] * Q[3] - Q[2] * Q[4]);2.0 * (Q[2] * Q[1] - Q[3] * Q[4]),2.0 * (Q[2] ^ 2.0 + Q[4] ^ 2.0) - 1.0,2.0 * (Q[2] * Q[3] + Q[1] * Q[4]);2.0 * (Q[3] * Q[1] + Q[2] * Q[4]),2.0 * (Q[3] * Q[2] - Q[1] * Q[4]),2.0 * (Q[3] ^ 2.0 + Q[4] ^ 2.0) - 1.0],{w[1],w[2],w[3]});
// end Modelica.Mechanics.MultiBody.Frames.from_Q;
// 
// function Modelica.Mechanics.MultiBody.Frames.from_T
//   input Real[3, 3] T \"Transformation matrix to transform vector from frame 1 to frame 2 (v2=T*v1)\";
//   input Real[3] w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity from frame 2 with respect to frame 1, resolved in frame 2 (skew(w)=T*der(transpose(T)))\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[T[1,1],T[1,2],T[1,3];T[2,1],T[2,2],T[2,3];T[3,1],T[3,2],T[3,3]],{w[1],w[2],w[3]});
// end Modelica.Mechanics.MultiBody.Frames.from_T;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.planarRotation
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation (must have length=1)\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e\";
//   input Real der_angle(quantity = \"AngularVelocity\", unit = \"rad/s\") \"= der(angle)\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[e[1] ^ 2.0 + cos(angle) * (1.0 - e[1] ^ 2.0),(e[1] * e[2] + cos(angle) * -e[1] * e[2]) - -sin(angle) * e[3],(e[1] * e[3] + cos(angle) * -e[1] * e[3]) - sin(angle) * e[2];(e[2] * e[1] + cos(angle) * -e[2] * e[1]) - sin(angle) * e[3],e[2] ^ 2.0 + cos(angle) * (1.0 - e[2] ^ 2.0),(e[2] * e[3] + cos(angle) * -e[2] * e[3]) - -sin(angle) * e[1];(e[3] * e[1] + cos(angle) * -e[3] * e[1]) - -sin(angle) * e[2],(e[3] * e[2] + cos(angle) * -e[3] * e[2]) - sin(angle) * e[1],e[3] ^ 2.0 + cos(angle) * (1.0 - e[3] ^ 2.0)],{der_angle * e[1],der_angle * e[2],der_angle * e[3]});
// end Modelica.Mechanics.MultiBody.Frames.planarRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.planarRotationAngle
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation to rotate frame 1 around e into frame 2 (must have length=1)\";
//   input Real[3] v1 \"A vector v resolved in frame 1 (shall not be parallel to e)\";
//   input Real[3] v2 \"Vector v resolved in frame 2, i.e., v2 = resolve2(planarRotation(e,angle),v1)\";
//   output Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e in the range: -pi <= angle <= pi\";
// algorithm
//   angle := atan2((e[3] * v1[2] - e[2] * v1[3]) * v2[1] + (e[1] * v1[3] - e[3] * v1[1]) * v2[2] + (e[2] * v1[1] - e[1] * v1[2]) * v2[3],(v1[1] * v2[1] + v1[2] * v2[2] + v1[3] * v2[3]) - (e[1] * v1[1] + e[2] * v1[2] + e[3] * v1[3]) * (e[1] * v2[1] + e[2] * v2[2] + e[3] * v2[3]));
// end Modelica.Mechanics.MultiBody.Frames.planarRotationAngle;
// 
// function Modelica.Mechanics.MultiBody.Frames.resolve1
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {R.T[1,1] * v2[1] + R.T[2,1] * v2[2] + R.T[3,1] * v2[3],R.T[1,2] * v2[1] + R.T[2,2] * v2[2] + R.T[3,2] * v2[3],R.T[1,3] * v2[1] + R.T[2,3] * v2[2] + R.T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.resolve2
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v1 \"Vector in frame 1\";
//   output Real[3] v2 \"Vector in frame 2\";
// algorithm
//   v2 := {R.T[1,1] * v1[1] + R.T[1,2] * v1[2] + R.T[1,3] * v1[3],R.T[2,1] * v1[1] + R.T[2,2] * v1[2] + R.T[2,3] * v1[3],R.T[3,1] * v1[1] + R.T[3,2] * v1[2] + R.T[3,3] * v1[3]};
// end Modelica.Mechanics.MultiBody.Frames.resolve2;
// 
// function Modelica.Mechanics.MultiBody.Frames.resolveRelative
//   input Real[3] v1 \"Vector in frame 1\";
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R1 \"Orientation object to rotate frame 0 into frame 1\";
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R2 \"Orientation object to rotate frame 0 into frame 2\";
//   output Real[3] v2 \"Vector in frame 2\";
// algorithm
//   v2 := Modelica.Mechanics.MultiBody.Frames.resolve2(R2,Modelica.Mechanics.MultiBody.Frames.resolve1(R1,{v1[1],v1[2],v1[3]}));
// end Modelica.Mechanics.MultiBody.Frames.resolveRelative;
// 
// function Modelica.Mechanics.MultiBody.Frames.to_Q
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[4] Q_guess = {0.0,0.0,0.0,1.0} \"Guess value for output Q (there are 2 solutions; the one closer to Q_guess is used\";
//   output Real[4] Q \"Quaternions orientation object to rotate frame 1 into frame 2\";
// algorithm
//   Q := Modelica.Mechanics.MultiBody.Frames.Quaternions.from_T(<matrix>[R.T[1,1],R.T[1,2],R.T[1,3];R.T[2,1],R.T[2,2],R.T[2,3];R.T[3,1],R.T[3,2],R.T[3,3]],{Q_guess[1],Q_guess[2],Q_guess[3],Q_guess[4]});
// end Modelica.Mechanics.MultiBody.Frames.to_Q;
// 
// function Modelica.Mechanics.MultiBody.Joints.Internal.RevoluteWithLengthConstraint.selectBranch
//   input Real L(quantity = \"Length\", unit = \"m\") \"Length of length constraint\";
//   input Real[3] e(unit = \"1\") \"Unit vector along axis of rotation, resolved in frame_a (= same in frame_b)\";
//   input Real angle_guess(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Select the configuration such that at initial time |angle-angle_guess|is minimal (angle=0: frame_a and frame_b coincide)\";
//   input Real[3] r_a(quantity = \"Length\", unit = \"m\") \"Position vector from frame_a to frame_a side of length constraint, resolved in frame_a of revolute joint\";
//   input Real[3] r_b(quantity = \"Length\", unit = \"m\") \"Position vector from frame_b to frame_b side of length constraint, resolved in frame_b of revolute joint\";
//   output Boolean positiveBranch \"Branch of the initial solution\";
//   protected Real e_r_a \"Projection of r_a on e\";
//   protected Real e_r_b \"Projection of r_b on e\";
//   protected Real A \"Coefficient A of equation: A*cos(phi) + B*sin(phi) + C = 0\";
//   protected Real B \"Coefficient B of equation: A*cos(phi) + B*sin(phi) + C = 0\";
//   protected Real C \"Coefficient C of equation: A*cos(phi) + B*sin(phi) + C = 0\";
//   protected Real k1 \"Constant of quadratic equation\";
//   protected Real k2 \"Constant of quadratic equation\";
//   protected Real k1a;
//   protected Real k1b;
//   protected Real kcos1 \"k1*cos(angle1)\";
//   protected Real ksin1 \"k1*sin(angle1)\";
//   protected Real kcos2 \"k2*cos(angle2)\";
//   protected Real ksin2 \"k2*sin(angle2)\";
//   protected Real angle1(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"solution 1 of nonlinear equation\";
//   protected Real angle2(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"solution 2 of nonlinear equation\";
// algorithm
//   e_r_a := e[1] * r_a[1] + e[2] * r_a[2] + e[3] * r_a[3];
//   e_r_b := e[1] * r_b[1] + e[2] * r_b[2] + e[3] * r_b[3];
//   A := -2.0 * (r_b[1] * r_a[1] + r_b[2] * r_a[2] + r_b[3] * r_a[3] - e_r_b * e_r_a);
//   B := 2.0 * r_b[1] * (e[2] * r_a[3] - e[3] * r_a[2]) + 2.0 * r_b[2] * (e[3] * r_a[1] - e[1] * r_a[3]) + 2.0 * r_b[3] * (e[1] * r_a[2] - e[2] * r_a[1]);
//   C := (r_a[1] ^ 2.0 + r_a[2] ^ 2.0 + r_a[3] ^ 2.0 + r_b[1] ^ 2.0 + r_b[2] ^ 2.0 + r_b[3] ^ 2.0) - L ^ 2.0 - 2.0 * e_r_b * e_r_a;
//   k1 := A ^ 2.0 + B ^ 2.0;
//   k1a := k1 - C ^ 2.0;
//   assert( k1a > 1e-10, \"
// Singular position of loop (either no or two analytic solutions;
// the mechanism has lost one-degree-of freedom in this position).
// Try first to use another Modelica.Mechanics.MultiBody.Joints.Assemblies.JointXXX component.
// In most cases it is best that the joints outside of the JointXXX
// component are revolute and NOT prismatic joints. If this also
// lead to singular positions, it could be that this kinematic loop
// cannot be solved analytically. In this case you have to build
// up the loop with basic joints (NO aggregation JointXXX components)
// and rely on dynamic state selection, i.e., during simulation
// the states will be dynamically selected in such a way that in no
// position a degree of freedom is lost.
// \");
//   k1b := max(k1a,1e-12);
//   k2 := sqrt(k1b);
//   kcos1 := -A * C + B * k2;
//   ksin1 := -B * C - A * k2;
//   angle1 := atan2(ksin1,kcos1);
//   kcos2 := -A * C - B * k2;
//   ksin2 := -B * C + A * k2;
//   angle2 := atan2(ksin2,kcos2);
//   if abs(angle1 - angle_guess) <= abs(angle2 - angle_guess) then
//     positiveBranch := true;
//   else
//     positiveBranch := false;
//   end if;
// end Modelica.Mechanics.MultiBody.Joints.Internal.RevoluteWithLengthConstraint.selectBranch;
// 
// function Modelica.Mechanics.MultiBody.Parts.Body.world__gravityAcceleration
//   input Real[3] r(quantity = \"Length\", unit = \"m\") \"Position vector from world frame to actual point, resolved in world frame\";
//   input enumeration(NoGravity, UniformGravity, PointGravity) gravityType \"Type of gravity field\";
//   input Real[3] g(quantity = \"Acceleration\", unit = \"m/s2\") \"Constant gravity acceleration, resolved in world frame, if gravityType=1\";
//   input Real mue(unit = \"m3/s2\") \"Field constant of point gravity field, if gravityType=2\";
//   output Real[3] gravity(quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration at point r, resolved in world frame\";
// algorithm
//   gravity := if gravityType == Modelica.Mechanics.MultiBody.Types.GravityTypes.UniformGravity then {g[1],g[2],g[3]} else if gravityType == Modelica.Mechanics.MultiBody.Types.GravityTypes.PointGravity then -{(mue * r[1]) / (Modelica.Math.Vectors.length({r[1],r[2],r[3]}) * (r[1] ^ 2.0 + r[2] ^ 2.0 + r[3] ^ 2.0)),(mue * r[2]) / (Modelica.Math.Vectors.length({r[1],r[2],r[3]}) * (r[1] ^ 2.0 + r[2] ^ 2.0 + r[3] ^ 2.0)),(mue * r[3]) / (Modelica.Math.Vectors.length({r[1],r[2],r[3]}) * (r[1] ^ 2.0 + r[2] ^ 2.0 + r[3] ^ 2.0))} else {0.0,0.0,0.0};
// end Modelica.Mechanics.MultiBody.Parts.Body.world__gravityAcceleration;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial
//   input Real material1;
//   input Real material2;
//   input Real material3;
//   input Real sp;
//   output Real mat;
// algorithm
//   mat := material1 + material2 + material3 + sp;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// function Modelica.SIunits.Conversions.from_deg
//   input Real degree(quantity = \"Angle\", unit = \"deg\") \"degree value\";
//   output Real radian(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"radian value\";
// algorithm
//   radian := 0.0174532925199433 * degree;
// end Modelica.SIunits.Conversions.from_deg;
// 
// class Modelica.Mechanics.MultiBody.Examples.Loops.PlanarLoops_analytic
//   Real world.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real world.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real world.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real world.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real world.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real world.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real world.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real world.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real world.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real world.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real world.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real world.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real world.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean world.enableAnimation = true \"= true, if animation of all components is enabled\";
//   parameter Boolean world.animateWorld = true \"= true, if world coordinate system shall be visualized\";
//   parameter Boolean world.animateGravity = true \"= true, if gravity field shall be visualized (acceleration vector or field center)\";
//   parameter String world.label1 = \"x\" \"Label of horizontal axis in icon\";
//   parameter String world.label2 = \"y\" \"Label of vertical axis in icon\";
//   parameter enumeration(NoGravity, UniformGravity, PointGravity) world.gravityType = Modelica.Mechanics.MultiBody.Types.GravityTypes.UniformGravity \"Type of gravity field\";
//   parameter Real world.g(quantity = \"Acceleration\", unit = \"m/s2\") = 9.81 \"Constant gravity acceleration\";
//   parameter Real world.n[1](unit = \"1\") = 0.0 \"Direction of gravity resolved in world frame (gravity = g*n/length(n))\";
//   parameter Real world.n[2](unit = \"1\") = -1.0 \"Direction of gravity resolved in world frame (gravity = g*n/length(n))\";
//   parameter Real world.n[3](unit = \"1\") = 0.0 \"Direction of gravity resolved in world frame (gravity = g*n/length(n))\";
//   parameter Real world.mue(unit = \"m3/s2\", min = 0.0) = 398600000000000.0 \"Gravity field constant (default = field constant of earth)\";
//   parameter Boolean world.driveTrainMechanics3D = true \"= true, if 3-dim. mechanical effects of Parts.Mounting1D/Rotor1D/BevelGear1D shall be taken into account\";
//   parameter Boolean world.axisShowLabels = true \"= true, if labels shall be shown\";
//   input Integer world.axisColor_x[1](min = 0, max = 255) = 0 \"Color of x-arrow\";
//   input Integer world.axisColor_x[2](min = 0, max = 255) = 0 \"Color of x-arrow\";
//   input Integer world.axisColor_x[3](min = 0, max = 255) = 0 \"Color of x-arrow\";
//   input Integer world.axisColor_y[1](min = 0, max = 255) = world.axisColor_x[1];
//   input Integer world.axisColor_y[2](min = 0, max = 255) = world.axisColor_x[2];
//   input Integer world.axisColor_y[3](min = 0, max = 255) = world.axisColor_x[3];
//   input Integer world.axisColor_z[1](min = 0, max = 255) = world.axisColor_x[1] \"Color of z-arrow\";
//   input Integer world.axisColor_z[2](min = 0, max = 255) = world.axisColor_x[2] \"Color of z-arrow\";
//   input Integer world.axisColor_z[3](min = 0, max = 255) = world.axisColor_x[3] \"Color of z-arrow\";
//   parameter Real world.gravityArrowTail[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to arrow tail, resolved in world frame\";
//   parameter Real world.gravityArrowTail[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to arrow tail, resolved in world frame\";
//   parameter Real world.gravityArrowTail[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to arrow tail, resolved in world frame\";
//   input Integer world.gravityArrowColor[1](min = 0, max = 255) = 0 \"Color of gravity arrow\";
//   input Integer world.gravityArrowColor[2](min = 0, max = 255) = 230 \"Color of gravity arrow\";
//   input Integer world.gravityArrowColor[3](min = 0, max = 255) = 0 \"Color of gravity arrow\";
//   parameter Real world.gravitySphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 12742000.0 \"Diameter of sphere representing gravity center (default = mean diameter of earth)\";
//   input Integer world.gravitySphereColor[1](min = 0, max = 255) = 0 \"Color of gravity sphere\";
//   input Integer world.gravitySphereColor[2](min = 0, max = 255) = 230 \"Color of gravity sphere\";
//   input Integer world.gravitySphereColor[3](min = 0, max = 255) = 0 \"Color of gravity sphere\";
//   parameter Real world.nominalLength(quantity = \"Length\", unit = \"m\") = 1.0 \"\\\"Nominal\\\" length of multi-body system\";
//   parameter Real world.defaultWidthFraction = 20.0 \"Default for shape width as a fraction of shape length (e.g., for Parts.FixedTranslation)\";
//   parameter Real world.defaultFrameDiameterFraction = 40.0 \"Default for arrow diameter of a coordinate system as a fraction of axis length\";
//   parameter Real world.defaultSpecularCoefficient(min = 0.0) = 0.7 \"Default reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Real world.defaultN_to_m(unit = \"N/m\", min = 0.0) = 1000.0 \"Default scaling of force arrows (length = force/defaultN_to_m)\";
//   parameter Real world.defaultNm_to_m(unit = \"N.m/m\", min = 0.0) = 1000.0 \"Default scaling of torque arrows (length = torque/defaultNm_to_m)\";
//   protected parameter Integer world.ndim = if world.enableAnimation AND world.animateWorld then 1 else 0;
//   parameter String world.x_arrowLine.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.x_arrowLine.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowLine.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_arrowLine.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_arrowLine.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_arrowLine.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_arrowLine.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_arrowLine.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_arrowLine.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_arrowLine.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_arrowLine.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_arrowLine.lengthDirection[1](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.x_arrowLine.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.x_arrowLine.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.x_arrowLine.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_arrowLine.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_arrowLine.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_arrowLine.length(quantity = \"Length\", unit = \"m\") = world.lineLength \"Length of visual object\";
//   input Real world.x_arrowLine.width(quantity = \"Length\", unit = \"m\") = world.lineWidth \"Width of visual object\";
//   input Real world.x_arrowLine.height(quantity = \"Length\", unit = \"m\") = world.lineWidth \"Height of visual object\";
//   input Real world.x_arrowLine.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.x_arrowLine.color[1] = Real(world.axisColor_x[1]) \"Color of shape\";
//   input Real world.x_arrowLine.color[2] = Real(world.axisColor_x[2]) \"Color of shape\";
//   input Real world.x_arrowLine.color[3] = Real(world.axisColor_x[3]) \"Color of shape\";
//   input Real world.x_arrowLine.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.x_arrowLine.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.x_arrowLine.lengthDirection[1],world.x_arrowLine.lengthDirection[2],world.x_arrowLine.lengthDirection[3]});
//   protected Real world.x_arrowLine.e_x[1](unit = \"1\") = if noEvent(world.x_arrowLine.abs_n_x < 1e-10) then 1.0 else world.x_arrowLine.lengthDirection[1] / world.x_arrowLine.abs_n_x;
//   protected Real world.x_arrowLine.e_x[2](unit = \"1\") = if noEvent(world.x_arrowLine.abs_n_x < 1e-10) then 0.0 else world.x_arrowLine.lengthDirection[2] / world.x_arrowLine.abs_n_x;
//   protected Real world.x_arrowLine.e_x[3](unit = \"1\") = if noEvent(world.x_arrowLine.abs_n_x < 1e-10) then 0.0 else world.x_arrowLine.lengthDirection[3] / world.x_arrowLine.abs_n_x;
//   protected Real world.x_arrowLine.n_z_aux[1](unit = \"1\") = world.x_arrowLine.e_x[2] * world.x_arrowLine.widthDirection[3] - world.x_arrowLine.e_x[3] * world.x_arrowLine.widthDirection[2];
//   protected Real world.x_arrowLine.n_z_aux[2](unit = \"1\") = world.x_arrowLine.e_x[3] * world.x_arrowLine.widthDirection[1] - world.x_arrowLine.e_x[1] * world.x_arrowLine.widthDirection[3];
//   protected Real world.x_arrowLine.n_z_aux[3](unit = \"1\") = world.x_arrowLine.e_x[1] * world.x_arrowLine.widthDirection[2] - world.x_arrowLine.e_x[2] * world.x_arrowLine.widthDirection[1];
//   protected Real world.x_arrowLine.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]},if noEvent(world.x_arrowLine.n_z_aux[1] ^ 2.0 + (world.x_arrowLine.n_z_aux[2] ^ 2.0 + world.x_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowLine.widthDirection[1],world.x_arrowLine.widthDirection[2],world.x_arrowLine.widthDirection[3]} else if noEvent(abs(world.x_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]})[1];
//   protected Real world.x_arrowLine.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]},if noEvent(world.x_arrowLine.n_z_aux[1] ^ 2.0 + (world.x_arrowLine.n_z_aux[2] ^ 2.0 + world.x_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowLine.widthDirection[1],world.x_arrowLine.widthDirection[2],world.x_arrowLine.widthDirection[3]} else if noEvent(abs(world.x_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]})[2];
//   protected Real world.x_arrowLine.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]},if noEvent(world.x_arrowLine.n_z_aux[1] ^ 2.0 + (world.x_arrowLine.n_z_aux[2] ^ 2.0 + world.x_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowLine.widthDirection[1],world.x_arrowLine.widthDirection[2],world.x_arrowLine.widthDirection[3]} else if noEvent(abs(world.x_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowLine.e_x[1],world.x_arrowLine.e_x[2],world.x_arrowLine.e_x[3]})[3];
//   protected output Real world.x_arrowLine.Form;
//   output Real world.x_arrowLine.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowLine.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowLine.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowLine.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowLine.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowLine.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowLine.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_arrowLine.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_arrowLine.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.x_arrowLine.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_arrowLine.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_arrowLine.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_arrowLine.Material;
//   protected output Real world.x_arrowLine.Extra;
//   parameter String world.x_arrowHead.shapeType = \"cone\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.x_arrowHead.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_arrowHead.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_arrowHead.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_arrowHead.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_arrowHead.r[1](quantity = \"Length\", unit = \"m\") = world.lineLength \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_arrowHead.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_arrowHead.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_arrowHead.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_arrowHead.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_arrowHead.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_arrowHead.lengthDirection[1](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.x_arrowHead.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.x_arrowHead.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.x_arrowHead.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_arrowHead.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_arrowHead.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_arrowHead.length(quantity = \"Length\", unit = \"m\") = world.headLength \"Length of visual object\";
//   input Real world.x_arrowHead.width(quantity = \"Length\", unit = \"m\") = world.headWidth \"Width of visual object\";
//   input Real world.x_arrowHead.height(quantity = \"Length\", unit = \"m\") = world.headWidth \"Height of visual object\";
//   input Real world.x_arrowHead.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.x_arrowHead.color[1] = Real(world.axisColor_x[1]) \"Color of shape\";
//   input Real world.x_arrowHead.color[2] = Real(world.axisColor_x[2]) \"Color of shape\";
//   input Real world.x_arrowHead.color[3] = Real(world.axisColor_x[3]) \"Color of shape\";
//   input Real world.x_arrowHead.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.x_arrowHead.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.x_arrowHead.lengthDirection[1],world.x_arrowHead.lengthDirection[2],world.x_arrowHead.lengthDirection[3]});
//   protected Real world.x_arrowHead.e_x[1](unit = \"1\") = if noEvent(world.x_arrowHead.abs_n_x < 1e-10) then 1.0 else world.x_arrowHead.lengthDirection[1] / world.x_arrowHead.abs_n_x;
//   protected Real world.x_arrowHead.e_x[2](unit = \"1\") = if noEvent(world.x_arrowHead.abs_n_x < 1e-10) then 0.0 else world.x_arrowHead.lengthDirection[2] / world.x_arrowHead.abs_n_x;
//   protected Real world.x_arrowHead.e_x[3](unit = \"1\") = if noEvent(world.x_arrowHead.abs_n_x < 1e-10) then 0.0 else world.x_arrowHead.lengthDirection[3] / world.x_arrowHead.abs_n_x;
//   protected Real world.x_arrowHead.n_z_aux[1](unit = \"1\") = world.x_arrowHead.e_x[2] * world.x_arrowHead.widthDirection[3] - world.x_arrowHead.e_x[3] * world.x_arrowHead.widthDirection[2];
//   protected Real world.x_arrowHead.n_z_aux[2](unit = \"1\") = world.x_arrowHead.e_x[3] * world.x_arrowHead.widthDirection[1] - world.x_arrowHead.e_x[1] * world.x_arrowHead.widthDirection[3];
//   protected Real world.x_arrowHead.n_z_aux[3](unit = \"1\") = world.x_arrowHead.e_x[1] * world.x_arrowHead.widthDirection[2] - world.x_arrowHead.e_x[2] * world.x_arrowHead.widthDirection[1];
//   protected Real world.x_arrowHead.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]},if noEvent(world.x_arrowHead.n_z_aux[1] ^ 2.0 + (world.x_arrowHead.n_z_aux[2] ^ 2.0 + world.x_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowHead.widthDirection[1],world.x_arrowHead.widthDirection[2],world.x_arrowHead.widthDirection[3]} else if noEvent(abs(world.x_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]})[1];
//   protected Real world.x_arrowHead.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]},if noEvent(world.x_arrowHead.n_z_aux[1] ^ 2.0 + (world.x_arrowHead.n_z_aux[2] ^ 2.0 + world.x_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowHead.widthDirection[1],world.x_arrowHead.widthDirection[2],world.x_arrowHead.widthDirection[3]} else if noEvent(abs(world.x_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]})[2];
//   protected Real world.x_arrowHead.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]},if noEvent(world.x_arrowHead.n_z_aux[1] ^ 2.0 + (world.x_arrowHead.n_z_aux[2] ^ 2.0 + world.x_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_arrowHead.widthDirection[1],world.x_arrowHead.widthDirection[2],world.x_arrowHead.widthDirection[3]} else if noEvent(abs(world.x_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_arrowHead.e_x[1],world.x_arrowHead.e_x[2],world.x_arrowHead.e_x[3]})[3];
//   protected output Real world.x_arrowHead.Form;
//   output Real world.x_arrowHead.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowHead.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowHead.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowHead.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowHead.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowHead.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_arrowHead.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_arrowHead.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_arrowHead.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.x_arrowHead.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_arrowHead.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_arrowHead.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_arrowHead.Material;
//   protected output Real world.x_arrowHead.Extra;
//   parameter String world.y_arrowLine.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.y_arrowLine.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowLine.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_arrowLine.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_arrowLine.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_arrowLine.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_arrowLine.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_arrowLine.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_arrowLine.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_arrowLine.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_arrowLine.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_arrowLine.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.y_arrowLine.lengthDirection[2](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.y_arrowLine.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.y_arrowLine.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_arrowLine.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_arrowLine.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_arrowLine.length(quantity = \"Length\", unit = \"m\") = world.lineLength \"Length of visual object\";
//   input Real world.y_arrowLine.width(quantity = \"Length\", unit = \"m\") = world.lineWidth \"Width of visual object\";
//   input Real world.y_arrowLine.height(quantity = \"Length\", unit = \"m\") = world.lineWidth \"Height of visual object\";
//   input Real world.y_arrowLine.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.y_arrowLine.color[1] = Real(world.axisColor_y[1]) \"Color of shape\";
//   input Real world.y_arrowLine.color[2] = Real(world.axisColor_y[2]) \"Color of shape\";
//   input Real world.y_arrowLine.color[3] = Real(world.axisColor_y[3]) \"Color of shape\";
//   input Real world.y_arrowLine.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.y_arrowLine.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.y_arrowLine.lengthDirection[1],world.y_arrowLine.lengthDirection[2],world.y_arrowLine.lengthDirection[3]});
//   protected Real world.y_arrowLine.e_x[1](unit = \"1\") = if noEvent(world.y_arrowLine.abs_n_x < 1e-10) then 1.0 else world.y_arrowLine.lengthDirection[1] / world.y_arrowLine.abs_n_x;
//   protected Real world.y_arrowLine.e_x[2](unit = \"1\") = if noEvent(world.y_arrowLine.abs_n_x < 1e-10) then 0.0 else world.y_arrowLine.lengthDirection[2] / world.y_arrowLine.abs_n_x;
//   protected Real world.y_arrowLine.e_x[3](unit = \"1\") = if noEvent(world.y_arrowLine.abs_n_x < 1e-10) then 0.0 else world.y_arrowLine.lengthDirection[3] / world.y_arrowLine.abs_n_x;
//   protected Real world.y_arrowLine.n_z_aux[1](unit = \"1\") = world.y_arrowLine.e_x[2] * world.y_arrowLine.widthDirection[3] - world.y_arrowLine.e_x[3] * world.y_arrowLine.widthDirection[2];
//   protected Real world.y_arrowLine.n_z_aux[2](unit = \"1\") = world.y_arrowLine.e_x[3] * world.y_arrowLine.widthDirection[1] - world.y_arrowLine.e_x[1] * world.y_arrowLine.widthDirection[3];
//   protected Real world.y_arrowLine.n_z_aux[3](unit = \"1\") = world.y_arrowLine.e_x[1] * world.y_arrowLine.widthDirection[2] - world.y_arrowLine.e_x[2] * world.y_arrowLine.widthDirection[1];
//   protected Real world.y_arrowLine.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]},if noEvent(world.y_arrowLine.n_z_aux[1] ^ 2.0 + (world.y_arrowLine.n_z_aux[2] ^ 2.0 + world.y_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowLine.widthDirection[1],world.y_arrowLine.widthDirection[2],world.y_arrowLine.widthDirection[3]} else if noEvent(abs(world.y_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]})[1];
//   protected Real world.y_arrowLine.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]},if noEvent(world.y_arrowLine.n_z_aux[1] ^ 2.0 + (world.y_arrowLine.n_z_aux[2] ^ 2.0 + world.y_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowLine.widthDirection[1],world.y_arrowLine.widthDirection[2],world.y_arrowLine.widthDirection[3]} else if noEvent(abs(world.y_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]})[2];
//   protected Real world.y_arrowLine.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]},if noEvent(world.y_arrowLine.n_z_aux[1] ^ 2.0 + (world.y_arrowLine.n_z_aux[2] ^ 2.0 + world.y_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowLine.widthDirection[1],world.y_arrowLine.widthDirection[2],world.y_arrowLine.widthDirection[3]} else if noEvent(abs(world.y_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowLine.e_x[1],world.y_arrowLine.e_x[2],world.y_arrowLine.e_x[3]})[3];
//   protected output Real world.y_arrowLine.Form;
//   output Real world.y_arrowLine.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowLine.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowLine.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowLine.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowLine.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowLine.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowLine.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_arrowLine.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_arrowLine.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.y_arrowLine.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_arrowLine.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_arrowLine.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_arrowLine.Material;
//   protected output Real world.y_arrowLine.Extra;
//   parameter String world.y_arrowHead.shapeType = \"cone\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.y_arrowHead.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_arrowHead.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_arrowHead.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_arrowHead.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_arrowHead.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_arrowHead.r[2](quantity = \"Length\", unit = \"m\") = world.lineLength \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_arrowHead.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_arrowHead.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_arrowHead.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_arrowHead.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_arrowHead.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.y_arrowHead.lengthDirection[2](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.y_arrowHead.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.y_arrowHead.widthDirection[1](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_arrowHead.widthDirection[2](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_arrowHead.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_arrowHead.length(quantity = \"Length\", unit = \"m\") = world.headLength \"Length of visual object\";
//   input Real world.y_arrowHead.width(quantity = \"Length\", unit = \"m\") = world.headWidth \"Width of visual object\";
//   input Real world.y_arrowHead.height(quantity = \"Length\", unit = \"m\") = world.headWidth \"Height of visual object\";
//   input Real world.y_arrowHead.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.y_arrowHead.color[1] = Real(world.axisColor_y[1]) \"Color of shape\";
//   input Real world.y_arrowHead.color[2] = Real(world.axisColor_y[2]) \"Color of shape\";
//   input Real world.y_arrowHead.color[3] = Real(world.axisColor_y[3]) \"Color of shape\";
//   input Real world.y_arrowHead.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.y_arrowHead.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.y_arrowHead.lengthDirection[1],world.y_arrowHead.lengthDirection[2],world.y_arrowHead.lengthDirection[3]});
//   protected Real world.y_arrowHead.e_x[1](unit = \"1\") = if noEvent(world.y_arrowHead.abs_n_x < 1e-10) then 1.0 else world.y_arrowHead.lengthDirection[1] / world.y_arrowHead.abs_n_x;
//   protected Real world.y_arrowHead.e_x[2](unit = \"1\") = if noEvent(world.y_arrowHead.abs_n_x < 1e-10) then 0.0 else world.y_arrowHead.lengthDirection[2] / world.y_arrowHead.abs_n_x;
//   protected Real world.y_arrowHead.e_x[3](unit = \"1\") = if noEvent(world.y_arrowHead.abs_n_x < 1e-10) then 0.0 else world.y_arrowHead.lengthDirection[3] / world.y_arrowHead.abs_n_x;
//   protected Real world.y_arrowHead.n_z_aux[1](unit = \"1\") = world.y_arrowHead.e_x[2] * world.y_arrowHead.widthDirection[3] - world.y_arrowHead.e_x[3] * world.y_arrowHead.widthDirection[2];
//   protected Real world.y_arrowHead.n_z_aux[2](unit = \"1\") = world.y_arrowHead.e_x[3] * world.y_arrowHead.widthDirection[1] - world.y_arrowHead.e_x[1] * world.y_arrowHead.widthDirection[3];
//   protected Real world.y_arrowHead.n_z_aux[3](unit = \"1\") = world.y_arrowHead.e_x[1] * world.y_arrowHead.widthDirection[2] - world.y_arrowHead.e_x[2] * world.y_arrowHead.widthDirection[1];
//   protected Real world.y_arrowHead.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]},if noEvent(world.y_arrowHead.n_z_aux[1] ^ 2.0 + (world.y_arrowHead.n_z_aux[2] ^ 2.0 + world.y_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowHead.widthDirection[1],world.y_arrowHead.widthDirection[2],world.y_arrowHead.widthDirection[3]} else if noEvent(abs(world.y_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]})[1];
//   protected Real world.y_arrowHead.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]},if noEvent(world.y_arrowHead.n_z_aux[1] ^ 2.0 + (world.y_arrowHead.n_z_aux[2] ^ 2.0 + world.y_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowHead.widthDirection[1],world.y_arrowHead.widthDirection[2],world.y_arrowHead.widthDirection[3]} else if noEvent(abs(world.y_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]})[2];
//   protected Real world.y_arrowHead.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]},if noEvent(world.y_arrowHead.n_z_aux[1] ^ 2.0 + (world.y_arrowHead.n_z_aux[2] ^ 2.0 + world.y_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_arrowHead.widthDirection[1],world.y_arrowHead.widthDirection[2],world.y_arrowHead.widthDirection[3]} else if noEvent(abs(world.y_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_arrowHead.e_x[1],world.y_arrowHead.e_x[2],world.y_arrowHead.e_x[3]})[3];
//   protected output Real world.y_arrowHead.Form;
//   output Real world.y_arrowHead.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowHead.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowHead.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowHead.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowHead.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowHead.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_arrowHead.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_arrowHead.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_arrowHead.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.y_arrowHead.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_arrowHead.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_arrowHead.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_arrowHead.Material;
//   protected output Real world.y_arrowHead.Extra;
//   parameter String world.z_arrowLine.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.z_arrowLine.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowLine.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_arrowLine.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_arrowLine.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_arrowLine.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_arrowLine.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_arrowLine.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_arrowLine.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_arrowLine.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_arrowLine.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_arrowLine.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.z_arrowLine.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.z_arrowLine.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.z_arrowLine.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_arrowLine.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_arrowLine.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_arrowLine.length(quantity = \"Length\", unit = \"m\") = world.lineLength \"Length of visual object\";
//   input Real world.z_arrowLine.width(quantity = \"Length\", unit = \"m\") = world.lineWidth \"Width of visual object\";
//   input Real world.z_arrowLine.height(quantity = \"Length\", unit = \"m\") = world.lineWidth \"Height of visual object\";
//   input Real world.z_arrowLine.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.z_arrowLine.color[1] = Real(world.axisColor_z[1]) \"Color of shape\";
//   input Real world.z_arrowLine.color[2] = Real(world.axisColor_z[2]) \"Color of shape\";
//   input Real world.z_arrowLine.color[3] = Real(world.axisColor_z[3]) \"Color of shape\";
//   input Real world.z_arrowLine.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.z_arrowLine.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.z_arrowLine.lengthDirection[1],world.z_arrowLine.lengthDirection[2],world.z_arrowLine.lengthDirection[3]});
//   protected Real world.z_arrowLine.e_x[1](unit = \"1\") = if noEvent(world.z_arrowLine.abs_n_x < 1e-10) then 1.0 else world.z_arrowLine.lengthDirection[1] / world.z_arrowLine.abs_n_x;
//   protected Real world.z_arrowLine.e_x[2](unit = \"1\") = if noEvent(world.z_arrowLine.abs_n_x < 1e-10) then 0.0 else world.z_arrowLine.lengthDirection[2] / world.z_arrowLine.abs_n_x;
//   protected Real world.z_arrowLine.e_x[3](unit = \"1\") = if noEvent(world.z_arrowLine.abs_n_x < 1e-10) then 0.0 else world.z_arrowLine.lengthDirection[3] / world.z_arrowLine.abs_n_x;
//   protected Real world.z_arrowLine.n_z_aux[1](unit = \"1\") = world.z_arrowLine.e_x[2] * world.z_arrowLine.widthDirection[3] - world.z_arrowLine.e_x[3] * world.z_arrowLine.widthDirection[2];
//   protected Real world.z_arrowLine.n_z_aux[2](unit = \"1\") = world.z_arrowLine.e_x[3] * world.z_arrowLine.widthDirection[1] - world.z_arrowLine.e_x[1] * world.z_arrowLine.widthDirection[3];
//   protected Real world.z_arrowLine.n_z_aux[3](unit = \"1\") = world.z_arrowLine.e_x[1] * world.z_arrowLine.widthDirection[2] - world.z_arrowLine.e_x[2] * world.z_arrowLine.widthDirection[1];
//   protected Real world.z_arrowLine.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]},if noEvent(world.z_arrowLine.n_z_aux[1] ^ 2.0 + (world.z_arrowLine.n_z_aux[2] ^ 2.0 + world.z_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowLine.widthDirection[1],world.z_arrowLine.widthDirection[2],world.z_arrowLine.widthDirection[3]} else if noEvent(abs(world.z_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]})[1];
//   protected Real world.z_arrowLine.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]},if noEvent(world.z_arrowLine.n_z_aux[1] ^ 2.0 + (world.z_arrowLine.n_z_aux[2] ^ 2.0 + world.z_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowLine.widthDirection[1],world.z_arrowLine.widthDirection[2],world.z_arrowLine.widthDirection[3]} else if noEvent(abs(world.z_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]})[2];
//   protected Real world.z_arrowLine.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]},if noEvent(world.z_arrowLine.n_z_aux[1] ^ 2.0 + (world.z_arrowLine.n_z_aux[2] ^ 2.0 + world.z_arrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowLine.widthDirection[1],world.z_arrowLine.widthDirection[2],world.z_arrowLine.widthDirection[3]} else if noEvent(abs(world.z_arrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowLine.e_x[1],world.z_arrowLine.e_x[2],world.z_arrowLine.e_x[3]})[3];
//   protected output Real world.z_arrowLine.Form;
//   output Real world.z_arrowLine.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowLine.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowLine.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowLine.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowLine.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowLine.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowLine.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_arrowLine.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_arrowLine.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.z_arrowLine.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_arrowLine.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_arrowLine.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_arrowLine.Material;
//   protected output Real world.z_arrowLine.Extra;
//   parameter String world.z_arrowHead.shapeType = \"cone\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.z_arrowHead.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_arrowHead.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_arrowHead.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_arrowHead.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_arrowHead.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_arrowHead.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_arrowHead.r[3](quantity = \"Length\", unit = \"m\") = world.lineLength \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_arrowHead.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_arrowHead.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_arrowHead.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_arrowHead.lengthDirection[1](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.z_arrowHead.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.z_arrowHead.lengthDirection[3](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real world.z_arrowHead.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_arrowHead.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_arrowHead.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_arrowHead.length(quantity = \"Length\", unit = \"m\") = world.headLength \"Length of visual object\";
//   input Real world.z_arrowHead.width(quantity = \"Length\", unit = \"m\") = world.headWidth \"Width of visual object\";
//   input Real world.z_arrowHead.height(quantity = \"Length\", unit = \"m\") = world.headWidth \"Height of visual object\";
//   input Real world.z_arrowHead.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.z_arrowHead.color[1] = Real(world.axisColor_z[1]) \"Color of shape\";
//   input Real world.z_arrowHead.color[2] = Real(world.axisColor_z[2]) \"Color of shape\";
//   input Real world.z_arrowHead.color[3] = Real(world.axisColor_z[3]) \"Color of shape\";
//   input Real world.z_arrowHead.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.z_arrowHead.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.z_arrowHead.lengthDirection[1],world.z_arrowHead.lengthDirection[2],world.z_arrowHead.lengthDirection[3]});
//   protected Real world.z_arrowHead.e_x[1](unit = \"1\") = if noEvent(world.z_arrowHead.abs_n_x < 1e-10) then 1.0 else world.z_arrowHead.lengthDirection[1] / world.z_arrowHead.abs_n_x;
//   protected Real world.z_arrowHead.e_x[2](unit = \"1\") = if noEvent(world.z_arrowHead.abs_n_x < 1e-10) then 0.0 else world.z_arrowHead.lengthDirection[2] / world.z_arrowHead.abs_n_x;
//   protected Real world.z_arrowHead.e_x[3](unit = \"1\") = if noEvent(world.z_arrowHead.abs_n_x < 1e-10) then 0.0 else world.z_arrowHead.lengthDirection[3] / world.z_arrowHead.abs_n_x;
//   protected Real world.z_arrowHead.n_z_aux[1](unit = \"1\") = world.z_arrowHead.e_x[2] * world.z_arrowHead.widthDirection[3] - world.z_arrowHead.e_x[3] * world.z_arrowHead.widthDirection[2];
//   protected Real world.z_arrowHead.n_z_aux[2](unit = \"1\") = world.z_arrowHead.e_x[3] * world.z_arrowHead.widthDirection[1] - world.z_arrowHead.e_x[1] * world.z_arrowHead.widthDirection[3];
//   protected Real world.z_arrowHead.n_z_aux[3](unit = \"1\") = world.z_arrowHead.e_x[1] * world.z_arrowHead.widthDirection[2] - world.z_arrowHead.e_x[2] * world.z_arrowHead.widthDirection[1];
//   protected Real world.z_arrowHead.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]},if noEvent(world.z_arrowHead.n_z_aux[1] ^ 2.0 + (world.z_arrowHead.n_z_aux[2] ^ 2.0 + world.z_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowHead.widthDirection[1],world.z_arrowHead.widthDirection[2],world.z_arrowHead.widthDirection[3]} else if noEvent(abs(world.z_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]})[1];
//   protected Real world.z_arrowHead.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]},if noEvent(world.z_arrowHead.n_z_aux[1] ^ 2.0 + (world.z_arrowHead.n_z_aux[2] ^ 2.0 + world.z_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowHead.widthDirection[1],world.z_arrowHead.widthDirection[2],world.z_arrowHead.widthDirection[3]} else if noEvent(abs(world.z_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]})[2];
//   protected Real world.z_arrowHead.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]},if noEvent(world.z_arrowHead.n_z_aux[1] ^ 2.0 + (world.z_arrowHead.n_z_aux[2] ^ 2.0 + world.z_arrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_arrowHead.widthDirection[1],world.z_arrowHead.widthDirection[2],world.z_arrowHead.widthDirection[3]} else if noEvent(abs(world.z_arrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_arrowHead.e_x[1],world.z_arrowHead.e_x[2],world.z_arrowHead.e_x[3]})[3];
//   protected output Real world.z_arrowHead.Form;
//   output Real world.z_arrowHead.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowHead.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowHead.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowHead.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowHead.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowHead.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_arrowHead.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_arrowHead.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_arrowHead.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.z_arrowHead.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_arrowHead.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_arrowHead.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_arrowHead.Material;
//   protected output Real world.z_arrowHead.Extra;
//   protected parameter Integer world.ndim_pointGravity = if world.enableAnimation AND world.animateGravity AND world.gravityType == Modelica.Mechanics.MultiBody.Types.GravityTypes.UniformGravity then 1 else 0;
//   parameter String world.gravityArrowLine.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.gravityArrowLine.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowLine.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.gravityArrowLine.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.gravityArrowLine.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.gravityArrowLine.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.gravityArrowLine.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.gravityArrowLine.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.gravityArrowLine.r_shape[1](quantity = \"Length\", unit = \"m\") = world.gravityArrowTail[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.gravityArrowLine.r_shape[2](quantity = \"Length\", unit = \"m\") = world.gravityArrowTail[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.gravityArrowLine.r_shape[3](quantity = \"Length\", unit = \"m\") = world.gravityArrowTail[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.gravityArrowLine.lengthDirection[1](unit = \"1\") = world.n[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.gravityArrowLine.lengthDirection[2](unit = \"1\") = world.n[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.gravityArrowLine.lengthDirection[3](unit = \"1\") = world.n[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.gravityArrowLine.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.gravityArrowLine.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.gravityArrowLine.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.gravityArrowLine.length(quantity = \"Length\", unit = \"m\") = world.gravityLineLength \"Length of visual object\";
//   input Real world.gravityArrowLine.width(quantity = \"Length\", unit = \"m\") = world.gravityArrowDiameter \"Width of visual object\";
//   input Real world.gravityArrowLine.height(quantity = \"Length\", unit = \"m\") = world.gravityArrowDiameter \"Height of visual object\";
//   input Real world.gravityArrowLine.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.gravityArrowLine.color[1] = Real(world.gravityArrowColor[1]) \"Color of shape\";
//   input Real world.gravityArrowLine.color[2] = Real(world.gravityArrowColor[2]) \"Color of shape\";
//   input Real world.gravityArrowLine.color[3] = Real(world.gravityArrowColor[3]) \"Color of shape\";
//   input Real world.gravityArrowLine.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.gravityArrowLine.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.gravityArrowLine.lengthDirection[1],world.gravityArrowLine.lengthDirection[2],world.gravityArrowLine.lengthDirection[3]});
//   protected Real world.gravityArrowLine.e_x[1](unit = \"1\") = if noEvent(world.gravityArrowLine.abs_n_x < 1e-10) then 1.0 else world.gravityArrowLine.lengthDirection[1] / world.gravityArrowLine.abs_n_x;
//   protected Real world.gravityArrowLine.e_x[2](unit = \"1\") = if noEvent(world.gravityArrowLine.abs_n_x < 1e-10) then 0.0 else world.gravityArrowLine.lengthDirection[2] / world.gravityArrowLine.abs_n_x;
//   protected Real world.gravityArrowLine.e_x[3](unit = \"1\") = if noEvent(world.gravityArrowLine.abs_n_x < 1e-10) then 0.0 else world.gravityArrowLine.lengthDirection[3] / world.gravityArrowLine.abs_n_x;
//   protected Real world.gravityArrowLine.n_z_aux[1](unit = \"1\") = world.gravityArrowLine.e_x[2] * world.gravityArrowLine.widthDirection[3] - world.gravityArrowLine.e_x[3] * world.gravityArrowLine.widthDirection[2];
//   protected Real world.gravityArrowLine.n_z_aux[2](unit = \"1\") = world.gravityArrowLine.e_x[3] * world.gravityArrowLine.widthDirection[1] - world.gravityArrowLine.e_x[1] * world.gravityArrowLine.widthDirection[3];
//   protected Real world.gravityArrowLine.n_z_aux[3](unit = \"1\") = world.gravityArrowLine.e_x[1] * world.gravityArrowLine.widthDirection[2] - world.gravityArrowLine.e_x[2] * world.gravityArrowLine.widthDirection[1];
//   protected Real world.gravityArrowLine.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.gravityArrowLine.e_x[1],world.gravityArrowLine.e_x[2],world.gravityArrowLine.e_x[3]},if noEvent(world.gravityArrowLine.n_z_aux[1] ^ 2.0 + (world.gravityArrowLine.n_z_aux[2] ^ 2.0 + world.gravityArrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.gravityArrowLine.widthDirection[1],world.gravityArrowLine.widthDirection[2],world.gravityArrowLine.widthDirection[3]} else if noEvent(abs(world.gravityArrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.gravityArrowLine.e_x[1],world.gravityArrowLine.e_x[2],world.gravityArrowLine.e_x[3]})[1];
//   protected Real world.gravityArrowLine.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.gravityArrowLine.e_x[1],world.gravityArrowLine.e_x[2],world.gravityArrowLine.e_x[3]},if noEvent(world.gravityArrowLine.n_z_aux[1] ^ 2.0 + (world.gravityArrowLine.n_z_aux[2] ^ 2.0 + world.gravityArrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.gravityArrowLine.widthDirection[1],world.gravityArrowLine.widthDirection[2],world.gravityArrowLine.widthDirection[3]} else if noEvent(abs(world.gravityArrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.gravityArrowLine.e_x[1],world.gravityArrowLine.e_x[2],world.gravityArrowLine.e_x[3]})[2];
//   protected Real world.gravityArrowLine.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.gravityArrowLine.e_x[1],world.gravityArrowLine.e_x[2],world.gravityArrowLine.e_x[3]},if noEvent(world.gravityArrowLine.n_z_aux[1] ^ 2.0 + (world.gravityArrowLine.n_z_aux[2] ^ 2.0 + world.gravityArrowLine.n_z_aux[3] ^ 2.0) > 1e-06) then {world.gravityArrowLine.widthDirection[1],world.gravityArrowLine.widthDirection[2],world.gravityArrowLine.widthDirection[3]} else if noEvent(abs(world.gravityArrowLine.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.gravityArrowLine.e_x[1],world.gravityArrowLine.e_x[2],world.gravityArrowLine.e_x[3]})[3];
//   protected output Real world.gravityArrowLine.Form;
//   output Real world.gravityArrowLine.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowLine.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowLine.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowLine.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowLine.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowLine.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowLine.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.gravityArrowLine.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.gravityArrowLine.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.gravityArrowLine.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.gravityArrowLine.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.gravityArrowLine.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.gravityArrowLine.Material;
//   protected output Real world.gravityArrowLine.Extra;
//   parameter String world.gravityArrowHead.shapeType = \"cone\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.gravityArrowHead.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.gravityArrowHead.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.gravityArrowHead.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.gravityArrowHead.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.gravityArrowHead.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.gravityArrowHead.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.gravityArrowHead.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.gravityArrowHead.r_shape[1](quantity = \"Length\", unit = \"m\") = world.gravityArrowTail[1] + Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13)[1] * world.gravityLineLength \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.gravityArrowHead.r_shape[2](quantity = \"Length\", unit = \"m\") = world.gravityArrowTail[2] + Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13)[2] * world.gravityLineLength \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.gravityArrowHead.r_shape[3](quantity = \"Length\", unit = \"m\") = world.gravityArrowTail[3] + Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13)[3] * world.gravityLineLength \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.gravityArrowHead.lengthDirection[1](unit = \"1\") = world.n[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.gravityArrowHead.lengthDirection[2](unit = \"1\") = world.n[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.gravityArrowHead.lengthDirection[3](unit = \"1\") = world.n[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.gravityArrowHead.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.gravityArrowHead.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.gravityArrowHead.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.gravityArrowHead.length(quantity = \"Length\", unit = \"m\") = world.gravityHeadLength \"Length of visual object\";
//   input Real world.gravityArrowHead.width(quantity = \"Length\", unit = \"m\") = world.gravityHeadWidth \"Width of visual object\";
//   input Real world.gravityArrowHead.height(quantity = \"Length\", unit = \"m\") = world.gravityHeadWidth \"Height of visual object\";
//   input Real world.gravityArrowHead.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.gravityArrowHead.color[1] = Real(world.gravityArrowColor[1]) \"Color of shape\";
//   input Real world.gravityArrowHead.color[2] = Real(world.gravityArrowColor[2]) \"Color of shape\";
//   input Real world.gravityArrowHead.color[3] = Real(world.gravityArrowColor[3]) \"Color of shape\";
//   input Real world.gravityArrowHead.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.gravityArrowHead.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.gravityArrowHead.lengthDirection[1],world.gravityArrowHead.lengthDirection[2],world.gravityArrowHead.lengthDirection[3]});
//   protected Real world.gravityArrowHead.e_x[1](unit = \"1\") = if noEvent(world.gravityArrowHead.abs_n_x < 1e-10) then 1.0 else world.gravityArrowHead.lengthDirection[1] / world.gravityArrowHead.abs_n_x;
//   protected Real world.gravityArrowHead.e_x[2](unit = \"1\") = if noEvent(world.gravityArrowHead.abs_n_x < 1e-10) then 0.0 else world.gravityArrowHead.lengthDirection[2] / world.gravityArrowHead.abs_n_x;
//   protected Real world.gravityArrowHead.e_x[3](unit = \"1\") = if noEvent(world.gravityArrowHead.abs_n_x < 1e-10) then 0.0 else world.gravityArrowHead.lengthDirection[3] / world.gravityArrowHead.abs_n_x;
//   protected Real world.gravityArrowHead.n_z_aux[1](unit = \"1\") = world.gravityArrowHead.e_x[2] * world.gravityArrowHead.widthDirection[3] - world.gravityArrowHead.e_x[3] * world.gravityArrowHead.widthDirection[2];
//   protected Real world.gravityArrowHead.n_z_aux[2](unit = \"1\") = world.gravityArrowHead.e_x[3] * world.gravityArrowHead.widthDirection[1] - world.gravityArrowHead.e_x[1] * world.gravityArrowHead.widthDirection[3];
//   protected Real world.gravityArrowHead.n_z_aux[3](unit = \"1\") = world.gravityArrowHead.e_x[1] * world.gravityArrowHead.widthDirection[2] - world.gravityArrowHead.e_x[2] * world.gravityArrowHead.widthDirection[1];
//   protected Real world.gravityArrowHead.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.gravityArrowHead.e_x[1],world.gravityArrowHead.e_x[2],world.gravityArrowHead.e_x[3]},if noEvent(world.gravityArrowHead.n_z_aux[1] ^ 2.0 + (world.gravityArrowHead.n_z_aux[2] ^ 2.0 + world.gravityArrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.gravityArrowHead.widthDirection[1],world.gravityArrowHead.widthDirection[2],world.gravityArrowHead.widthDirection[3]} else if noEvent(abs(world.gravityArrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.gravityArrowHead.e_x[1],world.gravityArrowHead.e_x[2],world.gravityArrowHead.e_x[3]})[1];
//   protected Real world.gravityArrowHead.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.gravityArrowHead.e_x[1],world.gravityArrowHead.e_x[2],world.gravityArrowHead.e_x[3]},if noEvent(world.gravityArrowHead.n_z_aux[1] ^ 2.0 + (world.gravityArrowHead.n_z_aux[2] ^ 2.0 + world.gravityArrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.gravityArrowHead.widthDirection[1],world.gravityArrowHead.widthDirection[2],world.gravityArrowHead.widthDirection[3]} else if noEvent(abs(world.gravityArrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.gravityArrowHead.e_x[1],world.gravityArrowHead.e_x[2],world.gravityArrowHead.e_x[3]})[2];
//   protected Real world.gravityArrowHead.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.gravityArrowHead.e_x[1],world.gravityArrowHead.e_x[2],world.gravityArrowHead.e_x[3]},if noEvent(world.gravityArrowHead.n_z_aux[1] ^ 2.0 + (world.gravityArrowHead.n_z_aux[2] ^ 2.0 + world.gravityArrowHead.n_z_aux[3] ^ 2.0) > 1e-06) then {world.gravityArrowHead.widthDirection[1],world.gravityArrowHead.widthDirection[2],world.gravityArrowHead.widthDirection[3]} else if noEvent(abs(world.gravityArrowHead.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.gravityArrowHead.e_x[1],world.gravityArrowHead.e_x[2],world.gravityArrowHead.e_x[3]})[3];
//   protected output Real world.gravityArrowHead.Form;
//   output Real world.gravityArrowHead.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowHead.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowHead.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowHead.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowHead.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowHead.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.gravityArrowHead.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.gravityArrowHead.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.gravityArrowHead.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.gravityArrowHead.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.gravityArrowHead.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.gravityArrowHead.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.gravityArrowHead.Material;
//   protected output Real world.gravityArrowHead.Extra;
//   protected parameter Integer world.ndim2 = if world.enableAnimation AND world.animateWorld AND world.axisShowLabels then 1 else 0;
//   input Real world.x_label.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.r_lines[1](quantity = \"Length\", unit = \"m\") = world.labelStart \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.r_lines[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.r_lines[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.n_x[1](unit = \"1\") = 1.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.n_x[2](unit = \"1\") = 0.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.n_x[3](unit = \"1\") = 0.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.n_y[1](unit = \"1\") = 0.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.n_y[2](unit = \"1\") = 1.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.n_y[3](unit = \"1\") = 0.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.x_label.lines[1,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[1,1,2](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[1,2,1](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[1,2,2](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[2,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[2,1,2](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[2,2,1](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.lines[2,2,2](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.x_label.diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.axisDiameter \"Diameter of the cylinders defined by lines\";
//   input Integer world.x_label.color[1](min = 0, max = 255) = world.axisColor_x[1] \"Color of cylinders\";
//   input Integer world.x_label.color[2](min = 0, max = 255) = world.axisColor_x[2] \"Color of cylinders\";
//   input Integer world.x_label.color[3](min = 0, max = 255) = world.axisColor_x[3] \"Color of cylinders\";
//   input Real world.x_label.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.x_label.R_rel[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[1][1];
//   protected Real world.x_label.R_rel[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[1][2];
//   protected Real world.x_label.R_rel[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[1][3];
//   protected Real world.x_label.R_rel[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[2][1];
//   protected Real world.x_label.R_rel[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[2][2];
//   protected Real world.x_label.R_rel[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[2][3];
//   protected Real world.x_label.R_rel[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[3][1];
//   protected Real world.x_label.R_rel[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[3][2];
//   protected Real world.x_label.R_rel[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.x_label.n_x[1],world.x_label.n_x[2],world.x_label.n_x[3]},{world.x_label.n_y[1],world.x_label.n_y[2],world.x_label.n_y[3]})[3][3];
//   protected Real world.x_label.R_lines[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[1][1];
//   protected Real world.x_label.R_lines[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[1][2];
//   protected Real world.x_label.R_lines[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[1][3];
//   protected Real world.x_label.R_lines[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[2][1];
//   protected Real world.x_label.R_lines[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[2][2];
//   protected Real world.x_label.R_lines[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[2][3];
//   protected Real world.x_label.R_lines[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[3][1];
//   protected Real world.x_label.R_lines[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[3][2];
//   protected Real world.x_label.R_lines[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}})[3][3];
//   protected Real world.x_label.r_abs[1](quantity = \"Length\", unit = \"m\") = world.x_label.r[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{world.x_label.r_lines[1],world.x_label.r_lines[2],world.x_label.r_lines[3]})[1];
//   protected Real world.x_label.r_abs[2](quantity = \"Length\", unit = \"m\") = world.x_label.r[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{world.x_label.r_lines[1],world.x_label.r_lines[2],world.x_label.r_lines[3]})[2];
//   protected Real world.x_label.r_abs[3](quantity = \"Length\", unit = \"m\") = world.x_label.r[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R.T[1,1],world.x_label.R.T[1,2],world.x_label.R.T[1,3]},{world.x_label.R.T[2,1],world.x_label.R.T[2,2],world.x_label.R.T[2,3]},{world.x_label.R.T[3,1],world.x_label.R.T[3,2],world.x_label.R.T[3,3]}},{world.x_label.r_lines[1],world.x_label.r_lines[2],world.x_label.r_lines[3]})[3];
//   parameter String world.x_label.cylinders[1].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.x_label.cylinders[1].R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[1].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.cylinders[1].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.cylinders[1].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.cylinders[1].r[1](quantity = \"Length\", unit = \"m\") = world.x_label.r_abs[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[1,1,1],world.x_label.lines[1,1,2],0.0})[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.cylinders[1].r[2](quantity = \"Length\", unit = \"m\") = world.x_label.r_abs[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[1,1,1],world.x_label.lines[1,1,2],0.0})[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.cylinders[1].r[3](quantity = \"Length\", unit = \"m\") = world.x_label.r_abs[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[1,1,1],world.x_label.lines[1,1,2],0.0})[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.cylinders[1].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_label.cylinders[1].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_label.cylinders[1].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_label.cylinders[1].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[1,2,1] - world.x_label.lines[1,1,1],world.x_label.lines[1,2,2] - world.x_label.lines[1,1,2],0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.x_label.cylinders[1].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[1,2,1] - world.x_label.lines[1,1,1],world.x_label.lines[1,2,2] - world.x_label.lines[1,1,2],0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.x_label.cylinders[1].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[1,2,1] - world.x_label.lines[1,1,1],world.x_label.lines[1,2,2] - world.x_label.lines[1,1,2],0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.x_label.cylinders[1].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_label.cylinders[1].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_label.cylinders[1].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_label.cylinders[1].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.x_label.lines[1,2,1] - world.x_label.lines[1,1,1],world.x_label.lines[1,2,2] - world.x_label.lines[1,1,2]}) \"Length of visual object\";
//   input Real world.x_label.cylinders[1].width(quantity = \"Length\", unit = \"m\") = world.x_label.diameter \"Width of visual object\";
//   input Real world.x_label.cylinders[1].height(quantity = \"Length\", unit = \"m\") = world.x_label.diameter \"Height of visual object\";
//   input Real world.x_label.cylinders[1].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.x_label.cylinders[1].color[1] = Real(world.x_label.color[1]) \"Color of shape\";
//   input Real world.x_label.cylinders[1].color[2] = Real(world.x_label.color[2]) \"Color of shape\";
//   input Real world.x_label.cylinders[1].color[3] = Real(world.x_label.color[3]) \"Color of shape\";
//   input Real world.x_label.cylinders[1].specularCoefficient = world.x_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.x_label.cylinders[1].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.x_label.cylinders[1].lengthDirection[1],world.x_label.cylinders[1].lengthDirection[2],world.x_label.cylinders[1].lengthDirection[3]});
//   protected Real world.x_label.cylinders[1].e_x[1](unit = \"1\") = if noEvent(world.x_label.cylinders[1].abs_n_x < 1e-10) then 1.0 else world.x_label.cylinders[1].lengthDirection[1] / world.x_label.cylinders[1].abs_n_x;
//   protected Real world.x_label.cylinders[1].e_x[2](unit = \"1\") = if noEvent(world.x_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.x_label.cylinders[1].lengthDirection[2] / world.x_label.cylinders[1].abs_n_x;
//   protected Real world.x_label.cylinders[1].e_x[3](unit = \"1\") = if noEvent(world.x_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.x_label.cylinders[1].lengthDirection[3] / world.x_label.cylinders[1].abs_n_x;
//   protected Real world.x_label.cylinders[1].n_z_aux[1](unit = \"1\") = world.x_label.cylinders[1].e_x[2] * world.x_label.cylinders[1].widthDirection[3] - world.x_label.cylinders[1].e_x[3] * world.x_label.cylinders[1].widthDirection[2];
//   protected Real world.x_label.cylinders[1].n_z_aux[2](unit = \"1\") = world.x_label.cylinders[1].e_x[3] * world.x_label.cylinders[1].widthDirection[1] - world.x_label.cylinders[1].e_x[1] * world.x_label.cylinders[1].widthDirection[3];
//   protected Real world.x_label.cylinders[1].n_z_aux[3](unit = \"1\") = world.x_label.cylinders[1].e_x[1] * world.x_label.cylinders[1].widthDirection[2] - world.x_label.cylinders[1].e_x[2] * world.x_label.cylinders[1].widthDirection[1];
//   protected Real world.x_label.cylinders[1].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]},if noEvent(world.x_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[1].widthDirection[1],world.x_label.cylinders[1].widthDirection[2],world.x_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]})[1];
//   protected Real world.x_label.cylinders[1].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]},if noEvent(world.x_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[1].widthDirection[1],world.x_label.cylinders[1].widthDirection[2],world.x_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]})[2];
//   protected Real world.x_label.cylinders[1].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]},if noEvent(world.x_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[1].widthDirection[1],world.x_label.cylinders[1].widthDirection[2],world.x_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[1].e_x[1],world.x_label.cylinders[1].e_x[2],world.x_label.cylinders[1].e_x[3]})[3];
//   protected output Real world.x_label.cylinders[1].Form;
//   output Real world.x_label.cylinders[1].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[1].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[1].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[1].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[1].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[1].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[1].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_label.cylinders[1].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_label.cylinders[1].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.x_label.cylinders[1].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_label.cylinders[1].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_label.cylinders[1].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_label.cylinders[1].Material;
//   protected output Real world.x_label.cylinders[1].Extra;
//   parameter String world.x_label.cylinders[2].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.x_label.cylinders[2].R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.x_label.cylinders[2].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.cylinders[2].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.cylinders[2].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.x_label.cylinders[2].r[1](quantity = \"Length\", unit = \"m\") = world.x_label.r_abs[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[2,1,1],world.x_label.lines[2,1,2],0.0})[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.cylinders[2].r[2](quantity = \"Length\", unit = \"m\") = world.x_label.r_abs[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[2,1,1],world.x_label.lines[2,1,2],0.0})[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.cylinders[2].r[3](quantity = \"Length\", unit = \"m\") = world.x_label.r_abs[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_lines[1,1],world.x_label.R_lines[1,2],world.x_label.R_lines[1,3]},{world.x_label.R_lines[2,1],world.x_label.R_lines[2,2],world.x_label.R_lines[2,3]},{world.x_label.R_lines[3,1],world.x_label.R_lines[3,2],world.x_label.R_lines[3,3]}},{world.x_label.lines[2,1,1],world.x_label.lines[2,1,2],0.0})[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.x_label.cylinders[2].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_label.cylinders[2].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_label.cylinders[2].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.x_label.cylinders[2].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[2,2,1] - world.x_label.lines[2,1,1],world.x_label.lines[2,2,2] - world.x_label.lines[2,1,2],0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.x_label.cylinders[2].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[2,2,1] - world.x_label.lines[2,1,1],world.x_label.lines[2,2,2] - world.x_label.lines[2,1,2],0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.x_label.cylinders[2].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.R_rel[1,1],world.x_label.R_rel[1,2],world.x_label.R_rel[1,3]},{world.x_label.R_rel[2,1],world.x_label.R_rel[2,2],world.x_label.R_rel[2,3]},{world.x_label.R_rel[3,1],world.x_label.R_rel[3,2],world.x_label.R_rel[3,3]}},{world.x_label.lines[2,2,1] - world.x_label.lines[2,1,1],world.x_label.lines[2,2,2] - world.x_label.lines[2,1,2],0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.x_label.cylinders[2].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_label.cylinders[2].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_label.cylinders[2].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.x_label.cylinders[2].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.x_label.lines[2,2,1] - world.x_label.lines[2,1,1],world.x_label.lines[2,2,2] - world.x_label.lines[2,1,2]}) \"Length of visual object\";
//   input Real world.x_label.cylinders[2].width(quantity = \"Length\", unit = \"m\") = world.x_label.diameter \"Width of visual object\";
//   input Real world.x_label.cylinders[2].height(quantity = \"Length\", unit = \"m\") = world.x_label.diameter \"Height of visual object\";
//   input Real world.x_label.cylinders[2].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.x_label.cylinders[2].color[1] = Real(world.x_label.color[1]) \"Color of shape\";
//   input Real world.x_label.cylinders[2].color[2] = Real(world.x_label.color[2]) \"Color of shape\";
//   input Real world.x_label.cylinders[2].color[3] = Real(world.x_label.color[3]) \"Color of shape\";
//   input Real world.x_label.cylinders[2].specularCoefficient = world.x_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.x_label.cylinders[2].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.x_label.cylinders[2].lengthDirection[1],world.x_label.cylinders[2].lengthDirection[2],world.x_label.cylinders[2].lengthDirection[3]});
//   protected Real world.x_label.cylinders[2].e_x[1](unit = \"1\") = if noEvent(world.x_label.cylinders[2].abs_n_x < 1e-10) then 1.0 else world.x_label.cylinders[2].lengthDirection[1] / world.x_label.cylinders[2].abs_n_x;
//   protected Real world.x_label.cylinders[2].e_x[2](unit = \"1\") = if noEvent(world.x_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.x_label.cylinders[2].lengthDirection[2] / world.x_label.cylinders[2].abs_n_x;
//   protected Real world.x_label.cylinders[2].e_x[3](unit = \"1\") = if noEvent(world.x_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.x_label.cylinders[2].lengthDirection[3] / world.x_label.cylinders[2].abs_n_x;
//   protected Real world.x_label.cylinders[2].n_z_aux[1](unit = \"1\") = world.x_label.cylinders[2].e_x[2] * world.x_label.cylinders[2].widthDirection[3] - world.x_label.cylinders[2].e_x[3] * world.x_label.cylinders[2].widthDirection[2];
//   protected Real world.x_label.cylinders[2].n_z_aux[2](unit = \"1\") = world.x_label.cylinders[2].e_x[3] * world.x_label.cylinders[2].widthDirection[1] - world.x_label.cylinders[2].e_x[1] * world.x_label.cylinders[2].widthDirection[3];
//   protected Real world.x_label.cylinders[2].n_z_aux[3](unit = \"1\") = world.x_label.cylinders[2].e_x[1] * world.x_label.cylinders[2].widthDirection[2] - world.x_label.cylinders[2].e_x[2] * world.x_label.cylinders[2].widthDirection[1];
//   protected Real world.x_label.cylinders[2].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]},if noEvent(world.x_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[2].widthDirection[1],world.x_label.cylinders[2].widthDirection[2],world.x_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]})[1];
//   protected Real world.x_label.cylinders[2].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]},if noEvent(world.x_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[2].widthDirection[1],world.x_label.cylinders[2].widthDirection[2],world.x_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]})[2];
//   protected Real world.x_label.cylinders[2].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]},if noEvent(world.x_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.x_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.x_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.x_label.cylinders[2].widthDirection[1],world.x_label.cylinders[2].widthDirection[2],world.x_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.x_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.x_label.cylinders[2].e_x[1],world.x_label.cylinders[2].e_x[2],world.x_label.cylinders[2].e_x[3]})[3];
//   protected output Real world.x_label.cylinders[2].Form;
//   output Real world.x_label.cylinders[2].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[2].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[2].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[2].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[2].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[2].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.x_label.cylinders[2].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_label.cylinders[2].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.x_label.cylinders[2].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.x_label.cylinders[2].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_label.cylinders[2].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_label.cylinders[2].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.x_label.cylinders[2].Material;
//   protected output Real world.x_label.cylinders[2].Extra;
//   protected parameter Integer world.x_label.n = 2 \"Number of cylinders\";
//   input Real world.y_label.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.r_lines[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.r_lines[2](quantity = \"Length\", unit = \"m\") = world.labelStart \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.r_lines[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.n_x[1](unit = \"1\") = 0.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.n_x[2](unit = \"1\") = 1.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.n_x[3](unit = \"1\") = 0.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.n_y[1](unit = \"1\") = -1.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.n_y[2](unit = \"1\") = 0.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.n_y[3](unit = \"1\") = 0.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.y_label.lines[1,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[1,1,2](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[1,2,1](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[1,2,2](quantity = \"Length\", unit = \"m\") = 1.5 * world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[2,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[2,1,2](quantity = \"Length\", unit = \"m\") = 1.5 * world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[2,2,1](quantity = \"Length\", unit = \"m\") = 0.5 * world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.lines[2,2,2](quantity = \"Length\", unit = \"m\") = 0.75 * world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.y_label.diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.axisDiameter \"Diameter of the cylinders defined by lines\";
//   input Integer world.y_label.color[1](min = 0, max = 255) = world.axisColor_y[1] \"Color of cylinders\";
//   input Integer world.y_label.color[2](min = 0, max = 255) = world.axisColor_y[2] \"Color of cylinders\";
//   input Integer world.y_label.color[3](min = 0, max = 255) = world.axisColor_y[3] \"Color of cylinders\";
//   input Real world.y_label.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.y_label.R_rel[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[1][1];
//   protected Real world.y_label.R_rel[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[1][2];
//   protected Real world.y_label.R_rel[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[1][3];
//   protected Real world.y_label.R_rel[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[2][1];
//   protected Real world.y_label.R_rel[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[2][2];
//   protected Real world.y_label.R_rel[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[2][3];
//   protected Real world.y_label.R_rel[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[3][1];
//   protected Real world.y_label.R_rel[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[3][2];
//   protected Real world.y_label.R_rel[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.y_label.n_x[1],world.y_label.n_x[2],world.y_label.n_x[3]},{world.y_label.n_y[1],world.y_label.n_y[2],world.y_label.n_y[3]})[3][3];
//   protected Real world.y_label.R_lines[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[1][1];
//   protected Real world.y_label.R_lines[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[1][2];
//   protected Real world.y_label.R_lines[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[1][3];
//   protected Real world.y_label.R_lines[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[2][1];
//   protected Real world.y_label.R_lines[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[2][2];
//   protected Real world.y_label.R_lines[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[2][3];
//   protected Real world.y_label.R_lines[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[3][1];
//   protected Real world.y_label.R_lines[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[3][2];
//   protected Real world.y_label.R_lines[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}})[3][3];
//   protected Real world.y_label.r_abs[1](quantity = \"Length\", unit = \"m\") = world.y_label.r[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{world.y_label.r_lines[1],world.y_label.r_lines[2],world.y_label.r_lines[3]})[1];
//   protected Real world.y_label.r_abs[2](quantity = \"Length\", unit = \"m\") = world.y_label.r[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{world.y_label.r_lines[1],world.y_label.r_lines[2],world.y_label.r_lines[3]})[2];
//   protected Real world.y_label.r_abs[3](quantity = \"Length\", unit = \"m\") = world.y_label.r[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R.T[1,1],world.y_label.R.T[1,2],world.y_label.R.T[1,3]},{world.y_label.R.T[2,1],world.y_label.R.T[2,2],world.y_label.R.T[2,3]},{world.y_label.R.T[3,1],world.y_label.R.T[3,2],world.y_label.R.T[3,3]}},{world.y_label.r_lines[1],world.y_label.r_lines[2],world.y_label.r_lines[3]})[3];
//   parameter String world.y_label.cylinders[1].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.y_label.cylinders[1].R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[1].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.cylinders[1].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.cylinders[1].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.cylinders[1].r[1](quantity = \"Length\", unit = \"m\") = world.y_label.r_abs[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[1,1,1],world.y_label.lines[1,1,2],0.0})[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.cylinders[1].r[2](quantity = \"Length\", unit = \"m\") = world.y_label.r_abs[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[1,1,1],world.y_label.lines[1,1,2],0.0})[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.cylinders[1].r[3](quantity = \"Length\", unit = \"m\") = world.y_label.r_abs[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[1,1,1],world.y_label.lines[1,1,2],0.0})[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.cylinders[1].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_label.cylinders[1].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_label.cylinders[1].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_label.cylinders[1].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[1,2,1] - world.y_label.lines[1,1,1],world.y_label.lines[1,2,2] - world.y_label.lines[1,1,2],0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.y_label.cylinders[1].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[1,2,1] - world.y_label.lines[1,1,1],world.y_label.lines[1,2,2] - world.y_label.lines[1,1,2],0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.y_label.cylinders[1].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[1,2,1] - world.y_label.lines[1,1,1],world.y_label.lines[1,2,2] - world.y_label.lines[1,1,2],0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.y_label.cylinders[1].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_label.cylinders[1].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_label.cylinders[1].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_label.cylinders[1].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.y_label.lines[1,2,1] - world.y_label.lines[1,1,1],world.y_label.lines[1,2,2] - world.y_label.lines[1,1,2]}) \"Length of visual object\";
//   input Real world.y_label.cylinders[1].width(quantity = \"Length\", unit = \"m\") = world.y_label.diameter \"Width of visual object\";
//   input Real world.y_label.cylinders[1].height(quantity = \"Length\", unit = \"m\") = world.y_label.diameter \"Height of visual object\";
//   input Real world.y_label.cylinders[1].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.y_label.cylinders[1].color[1] = Real(world.y_label.color[1]) \"Color of shape\";
//   input Real world.y_label.cylinders[1].color[2] = Real(world.y_label.color[2]) \"Color of shape\";
//   input Real world.y_label.cylinders[1].color[3] = Real(world.y_label.color[3]) \"Color of shape\";
//   input Real world.y_label.cylinders[1].specularCoefficient = world.y_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.y_label.cylinders[1].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.y_label.cylinders[1].lengthDirection[1],world.y_label.cylinders[1].lengthDirection[2],world.y_label.cylinders[1].lengthDirection[3]});
//   protected Real world.y_label.cylinders[1].e_x[1](unit = \"1\") = if noEvent(world.y_label.cylinders[1].abs_n_x < 1e-10) then 1.0 else world.y_label.cylinders[1].lengthDirection[1] / world.y_label.cylinders[1].abs_n_x;
//   protected Real world.y_label.cylinders[1].e_x[2](unit = \"1\") = if noEvent(world.y_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.y_label.cylinders[1].lengthDirection[2] / world.y_label.cylinders[1].abs_n_x;
//   protected Real world.y_label.cylinders[1].e_x[3](unit = \"1\") = if noEvent(world.y_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.y_label.cylinders[1].lengthDirection[3] / world.y_label.cylinders[1].abs_n_x;
//   protected Real world.y_label.cylinders[1].n_z_aux[1](unit = \"1\") = world.y_label.cylinders[1].e_x[2] * world.y_label.cylinders[1].widthDirection[3] - world.y_label.cylinders[1].e_x[3] * world.y_label.cylinders[1].widthDirection[2];
//   protected Real world.y_label.cylinders[1].n_z_aux[2](unit = \"1\") = world.y_label.cylinders[1].e_x[3] * world.y_label.cylinders[1].widthDirection[1] - world.y_label.cylinders[1].e_x[1] * world.y_label.cylinders[1].widthDirection[3];
//   protected Real world.y_label.cylinders[1].n_z_aux[3](unit = \"1\") = world.y_label.cylinders[1].e_x[1] * world.y_label.cylinders[1].widthDirection[2] - world.y_label.cylinders[1].e_x[2] * world.y_label.cylinders[1].widthDirection[1];
//   protected Real world.y_label.cylinders[1].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]},if noEvent(world.y_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[1].widthDirection[1],world.y_label.cylinders[1].widthDirection[2],world.y_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]})[1];
//   protected Real world.y_label.cylinders[1].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]},if noEvent(world.y_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[1].widthDirection[1],world.y_label.cylinders[1].widthDirection[2],world.y_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]})[2];
//   protected Real world.y_label.cylinders[1].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]},if noEvent(world.y_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[1].widthDirection[1],world.y_label.cylinders[1].widthDirection[2],world.y_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[1].e_x[1],world.y_label.cylinders[1].e_x[2],world.y_label.cylinders[1].e_x[3]})[3];
//   protected output Real world.y_label.cylinders[1].Form;
//   output Real world.y_label.cylinders[1].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[1].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[1].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[1].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[1].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[1].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[1].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_label.cylinders[1].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_label.cylinders[1].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.y_label.cylinders[1].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_label.cylinders[1].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_label.cylinders[1].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_label.cylinders[1].Material;
//   protected output Real world.y_label.cylinders[1].Extra;
//   parameter String world.y_label.cylinders[2].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.y_label.cylinders[2].R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.y_label.cylinders[2].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.cylinders[2].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.cylinders[2].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.y_label.cylinders[2].r[1](quantity = \"Length\", unit = \"m\") = world.y_label.r_abs[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[2,1,1],world.y_label.lines[2,1,2],0.0})[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.cylinders[2].r[2](quantity = \"Length\", unit = \"m\") = world.y_label.r_abs[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[2,1,1],world.y_label.lines[2,1,2],0.0})[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.cylinders[2].r[3](quantity = \"Length\", unit = \"m\") = world.y_label.r_abs[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_lines[1,1],world.y_label.R_lines[1,2],world.y_label.R_lines[1,3]},{world.y_label.R_lines[2,1],world.y_label.R_lines[2,2],world.y_label.R_lines[2,3]},{world.y_label.R_lines[3,1],world.y_label.R_lines[3,2],world.y_label.R_lines[3,3]}},{world.y_label.lines[2,1,1],world.y_label.lines[2,1,2],0.0})[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.y_label.cylinders[2].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_label.cylinders[2].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_label.cylinders[2].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.y_label.cylinders[2].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[2,2,1] - world.y_label.lines[2,1,1],world.y_label.lines[2,2,2] - world.y_label.lines[2,1,2],0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.y_label.cylinders[2].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[2,2,1] - world.y_label.lines[2,1,1],world.y_label.lines[2,2,2] - world.y_label.lines[2,1,2],0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.y_label.cylinders[2].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.R_rel[1,1],world.y_label.R_rel[1,2],world.y_label.R_rel[1,3]},{world.y_label.R_rel[2,1],world.y_label.R_rel[2,2],world.y_label.R_rel[2,3]},{world.y_label.R_rel[3,1],world.y_label.R_rel[3,2],world.y_label.R_rel[3,3]}},{world.y_label.lines[2,2,1] - world.y_label.lines[2,1,1],world.y_label.lines[2,2,2] - world.y_label.lines[2,1,2],0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.y_label.cylinders[2].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_label.cylinders[2].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_label.cylinders[2].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.y_label.cylinders[2].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.y_label.lines[2,2,1] - world.y_label.lines[2,1,1],world.y_label.lines[2,2,2] - world.y_label.lines[2,1,2]}) \"Length of visual object\";
//   input Real world.y_label.cylinders[2].width(quantity = \"Length\", unit = \"m\") = world.y_label.diameter \"Width of visual object\";
//   input Real world.y_label.cylinders[2].height(quantity = \"Length\", unit = \"m\") = world.y_label.diameter \"Height of visual object\";
//   input Real world.y_label.cylinders[2].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.y_label.cylinders[2].color[1] = Real(world.y_label.color[1]) \"Color of shape\";
//   input Real world.y_label.cylinders[2].color[2] = Real(world.y_label.color[2]) \"Color of shape\";
//   input Real world.y_label.cylinders[2].color[3] = Real(world.y_label.color[3]) \"Color of shape\";
//   input Real world.y_label.cylinders[2].specularCoefficient = world.y_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.y_label.cylinders[2].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.y_label.cylinders[2].lengthDirection[1],world.y_label.cylinders[2].lengthDirection[2],world.y_label.cylinders[2].lengthDirection[3]});
//   protected Real world.y_label.cylinders[2].e_x[1](unit = \"1\") = if noEvent(world.y_label.cylinders[2].abs_n_x < 1e-10) then 1.0 else world.y_label.cylinders[2].lengthDirection[1] / world.y_label.cylinders[2].abs_n_x;
//   protected Real world.y_label.cylinders[2].e_x[2](unit = \"1\") = if noEvent(world.y_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.y_label.cylinders[2].lengthDirection[2] / world.y_label.cylinders[2].abs_n_x;
//   protected Real world.y_label.cylinders[2].e_x[3](unit = \"1\") = if noEvent(world.y_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.y_label.cylinders[2].lengthDirection[3] / world.y_label.cylinders[2].abs_n_x;
//   protected Real world.y_label.cylinders[2].n_z_aux[1](unit = \"1\") = world.y_label.cylinders[2].e_x[2] * world.y_label.cylinders[2].widthDirection[3] - world.y_label.cylinders[2].e_x[3] * world.y_label.cylinders[2].widthDirection[2];
//   protected Real world.y_label.cylinders[2].n_z_aux[2](unit = \"1\") = world.y_label.cylinders[2].e_x[3] * world.y_label.cylinders[2].widthDirection[1] - world.y_label.cylinders[2].e_x[1] * world.y_label.cylinders[2].widthDirection[3];
//   protected Real world.y_label.cylinders[2].n_z_aux[3](unit = \"1\") = world.y_label.cylinders[2].e_x[1] * world.y_label.cylinders[2].widthDirection[2] - world.y_label.cylinders[2].e_x[2] * world.y_label.cylinders[2].widthDirection[1];
//   protected Real world.y_label.cylinders[2].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]},if noEvent(world.y_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[2].widthDirection[1],world.y_label.cylinders[2].widthDirection[2],world.y_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]})[1];
//   protected Real world.y_label.cylinders[2].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]},if noEvent(world.y_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[2].widthDirection[1],world.y_label.cylinders[2].widthDirection[2],world.y_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]})[2];
//   protected Real world.y_label.cylinders[2].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]},if noEvent(world.y_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.y_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.y_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.y_label.cylinders[2].widthDirection[1],world.y_label.cylinders[2].widthDirection[2],world.y_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.y_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.y_label.cylinders[2].e_x[1],world.y_label.cylinders[2].e_x[2],world.y_label.cylinders[2].e_x[3]})[3];
//   protected output Real world.y_label.cylinders[2].Form;
//   output Real world.y_label.cylinders[2].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[2].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[2].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[2].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[2].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[2].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.y_label.cylinders[2].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_label.cylinders[2].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.y_label.cylinders[2].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.y_label.cylinders[2].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_label.cylinders[2].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_label.cylinders[2].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.y_label.cylinders[2].Material;
//   protected output Real world.y_label.cylinders[2].Extra;
//   protected parameter Integer world.y_label.n = 2 \"Number of cylinders\";
//   input Real world.z_label.R.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.r[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.r[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.r[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.r_lines[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.r_lines[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.r_lines[3](quantity = \"Length\", unit = \"m\") = world.labelStart \"Position vector from origin of object frame to the origin of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.n_x[1](unit = \"1\") = 0.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.n_x[2](unit = \"1\") = 0.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.n_x[3](unit = \"1\") = 1.0 \"Vector in direction of x-axis of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.n_y[1](unit = \"1\") = 0.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.n_y[2](unit = \"1\") = 1.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.n_y[3](unit = \"1\") = 0.0 \"Vector in direction of y-axis of 'lines' frame, resolved in object frame\";
//   input Real world.z_label.lines[1,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[1,1,2](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[1,2,1](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[1,2,2](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[2,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[2,1,2](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[2,2,1](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[2,2,2](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[3,1,1](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[3,1,2](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[3,2,1](quantity = \"Length\", unit = \"m\") = world.scaledLabel \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.lines[3,2,2](quantity = \"Length\", unit = \"m\") = 0.0 \"List of start and end points of cylinders resolved in an x-y frame defined by n_x, n_y, e.g., {[0,0;1,1], [0,1;1,0], [2,0; 3,1]}\";
//   input Real world.z_label.diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.axisDiameter \"Diameter of the cylinders defined by lines\";
//   input Integer world.z_label.color[1](min = 0, max = 255) = world.axisColor_z[1] \"Color of cylinders\";
//   input Integer world.z_label.color[2](min = 0, max = 255) = world.axisColor_z[2] \"Color of cylinders\";
//   input Integer world.z_label.color[3](min = 0, max = 255) = world.axisColor_z[3] \"Color of cylinders\";
//   input Real world.z_label.specularCoefficient = 0.0 \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.z_label.R_rel[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[1][1];
//   protected Real world.z_label.R_rel[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[1][2];
//   protected Real world.z_label.R_rel[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[1][3];
//   protected Real world.z_label.R_rel[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[2][1];
//   protected Real world.z_label.R_rel[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[2][2];
//   protected Real world.z_label.R_rel[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[2][3];
//   protected Real world.z_label.R_rel[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[3][1];
//   protected Real world.z_label.R_rel[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[3][2];
//   protected Real world.z_label.R_rel[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy({world.z_label.n_x[1],world.z_label.n_x[2],world.z_label.n_x[3]},{world.z_label.n_y[1],world.z_label.n_y[2],world.z_label.n_y[3]})[3][3];
//   protected Real world.z_label.R_lines[1,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[1][1];
//   protected Real world.z_label.R_lines[1,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[1][2];
//   protected Real world.z_label.R_lines[1,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[1][3];
//   protected Real world.z_label.R_lines[2,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[2][1];
//   protected Real world.z_label.R_lines[2,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[2][2];
//   protected Real world.z_label.R_lines[2,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[2][3];
//   protected Real world.z_label.R_lines[3,1] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[3][1];
//   protected Real world.z_label.R_lines[3,2] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[3][2];
//   protected Real world.z_label.R_lines[3,3] = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}})[3][3];
//   protected Real world.z_label.r_abs[1](quantity = \"Length\", unit = \"m\") = world.z_label.r[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{world.z_label.r_lines[1],world.z_label.r_lines[2],world.z_label.r_lines[3]})[1];
//   protected Real world.z_label.r_abs[2](quantity = \"Length\", unit = \"m\") = world.z_label.r[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{world.z_label.r_lines[1],world.z_label.r_lines[2],world.z_label.r_lines[3]})[2];
//   protected Real world.z_label.r_abs[3](quantity = \"Length\", unit = \"m\") = world.z_label.r[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R.T[1,1],world.z_label.R.T[1,2],world.z_label.R.T[1,3]},{world.z_label.R.T[2,1],world.z_label.R.T[2,2],world.z_label.R.T[2,3]},{world.z_label.R.T[3,1],world.z_label.R.T[3,2],world.z_label.R.T[3,3]}},{world.z_label.r_lines[1],world.z_label.r_lines[2],world.z_label.r_lines[3]})[3];
//   parameter String world.z_label.cylinders[1].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.z_label.cylinders[1].R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[1].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[1].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[1].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[1].r[1](quantity = \"Length\", unit = \"m\") = world.z_label.r_abs[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[1,1,1],world.z_label.lines[1,1,2],0.0})[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[1].r[2](quantity = \"Length\", unit = \"m\") = world.z_label.r_abs[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[1,1,1],world.z_label.lines[1,1,2],0.0})[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[1].r[3](quantity = \"Length\", unit = \"m\") = world.z_label.r_abs[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[1,1,1],world.z_label.lines[1,1,2],0.0})[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[1].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[1].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[1].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[1].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[1,2,1] - world.z_label.lines[1,1,1],world.z_label.lines[1,2,2] - world.z_label.lines[1,1,2],0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[1].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[1,2,1] - world.z_label.lines[1,1,1],world.z_label.lines[1,2,2] - world.z_label.lines[1,1,2],0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[1].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[1,2,1] - world.z_label.lines[1,1,1],world.z_label.lines[1,2,2] - world.z_label.lines[1,1,2],0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[1].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[1].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[1].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[1].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.z_label.lines[1,2,1] - world.z_label.lines[1,1,1],world.z_label.lines[1,2,2] - world.z_label.lines[1,1,2]}) \"Length of visual object\";
//   input Real world.z_label.cylinders[1].width(quantity = \"Length\", unit = \"m\") = world.z_label.diameter \"Width of visual object\";
//   input Real world.z_label.cylinders[1].height(quantity = \"Length\", unit = \"m\") = world.z_label.diameter \"Height of visual object\";
//   input Real world.z_label.cylinders[1].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.z_label.cylinders[1].color[1] = Real(world.z_label.color[1]) \"Color of shape\";
//   input Real world.z_label.cylinders[1].color[2] = Real(world.z_label.color[2]) \"Color of shape\";
//   input Real world.z_label.cylinders[1].color[3] = Real(world.z_label.color[3]) \"Color of shape\";
//   input Real world.z_label.cylinders[1].specularCoefficient = world.z_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.z_label.cylinders[1].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.z_label.cylinders[1].lengthDirection[1],world.z_label.cylinders[1].lengthDirection[2],world.z_label.cylinders[1].lengthDirection[3]});
//   protected Real world.z_label.cylinders[1].e_x[1](unit = \"1\") = if noEvent(world.z_label.cylinders[1].abs_n_x < 1e-10) then 1.0 else world.z_label.cylinders[1].lengthDirection[1] / world.z_label.cylinders[1].abs_n_x;
//   protected Real world.z_label.cylinders[1].e_x[2](unit = \"1\") = if noEvent(world.z_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[1].lengthDirection[2] / world.z_label.cylinders[1].abs_n_x;
//   protected Real world.z_label.cylinders[1].e_x[3](unit = \"1\") = if noEvent(world.z_label.cylinders[1].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[1].lengthDirection[3] / world.z_label.cylinders[1].abs_n_x;
//   protected Real world.z_label.cylinders[1].n_z_aux[1](unit = \"1\") = world.z_label.cylinders[1].e_x[2] * world.z_label.cylinders[1].widthDirection[3] - world.z_label.cylinders[1].e_x[3] * world.z_label.cylinders[1].widthDirection[2];
//   protected Real world.z_label.cylinders[1].n_z_aux[2](unit = \"1\") = world.z_label.cylinders[1].e_x[3] * world.z_label.cylinders[1].widthDirection[1] - world.z_label.cylinders[1].e_x[1] * world.z_label.cylinders[1].widthDirection[3];
//   protected Real world.z_label.cylinders[1].n_z_aux[3](unit = \"1\") = world.z_label.cylinders[1].e_x[1] * world.z_label.cylinders[1].widthDirection[2] - world.z_label.cylinders[1].e_x[2] * world.z_label.cylinders[1].widthDirection[1];
//   protected Real world.z_label.cylinders[1].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]},if noEvent(world.z_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[1].widthDirection[1],world.z_label.cylinders[1].widthDirection[2],world.z_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]})[1];
//   protected Real world.z_label.cylinders[1].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]},if noEvent(world.z_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[1].widthDirection[1],world.z_label.cylinders[1].widthDirection[2],world.z_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]})[2];
//   protected Real world.z_label.cylinders[1].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]},if noEvent(world.z_label.cylinders[1].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[1].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[1].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[1].widthDirection[1],world.z_label.cylinders[1].widthDirection[2],world.z_label.cylinders[1].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[1].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[1].e_x[1],world.z_label.cylinders[1].e_x[2],world.z_label.cylinders[1].e_x[3]})[3];
//   protected output Real world.z_label.cylinders[1].Form;
//   output Real world.z_label.cylinders[1].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[1].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[1].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[1].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[1].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[1].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[1].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_label.cylinders[1].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_label.cylinders[1].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.z_label.cylinders[1].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[1].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[1].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[1].Material;
//   protected output Real world.z_label.cylinders[1].Extra;
//   parameter String world.z_label.cylinders[2].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.z_label.cylinders[2].R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[2].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[2].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[2].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[2].r[1](quantity = \"Length\", unit = \"m\") = world.z_label.r_abs[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[2,1,1],world.z_label.lines[2,1,2],0.0})[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[2].r[2](quantity = \"Length\", unit = \"m\") = world.z_label.r_abs[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[2,1,1],world.z_label.lines[2,1,2],0.0})[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[2].r[3](quantity = \"Length\", unit = \"m\") = world.z_label.r_abs[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[2,1,1],world.z_label.lines[2,1,2],0.0})[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[2].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[2].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[2].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[2].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[2,2,1] - world.z_label.lines[2,1,1],world.z_label.lines[2,2,2] - world.z_label.lines[2,1,2],0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[2].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[2,2,1] - world.z_label.lines[2,1,1],world.z_label.lines[2,2,2] - world.z_label.lines[2,1,2],0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[2].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[2,2,1] - world.z_label.lines[2,1,1],world.z_label.lines[2,2,2] - world.z_label.lines[2,1,2],0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[2].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[2].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[2].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[2].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.z_label.lines[2,2,1] - world.z_label.lines[2,1,1],world.z_label.lines[2,2,2] - world.z_label.lines[2,1,2]}) \"Length of visual object\";
//   input Real world.z_label.cylinders[2].width(quantity = \"Length\", unit = \"m\") = world.z_label.diameter \"Width of visual object\";
//   input Real world.z_label.cylinders[2].height(quantity = \"Length\", unit = \"m\") = world.z_label.diameter \"Height of visual object\";
//   input Real world.z_label.cylinders[2].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.z_label.cylinders[2].color[1] = Real(world.z_label.color[1]) \"Color of shape\";
//   input Real world.z_label.cylinders[2].color[2] = Real(world.z_label.color[2]) \"Color of shape\";
//   input Real world.z_label.cylinders[2].color[3] = Real(world.z_label.color[3]) \"Color of shape\";
//   input Real world.z_label.cylinders[2].specularCoefficient = world.z_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.z_label.cylinders[2].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.z_label.cylinders[2].lengthDirection[1],world.z_label.cylinders[2].lengthDirection[2],world.z_label.cylinders[2].lengthDirection[3]});
//   protected Real world.z_label.cylinders[2].e_x[1](unit = \"1\") = if noEvent(world.z_label.cylinders[2].abs_n_x < 1e-10) then 1.0 else world.z_label.cylinders[2].lengthDirection[1] / world.z_label.cylinders[2].abs_n_x;
//   protected Real world.z_label.cylinders[2].e_x[2](unit = \"1\") = if noEvent(world.z_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[2].lengthDirection[2] / world.z_label.cylinders[2].abs_n_x;
//   protected Real world.z_label.cylinders[2].e_x[3](unit = \"1\") = if noEvent(world.z_label.cylinders[2].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[2].lengthDirection[3] / world.z_label.cylinders[2].abs_n_x;
//   protected Real world.z_label.cylinders[2].n_z_aux[1](unit = \"1\") = world.z_label.cylinders[2].e_x[2] * world.z_label.cylinders[2].widthDirection[3] - world.z_label.cylinders[2].e_x[3] * world.z_label.cylinders[2].widthDirection[2];
//   protected Real world.z_label.cylinders[2].n_z_aux[2](unit = \"1\") = world.z_label.cylinders[2].e_x[3] * world.z_label.cylinders[2].widthDirection[1] - world.z_label.cylinders[2].e_x[1] * world.z_label.cylinders[2].widthDirection[3];
//   protected Real world.z_label.cylinders[2].n_z_aux[3](unit = \"1\") = world.z_label.cylinders[2].e_x[1] * world.z_label.cylinders[2].widthDirection[2] - world.z_label.cylinders[2].e_x[2] * world.z_label.cylinders[2].widthDirection[1];
//   protected Real world.z_label.cylinders[2].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]},if noEvent(world.z_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[2].widthDirection[1],world.z_label.cylinders[2].widthDirection[2],world.z_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]})[1];
//   protected Real world.z_label.cylinders[2].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]},if noEvent(world.z_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[2].widthDirection[1],world.z_label.cylinders[2].widthDirection[2],world.z_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]})[2];
//   protected Real world.z_label.cylinders[2].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]},if noEvent(world.z_label.cylinders[2].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[2].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[2].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[2].widthDirection[1],world.z_label.cylinders[2].widthDirection[2],world.z_label.cylinders[2].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[2].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[2].e_x[1],world.z_label.cylinders[2].e_x[2],world.z_label.cylinders[2].e_x[3]})[3];
//   protected output Real world.z_label.cylinders[2].Form;
//   output Real world.z_label.cylinders[2].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[2].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[2].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[2].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[2].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[2].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[2].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_label.cylinders[2].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_label.cylinders[2].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.z_label.cylinders[2].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[2].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[2].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[2].Material;
//   protected output Real world.z_label.cylinders[2].Extra;
//   parameter String world.z_label.cylinders[3].shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real world.z_label.cylinders[3].R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real world.z_label.cylinders[3].R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[3].R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[3].R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real world.z_label.cylinders[3].r[1](quantity = \"Length\", unit = \"m\") = world.z_label.r_abs[1] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[3,1,1],world.z_label.lines[3,1,2],0.0})[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[3].r[2](quantity = \"Length\", unit = \"m\") = world.z_label.r_abs[2] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[3,1,1],world.z_label.lines[3,1,2],0.0})[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[3].r[3](quantity = \"Length\", unit = \"m\") = world.z_label.r_abs[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_lines[1,1],world.z_label.R_lines[1,2],world.z_label.R_lines[1,3]},{world.z_label.R_lines[2,1],world.z_label.R_lines[2,2],world.z_label.R_lines[2,3]},{world.z_label.R_lines[3,1],world.z_label.R_lines[3,2],world.z_label.R_lines[3,3]}},{world.z_label.lines[3,1,1],world.z_label.lines[3,1,2],0.0})[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real world.z_label.cylinders[3].r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[3].r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[3].r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real world.z_label.cylinders[3].lengthDirection[1](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[3,2,1] - world.z_label.lines[3,1,1],world.z_label.lines[3,2,2] - world.z_label.lines[3,1,2],0.0})[1] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[3].lengthDirection[2](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[3,2,1] - world.z_label.lines[3,1,1],world.z_label.lines[3,2,2] - world.z_label.lines[3,1,2],0.0})[2] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[3].lengthDirection[3](unit = \"1\") = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.R_rel[1,1],world.z_label.R_rel[1,2],world.z_label.R_rel[1,3]},{world.z_label.R_rel[2,1],world.z_label.R_rel[2,2],world.z_label.R_rel[2,3]},{world.z_label.R_rel[3,1],world.z_label.R_rel[3,2],world.z_label.R_rel[3,3]}},{world.z_label.lines[3,2,1] - world.z_label.lines[3,1,1],world.z_label.lines[3,2,2] - world.z_label.lines[3,1,2],0.0})[3] \"Vector in length direction, resolved in object frame\";
//   input Real world.z_label.cylinders[3].widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[3].widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[3].widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real world.z_label.cylinders[3].length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({world.z_label.lines[3,2,1] - world.z_label.lines[3,1,1],world.z_label.lines[3,2,2] - world.z_label.lines[3,1,2]}) \"Length of visual object\";
//   input Real world.z_label.cylinders[3].width(quantity = \"Length\", unit = \"m\") = world.z_label.diameter \"Width of visual object\";
//   input Real world.z_label.cylinders[3].height(quantity = \"Length\", unit = \"m\") = world.z_label.diameter \"Height of visual object\";
//   input Real world.z_label.cylinders[3].extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real world.z_label.cylinders[3].color[1] = Real(world.z_label.color[1]) \"Color of shape\";
//   input Real world.z_label.cylinders[3].color[2] = Real(world.z_label.color[2]) \"Color of shape\";
//   input Real world.z_label.cylinders[3].color[3] = Real(world.z_label.color[3]) \"Color of shape\";
//   input Real world.z_label.cylinders[3].specularCoefficient = world.z_label.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real world.z_label.cylinders[3].abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({world.z_label.cylinders[3].lengthDirection[1],world.z_label.cylinders[3].lengthDirection[2],world.z_label.cylinders[3].lengthDirection[3]});
//   protected Real world.z_label.cylinders[3].e_x[1](unit = \"1\") = if noEvent(world.z_label.cylinders[3].abs_n_x < 1e-10) then 1.0 else world.z_label.cylinders[3].lengthDirection[1] / world.z_label.cylinders[3].abs_n_x;
//   protected Real world.z_label.cylinders[3].e_x[2](unit = \"1\") = if noEvent(world.z_label.cylinders[3].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[3].lengthDirection[2] / world.z_label.cylinders[3].abs_n_x;
//   protected Real world.z_label.cylinders[3].e_x[3](unit = \"1\") = if noEvent(world.z_label.cylinders[3].abs_n_x < 1e-10) then 0.0 else world.z_label.cylinders[3].lengthDirection[3] / world.z_label.cylinders[3].abs_n_x;
//   protected Real world.z_label.cylinders[3].n_z_aux[1](unit = \"1\") = world.z_label.cylinders[3].e_x[2] * world.z_label.cylinders[3].widthDirection[3] - world.z_label.cylinders[3].e_x[3] * world.z_label.cylinders[3].widthDirection[2];
//   protected Real world.z_label.cylinders[3].n_z_aux[2](unit = \"1\") = world.z_label.cylinders[3].e_x[3] * world.z_label.cylinders[3].widthDirection[1] - world.z_label.cylinders[3].e_x[1] * world.z_label.cylinders[3].widthDirection[3];
//   protected Real world.z_label.cylinders[3].n_z_aux[3](unit = \"1\") = world.z_label.cylinders[3].e_x[1] * world.z_label.cylinders[3].widthDirection[2] - world.z_label.cylinders[3].e_x[2] * world.z_label.cylinders[3].widthDirection[1];
//   protected Real world.z_label.cylinders[3].e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]},if noEvent(world.z_label.cylinders[3].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[3].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[3].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[3].widthDirection[1],world.z_label.cylinders[3].widthDirection[2],world.z_label.cylinders[3].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[3].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]})[1];
//   protected Real world.z_label.cylinders[3].e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]},if noEvent(world.z_label.cylinders[3].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[3].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[3].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[3].widthDirection[1],world.z_label.cylinders[3].widthDirection[2],world.z_label.cylinders[3].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[3].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]})[2];
//   protected Real world.z_label.cylinders[3].e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]},if noEvent(world.z_label.cylinders[3].n_z_aux[1] ^ 2.0 + (world.z_label.cylinders[3].n_z_aux[2] ^ 2.0 + world.z_label.cylinders[3].n_z_aux[3] ^ 2.0) > 1e-06) then {world.z_label.cylinders[3].widthDirection[1],world.z_label.cylinders[3].widthDirection[2],world.z_label.cylinders[3].widthDirection[3]} else if noEvent(abs(world.z_label.cylinders[3].e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{world.z_label.cylinders[3].e_x[1],world.z_label.cylinders[3].e_x[2],world.z_label.cylinders[3].e_x[3]})[3];
//   protected output Real world.z_label.cylinders[3].Form;
//   output Real world.z_label.cylinders[3].rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[3].rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[3].rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[3].ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[3].ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[3].ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real world.z_label.cylinders[3].rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_label.cylinders[3].rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real world.z_label.cylinders[3].rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real world.z_label.cylinders[3].size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[3].size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[3].size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real world.z_label.cylinders[3].Material;
//   protected output Real world.z_label.cylinders[3].Extra;
//   protected parameter Integer world.z_label.n = 3 \"Number of cylinders\";
//   parameter Real world.axisLength(quantity = \"Length\", unit = \"m\", min = 0.0) = world.nominalLength / 2.0 \"Length of world axes arrows\";
//   parameter Real world.defaultAxisLength(quantity = \"Length\", unit = \"m\") = world.nominalLength / 5.0 \"Default for length of a frame axis (but not world frame)\";
//   parameter Real world.defaultJointLength(quantity = \"Length\", unit = \"m\") = world.nominalLength / 10.0 \"Default for the fixed length of a shape representing a joint\";
//   parameter Real world.defaultJointWidth(quantity = \"Length\", unit = \"m\") = world.nominalLength / 20.0 \"Default for the fixed width of a shape representing a joint\";
//   parameter Real world.defaultForceLength(quantity = \"Length\", unit = \"m\") = world.nominalLength / 10.0 \"Default for the fixed length of a shape representing a force (e.g. damper)\";
//   parameter Real world.defaultForceWidth(quantity = \"Length\", unit = \"m\") = world.nominalLength / 20.0 \"Default for the fixed width of a shape represening a force (e.g. spring, bushing)\";
//   parameter Real world.defaultBodyDiameter(quantity = \"Length\", unit = \"m\") = world.nominalLength / 9.0 \"Default for diameter of sphere representing the center of mass of a body\";
//   parameter Real world.defaultArrowDiameter(quantity = \"Length\", unit = \"m\") = world.nominalLength / 40.0 \"Default for arrow diameter (e.g., of forces, torques, sensors)\";
//   parameter Real world.axisDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.axisLength / world.defaultFrameDiameterFraction \"Diameter of world axes arrows\";
//   parameter Real world.gravityArrowLength(quantity = \"Length\", unit = \"m\") = world.axisLength / 2.0 \"Length of gravity arrow\";
//   protected parameter Real world.labelStart(quantity = \"Length\", unit = \"m\") = 1.05 * world.axisLength;
//   protected parameter Real world.headLength(quantity = \"Length\", unit = \"m\") = min(world.axisLength,5.0 * world.axisDiameter);
//   protected parameter Real world.headWidth(quantity = \"Length\", unit = \"m\") = 3.0 * world.axisDiameter;
//   protected parameter Real world.lineWidth(quantity = \"Length\", unit = \"m\") = world.axisDiameter;
//   protected parameter Real world.scaledLabel(quantity = \"Length\", unit = \"m\") = 3.0 * world.axisDiameter;
//   parameter Real world.gravityArrowDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.gravityArrowLength / world.defaultWidthFraction \"Diameter of gravity arrow\";
//   protected parameter Real world.lineLength(quantity = \"Length\", unit = \"m\") = max(0.0,world.axisLength - world.headLength);
//   protected parameter Real world.gravityHeadLength(quantity = \"Length\", unit = \"m\") = min(world.gravityArrowLength,4.0 * world.gravityArrowDiameter);
//   protected parameter Real world.gravityHeadWidth(quantity = \"Length\", unit = \"m\") = 3.0 * world.gravityArrowDiameter;
//   protected parameter Real world.gravityLineLength(quantity = \"Length\", unit = \"m\") = max(0.0,world.gravityArrowLength - world.gravityHeadLength);
//   parameter Real rh[1](quantity = \"Length\", unit = \"m\") = 0.5 \"Position vector from 'lower left' revolute to 'lower right' revolute joint for all the 3 loops\";
//   parameter Real rh[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from 'lower left' revolute to 'lower right' revolute joint for all the 3 loops\";
//   parameter Real rh[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from 'lower left' revolute to 'lower right' revolute joint for all the 3 loops\";
//   parameter Real rv[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from 'lower left' revolute to 'upper left' revolute joint in the first loop\";
//   parameter Real rv[2](quantity = \"Length\", unit = \"m\") = 0.5 \"Position vector from 'lower left' revolute to 'upper left' revolute joint in the first loop\";
//   parameter Real rv[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from 'lower left' revolute to 'upper left' revolute joint in the first loop\";
//   parameter Real r1b[1](quantity = \"Length\", unit = \"m\") = 0.1 \"Position vector from 'lower right' revolute to 'upper right' revolute joint in the first loop\";
//   parameter Real r1b[2](quantity = \"Length\", unit = \"m\") = 0.5 \"Position vector from 'lower right' revolute to 'upper right' revolute joint in the first loop\";
//   parameter Real r1b[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from 'lower right' revolute to 'upper right' revolute joint in the first loop\";
//   parameter Real r2b[1](quantity = \"Length\", unit = \"m\") = 0.1 \"Position vector from 'lower right' revolute to 'upper right' revolute joint in the second loop\";
//   parameter Real r2b[2](quantity = \"Length\", unit = \"m\") = 0.6 \"Position vector from 'lower right' revolute to 'upper right' revolute joint in the second loop\";
//   parameter Real r2b[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from 'lower right' revolute to 'upper right' revolute joint in the second loop\";
//   parameter Real r3b[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from 'lower right' revolute to 'upper right' revolute joint in the third loop\";
//   parameter Real r3b[2](quantity = \"Length\", unit = \"m\") = 0.55 \"Position vector from 'lower right' revolute to 'upper right' revolute joint in the third loop\";
//   parameter Real r3b[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from 'lower right' revolute to 'upper right' revolute joint in the third loop\";
//   Real jointRRR1.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.frame_ia.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.frame_ia.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.frame_ia.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.frame_ia.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_ia.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_ia.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_ia.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_ia.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_ia.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_ia.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_ia.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_ia.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_ia.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.frame_ia.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.frame_ia.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.frame_ia.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.frame_ia.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.frame_ia.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.frame_ia.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.frame_ia.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.frame_ia.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.frame_ib.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.frame_ib.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.frame_ib.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.frame_ib.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_ib.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_ib.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_ib.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_ib.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_ib.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_ib.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_ib.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_ib.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_ib.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.frame_ib.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.frame_ib.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.frame_ib.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.frame_ib.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.frame_ib.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.frame_ib.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.frame_ib.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.frame_ib.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.frame_im.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.frame_im.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.frame_im.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.frame_im.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_im.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_im.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_im.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_im.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_im.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_im.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_im.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_im.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.frame_im.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.frame_im.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.frame_im.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.frame_im.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.frame_im.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.frame_im.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.frame_im.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.frame_im.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.frame_im.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.axis.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real jointRRR1.axis.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real jointRRR1.bearing.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real jointRRR1.bearing.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Boolean jointRRR1.animation = true \"= true, if animation shall be enabled\";
//   parameter Real jointRRR1.n_a[1](unit = \"1\") = 0.0 \"Axes of revolute joints resolved in frame_a (all axes are parallel to each other)\";
//   parameter Real jointRRR1.n_a[2](unit = \"1\") = 0.0 \"Axes of revolute joints resolved in frame_a (all axes are parallel to each other)\";
//   parameter Real jointRRR1.n_a[3](unit = \"1\") = 1.0 \"Axes of revolute joints resolved in frame_a (all axes are parallel to each other)\";
//   parameter Real jointRRR1.n_b[1](unit = \"1\", fixed = false) = 0.0 \"Axis of revolute joint fixed and resolved in frame_b\";
//   parameter Real jointRRR1.n_b[2](unit = \"1\", fixed = false) = 0.0 \"Axis of revolute joint fixed and resolved in frame_b\";
//   parameter Real jointRRR1.n_b[3](unit = \"1\", fixed = false) = 1.0 \"Axis of revolute joint fixed and resolved in frame_b\";
//   parameter Real jointRRR1.rRod1_ia[1](quantity = \"Length\", unit = \"m\") = r1a[1] \"Vector from origin of frame_a to revolute joint in the middle, resolved in frame_ia\";
//   parameter Real jointRRR1.rRod1_ia[2](quantity = \"Length\", unit = \"m\") = r1a[2] \"Vector from origin of frame_a to revolute joint in the middle, resolved in frame_ia\";
//   parameter Real jointRRR1.rRod1_ia[3](quantity = \"Length\", unit = \"m\") = r1a[3] \"Vector from origin of frame_a to revolute joint in the middle, resolved in frame_ia\";
//   parameter Real jointRRR1.rRod2_ib[1](quantity = \"Length\", unit = \"m\") = r1b[1] \"Vector from origin of frame_ib to revolute joint in the middle, resolved in frame_ib\";
//   parameter Real jointRRR1.rRod2_ib[2](quantity = \"Length\", unit = \"m\") = r1b[2] \"Vector from origin of frame_ib to revolute joint in the middle, resolved in frame_ib\";
//   parameter Real jointRRR1.rRod2_ib[3](quantity = \"Length\", unit = \"m\") = r1b[3] \"Vector from origin of frame_ib to revolute joint in the middle, resolved in frame_ib\";
//   parameter Real jointRRR1.phi_offset(quantity = \"Angle\", unit = \"deg\") = 0.0 \"Relative angle offset of revolute joint at frame_b (angle = phi(t) + from_deg(phi_offset))\";
//   parameter Real jointRRR1.phi_guess(quantity = \"Angle\", unit = \"deg\") = 0.0 \"Select the configuration such that at initial time |phi(t0) - from_deg(phi_guess)|is minimal\";
//   parameter Real jointRRR1.cylinderLength(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultJointLength \"Length of cylinders representing the revolute joints\";
//   parameter Real jointRRR1.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultJointWidth \"Diameter of cylinders representing the revolute joints\";
//   input Integer jointRRR1.cylinderColor[1](min = 0, max = 255) = 255 \"Color of cylinders representing the revolute joints\";
//   input Integer jointRRR1.cylinderColor[2](min = 0, max = 255) = 0 \"Color of cylinders representing the revolute joints\";
//   input Integer jointRRR1.cylinderColor[3](min = 0, max = 255) = 0 \"Color of cylinders representing the revolute joints\";
//   input Integer jointRRR1.rodColor[1](min = 0, max = 255) = 155 \"Color of the two rods connecting the revolute joint\";
//   input Integer jointRRR1.rodColor[2](min = 0, max = 255) = 155 \"Color of the two rods connecting the revolute joint\";
//   input Integer jointRRR1.rodColor[3](min = 0, max = 255) = 155 \"Color of the two rods connecting the revolute joint\";
//   input Real jointRRR1.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean jointRRR1.checkTotalPower = true \"= true, if total power flowing into this component shall be determined (must be zero)\";
//   parameter Real jointRRR1.e_ia[1](unit = \"1\") = jointRRR1.jointUSR.e2_ia[1] \"Unit vector along axes of rotations, resolved in frame_ia\";
//   parameter Real jointRRR1.e_ia[2](unit = \"1\") = jointRRR1.jointUSR.e2_ia[2] \"Unit vector along axes of rotations, resolved in frame_ia\";
//   parameter Real jointRRR1.e_ia[3](unit = \"1\") = jointRRR1.jointUSR.e2_ia[3] \"Unit vector along axes of rotations, resolved in frame_ia\";
//   parameter Real jointRRR1.e_b[1](unit = \"1\") = jointRRR1.jointUSR.revolute.e[1] \"Unit vector along axes of rotations, resolved in frame_b, frame_ib and frame_im\";
//   parameter Real jointRRR1.e_b[2](unit = \"1\") = jointRRR1.jointUSR.revolute.e[2] \"Unit vector along axes of rotations, resolved in frame_b, frame_ib and frame_im\";
//   parameter Real jointRRR1.e_b[3](unit = \"1\") = jointRRR1.jointUSR.revolute.e[3] \"Unit vector along axes of rotations, resolved in frame_b, frame_ib and frame_im\";
//   Real jointRRR1.totalPower(quantity = \"Power\", unit = \"W\") = jointRRR1.jointUSR.totalPower \"Total power flowing into this element, if checkTotalPower=true (otherwise dummy)\";
//   Real jointRRR1.jointUSR.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.frame_ia.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.frame_ia.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.frame_ia.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.frame_ia.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_ia.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_ia.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_ia.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_ia.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_ia.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_ia.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_ia.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_ia.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_ia.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.frame_ia.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.frame_ia.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.frame_ia.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.frame_ia.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.frame_ia.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.frame_ia.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.frame_ia.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.frame_ia.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.frame_ib.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.frame_ib.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.frame_ib.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.frame_ib.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_ib.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_ib.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_ib.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_ib.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_ib.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_ib.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_ib.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_ib.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_ib.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.frame_ib.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.frame_ib.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.frame_ib.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.frame_ib.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.frame_ib.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.frame_ib.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.frame_ib.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.frame_ib.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.frame_im.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.frame_im.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.frame_im.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.frame_im.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_im.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_im.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_im.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_im.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_im.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_im.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_im.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_im.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.frame_im.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.frame_im.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.frame_im.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.frame_im.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.frame_im.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.frame_im.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.frame_im.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.frame_im.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.frame_im.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.axis.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real jointRRR1.jointUSR.axis.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real jointRRR1.jointUSR.bearing.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real jointRRR1.jointUSR.bearing.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Boolean jointRRR1.jointUSR.animation = false \"= true, if animation shall be enabled\";
//   parameter Boolean jointRRR1.jointUSR.showUniversalAxes = false \" = true, if universal joint shall be visualized with two cylinders, otherwise with a sphere (provided animation=true)\";
//   parameter Real jointRRR1.jointUSR.n1_a[1](unit = \"1\") = jointRRR1.n_a[1] \"Axis 1 of universal joint fixed and resolved in frame_a (axis 2 is orthogonal to axis 1 and to rod 1)\";
//   parameter Real jointRRR1.jointUSR.n1_a[2](unit = \"1\") = jointRRR1.n_a[2] \"Axis 1 of universal joint fixed and resolved in frame_a (axis 2 is orthogonal to axis 1 and to rod 1)\";
//   parameter Real jointRRR1.jointUSR.n1_a[3](unit = \"1\") = jointRRR1.n_a[3] \"Axis 1 of universal joint fixed and resolved in frame_a (axis 2 is orthogonal to axis 1 and to rod 1)\";
//   parameter Real jointRRR1.jointUSR.n_b[1](unit = \"1\") = jointRRR1.n_b[1] \"Axis of revolute joint fixed and resolved in frame_b\";
//   parameter Real jointRRR1.jointUSR.n_b[2](unit = \"1\") = jointRRR1.n_b[2] \"Axis of revolute joint fixed and resolved in frame_b\";
//   parameter Real jointRRR1.jointUSR.n_b[3](unit = \"1\") = jointRRR1.n_b[3] \"Axis of revolute joint fixed and resolved in frame_b\";
//   parameter Real jointRRR1.jointUSR.rRod1_ia[1](quantity = \"Length\", unit = \"m\") = jointRRR1.rRod1_ia[1] \"Vector from origin of frame_a to spherical joint, resolved in frame_ia\";
//   parameter Real jointRRR1.jointUSR.rRod1_ia[2](quantity = \"Length\", unit = \"m\") = jointRRR1.rRod1_ia[2] \"Vector from origin of frame_a to spherical joint, resolved in frame_ia\";
//   parameter Real jointRRR1.jointUSR.rRod1_ia[3](quantity = \"Length\", unit = \"m\") = jointRRR1.rRod1_ia[3] \"Vector from origin of frame_a to spherical joint, resolved in frame_ia\";
//   parameter Real jointRRR1.jointUSR.rRod2_ib[1](quantity = \"Length\", unit = \"m\") = jointRRR1.rRod2_ib[1] \"Vector from origin of frame_ib to spherical joint, resolved in frame_ib\";
//   parameter Real jointRRR1.jointUSR.rRod2_ib[2](quantity = \"Length\", unit = \"m\") = jointRRR1.rRod2_ib[2] \"Vector from origin of frame_ib to spherical joint, resolved in frame_ib\";
//   parameter Real jointRRR1.jointUSR.rRod2_ib[3](quantity = \"Length\", unit = \"m\") = jointRRR1.rRod2_ib[3] \"Vector from origin of frame_ib to spherical joint, resolved in frame_ib\";
//   parameter Real jointRRR1.jointUSR.phi_offset(quantity = \"Angle\", unit = \"deg\") = jointRRR1.phi_offset \"Relative angle offset of revolute joint (angle = phi(t) + from_deg(phi_offset))\";
//   parameter Real jointRRR1.jointUSR.phi_guess(quantity = \"Angle\", unit = \"deg\") = jointRRR1.phi_guess \"Select the configuration such that at initial time |phi(t0) - from_deg(phi_guess)|is minimal\";
//   parameter Real jointRRR1.jointUSR.sphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultJointLength \"Diameter of the spheres representing the universal and the spherical joint\";
//   input Integer jointRRR1.jointUSR.sphereColor[1](min = 0, max = 255) = 255 \"Color of the spheres representing the universal and the spherical joint\";
//   input Integer jointRRR1.jointUSR.sphereColor[2](min = 0, max = 255) = 0 \"Color of the spheres representing the universal and the spherical joint\";
//   input Integer jointRRR1.jointUSR.sphereColor[3](min = 0, max = 255) = 0 \"Color of the spheres representing the universal and the spherical joint\";
//   input Integer jointRRR1.jointUSR.rod1Color[1](min = 0, max = 255) = 155 \"Color of rod 1 connecting the universal and the spherical joint\";
//   input Integer jointRRR1.jointUSR.rod1Color[2](min = 0, max = 255) = 155 \"Color of rod 1 connecting the universal and the spherical joint\";
//   input Integer jointRRR1.jointUSR.rod1Color[3](min = 0, max = 255) = 155 \"Color of rod 1 connecting the universal and the spherical joint\";
//   input Integer jointRRR1.jointUSR.rod2Color[1](min = 0, max = 255) = jointRRR1.jointUSR.rod1Color[1] \"Color of rod 2 connecting the revolute and the spherical joint\";
//   input Integer jointRRR1.jointUSR.rod2Color[2](min = 0, max = 255) = jointRRR1.jointUSR.rod1Color[2] \"Color of rod 2 connecting the revolute and the spherical joint\";
//   input Integer jointRRR1.jointUSR.rod2Color[3](min = 0, max = 255) = jointRRR1.jointUSR.rod1Color[3] \"Color of rod 2 connecting the revolute and the spherical joint\";
//   parameter Real jointRRR1.jointUSR.revoluteDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultJointWidth \"Diameter of cylinder representing the revolute joint\";
//   parameter Real jointRRR1.jointUSR.revoluteLength(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultJointLength \"Length of cylinder representing the revolute joint\";
//   input Integer jointRRR1.jointUSR.revoluteColor[1](min = 0, max = 255) = 255 \"Color of cylinder representing the revolute joint\";
//   input Integer jointRRR1.jointUSR.revoluteColor[2](min = 0, max = 255) = 0 \"Color of cylinder representing the revolute joint\";
//   input Integer jointRRR1.jointUSR.revoluteColor[3](min = 0, max = 255) = 0 \"Color of cylinder representing the revolute joint\";
//   input Real jointRRR1.jointUSR.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Real jointRRR1.jointUSR.cylinderLength(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultJointLength \"Length of cylinders representing the two universal joint axes\";
//   parameter Real jointRRR1.jointUSR.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultJointWidth \"Diameter of cylinders representing the two universal joint axes\";
//   input Integer jointRRR1.jointUSR.cylinderColor[1](min = 0, max = 255) = 255 \"Color of cylinders representing the two universal joint axes\";
//   input Integer jointRRR1.jointUSR.cylinderColor[2](min = 0, max = 255) = 0 \"Color of cylinders representing the two universal joint axes\";
//   input Integer jointRRR1.jointUSR.cylinderColor[3](min = 0, max = 255) = 0 \"Color of cylinders representing the two universal joint axes\";
//   parameter Boolean jointRRR1.jointUSR.checkTotalPower = jointRRR1.checkTotalPower \"= true, if total power flowing into this component shall be determined (must be zero)\";
//   parameter Real jointRRR1.jointUSR.eRod1_ia[1](unit = \"1\") = jointRRR1.jointUSR.rod1.eRod_ia[1] \"Unit vector from origin of frame_a to origin of spherical joint, resolved in frame_ia\";
//   parameter Real jointRRR1.jointUSR.eRod1_ia[2](unit = \"1\") = jointRRR1.jointUSR.rod1.eRod_ia[2] \"Unit vector from origin of frame_a to origin of spherical joint, resolved in frame_ia\";
//   parameter Real jointRRR1.jointUSR.eRod1_ia[3](unit = \"1\") = jointRRR1.jointUSR.rod1.eRod_ia[3] \"Unit vector from origin of frame_a to origin of spherical joint, resolved in frame_ia\";
//   parameter Real jointRRR1.jointUSR.e2_ia[1](unit = \"1\") = jointRRR1.jointUSR.rod1.e2_ia[1] \"Unit vector in direction of axis 2 of universal joint, resolved in frame_ia\";
//   parameter Real jointRRR1.jointUSR.e2_ia[2](unit = \"1\") = jointRRR1.jointUSR.rod1.e2_ia[2] \"Unit vector in direction of axis 2 of universal joint, resolved in frame_ia\";
//   parameter Real jointRRR1.jointUSR.e2_ia[3](unit = \"1\") = jointRRR1.jointUSR.rod1.e2_ia[3] \"Unit vector in direction of axis 2 of universal joint, resolved in frame_ia\";
//   parameter Real jointRRR1.jointUSR.rod1Length(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR1.jointUSR.rod1.rodLength \"Length of rod 1 (= distance between universal and spherical joint\";
//   Real jointRRR1.jointUSR.totalPower(quantity = \"Power\", unit = \"W\") \"Total power flowing into this element, if checkTotalPower=true (otherwise dummy)\";
//   Real jointRRR1.jointUSR.aux(quantity = \"Length\", unit = \"m\") \"Denominator used to compute force in rod connecting universal and spherical joint\";
//   Real jointRRR1.jointUSR.f_rod(quantity = \"Force\", unit = \"N\") \"Constraint force in direction of the rod (positive, if rod is pressed)\";
//   Real jointRRR1.jointUSR.revolute.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.revolute.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.revolute.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.revolute.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.revolute.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.revolute.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.revolute.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.revolute.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.revolute.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.revolute.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.revolute.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.revolute.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.revolute.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.revolute.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.revolute.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.revolute.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.revolute.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.revolute.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.revolute.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.revolute.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.revolute.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.revolute.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.revolute.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.revolute.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.revolute.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.revolute.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.revolute.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.revolute.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.revolute.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.revolute.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.revolute.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.revolute.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.revolute.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.revolute.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.revolute.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.revolute.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.revolute.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.revolute.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.revolute.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.revolute.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.revolute.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.revolute.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.revolute.axis.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real jointRRR1.jointUSR.revolute.axis.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real jointRRR1.jointUSR.revolute.bearing.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real jointRRR1.jointUSR.revolute.bearing.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real jointRRR1.jointUSR.revolute.position_a[1](quantity = \"Position\", unit = \"m\") \"Position vector from frame_a to frame_a side of length constraint, resolved in frame_a of revolute joint\";
//   input Real jointRRR1.jointUSR.revolute.position_a[2](quantity = \"Position\", unit = \"m\") \"Position vector from frame_a to frame_a side of length constraint, resolved in frame_a of revolute joint\";
//   input Real jointRRR1.jointUSR.revolute.position_a[3](quantity = \"Position\", unit = \"m\") \"Position vector from frame_a to frame_a side of length constraint, resolved in frame_a of revolute joint\";
//   input Real jointRRR1.jointUSR.revolute.position_b[1](quantity = \"Position\", unit = \"m\") \"Position vector from frame_b to frame_b side of length constraint, resolved in frame_b of revolute joint\";
//   input Real jointRRR1.jointUSR.revolute.position_b[2](quantity = \"Position\", unit = \"m\") \"Position vector from frame_b to frame_b side of length constraint, resolved in frame_b of revolute joint\";
//   input Real jointRRR1.jointUSR.revolute.position_b[3](quantity = \"Position\", unit = \"m\") \"Position vector from frame_b to frame_b side of length constraint, resolved in frame_b of revolute joint\";
//   parameter Boolean jointRRR1.jointUSR.revolute.animation = jointRRR1.jointUSR.animation \"= true, if animation shall be enabled\";
//   parameter Real jointRRR1.jointUSR.revolute.lengthConstraint(quantity = \"Length\", unit = \"m\", start = 1.0) = jointRRR1.jointUSR.rod1Length \"Fixed length of length constraint\";
//   parameter Real jointRRR1.jointUSR.revolute.n[1](unit = \"1\") = jointRRR1.jointUSR.n_b[1] \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real jointRRR1.jointUSR.revolute.n[2](unit = \"1\") = jointRRR1.jointUSR.n_b[2] \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real jointRRR1.jointUSR.revolute.n[3](unit = \"1\") = jointRRR1.jointUSR.n_b[3] \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real jointRRR1.jointUSR.revolute.phi_offset(quantity = \"Angle\", unit = \"deg\") = jointRRR1.jointUSR.phi_offset \"Relative angle offset (angle = phi + from_deg(phi_offset))\";
//   parameter Real jointRRR1.jointUSR.revolute.phi_guess(quantity = \"Angle\", unit = \"deg\") = jointRRR1.jointUSR.phi_guess \"Select the configuration such that at initial time |phi - from_deg(phi_guess)|is minimal\";
//   parameter Real jointRRR1.jointUSR.revolute.cylinderLength(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR1.jointUSR.revoluteLength \"Length of cylinder representing the joint axis\";
//   parameter Real jointRRR1.jointUSR.revolute.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR1.jointUSR.revoluteDiameter \"Diameter of cylinder representing the joint axis\";
//   input Integer jointRRR1.jointUSR.revolute.cylinderColor[1](min = 0, max = 255) = jointRRR1.jointUSR.revoluteColor[1] \"Color of cylinder representing the joint axis\";
//   input Integer jointRRR1.jointUSR.revolute.cylinderColor[2](min = 0, max = 255) = jointRRR1.jointUSR.revoluteColor[2] \"Color of cylinder representing the joint axis\";
//   input Integer jointRRR1.jointUSR.revolute.cylinderColor[3](min = 0, max = 255) = jointRRR1.jointUSR.revoluteColor[3] \"Color of cylinder representing the joint axis\";
//   input Real jointRRR1.jointUSR.revolute.specularCoefficient = jointRRR1.jointUSR.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean jointRRR1.jointUSR.revolute.positiveBranch(fixed = false) \"Based on phi_guess, selection of one of the two solutions of the non-linear constraint equation\";
//   Real jointRRR1.jointUSR.revolute.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle of revolute joint\";
//   Real jointRRR1.jointUSR.revolute.R_rel.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.revolute.R_rel.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.revolute.R_rel.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.revolute.R_rel.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.revolute.R_rel.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.revolute.R_rel.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.revolute.R_rel.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.revolute.R_rel.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.revolute.R_rel.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.revolute.R_rel.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.revolute.R_rel.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.revolute.R_rel.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.revolute.angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"= phi + from_deg(phi_offset) (relative rotation angle between frame_a and frame_b)\";
//   Real jointRRR1.jointUSR.revolute.tau(quantity = \"Torque\", unit = \"N.m\") \"= axis.tau (driving torque in the axis)\";
//   protected Real jointRRR1.jointUSR.revolute.r_a[1](quantity = \"Length\", unit = \"m\") = jointRRR1.jointUSR.revolute.position_a[1] \"Position vector from frame_a to frame_a side of length constraint, resolved in frame_a of revolute joint\";
//   protected Real jointRRR1.jointUSR.revolute.r_a[2](quantity = \"Length\", unit = \"m\") = jointRRR1.jointUSR.revolute.position_a[2] \"Position vector from frame_a to frame_a side of length constraint, resolved in frame_a of revolute joint\";
//   protected Real jointRRR1.jointUSR.revolute.r_a[3](quantity = \"Length\", unit = \"m\") = jointRRR1.jointUSR.revolute.position_a[3] \"Position vector from frame_a to frame_a side of length constraint, resolved in frame_a of revolute joint\";
//   protected Real jointRRR1.jointUSR.revolute.r_b[1](quantity = \"Length\", unit = \"m\") = jointRRR1.jointUSR.revolute.position_b[1] \"Position vector from frame_b to frame_b side of length constraint, resolved in frame_b of revolute joint\";
//   protected Real jointRRR1.jointUSR.revolute.r_b[2](quantity = \"Length\", unit = \"m\") = jointRRR1.jointUSR.revolute.position_b[2] \"Position vector from frame_b to frame_b side of length constraint, resolved in frame_b of revolute joint\";
//   protected Real jointRRR1.jointUSR.revolute.r_b[3](quantity = \"Length\", unit = \"m\") = jointRRR1.jointUSR.revolute.position_b[3] \"Position vector from frame_b to frame_b side of length constraint, resolved in frame_b of revolute joint\";
//   protected Real jointRRR1.jointUSR.revolute.e_r_a \"Projection of r_a on e\";
//   protected Real jointRRR1.jointUSR.revolute.e_r_b \"Projection of r_b on e\";
//   protected Real jointRRR1.jointUSR.revolute.A \"Coefficient A of equation: A*cos(phi) + B*sin(phi) + C = 0\";
//   protected Real jointRRR1.jointUSR.revolute.B \"Coefficient B of equation: A*cos(phi) + B*sin(phi) + C = 0\";
//   protected Real jointRRR1.jointUSR.revolute.C \"Coefficient C of equation: A*cos(phi) + B*sin(phi) + C = 0\";
//   protected Real jointRRR1.jointUSR.revolute.k1 \"Constant of quadratic equation\";
//   protected Real jointRRR1.jointUSR.revolute.k2 \"Constant of quadratic equation\";
//   protected Real jointRRR1.jointUSR.revolute.k1a(start = 1.0);
//   protected Real jointRRR1.jointUSR.revolute.k1b;
//   protected Real jointRRR1.jointUSR.revolute.kcos_angle \"= k1*cos(angle)\";
//   protected Real jointRRR1.jointUSR.revolute.ksin_angle \"= k1*sin(angle)\";
//   parameter Real jointRRR1.jointUSR.revolute.e[1](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR1.jointUSR.revolute.n[1],jointRRR1.jointUSR.revolute.n[2],jointRRR1.jointUSR.revolute.n[3]},1e-13)[1] \"Unit vector in direction of rotation axis, resolved in frame_a\";
//   parameter Real jointRRR1.jointUSR.revolute.e[2](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR1.jointUSR.revolute.n[1],jointRRR1.jointUSR.revolute.n[2],jointRRR1.jointUSR.revolute.n[3]},1e-13)[2] \"Unit vector in direction of rotation axis, resolved in frame_a\";
//   parameter Real jointRRR1.jointUSR.revolute.e[3](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR1.jointUSR.revolute.n[1],jointRRR1.jointUSR.revolute.n[2],jointRRR1.jointUSR.revolute.n[3]},1e-13)[3] \"Unit vector in direction of rotation axis, resolved in frame_a\";
//   Real jointRRR1.jointUSR.rod1.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.rod1.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.rod1.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.rod1.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.rod1.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.rod1.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.rod1.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.rod1.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.rod1.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.rod1.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.rod1.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.rod1.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.rod1.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.rod1.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.rod1.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.rod1.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.rod1.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.rod1.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.rod1.frame_ia.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.rod1.frame_ia.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.rod1.frame_ia.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.rod1.frame_ia.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_ia.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_ia.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_ia.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_ia.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_ia.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_ia.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_ia.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_ia.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_ia.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_ia.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_ia.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.rod1.frame_ia.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.rod1.frame_ia.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.rod1.frame_ia.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.rod1.frame_ia.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.rod1.frame_ia.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.rod1.frame_ia.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean jointRRR1.jointUSR.rod1.animation = jointRRR1.jointUSR.animation \"= true, if animation shall be enabled\";
//   parameter Boolean jointRRR1.jointUSR.rod1.showUniversalAxes = jointRRR1.jointUSR.showUniversalAxes \" = true, if universal joint shall be visualized with two cylinders, otherwise with a sphere (provided animation=true)\";
//   parameter Boolean jointRRR1.jointUSR.rod1.computeRodLength = false \"= true, if distance between frame_a and frame_b shall be computed during initialization (see info)\";
//   parameter Real jointRRR1.jointUSR.rod1.n1_a[1](unit = \"1\") = jointRRR1.jointUSR.n1_a[1] \"Axis 1 of universal joint resolved in frame_a (axis 2 is orthogonal to axis 1 and to rod)\";
//   parameter Real jointRRR1.jointUSR.rod1.n1_a[2](unit = \"1\") = jointRRR1.jointUSR.n1_a[2] \"Axis 1 of universal joint resolved in frame_a (axis 2 is orthogonal to axis 1 and to rod)\";
//   parameter Real jointRRR1.jointUSR.rod1.n1_a[3](unit = \"1\") = jointRRR1.jointUSR.n1_a[3] \"Axis 1 of universal joint resolved in frame_a (axis 2 is orthogonal to axis 1 and to rod)\";
//   parameter Real jointRRR1.jointUSR.rod1.rRod_ia[1](quantity = \"Length\", unit = \"m\") = jointRRR1.jointUSR.rRod1_ia[1] \"Vector from origin of frame_a to origin of frame_b, resolved in frame_ia (if computeRodLength=true, rRod_ia is only an axis vector along the connecting rod)\";
//   parameter Real jointRRR1.jointUSR.rod1.rRod_ia[2](quantity = \"Length\", unit = \"m\") = jointRRR1.jointUSR.rRod1_ia[2] \"Vector from origin of frame_a to origin of frame_b, resolved in frame_ia (if computeRodLength=true, rRod_ia is only an axis vector along the connecting rod)\";
//   parameter Real jointRRR1.jointUSR.rod1.rRod_ia[3](quantity = \"Length\", unit = \"m\") = jointRRR1.jointUSR.rRod1_ia[3] \"Vector from origin of frame_a to origin of frame_b, resolved in frame_ia (if computeRodLength=true, rRod_ia is only an axis vector along the connecting rod)\";
//   parameter Real jointRRR1.jointUSR.rod1.sphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR1.jointUSR.sphereDiameter \"Diameter of spheres representing the universal and the spherical joint\";
//   input Integer jointRRR1.jointUSR.rod1.sphereColor[1](min = 0, max = 255) = jointRRR1.jointUSR.sphereColor[1] \"Color of spheres representing the universal and the spherical joint\";
//   input Integer jointRRR1.jointUSR.rod1.sphereColor[2](min = 0, max = 255) = jointRRR1.jointUSR.sphereColor[2] \"Color of spheres representing the universal and the spherical joint\";
//   input Integer jointRRR1.jointUSR.rod1.sphereColor[3](min = 0, max = 255) = jointRRR1.jointUSR.sphereColor[3] \"Color of spheres representing the universal and the spherical joint\";
//   parameter String jointRRR1.jointUSR.rod1.rodShapeType = \"cylinder\" \"Shape type of rod connecting the universal and the spherical joint\";
//   parameter Real jointRRR1.jointUSR.rod1.rodExtra = 0.0 \"Additional parameter depending on rodShapeType\";
//   input Integer jointRRR1.jointUSR.rod1.rodColor[1](min = 0, max = 255) = jointRRR1.jointUSR.rod1Color[1] \"Color of rod shape connecting the universal and the spherical joints\";
//   input Integer jointRRR1.jointUSR.rod1.rodColor[2](min = 0, max = 255) = jointRRR1.jointUSR.rod1Color[2] \"Color of rod shape connecting the universal and the spherical joints\";
//   input Integer jointRRR1.jointUSR.rod1.rodColor[3](min = 0, max = 255) = jointRRR1.jointUSR.rod1Color[3] \"Color of rod shape connecting the universal and the spherical joints\";
//   parameter Real jointRRR1.jointUSR.rod1.cylinderLength(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR1.jointUSR.cylinderLength \"Length of cylinders representing the two universal joint axes\";
//   parameter Real jointRRR1.jointUSR.rod1.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR1.jointUSR.cylinderDiameter \"Diameter of cylinders representing the two universal joint axes\";
//   input Integer jointRRR1.jointUSR.rod1.cylinderColor[1](min = 0, max = 255) = jointRRR1.jointUSR.cylinderColor[1] \"Color of cylinders representing the two universal joint axes\";
//   input Integer jointRRR1.jointUSR.rod1.cylinderColor[2](min = 0, max = 255) = jointRRR1.jointUSR.cylinderColor[2] \"Color of cylinders representing the two universal joint axes\";
//   input Integer jointRRR1.jointUSR.rod1.cylinderColor[3](min = 0, max = 255) = jointRRR1.jointUSR.cylinderColor[3] \"Color of cylinders representing the two universal joint axes\";
//   input Real jointRRR1.jointUSR.rod1.specularCoefficient = jointRRR1.jointUSR.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean jointRRR1.jointUSR.rod1.kinematicConstraint = false \"= false, if no constraint shall be defined, due to analytically solving a kinematic loop\";
//   Real jointRRR1.jointUSR.rod1.constraintResidue = jointRRR1.jointUSR.rod1.f_rod - jointRRR1.jointUSR.f_rod \"Constraint equation of joint in residue form: Either length constraint (= default) or equation to compute rod force (for analytic solution of loops in combination with Internal.RevoluteWithLengthConstraint/PrismaticWithLengthConstraint)\";
//   parameter Boolean jointRRR1.jointUSR.rod1.checkTotalPower = false \"= true, if total power flowing into this component shall be determined (must be zero)\";
//   Real jointRRR1.jointUSR.rod1.f_rod(quantity = \"Force\", unit = \"N\") \"Constraint force in direction of the rod (positive, if rod is pressed)\";
//   Real jointRRR1.jointUSR.rod1.totalPower(quantity = \"Power\", unit = \"W\") \"Total power flowing into this element, if checkTotalPower=true (otherwise dummy)\";
//   Real jointRRR1.jointUSR.rod1.f_b_a1[1](quantity = \"Force\", unit = \"N\") \"frame_b.f without f_rod part, resolved in frame_a (needed for analytic loop handling)\";
//   Real jointRRR1.jointUSR.rod1.f_b_a1[2](quantity = \"Force\", unit = \"N\") \"frame_b.f without f_rod part, resolved in frame_a (needed for analytic loop handling)\";
//   Real jointRRR1.jointUSR.rod1.f_b_a1[3](quantity = \"Force\", unit = \"N\") \"frame_b.f without f_rod part, resolved in frame_a (needed for analytic loop handling)\";
//   Real jointRRR1.jointUSR.rod1.eRod_a[1](unit = \"1\") \"Unit vector in direction of rRod_a, resolved in frame_a (needed for analytic loop handling)\";
//   Real jointRRR1.jointUSR.rod1.eRod_a[2](unit = \"1\") \"Unit vector in direction of rRod_a, resolved in frame_a (needed for analytic loop handling)\";
//   Real jointRRR1.jointUSR.rod1.eRod_a[3](unit = \"1\") \"Unit vector in direction of rRod_a, resolved in frame_a (needed for analytic loop handling)\";
//   Real jointRRR1.jointUSR.rod1.rRod_0[1](quantity = \"Length\", unit = \"m\", start = jointRRR1.jointUSR.rod1.rRod_ia[1]) \"Position vector from origin of frame_a to origin of frame_b resolved in world frame\";
//   Real jointRRR1.jointUSR.rod1.rRod_0[2](quantity = \"Length\", unit = \"m\", start = jointRRR1.jointUSR.rod1.rRod_ia[2]) \"Position vector from origin of frame_a to origin of frame_b resolved in world frame\";
//   Real jointRRR1.jointUSR.rod1.rRod_0[3](quantity = \"Length\", unit = \"m\", start = jointRRR1.jointUSR.rod1.rRod_ia[3]) \"Position vector from origin of frame_a to origin of frame_b resolved in world frame\";
//   Real jointRRR1.jointUSR.rod1.rRod_a[1](quantity = \"Length\", unit = \"m\", start = jointRRR1.jointUSR.rod1.rRod_ia[1]) \"Position vector from origin of frame_a to origin of frame_b resolved in frame_a\";
//   Real jointRRR1.jointUSR.rod1.rRod_a[2](quantity = \"Length\", unit = \"m\", start = jointRRR1.jointUSR.rod1.rRod_ia[2]) \"Position vector from origin of frame_a to origin of frame_b resolved in frame_a\";
//   Real jointRRR1.jointUSR.rod1.rRod_a[3](quantity = \"Length\", unit = \"m\", start = jointRRR1.jointUSR.rod1.rRod_ia[3]) \"Position vector from origin of frame_a to origin of frame_b resolved in frame_a\";
//   protected Real jointRRR1.jointUSR.rod1.f_b_a[1](quantity = \"Force\", unit = \"N\") \"frame_b.f resolved in frame_a\";
//   protected Real jointRRR1.jointUSR.rod1.f_b_a[2](quantity = \"Force\", unit = \"N\") \"frame_b.f resolved in frame_a\";
//   protected Real jointRRR1.jointUSR.rod1.f_b_a[3](quantity = \"Force\", unit = \"N\") \"frame_b.f resolved in frame_a\";
//   protected Real jointRRR1.jointUSR.rod1.f_ia_a[1](quantity = \"Force\", unit = \"N\") \"frame_ia.f resolved in frame_a\";
//   protected Real jointRRR1.jointUSR.rod1.f_ia_a[2](quantity = \"Force\", unit = \"N\") \"frame_ia.f resolved in frame_a\";
//   protected Real jointRRR1.jointUSR.rod1.f_ia_a[3](quantity = \"Force\", unit = \"N\") \"frame_ia.f resolved in frame_a\";
//   protected Real jointRRR1.jointUSR.rod1.t_ia_a[1](quantity = \"Torque\", unit = \"N.m\") \"frame_ia.t resolved in frame_a\";
//   protected Real jointRRR1.jointUSR.rod1.t_ia_a[2](quantity = \"Torque\", unit = \"N.m\") \"frame_ia.t resolved in frame_a\";
//   protected Real jointRRR1.jointUSR.rod1.t_ia_a[3](quantity = \"Torque\", unit = \"N.m\") \"frame_ia.t resolved in frame_a\";
//   protected Real jointRRR1.jointUSR.rod1.n2_a[1](unit = \"1\") \"Vector in direction of axis 2 of the universal joint (e2_ia), resolved in frame_a\";
//   protected Real jointRRR1.jointUSR.rod1.n2_a[2](unit = \"1\") \"Vector in direction of axis 2 of the universal joint (e2_ia), resolved in frame_a\";
//   protected Real jointRRR1.jointUSR.rod1.n2_a[3](unit = \"1\") \"Vector in direction of axis 2 of the universal joint (e2_ia), resolved in frame_a\";
//   protected Real jointRRR1.jointUSR.rod1.length2_n2_a(unit = \"m2\", start = 1.0) \"Square of length of vector n2_a\";
//   protected Real jointRRR1.jointUSR.rod1.length_n2_a(quantity = \"Length\", unit = \"m\") \"Length of vector n2_a\";
//   protected Real jointRRR1.jointUSR.rod1.e2_a[1](unit = \"1\") \"Unit vector in direction of axis 2 of the universal joint (e2_ia), resolved in frame_a\";
//   protected Real jointRRR1.jointUSR.rod1.e2_a[2](unit = \"1\") \"Unit vector in direction of axis 2 of the universal joint (e2_ia), resolved in frame_a\";
//   protected Real jointRRR1.jointUSR.rod1.e2_a[3](unit = \"1\") \"Unit vector in direction of axis 2 of the universal joint (e2_ia), resolved in frame_a\";
//   protected Real jointRRR1.jointUSR.rod1.e3_a[1](unit = \"1\") \"Unit vector perpendicular to eRod_ia and e2_a, resolved in frame_a\";
//   protected Real jointRRR1.jointUSR.rod1.e3_a[2](unit = \"1\") \"Unit vector perpendicular to eRod_ia and e2_a, resolved in frame_a\";
//   protected Real jointRRR1.jointUSR.rod1.e3_a[3](unit = \"1\") \"Unit vector perpendicular to eRod_ia and e2_a, resolved in frame_a\";
//   protected Real jointRRR1.jointUSR.rod1.der_rRod_a_L[1](unit = \"1/s\") \"= der(rRod_a)/rodLength\";
//   protected Real jointRRR1.jointUSR.rod1.der_rRod_a_L[2](unit = \"1/s\") \"= der(rRod_a)/rodLength\";
//   protected Real jointRRR1.jointUSR.rod1.der_rRod_a_L[3](unit = \"1/s\") \"= der(rRod_a)/rodLength\";
//   protected Real jointRRR1.jointUSR.rod1.w_rel_ia1[1](quantity = \"AngularVelocity\", unit = \"rad/s\");
//   protected Real jointRRR1.jointUSR.rod1.w_rel_ia1[2](quantity = \"AngularVelocity\", unit = \"rad/s\");
//   protected Real jointRRR1.jointUSR.rod1.w_rel_ia1[3](quantity = \"AngularVelocity\", unit = \"rad/s\");
//   Real jointRRR1.jointUSR.rod1.R_rel_ia1.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia1.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia1.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia1.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia1.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia1.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia1.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia1.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia1.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia1.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia1.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia1.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia2.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia2.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia2.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia2.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia2.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia2.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia2.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia2.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia2.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia2.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia2.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia2.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.rod1.R_rel_ia.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real jointRRR1.jointUSR.rod1.rodLength(quantity = \"Length\", unit = \"m\", min = 0.0, fixed =  NOT jointRRR1.jointUSR.rod1.computeRodLength) = Modelica.Math.Vectors.length({jointRRR1.jointUSR.rod1.rRod_ia[1],jointRRR1.jointUSR.rod1.rRod_ia[2],jointRRR1.jointUSR.rod1.rRod_ia[3]}) \"Length of rod (distance between origin of frame_a and origin of frame_b)\";
//   parameter Real jointRRR1.jointUSR.rod1.eRod_ia[1](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR1.jointUSR.rod1.rRod_ia[1],jointRRR1.jointUSR.rod1.rRod_ia[2],jointRRR1.jointUSR.rod1.rRod_ia[3]},1e-13)[1] \"Unit vector from origin of frame_a to origin of frame_b, resolved in frame_ia\";
//   parameter Real jointRRR1.jointUSR.rod1.eRod_ia[2](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR1.jointUSR.rod1.rRod_ia[1],jointRRR1.jointUSR.rod1.rRod_ia[2],jointRRR1.jointUSR.rod1.rRod_ia[3]},1e-13)[2] \"Unit vector from origin of frame_a to origin of frame_b, resolved in frame_ia\";
//   parameter Real jointRRR1.jointUSR.rod1.eRod_ia[3](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR1.jointUSR.rod1.rRod_ia[1],jointRRR1.jointUSR.rod1.rRod_ia[2],jointRRR1.jointUSR.rod1.rRod_ia[3]},1e-13)[3] \"Unit vector from origin of frame_a to origin of frame_b, resolved in frame_ia\";
//   parameter Real jointRRR1.jointUSR.rod1.rodWidth(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR1.jointUSR.rod1Diameter \"Width of rod shape in direction of axis 2 of universal joint.\";
//   parameter Real jointRRR1.jointUSR.rod1.e2_ia[1](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR1.jointUSR.rod1.n1_a[2] * jointRRR1.jointUSR.rod1.eRod_ia[3] - jointRRR1.jointUSR.rod1.n1_a[3] * jointRRR1.jointUSR.rod1.eRod_ia[2],jointRRR1.jointUSR.rod1.n1_a[3] * jointRRR1.jointUSR.rod1.eRod_ia[1] - jointRRR1.jointUSR.rod1.n1_a[1] * jointRRR1.jointUSR.rod1.eRod_ia[3],jointRRR1.jointUSR.rod1.n1_a[1] * jointRRR1.jointUSR.rod1.eRod_ia[2] - jointRRR1.jointUSR.rod1.n1_a[2] * jointRRR1.jointUSR.rod1.eRod_ia[1]},1e-13)[1] \"Unit vector in direction of axis 2 of universal joint, resolved in frame_ia (orthogonal to n1_a and eRod_ia; note: frame_ia is parallel to frame_a when the universal joint angles are zero)\";
//   parameter Real jointRRR1.jointUSR.rod1.e2_ia[2](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR1.jointUSR.rod1.n1_a[2] * jointRRR1.jointUSR.rod1.eRod_ia[3] - jointRRR1.jointUSR.rod1.n1_a[3] * jointRRR1.jointUSR.rod1.eRod_ia[2],jointRRR1.jointUSR.rod1.n1_a[3] * jointRRR1.jointUSR.rod1.eRod_ia[1] - jointRRR1.jointUSR.rod1.n1_a[1] * jointRRR1.jointUSR.rod1.eRod_ia[3],jointRRR1.jointUSR.rod1.n1_a[1] * jointRRR1.jointUSR.rod1.eRod_ia[2] - jointRRR1.jointUSR.rod1.n1_a[2] * jointRRR1.jointUSR.rod1.eRod_ia[1]},1e-13)[2] \"Unit vector in direction of axis 2 of universal joint, resolved in frame_ia (orthogonal to n1_a and eRod_ia; note: frame_ia is parallel to frame_a when the universal joint angles are zero)\";
//   parameter Real jointRRR1.jointUSR.rod1.e2_ia[3](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR1.jointUSR.rod1.n1_a[2] * jointRRR1.jointUSR.rod1.eRod_ia[3] - jointRRR1.jointUSR.rod1.n1_a[3] * jointRRR1.jointUSR.rod1.eRod_ia[2],jointRRR1.jointUSR.rod1.n1_a[3] * jointRRR1.jointUSR.rod1.eRod_ia[1] - jointRRR1.jointUSR.rod1.n1_a[1] * jointRRR1.jointUSR.rod1.eRod_ia[3],jointRRR1.jointUSR.rod1.n1_a[1] * jointRRR1.jointUSR.rod1.eRod_ia[2] - jointRRR1.jointUSR.rod1.n1_a[2] * jointRRR1.jointUSR.rod1.eRod_ia[1]},1e-13)[3] \"Unit vector in direction of axis 2 of universal joint, resolved in frame_ia (orthogonal to n1_a and eRod_ia; note: frame_ia is parallel to frame_a when the universal joint angles are zero)\";
//   parameter Real jointRRR1.jointUSR.rod1.rodHeight(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR1.jointUSR.rod1Diameter \"Height of rod shape in direction that is orthogonal to rod and to axis 2\";
//   parameter Real jointRRR1.jointUSR.rod1.e3_ia[1](unit = \"1\") = jointRRR1.jointUSR.rod1.eRod_ia[2] * jointRRR1.jointUSR.rod1.e2_ia[3] - jointRRR1.jointUSR.rod1.eRod_ia[3] * jointRRR1.jointUSR.rod1.e2_ia[2] \"Unit vector perpendicular to eRod_ia and e2_ia, resolved in frame_ia\";
//   parameter Real jointRRR1.jointUSR.rod1.e3_ia[2](unit = \"1\") = jointRRR1.jointUSR.rod1.eRod_ia[3] * jointRRR1.jointUSR.rod1.e2_ia[1] - jointRRR1.jointUSR.rod1.eRod_ia[1] * jointRRR1.jointUSR.rod1.e2_ia[3] \"Unit vector perpendicular to eRod_ia and e2_ia, resolved in frame_ia\";
//   parameter Real jointRRR1.jointUSR.rod1.e3_ia[3](unit = \"1\") = jointRRR1.jointUSR.rod1.eRod_ia[1] * jointRRR1.jointUSR.rod1.e2_ia[2] - jointRRR1.jointUSR.rod1.eRod_ia[2] * jointRRR1.jointUSR.rod1.e2_ia[1] \"Unit vector perpendicular to eRod_ia and e2_ia, resolved in frame_ia\";
//   Real jointRRR1.jointUSR.rod2.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.rod2.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.rod2.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.rod2.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod2.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod2.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod2.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod2.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod2.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod2.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod2.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod2.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod2.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.rod2.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.rod2.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.rod2.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.rod2.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.rod2.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.rod2.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.rod2.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.rod2.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.rod2.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.rod2.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.rod2.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.rod2.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod2.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod2.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod2.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod2.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod2.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod2.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod2.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod2.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.rod2.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.rod2.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.rod2.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.rod2.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.rod2.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.rod2.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.rod2.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.rod2.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.rod2.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean jointRRR1.jointUSR.rod2.animation = jointRRR1.jointUSR.animation \"= true, if animation shall be enabled\";
//   parameter Real jointRRR1.jointUSR.rod2.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = jointRRR1.jointUSR.rRod2_ib[1] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real jointRRR1.jointUSR.rod2.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = jointRRR1.jointUSR.rRod2_ib[2] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real jointRRR1.jointUSR.rod2.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = jointRRR1.jointUSR.rRod2_ib[3] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter String jointRRR1.jointUSR.rod2.shapeType = \"cylinder\" \" Type of shape\";
//   parameter Real jointRRR1.jointUSR.rod2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real jointRRR1.jointUSR.rod2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real jointRRR1.jointUSR.rod2.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real jointRRR1.jointUSR.rod2.widthDirection[1](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real jointRRR1.jointUSR.rod2.widthDirection[2](unit = \"1\") = 1.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real jointRRR1.jointUSR.rod2.widthDirection[3](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real jointRRR1.jointUSR.rod2.extra = 0.0 \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer jointRRR1.jointUSR.rod2.color[1](min = 0, max = 255) = jointRRR1.jointUSR.rod2Color[1] \" Color of shape\";
//   input Integer jointRRR1.jointUSR.rod2.color[2](min = 0, max = 255) = jointRRR1.jointUSR.rod2Color[2] \" Color of shape\";
//   input Integer jointRRR1.jointUSR.rod2.color[3](min = 0, max = 255) = jointRRR1.jointUSR.rod2Color[3] \" Color of shape\";
//   input Real jointRRR1.jointUSR.rod2.specularCoefficient = jointRRR1.jointUSR.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Real jointRRR1.jointUSR.rod2.lengthDirection[1](unit = \"1\") = jointRRR1.jointUSR.rod2.r[1] - jointRRR1.jointUSR.rod2.r_shape[1] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real jointRRR1.jointUSR.rod2.lengthDirection[2](unit = \"1\") = jointRRR1.jointUSR.rod2.r[2] - jointRRR1.jointUSR.rod2.r_shape[2] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real jointRRR1.jointUSR.rod2.lengthDirection[3](unit = \"1\") = jointRRR1.jointUSR.rod2.r[3] - jointRRR1.jointUSR.rod2.r_shape[3] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real jointRRR1.jointUSR.rod2.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({jointRRR1.jointUSR.rod2.r[1] - jointRRR1.jointUSR.rod2.r_shape[1],jointRRR1.jointUSR.rod2.r[2] - jointRRR1.jointUSR.rod2.r_shape[2],jointRRR1.jointUSR.rod2.r[3] - jointRRR1.jointUSR.rod2.r_shape[3]}) \" Length of shape\";
//   parameter Real jointRRR1.jointUSR.rod2.width(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR1.jointUSR.rod2Diameter \" Width of shape\";
//   parameter Real jointRRR1.jointUSR.rod2.height(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR1.jointUSR.rod2Diameter \" Height of shape.\";
//   Real jointRRR1.jointUSR.relativePosition.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.relativePosition.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   output Real jointRRR1.jointUSR.relativePosition.r_rel[1] \"Relative position vector resolved in frame defined by resolveInFrame\";
//   output Real jointRRR1.jointUSR.relativePosition.r_rel[2] \"Relative position vector resolved in frame defined by resolveInFrame\";
//   output Real jointRRR1.jointUSR.relativePosition.r_rel[3] \"Relative position vector resolved in frame defined by resolveInFrame\";
//   parameter enumeration(world, frame_a, frame_b, frame_resolve) jointRRR1.jointUSR.relativePosition.resolveInFrame = Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_a \"Frame in which output vector r_rel shall be resolved (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   output Real jointRRR1.jointUSR.relativePosition.relativePosition.r_rel[1](quantity = \"Position\", unit = \"m\") \"Relative position vector frame_b.r_0 - frame_a.r_0 resolved in frame defined by resolveInFrame\";
//   output Real jointRRR1.jointUSR.relativePosition.relativePosition.r_rel[2](quantity = \"Position\", unit = \"m\") \"Relative position vector frame_b.r_0 - frame_a.r_0 resolved in frame defined by resolveInFrame\";
//   output Real jointRRR1.jointUSR.relativePosition.relativePosition.r_rel[3](quantity = \"Position\", unit = \"m\") \"Relative position vector frame_b.r_0 - frame_a.r_0 resolved in frame defined by resolveInFrame\";
//   parameter enumeration(world, frame_a, frame_b, frame_resolve) jointRRR1.jointUSR.relativePosition.relativePosition.resolveInFrame = jointRRR1.jointUSR.relativePosition.resolveInFrame \"Frame in which output vector r_rel is resolved (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)\";
//   Real jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   output Real jointRRR1.jointUSR.position_b[1].y \"Connector of Real output signal\";
//   parameter Real jointRRR1.jointUSR.position_b[1].k(start = 1.0) = jointRRR1.jointUSR.rRod2_ib[1] \"Constant output value\";
//   output Real jointRRR1.jointUSR.position_b[2].y \"Connector of Real output signal\";
//   parameter Real jointRRR1.jointUSR.position_b[2].k(start = 1.0) = jointRRR1.jointUSR.rRod2_ib[2] \"Constant output value\";
//   output Real jointRRR1.jointUSR.position_b[3].y \"Connector of Real output signal\";
//   parameter Real jointRRR1.jointUSR.position_b[3].k(start = 1.0) = jointRRR1.jointUSR.rRod2_ib[3] \"Constant output value\";
//   parameter Real jointRRR1.jointUSR.rod1Diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR1.jointUSR.sphereDiameter / 2.0 \"Diameter of rod 1 connecting the universal and the spherical joint\";
//   parameter Real jointRRR1.jointUSR.rod2Diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR1.jointUSR.rod1Diameter \"Diameter of rod 2 connecting the revolute and the spherical joint\";
//   parameter String jointRRR1.shape_rev1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real jointRRR1.shape_rev1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rev1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rev1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rev1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rev1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rev1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rev1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rev1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rev1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rev1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR1.shape_rev1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR1.shape_rev1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR1.shape_rev1.r[1](quantity = \"Length\", unit = \"m\") = jointRRR1.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR1.shape_rev1.r[2](quantity = \"Length\", unit = \"m\") = jointRRR1.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR1.shape_rev1.r[3](quantity = \"Length\", unit = \"m\") = jointRRR1.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR1.shape_rev1.r_shape[1](quantity = \"Length\", unit = \"m\") = (-jointRRR1.cylinderLength) * jointRRR1.e_a[1] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR1.shape_rev1.r_shape[2](quantity = \"Length\", unit = \"m\") = (-jointRRR1.cylinderLength) * jointRRR1.e_a[2] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR1.shape_rev1.r_shape[3](quantity = \"Length\", unit = \"m\") = (-jointRRR1.cylinderLength) * jointRRR1.e_a[3] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR1.shape_rev1.lengthDirection[1](unit = \"1\") = jointRRR1.e_a[1] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR1.shape_rev1.lengthDirection[2](unit = \"1\") = jointRRR1.e_a[2] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR1.shape_rev1.lengthDirection[3](unit = \"1\") = jointRRR1.e_a[3] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR1.shape_rev1.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR1.shape_rev1.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR1.shape_rev1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR1.shape_rev1.length(quantity = \"Length\", unit = \"m\") = jointRRR1.cylinderLength \"Length of visual object\";
//   input Real jointRRR1.shape_rev1.width(quantity = \"Length\", unit = \"m\") = jointRRR1.cylinderDiameter \"Width of visual object\";
//   input Real jointRRR1.shape_rev1.height(quantity = \"Length\", unit = \"m\") = jointRRR1.cylinderDiameter \"Height of visual object\";
//   input Real jointRRR1.shape_rev1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real jointRRR1.shape_rev1.color[1] = Real(jointRRR1.cylinderColor[1]) \"Color of shape\";
//   input Real jointRRR1.shape_rev1.color[2] = Real(jointRRR1.cylinderColor[2]) \"Color of shape\";
//   input Real jointRRR1.shape_rev1.color[3] = Real(jointRRR1.cylinderColor[3]) \"Color of shape\";
//   input Real jointRRR1.shape_rev1.specularCoefficient = jointRRR1.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real jointRRR1.shape_rev1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({jointRRR1.shape_rev1.lengthDirection[1],jointRRR1.shape_rev1.lengthDirection[2],jointRRR1.shape_rev1.lengthDirection[3]});
//   protected Real jointRRR1.shape_rev1.e_x[1](unit = \"1\") = if noEvent(jointRRR1.shape_rev1.abs_n_x < 1e-10) then 1.0 else jointRRR1.shape_rev1.lengthDirection[1] / jointRRR1.shape_rev1.abs_n_x;
//   protected Real jointRRR1.shape_rev1.e_x[2](unit = \"1\") = if noEvent(jointRRR1.shape_rev1.abs_n_x < 1e-10) then 0.0 else jointRRR1.shape_rev1.lengthDirection[2] / jointRRR1.shape_rev1.abs_n_x;
//   protected Real jointRRR1.shape_rev1.e_x[3](unit = \"1\") = if noEvent(jointRRR1.shape_rev1.abs_n_x < 1e-10) then 0.0 else jointRRR1.shape_rev1.lengthDirection[3] / jointRRR1.shape_rev1.abs_n_x;
//   protected Real jointRRR1.shape_rev1.n_z_aux[1](unit = \"1\") = jointRRR1.shape_rev1.e_x[2] * jointRRR1.shape_rev1.widthDirection[3] - jointRRR1.shape_rev1.e_x[3] * jointRRR1.shape_rev1.widthDirection[2];
//   protected Real jointRRR1.shape_rev1.n_z_aux[2](unit = \"1\") = jointRRR1.shape_rev1.e_x[3] * jointRRR1.shape_rev1.widthDirection[1] - jointRRR1.shape_rev1.e_x[1] * jointRRR1.shape_rev1.widthDirection[3];
//   protected Real jointRRR1.shape_rev1.n_z_aux[3](unit = \"1\") = jointRRR1.shape_rev1.e_x[1] * jointRRR1.shape_rev1.widthDirection[2] - jointRRR1.shape_rev1.e_x[2] * jointRRR1.shape_rev1.widthDirection[1];
//   protected Real jointRRR1.shape_rev1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR1.shape_rev1.e_x[1],jointRRR1.shape_rev1.e_x[2],jointRRR1.shape_rev1.e_x[3]},if noEvent(jointRRR1.shape_rev1.n_z_aux[1] ^ 2.0 + (jointRRR1.shape_rev1.n_z_aux[2] ^ 2.0 + jointRRR1.shape_rev1.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR1.shape_rev1.widthDirection[1],jointRRR1.shape_rev1.widthDirection[2],jointRRR1.shape_rev1.widthDirection[3]} else if noEvent(abs(jointRRR1.shape_rev1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR1.shape_rev1.e_x[1],jointRRR1.shape_rev1.e_x[2],jointRRR1.shape_rev1.e_x[3]})[1];
//   protected Real jointRRR1.shape_rev1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR1.shape_rev1.e_x[1],jointRRR1.shape_rev1.e_x[2],jointRRR1.shape_rev1.e_x[3]},if noEvent(jointRRR1.shape_rev1.n_z_aux[1] ^ 2.0 + (jointRRR1.shape_rev1.n_z_aux[2] ^ 2.0 + jointRRR1.shape_rev1.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR1.shape_rev1.widthDirection[1],jointRRR1.shape_rev1.widthDirection[2],jointRRR1.shape_rev1.widthDirection[3]} else if noEvent(abs(jointRRR1.shape_rev1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR1.shape_rev1.e_x[1],jointRRR1.shape_rev1.e_x[2],jointRRR1.shape_rev1.e_x[3]})[2];
//   protected Real jointRRR1.shape_rev1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR1.shape_rev1.e_x[1],jointRRR1.shape_rev1.e_x[2],jointRRR1.shape_rev1.e_x[3]},if noEvent(jointRRR1.shape_rev1.n_z_aux[1] ^ 2.0 + (jointRRR1.shape_rev1.n_z_aux[2] ^ 2.0 + jointRRR1.shape_rev1.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR1.shape_rev1.widthDirection[1],jointRRR1.shape_rev1.widthDirection[2],jointRRR1.shape_rev1.widthDirection[3]} else if noEvent(abs(jointRRR1.shape_rev1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR1.shape_rev1.e_x[1],jointRRR1.shape_rev1.e_x[2],jointRRR1.shape_rev1.e_x[3]})[3];
//   protected output Real jointRRR1.shape_rev1.Form;
//   output Real jointRRR1.shape_rev1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR1.shape_rev1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR1.shape_rev1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR1.shape_rev1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR1.shape_rev1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR1.shape_rev1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR1.shape_rev1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real jointRRR1.shape_rev1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real jointRRR1.shape_rev1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real jointRRR1.shape_rev1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR1.shape_rev1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR1.shape_rev1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR1.shape_rev1.Material;
//   protected output Real jointRRR1.shape_rev1.Extra;
//   parameter String jointRRR1.shape_rev2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real jointRRR1.shape_rev2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rev2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rev2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rev2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rev2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rev2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rev2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rev2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rev2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rev2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR1.shape_rev2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR1.shape_rev2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR1.shape_rev2.r[1](quantity = \"Length\", unit = \"m\") = jointRRR1.frame_im.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR1.shape_rev2.r[2](quantity = \"Length\", unit = \"m\") = jointRRR1.frame_im.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR1.shape_rev2.r[3](quantity = \"Length\", unit = \"m\") = jointRRR1.frame_im.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR1.shape_rev2.r_shape[1](quantity = \"Length\", unit = \"m\") = (-jointRRR1.cylinderLength) * jointRRR1.e_b[1] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR1.shape_rev2.r_shape[2](quantity = \"Length\", unit = \"m\") = (-jointRRR1.cylinderLength) * jointRRR1.e_b[2] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR1.shape_rev2.r_shape[3](quantity = \"Length\", unit = \"m\") = (-jointRRR1.cylinderLength) * jointRRR1.e_b[3] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR1.shape_rev2.lengthDirection[1](unit = \"1\") = jointRRR1.e_b[1] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR1.shape_rev2.lengthDirection[2](unit = \"1\") = jointRRR1.e_b[2] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR1.shape_rev2.lengthDirection[3](unit = \"1\") = jointRRR1.e_b[3] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR1.shape_rev2.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR1.shape_rev2.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR1.shape_rev2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR1.shape_rev2.length(quantity = \"Length\", unit = \"m\") = jointRRR1.cylinderLength \"Length of visual object\";
//   input Real jointRRR1.shape_rev2.width(quantity = \"Length\", unit = \"m\") = jointRRR1.cylinderDiameter \"Width of visual object\";
//   input Real jointRRR1.shape_rev2.height(quantity = \"Length\", unit = \"m\") = jointRRR1.cylinderDiameter \"Height of visual object\";
//   input Real jointRRR1.shape_rev2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real jointRRR1.shape_rev2.color[1] = Real(jointRRR1.cylinderColor[1]) \"Color of shape\";
//   input Real jointRRR1.shape_rev2.color[2] = Real(jointRRR1.cylinderColor[2]) \"Color of shape\";
//   input Real jointRRR1.shape_rev2.color[3] = Real(jointRRR1.cylinderColor[3]) \"Color of shape\";
//   input Real jointRRR1.shape_rev2.specularCoefficient = jointRRR1.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real jointRRR1.shape_rev2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({jointRRR1.shape_rev2.lengthDirection[1],jointRRR1.shape_rev2.lengthDirection[2],jointRRR1.shape_rev2.lengthDirection[3]});
//   protected Real jointRRR1.shape_rev2.e_x[1](unit = \"1\") = if noEvent(jointRRR1.shape_rev2.abs_n_x < 1e-10) then 1.0 else jointRRR1.shape_rev2.lengthDirection[1] / jointRRR1.shape_rev2.abs_n_x;
//   protected Real jointRRR1.shape_rev2.e_x[2](unit = \"1\") = if noEvent(jointRRR1.shape_rev2.abs_n_x < 1e-10) then 0.0 else jointRRR1.shape_rev2.lengthDirection[2] / jointRRR1.shape_rev2.abs_n_x;
//   protected Real jointRRR1.shape_rev2.e_x[3](unit = \"1\") = if noEvent(jointRRR1.shape_rev2.abs_n_x < 1e-10) then 0.0 else jointRRR1.shape_rev2.lengthDirection[3] / jointRRR1.shape_rev2.abs_n_x;
//   protected Real jointRRR1.shape_rev2.n_z_aux[1](unit = \"1\") = jointRRR1.shape_rev2.e_x[2] * jointRRR1.shape_rev2.widthDirection[3] - jointRRR1.shape_rev2.e_x[3] * jointRRR1.shape_rev2.widthDirection[2];
//   protected Real jointRRR1.shape_rev2.n_z_aux[2](unit = \"1\") = jointRRR1.shape_rev2.e_x[3] * jointRRR1.shape_rev2.widthDirection[1] - jointRRR1.shape_rev2.e_x[1] * jointRRR1.shape_rev2.widthDirection[3];
//   protected Real jointRRR1.shape_rev2.n_z_aux[3](unit = \"1\") = jointRRR1.shape_rev2.e_x[1] * jointRRR1.shape_rev2.widthDirection[2] - jointRRR1.shape_rev2.e_x[2] * jointRRR1.shape_rev2.widthDirection[1];
//   protected Real jointRRR1.shape_rev2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR1.shape_rev2.e_x[1],jointRRR1.shape_rev2.e_x[2],jointRRR1.shape_rev2.e_x[3]},if noEvent(jointRRR1.shape_rev2.n_z_aux[1] ^ 2.0 + (jointRRR1.shape_rev2.n_z_aux[2] ^ 2.0 + jointRRR1.shape_rev2.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR1.shape_rev2.widthDirection[1],jointRRR1.shape_rev2.widthDirection[2],jointRRR1.shape_rev2.widthDirection[3]} else if noEvent(abs(jointRRR1.shape_rev2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR1.shape_rev2.e_x[1],jointRRR1.shape_rev2.e_x[2],jointRRR1.shape_rev2.e_x[3]})[1];
//   protected Real jointRRR1.shape_rev2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR1.shape_rev2.e_x[1],jointRRR1.shape_rev2.e_x[2],jointRRR1.shape_rev2.e_x[3]},if noEvent(jointRRR1.shape_rev2.n_z_aux[1] ^ 2.0 + (jointRRR1.shape_rev2.n_z_aux[2] ^ 2.0 + jointRRR1.shape_rev2.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR1.shape_rev2.widthDirection[1],jointRRR1.shape_rev2.widthDirection[2],jointRRR1.shape_rev2.widthDirection[3]} else if noEvent(abs(jointRRR1.shape_rev2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR1.shape_rev2.e_x[1],jointRRR1.shape_rev2.e_x[2],jointRRR1.shape_rev2.e_x[3]})[2];
//   protected Real jointRRR1.shape_rev2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR1.shape_rev2.e_x[1],jointRRR1.shape_rev2.e_x[2],jointRRR1.shape_rev2.e_x[3]},if noEvent(jointRRR1.shape_rev2.n_z_aux[1] ^ 2.0 + (jointRRR1.shape_rev2.n_z_aux[2] ^ 2.0 + jointRRR1.shape_rev2.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR1.shape_rev2.widthDirection[1],jointRRR1.shape_rev2.widthDirection[2],jointRRR1.shape_rev2.widthDirection[3]} else if noEvent(abs(jointRRR1.shape_rev2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR1.shape_rev2.e_x[1],jointRRR1.shape_rev2.e_x[2],jointRRR1.shape_rev2.e_x[3]})[3];
//   protected output Real jointRRR1.shape_rev2.Form;
//   output Real jointRRR1.shape_rev2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR1.shape_rev2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR1.shape_rev2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR1.shape_rev2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR1.shape_rev2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR1.shape_rev2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR1.shape_rev2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real jointRRR1.shape_rev2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real jointRRR1.shape_rev2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real jointRRR1.shape_rev2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR1.shape_rev2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR1.shape_rev2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR1.shape_rev2.Material;
//   protected output Real jointRRR1.shape_rev2.Extra;
//   parameter String jointRRR1.shape_rev3.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real jointRRR1.shape_rev3.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rev3.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rev3.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rev3.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rev3.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rev3.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rev3.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rev3.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rev3.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rev3.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR1.shape_rev3.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR1.shape_rev3.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR1.shape_rev3.r[1](quantity = \"Length\", unit = \"m\") = jointRRR1.frame_b.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR1.shape_rev3.r[2](quantity = \"Length\", unit = \"m\") = jointRRR1.frame_b.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR1.shape_rev3.r[3](quantity = \"Length\", unit = \"m\") = jointRRR1.frame_b.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR1.shape_rev3.r_shape[1](quantity = \"Length\", unit = \"m\") = (-jointRRR1.cylinderLength) * jointRRR1.e_b[1] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR1.shape_rev3.r_shape[2](quantity = \"Length\", unit = \"m\") = (-jointRRR1.cylinderLength) * jointRRR1.e_b[2] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR1.shape_rev3.r_shape[3](quantity = \"Length\", unit = \"m\") = (-jointRRR1.cylinderLength) * jointRRR1.e_b[3] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR1.shape_rev3.lengthDirection[1](unit = \"1\") = jointRRR1.e_b[1] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR1.shape_rev3.lengthDirection[2](unit = \"1\") = jointRRR1.e_b[2] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR1.shape_rev3.lengthDirection[3](unit = \"1\") = jointRRR1.e_b[3] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR1.shape_rev3.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR1.shape_rev3.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR1.shape_rev3.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR1.shape_rev3.length(quantity = \"Length\", unit = \"m\") = jointRRR1.cylinderLength \"Length of visual object\";
//   input Real jointRRR1.shape_rev3.width(quantity = \"Length\", unit = \"m\") = jointRRR1.cylinderDiameter \"Width of visual object\";
//   input Real jointRRR1.shape_rev3.height(quantity = \"Length\", unit = \"m\") = jointRRR1.cylinderDiameter \"Height of visual object\";
//   input Real jointRRR1.shape_rev3.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real jointRRR1.shape_rev3.color[1] = Real(jointRRR1.cylinderColor[1]) \"Color of shape\";
//   input Real jointRRR1.shape_rev3.color[2] = Real(jointRRR1.cylinderColor[2]) \"Color of shape\";
//   input Real jointRRR1.shape_rev3.color[3] = Real(jointRRR1.cylinderColor[3]) \"Color of shape\";
//   input Real jointRRR1.shape_rev3.specularCoefficient = jointRRR1.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real jointRRR1.shape_rev3.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({jointRRR1.shape_rev3.lengthDirection[1],jointRRR1.shape_rev3.lengthDirection[2],jointRRR1.shape_rev3.lengthDirection[3]});
//   protected Real jointRRR1.shape_rev3.e_x[1](unit = \"1\") = if noEvent(jointRRR1.shape_rev3.abs_n_x < 1e-10) then 1.0 else jointRRR1.shape_rev3.lengthDirection[1] / jointRRR1.shape_rev3.abs_n_x;
//   protected Real jointRRR1.shape_rev3.e_x[2](unit = \"1\") = if noEvent(jointRRR1.shape_rev3.abs_n_x < 1e-10) then 0.0 else jointRRR1.shape_rev3.lengthDirection[2] / jointRRR1.shape_rev3.abs_n_x;
//   protected Real jointRRR1.shape_rev3.e_x[3](unit = \"1\") = if noEvent(jointRRR1.shape_rev3.abs_n_x < 1e-10) then 0.0 else jointRRR1.shape_rev3.lengthDirection[3] / jointRRR1.shape_rev3.abs_n_x;
//   protected Real jointRRR1.shape_rev3.n_z_aux[1](unit = \"1\") = jointRRR1.shape_rev3.e_x[2] * jointRRR1.shape_rev3.widthDirection[3] - jointRRR1.shape_rev3.e_x[3] * jointRRR1.shape_rev3.widthDirection[2];
//   protected Real jointRRR1.shape_rev3.n_z_aux[2](unit = \"1\") = jointRRR1.shape_rev3.e_x[3] * jointRRR1.shape_rev3.widthDirection[1] - jointRRR1.shape_rev3.e_x[1] * jointRRR1.shape_rev3.widthDirection[3];
//   protected Real jointRRR1.shape_rev3.n_z_aux[3](unit = \"1\") = jointRRR1.shape_rev3.e_x[1] * jointRRR1.shape_rev3.widthDirection[2] - jointRRR1.shape_rev3.e_x[2] * jointRRR1.shape_rev3.widthDirection[1];
//   protected Real jointRRR1.shape_rev3.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR1.shape_rev3.e_x[1],jointRRR1.shape_rev3.e_x[2],jointRRR1.shape_rev3.e_x[3]},if noEvent(jointRRR1.shape_rev3.n_z_aux[1] ^ 2.0 + (jointRRR1.shape_rev3.n_z_aux[2] ^ 2.0 + jointRRR1.shape_rev3.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR1.shape_rev3.widthDirection[1],jointRRR1.shape_rev3.widthDirection[2],jointRRR1.shape_rev3.widthDirection[3]} else if noEvent(abs(jointRRR1.shape_rev3.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR1.shape_rev3.e_x[1],jointRRR1.shape_rev3.e_x[2],jointRRR1.shape_rev3.e_x[3]})[1];
//   protected Real jointRRR1.shape_rev3.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR1.shape_rev3.e_x[1],jointRRR1.shape_rev3.e_x[2],jointRRR1.shape_rev3.e_x[3]},if noEvent(jointRRR1.shape_rev3.n_z_aux[1] ^ 2.0 + (jointRRR1.shape_rev3.n_z_aux[2] ^ 2.0 + jointRRR1.shape_rev3.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR1.shape_rev3.widthDirection[1],jointRRR1.shape_rev3.widthDirection[2],jointRRR1.shape_rev3.widthDirection[3]} else if noEvent(abs(jointRRR1.shape_rev3.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR1.shape_rev3.e_x[1],jointRRR1.shape_rev3.e_x[2],jointRRR1.shape_rev3.e_x[3]})[2];
//   protected Real jointRRR1.shape_rev3.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR1.shape_rev3.e_x[1],jointRRR1.shape_rev3.e_x[2],jointRRR1.shape_rev3.e_x[3]},if noEvent(jointRRR1.shape_rev3.n_z_aux[1] ^ 2.0 + (jointRRR1.shape_rev3.n_z_aux[2] ^ 2.0 + jointRRR1.shape_rev3.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR1.shape_rev3.widthDirection[1],jointRRR1.shape_rev3.widthDirection[2],jointRRR1.shape_rev3.widthDirection[3]} else if noEvent(abs(jointRRR1.shape_rev3.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR1.shape_rev3.e_x[1],jointRRR1.shape_rev3.e_x[2],jointRRR1.shape_rev3.e_x[3]})[3];
//   protected output Real jointRRR1.shape_rev3.Form;
//   output Real jointRRR1.shape_rev3.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR1.shape_rev3.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR1.shape_rev3.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR1.shape_rev3.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR1.shape_rev3.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR1.shape_rev3.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR1.shape_rev3.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real jointRRR1.shape_rev3.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real jointRRR1.shape_rev3.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real jointRRR1.shape_rev3.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR1.shape_rev3.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR1.shape_rev3.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR1.shape_rev3.Material;
//   protected output Real jointRRR1.shape_rev3.Extra;
//   parameter String jointRRR1.shape_rod1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real jointRRR1.shape_rod1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rod1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rod1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rod1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rod1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rod1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rod1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rod1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rod1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rod1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR1.shape_rod1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR1.shape_rod1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR1.shape_rod1.r[1](quantity = \"Length\", unit = \"m\") = jointRRR1.frame_ia.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR1.shape_rod1.r[2](quantity = \"Length\", unit = \"m\") = jointRRR1.frame_ia.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR1.shape_rod1.r[3](quantity = \"Length\", unit = \"m\") = jointRRR1.frame_ia.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR1.shape_rod1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR1.shape_rod1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR1.shape_rod1.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR1.shape_rod1.lengthDirection[1](unit = \"1\") = jointRRR1.rRod1_ia[1] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR1.shape_rod1.lengthDirection[2](unit = \"1\") = jointRRR1.rRod1_ia[2] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR1.shape_rod1.lengthDirection[3](unit = \"1\") = jointRRR1.rRod1_ia[3] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR1.shape_rod1.widthDirection[1](unit = \"1\") = jointRRR1.e_ia[1] \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR1.shape_rod1.widthDirection[2](unit = \"1\") = jointRRR1.e_ia[2] \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR1.shape_rod1.widthDirection[3](unit = \"1\") = jointRRR1.e_ia[3] \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR1.shape_rod1.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({jointRRR1.rRod1_ia[1],jointRRR1.rRod1_ia[2],jointRRR1.rRod1_ia[3]}) \"Length of visual object\";
//   input Real jointRRR1.shape_rod1.width(quantity = \"Length\", unit = \"m\") = jointRRR1.rodDiameter \"Width of visual object\";
//   input Real jointRRR1.shape_rod1.height(quantity = \"Length\", unit = \"m\") = jointRRR1.rodDiameter \"Height of visual object\";
//   input Real jointRRR1.shape_rod1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real jointRRR1.shape_rod1.color[1] = Real(jointRRR1.rodColor[1]) \"Color of shape\";
//   input Real jointRRR1.shape_rod1.color[2] = Real(jointRRR1.rodColor[2]) \"Color of shape\";
//   input Real jointRRR1.shape_rod1.color[3] = Real(jointRRR1.rodColor[3]) \"Color of shape\";
//   input Real jointRRR1.shape_rod1.specularCoefficient = jointRRR1.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real jointRRR1.shape_rod1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({jointRRR1.shape_rod1.lengthDirection[1],jointRRR1.shape_rod1.lengthDirection[2],jointRRR1.shape_rod1.lengthDirection[3]});
//   protected Real jointRRR1.shape_rod1.e_x[1](unit = \"1\") = if noEvent(jointRRR1.shape_rod1.abs_n_x < 1e-10) then 1.0 else jointRRR1.shape_rod1.lengthDirection[1] / jointRRR1.shape_rod1.abs_n_x;
//   protected Real jointRRR1.shape_rod1.e_x[2](unit = \"1\") = if noEvent(jointRRR1.shape_rod1.abs_n_x < 1e-10) then 0.0 else jointRRR1.shape_rod1.lengthDirection[2] / jointRRR1.shape_rod1.abs_n_x;
//   protected Real jointRRR1.shape_rod1.e_x[3](unit = \"1\") = if noEvent(jointRRR1.shape_rod1.abs_n_x < 1e-10) then 0.0 else jointRRR1.shape_rod1.lengthDirection[3] / jointRRR1.shape_rod1.abs_n_x;
//   protected Real jointRRR1.shape_rod1.n_z_aux[1](unit = \"1\") = jointRRR1.shape_rod1.e_x[2] * jointRRR1.shape_rod1.widthDirection[3] - jointRRR1.shape_rod1.e_x[3] * jointRRR1.shape_rod1.widthDirection[2];
//   protected Real jointRRR1.shape_rod1.n_z_aux[2](unit = \"1\") = jointRRR1.shape_rod1.e_x[3] * jointRRR1.shape_rod1.widthDirection[1] - jointRRR1.shape_rod1.e_x[1] * jointRRR1.shape_rod1.widthDirection[3];
//   protected Real jointRRR1.shape_rod1.n_z_aux[3](unit = \"1\") = jointRRR1.shape_rod1.e_x[1] * jointRRR1.shape_rod1.widthDirection[2] - jointRRR1.shape_rod1.e_x[2] * jointRRR1.shape_rod1.widthDirection[1];
//   protected Real jointRRR1.shape_rod1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR1.shape_rod1.e_x[1],jointRRR1.shape_rod1.e_x[2],jointRRR1.shape_rod1.e_x[3]},if noEvent(jointRRR1.shape_rod1.n_z_aux[1] ^ 2.0 + (jointRRR1.shape_rod1.n_z_aux[2] ^ 2.0 + jointRRR1.shape_rod1.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR1.shape_rod1.widthDirection[1],jointRRR1.shape_rod1.widthDirection[2],jointRRR1.shape_rod1.widthDirection[3]} else if noEvent(abs(jointRRR1.shape_rod1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR1.shape_rod1.e_x[1],jointRRR1.shape_rod1.e_x[2],jointRRR1.shape_rod1.e_x[3]})[1];
//   protected Real jointRRR1.shape_rod1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR1.shape_rod1.e_x[1],jointRRR1.shape_rod1.e_x[2],jointRRR1.shape_rod1.e_x[3]},if noEvent(jointRRR1.shape_rod1.n_z_aux[1] ^ 2.0 + (jointRRR1.shape_rod1.n_z_aux[2] ^ 2.0 + jointRRR1.shape_rod1.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR1.shape_rod1.widthDirection[1],jointRRR1.shape_rod1.widthDirection[2],jointRRR1.shape_rod1.widthDirection[3]} else if noEvent(abs(jointRRR1.shape_rod1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR1.shape_rod1.e_x[1],jointRRR1.shape_rod1.e_x[2],jointRRR1.shape_rod1.e_x[3]})[2];
//   protected Real jointRRR1.shape_rod1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR1.shape_rod1.e_x[1],jointRRR1.shape_rod1.e_x[2],jointRRR1.shape_rod1.e_x[3]},if noEvent(jointRRR1.shape_rod1.n_z_aux[1] ^ 2.0 + (jointRRR1.shape_rod1.n_z_aux[2] ^ 2.0 + jointRRR1.shape_rod1.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR1.shape_rod1.widthDirection[1],jointRRR1.shape_rod1.widthDirection[2],jointRRR1.shape_rod1.widthDirection[3]} else if noEvent(abs(jointRRR1.shape_rod1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR1.shape_rod1.e_x[1],jointRRR1.shape_rod1.e_x[2],jointRRR1.shape_rod1.e_x[3]})[3];
//   protected output Real jointRRR1.shape_rod1.Form;
//   output Real jointRRR1.shape_rod1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR1.shape_rod1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR1.shape_rod1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR1.shape_rod1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR1.shape_rod1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR1.shape_rod1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR1.shape_rod1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real jointRRR1.shape_rod1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real jointRRR1.shape_rod1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real jointRRR1.shape_rod1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR1.shape_rod1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR1.shape_rod1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR1.shape_rod1.Material;
//   protected output Real jointRRR1.shape_rod1.Extra;
//   parameter String jointRRR1.shape_rod2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real jointRRR1.shape_rod2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rod2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rod2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rod2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rod2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rod2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rod2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rod2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rod2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR1.shape_rod2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR1.shape_rod2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR1.shape_rod2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR1.shape_rod2.r[1](quantity = \"Length\", unit = \"m\") = jointRRR1.frame_ib.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR1.shape_rod2.r[2](quantity = \"Length\", unit = \"m\") = jointRRR1.frame_ib.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR1.shape_rod2.r[3](quantity = \"Length\", unit = \"m\") = jointRRR1.frame_ib.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR1.shape_rod2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR1.shape_rod2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR1.shape_rod2.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR1.shape_rod2.lengthDirection[1](unit = \"1\") = jointRRR1.rRod2_ib[1] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR1.shape_rod2.lengthDirection[2](unit = \"1\") = jointRRR1.rRod2_ib[2] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR1.shape_rod2.lengthDirection[3](unit = \"1\") = jointRRR1.rRod2_ib[3] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR1.shape_rod2.widthDirection[1](unit = \"1\") = jointRRR1.e_b[1] \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR1.shape_rod2.widthDirection[2](unit = \"1\") = jointRRR1.e_b[2] \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR1.shape_rod2.widthDirection[3](unit = \"1\") = jointRRR1.e_b[3] \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR1.shape_rod2.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({jointRRR1.rRod2_ib[1],jointRRR1.rRod2_ib[2],jointRRR1.rRod2_ib[3]}) \"Length of visual object\";
//   input Real jointRRR1.shape_rod2.width(quantity = \"Length\", unit = \"m\") = jointRRR1.rodDiameter \"Width of visual object\";
//   input Real jointRRR1.shape_rod2.height(quantity = \"Length\", unit = \"m\") = jointRRR1.rodDiameter \"Height of visual object\";
//   input Real jointRRR1.shape_rod2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real jointRRR1.shape_rod2.color[1] = Real(jointRRR1.rodColor[1]) \"Color of shape\";
//   input Real jointRRR1.shape_rod2.color[2] = Real(jointRRR1.rodColor[2]) \"Color of shape\";
//   input Real jointRRR1.shape_rod2.color[3] = Real(jointRRR1.rodColor[3]) \"Color of shape\";
//   input Real jointRRR1.shape_rod2.specularCoefficient = jointRRR1.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real jointRRR1.shape_rod2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({jointRRR1.shape_rod2.lengthDirection[1],jointRRR1.shape_rod2.lengthDirection[2],jointRRR1.shape_rod2.lengthDirection[3]});
//   protected Real jointRRR1.shape_rod2.e_x[1](unit = \"1\") = if noEvent(jointRRR1.shape_rod2.abs_n_x < 1e-10) then 1.0 else jointRRR1.shape_rod2.lengthDirection[1] / jointRRR1.shape_rod2.abs_n_x;
//   protected Real jointRRR1.shape_rod2.e_x[2](unit = \"1\") = if noEvent(jointRRR1.shape_rod2.abs_n_x < 1e-10) then 0.0 else jointRRR1.shape_rod2.lengthDirection[2] / jointRRR1.shape_rod2.abs_n_x;
//   protected Real jointRRR1.shape_rod2.e_x[3](unit = \"1\") = if noEvent(jointRRR1.shape_rod2.abs_n_x < 1e-10) then 0.0 else jointRRR1.shape_rod2.lengthDirection[3] / jointRRR1.shape_rod2.abs_n_x;
//   protected Real jointRRR1.shape_rod2.n_z_aux[1](unit = \"1\") = jointRRR1.shape_rod2.e_x[2] * jointRRR1.shape_rod2.widthDirection[3] - jointRRR1.shape_rod2.e_x[3] * jointRRR1.shape_rod2.widthDirection[2];
//   protected Real jointRRR1.shape_rod2.n_z_aux[2](unit = \"1\") = jointRRR1.shape_rod2.e_x[3] * jointRRR1.shape_rod2.widthDirection[1] - jointRRR1.shape_rod2.e_x[1] * jointRRR1.shape_rod2.widthDirection[3];
//   protected Real jointRRR1.shape_rod2.n_z_aux[3](unit = \"1\") = jointRRR1.shape_rod2.e_x[1] * jointRRR1.shape_rod2.widthDirection[2] - jointRRR1.shape_rod2.e_x[2] * jointRRR1.shape_rod2.widthDirection[1];
//   protected Real jointRRR1.shape_rod2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR1.shape_rod2.e_x[1],jointRRR1.shape_rod2.e_x[2],jointRRR1.shape_rod2.e_x[3]},if noEvent(jointRRR1.shape_rod2.n_z_aux[1] ^ 2.0 + (jointRRR1.shape_rod2.n_z_aux[2] ^ 2.0 + jointRRR1.shape_rod2.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR1.shape_rod2.widthDirection[1],jointRRR1.shape_rod2.widthDirection[2],jointRRR1.shape_rod2.widthDirection[3]} else if noEvent(abs(jointRRR1.shape_rod2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR1.shape_rod2.e_x[1],jointRRR1.shape_rod2.e_x[2],jointRRR1.shape_rod2.e_x[3]})[1];
//   protected Real jointRRR1.shape_rod2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR1.shape_rod2.e_x[1],jointRRR1.shape_rod2.e_x[2],jointRRR1.shape_rod2.e_x[3]},if noEvent(jointRRR1.shape_rod2.n_z_aux[1] ^ 2.0 + (jointRRR1.shape_rod2.n_z_aux[2] ^ 2.0 + jointRRR1.shape_rod2.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR1.shape_rod2.widthDirection[1],jointRRR1.shape_rod2.widthDirection[2],jointRRR1.shape_rod2.widthDirection[3]} else if noEvent(abs(jointRRR1.shape_rod2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR1.shape_rod2.e_x[1],jointRRR1.shape_rod2.e_x[2],jointRRR1.shape_rod2.e_x[3]})[2];
//   protected Real jointRRR1.shape_rod2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR1.shape_rod2.e_x[1],jointRRR1.shape_rod2.e_x[2],jointRRR1.shape_rod2.e_x[3]},if noEvent(jointRRR1.shape_rod2.n_z_aux[1] ^ 2.0 + (jointRRR1.shape_rod2.n_z_aux[2] ^ 2.0 + jointRRR1.shape_rod2.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR1.shape_rod2.widthDirection[1],jointRRR1.shape_rod2.widthDirection[2],jointRRR1.shape_rod2.widthDirection[3]} else if noEvent(abs(jointRRR1.shape_rod2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR1.shape_rod2.e_x[1],jointRRR1.shape_rod2.e_x[2],jointRRR1.shape_rod2.e_x[3]})[3];
//   protected output Real jointRRR1.shape_rod2.Form;
//   output Real jointRRR1.shape_rod2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR1.shape_rod2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR1.shape_rod2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR1.shape_rod2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR1.shape_rod2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR1.shape_rod2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR1.shape_rod2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real jointRRR1.shape_rod2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real jointRRR1.shape_rod2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real jointRRR1.shape_rod2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR1.shape_rod2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR1.shape_rod2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR1.shape_rod2.Material;
//   protected output Real jointRRR1.shape_rod2.Extra;
//   parameter Real jointRRR1.e_a[1](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR1.n_a[1],jointRRR1.n_a[2],jointRRR1.n_a[3]},1e-13)[1] \"Unit vector along axes of rotations, resolved in frame_a\";
//   parameter Real jointRRR1.e_a[2](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR1.n_a[1],jointRRR1.n_a[2],jointRRR1.n_a[3]},1e-13)[2] \"Unit vector along axes of rotations, resolved in frame_a\";
//   parameter Real jointRRR1.e_a[3](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR1.n_a[1],jointRRR1.n_a[2],jointRRR1.n_a[3]},1e-13)[3] \"Unit vector along axes of rotations, resolved in frame_a\";
//   parameter Real jointRRR1.rodDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 1.1 * jointRRR1.cylinderDiameter \"Diameter of the two rods connecting the revolute joints\";
//   Real rev.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real rev.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real rev.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real rev.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real rev.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real rev.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real rev.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real rev.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real rev.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real rev.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real rev.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real rev.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real rev.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real rev.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real rev.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real rev.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real rev.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real rev.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real rev.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real rev.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real rev.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real rev.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real rev.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real rev.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real rev.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real rev.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real rev.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real rev.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real rev.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real rev.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real rev.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real rev.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real rev.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real rev.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real rev.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real rev.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real rev.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real rev.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real rev.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real rev.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real rev.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real rev.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean rev.useAxisFlange = true \"= true, if axis flange is enabled\";
//   parameter Boolean rev.animation = true \"= true, if animation shall be enabled (show axis as cylinder)\";
//   parameter Real rev.n[1](unit = \"1\") = 0.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real rev.n[2](unit = \"1\") = 0.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real rev.n[3](unit = \"1\") = 1.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   constant Real rev.phi_offset(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Relative angle offset (angle = phi_offset + phi)\";
//   parameter Real rev.cylinderLength(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultJointLength \"Length of cylinder representing the joint axis\";
//   parameter Real rev.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultJointWidth \"Diameter of cylinder representing the joint axis\";
//   input Integer rev.cylinderColor[1](min = 0, max = 255) = 255 \"Color of cylinder representing the joint axis\";
//   input Integer rev.cylinderColor[2](min = 0, max = 255) = 0 \"Color of cylinder representing the joint axis\";
//   input Integer rev.cylinderColor[3](min = 0, max = 255) = 0 \"Color of cylinder representing the joint axis\";
//   input Real rev.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter enumeration(never, avoid, default, prefer, always) rev.stateSelect = StateSelect.prefer \"Priority to use joint angle phi and w=der(phi) as states\";
//   Real rev.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, StateSelect = StateSelect.prefer) \"Relative rotation angle from frame_a to frame_b\";
//   Real rev.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, fixed = true, StateSelect = StateSelect.prefer) \"First derivative of angle phi (relative angular velocity)\";
//   Real rev.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = 0.0) \"Second derivative of angle phi (relative angular acceleration)\";
//   Real rev.tau(quantity = \"Torque\", unit = \"N.m\") \"Driving torque in direction of axis of rotation\";
//   Real rev.angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"= phi_offset + phi\";
//   Real rev.R_rel.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real rev.R_rel.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real rev.R_rel.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real rev.R_rel.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real rev.R_rel.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real rev.R_rel.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real rev.R_rel.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real rev.R_rel.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real rev.R_rel.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real rev.R_rel.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real rev.R_rel.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real rev.R_rel.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real rev.fixed.phi0(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Fixed offset angle of housing\";
//   Real rev.fixed.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real rev.fixed.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real rev.internalAxis.tau(quantity = \"Torque\", unit = \"N.m\") = rev.tau \"External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau)\";
//   Real rev.internalAxis.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"External support angle (= flange.phi)\";
//   Real rev.internalAxis.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real rev.internalAxis.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real rev.axis.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real rev.axis.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real rev.support.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real rev.support.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter String rev.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real rev.cylinder.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real rev.cylinder.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real rev.cylinder.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real rev.cylinder.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real rev.cylinder.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real rev.cylinder.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real rev.cylinder.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real rev.cylinder.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real rev.cylinder.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real rev.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rev.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rev.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rev.cylinder.r[1](quantity = \"Length\", unit = \"m\") = rev.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rev.cylinder.r[2](quantity = \"Length\", unit = \"m\") = rev.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rev.cylinder.r[3](quantity = \"Length\", unit = \"m\") = rev.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rev.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = (-rev.cylinderLength) * rev.e[1] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rev.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = (-rev.cylinderLength) * rev.e[2] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rev.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = (-rev.cylinderLength) * rev.e[3] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rev.cylinder.lengthDirection[1](unit = \"1\") = rev.e[1] \"Vector in length direction, resolved in object frame\";
//   input Real rev.cylinder.lengthDirection[2](unit = \"1\") = rev.e[2] \"Vector in length direction, resolved in object frame\";
//   input Real rev.cylinder.lengthDirection[3](unit = \"1\") = rev.e[3] \"Vector in length direction, resolved in object frame\";
//   input Real rev.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rev.cylinder.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real rev.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real rev.cylinder.length(quantity = \"Length\", unit = \"m\") = rev.cylinderLength \"Length of visual object\";
//   input Real rev.cylinder.width(quantity = \"Length\", unit = \"m\") = rev.cylinderDiameter \"Width of visual object\";
//   input Real rev.cylinder.height(quantity = \"Length\", unit = \"m\") = rev.cylinderDiameter \"Height of visual object\";
//   input Real rev.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real rev.cylinder.color[1] = Real(rev.cylinderColor[1]) \"Color of shape\";
//   input Real rev.cylinder.color[2] = Real(rev.cylinderColor[2]) \"Color of shape\";
//   input Real rev.cylinder.color[3] = Real(rev.cylinderColor[3]) \"Color of shape\";
//   input Real rev.cylinder.specularCoefficient = rev.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real rev.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({rev.cylinder.lengthDirection[1],rev.cylinder.lengthDirection[2],rev.cylinder.lengthDirection[3]});
//   protected Real rev.cylinder.e_x[1](unit = \"1\") = if noEvent(rev.cylinder.abs_n_x < 1e-10) then 1.0 else rev.cylinder.lengthDirection[1] / rev.cylinder.abs_n_x;
//   protected Real rev.cylinder.e_x[2](unit = \"1\") = if noEvent(rev.cylinder.abs_n_x < 1e-10) then 0.0 else rev.cylinder.lengthDirection[2] / rev.cylinder.abs_n_x;
//   protected Real rev.cylinder.e_x[3](unit = \"1\") = if noEvent(rev.cylinder.abs_n_x < 1e-10) then 0.0 else rev.cylinder.lengthDirection[3] / rev.cylinder.abs_n_x;
//   protected Real rev.cylinder.n_z_aux[1](unit = \"1\") = rev.cylinder.e_x[2] * rev.cylinder.widthDirection[3] - rev.cylinder.e_x[3] * rev.cylinder.widthDirection[2];
//   protected Real rev.cylinder.n_z_aux[2](unit = \"1\") = rev.cylinder.e_x[3] * rev.cylinder.widthDirection[1] - rev.cylinder.e_x[1] * rev.cylinder.widthDirection[3];
//   protected Real rev.cylinder.n_z_aux[3](unit = \"1\") = rev.cylinder.e_x[1] * rev.cylinder.widthDirection[2] - rev.cylinder.e_x[2] * rev.cylinder.widthDirection[1];
//   protected Real rev.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rev.cylinder.e_x[1],rev.cylinder.e_x[2],rev.cylinder.e_x[3]},if noEvent(rev.cylinder.n_z_aux[1] ^ 2.0 + (rev.cylinder.n_z_aux[2] ^ 2.0 + rev.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {rev.cylinder.widthDirection[1],rev.cylinder.widthDirection[2],rev.cylinder.widthDirection[3]} else if noEvent(abs(rev.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rev.cylinder.e_x[1],rev.cylinder.e_x[2],rev.cylinder.e_x[3]})[1];
//   protected Real rev.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rev.cylinder.e_x[1],rev.cylinder.e_x[2],rev.cylinder.e_x[3]},if noEvent(rev.cylinder.n_z_aux[1] ^ 2.0 + (rev.cylinder.n_z_aux[2] ^ 2.0 + rev.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {rev.cylinder.widthDirection[1],rev.cylinder.widthDirection[2],rev.cylinder.widthDirection[3]} else if noEvent(abs(rev.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rev.cylinder.e_x[1],rev.cylinder.e_x[2],rev.cylinder.e_x[3]})[2];
//   protected Real rev.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rev.cylinder.e_x[1],rev.cylinder.e_x[2],rev.cylinder.e_x[3]},if noEvent(rev.cylinder.n_z_aux[1] ^ 2.0 + (rev.cylinder.n_z_aux[2] ^ 2.0 + rev.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {rev.cylinder.widthDirection[1],rev.cylinder.widthDirection[2],rev.cylinder.widthDirection[3]} else if noEvent(abs(rev.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rev.cylinder.e_x[1],rev.cylinder.e_x[2],rev.cylinder.e_x[3]})[3];
//   protected output Real rev.cylinder.Form;
//   output Real rev.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rev.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rev.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rev.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rev.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rev.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rev.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rev.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rev.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real rev.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rev.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rev.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rev.cylinder.Material;
//   protected output Real rev.cylinder.Extra;
//   protected parameter Real rev.e[1](unit = \"1\") = Modelica.Math.Vectors.normalize({rev.n[1],rev.n[2],rev.n[3]},1e-13)[1] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   protected parameter Real rev.e[2](unit = \"1\") = Modelica.Math.Vectors.normalize({rev.n[1],rev.n[2],rev.n[3]},1e-13)[2] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   protected parameter Real rev.e[3](unit = \"1\") = Modelica.Math.Vectors.normalize({rev.n[1],rev.n[2],rev.n[3]},1e-13)[3] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   Real rod1.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real rod1.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real rod1.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real rod1.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real rod1.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real rod1.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real rod1.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real rod1.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real rod1.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real rod1.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real rod1.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real rod1.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real rod1.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real rod1.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real rod1.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real rod1.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real rod1.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real rod1.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real rod1.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real rod1.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real rod1.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real rod1.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real rod1.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real rod1.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real rod1.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real rod1.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real rod1.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real rod1.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real rod1.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real rod1.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real rod1.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real rod1.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real rod1.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real rod1.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real rod1.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real rod1.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real rod1.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real rod1.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real rod1.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real rod1.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real rod1.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real rod1.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean rod1.animation = true \"= true, if animation shall be enabled\";
//   parameter Real rod1.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = rv[1] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real rod1.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = rv[2] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real rod1.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = rv[3] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter String rod1.shapeType = \"cylinder\" \" Type of shape\";
//   parameter Real rod1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real rod1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real rod1.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real rod1.widthDirection[1](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real rod1.widthDirection[2](unit = \"1\") = 1.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real rod1.widthDirection[3](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real rod1.extra = 0.0 \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer rod1.color[1](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer rod1.color[2](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer rod1.color[3](min = 0, max = 255) = 155 \" Color of shape\";
//   input Real rod1.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter String rod1.shape.shapeType = rod1.shapeType \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real rod1.shape.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real rod1.shape.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real rod1.shape.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real rod1.shape.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real rod1.shape.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real rod1.shape.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real rod1.shape.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real rod1.shape.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real rod1.shape.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real rod1.shape.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rod1.shape.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rod1.shape.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rod1.shape.r[1](quantity = \"Length\", unit = \"m\") = rod1.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rod1.shape.r[2](quantity = \"Length\", unit = \"m\") = rod1.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rod1.shape.r[3](quantity = \"Length\", unit = \"m\") = rod1.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rod1.shape.r_shape[1](quantity = \"Length\", unit = \"m\") = rod1.r_shape[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rod1.shape.r_shape[2](quantity = \"Length\", unit = \"m\") = rod1.r_shape[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rod1.shape.r_shape[3](quantity = \"Length\", unit = \"m\") = rod1.r_shape[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rod1.shape.lengthDirection[1](unit = \"1\") = rod1.lengthDirection[1] \"Vector in length direction, resolved in object frame\";
//   input Real rod1.shape.lengthDirection[2](unit = \"1\") = rod1.lengthDirection[2] \"Vector in length direction, resolved in object frame\";
//   input Real rod1.shape.lengthDirection[3](unit = \"1\") = rod1.lengthDirection[3] \"Vector in length direction, resolved in object frame\";
//   input Real rod1.shape.widthDirection[1](unit = \"1\") = rod1.widthDirection[1] \"Vector in width direction, resolved in object frame\";
//   input Real rod1.shape.widthDirection[2](unit = \"1\") = rod1.widthDirection[2] \"Vector in width direction, resolved in object frame\";
//   input Real rod1.shape.widthDirection[3](unit = \"1\") = rod1.widthDirection[3] \"Vector in width direction, resolved in object frame\";
//   input Real rod1.shape.length(quantity = \"Length\", unit = \"m\") = rod1.length \"Length of visual object\";
//   input Real rod1.shape.width(quantity = \"Length\", unit = \"m\") = rod1.width \"Width of visual object\";
//   input Real rod1.shape.height(quantity = \"Length\", unit = \"m\") = rod1.height \"Height of visual object\";
//   input Real rod1.shape.extra = rod1.extra \"Additional size data for some of the shape types\";
//   input Real rod1.shape.color[1] = Real(rod1.color[1]) \"Color of shape\";
//   input Real rod1.shape.color[2] = Real(rod1.color[2]) \"Color of shape\";
//   input Real rod1.shape.color[3] = Real(rod1.color[3]) \"Color of shape\";
//   input Real rod1.shape.specularCoefficient = rod1.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real rod1.shape.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({rod1.shape.lengthDirection[1],rod1.shape.lengthDirection[2],rod1.shape.lengthDirection[3]});
//   protected Real rod1.shape.e_x[1](unit = \"1\") = if noEvent(rod1.shape.abs_n_x < 1e-10) then 1.0 else rod1.shape.lengthDirection[1] / rod1.shape.abs_n_x;
//   protected Real rod1.shape.e_x[2](unit = \"1\") = if noEvent(rod1.shape.abs_n_x < 1e-10) then 0.0 else rod1.shape.lengthDirection[2] / rod1.shape.abs_n_x;
//   protected Real rod1.shape.e_x[3](unit = \"1\") = if noEvent(rod1.shape.abs_n_x < 1e-10) then 0.0 else rod1.shape.lengthDirection[3] / rod1.shape.abs_n_x;
//   protected Real rod1.shape.n_z_aux[1](unit = \"1\") = rod1.shape.e_x[2] * rod1.shape.widthDirection[3] - rod1.shape.e_x[3] * rod1.shape.widthDirection[2];
//   protected Real rod1.shape.n_z_aux[2](unit = \"1\") = rod1.shape.e_x[3] * rod1.shape.widthDirection[1] - rod1.shape.e_x[1] * rod1.shape.widthDirection[3];
//   protected Real rod1.shape.n_z_aux[3](unit = \"1\") = rod1.shape.e_x[1] * rod1.shape.widthDirection[2] - rod1.shape.e_x[2] * rod1.shape.widthDirection[1];
//   protected Real rod1.shape.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rod1.shape.e_x[1],rod1.shape.e_x[2],rod1.shape.e_x[3]},if noEvent(rod1.shape.n_z_aux[1] ^ 2.0 + (rod1.shape.n_z_aux[2] ^ 2.0 + rod1.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {rod1.shape.widthDirection[1],rod1.shape.widthDirection[2],rod1.shape.widthDirection[3]} else if noEvent(abs(rod1.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rod1.shape.e_x[1],rod1.shape.e_x[2],rod1.shape.e_x[3]})[1];
//   protected Real rod1.shape.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rod1.shape.e_x[1],rod1.shape.e_x[2],rod1.shape.e_x[3]},if noEvent(rod1.shape.n_z_aux[1] ^ 2.0 + (rod1.shape.n_z_aux[2] ^ 2.0 + rod1.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {rod1.shape.widthDirection[1],rod1.shape.widthDirection[2],rod1.shape.widthDirection[3]} else if noEvent(abs(rod1.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rod1.shape.e_x[1],rod1.shape.e_x[2],rod1.shape.e_x[3]})[2];
//   protected Real rod1.shape.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rod1.shape.e_x[1],rod1.shape.e_x[2],rod1.shape.e_x[3]},if noEvent(rod1.shape.n_z_aux[1] ^ 2.0 + (rod1.shape.n_z_aux[2] ^ 2.0 + rod1.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {rod1.shape.widthDirection[1],rod1.shape.widthDirection[2],rod1.shape.widthDirection[3]} else if noEvent(abs(rod1.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rod1.shape.e_x[1],rod1.shape.e_x[2],rod1.shape.e_x[3]})[3];
//   protected output Real rod1.shape.Form;
//   output Real rod1.shape.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rod1.shape.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rod1.shape.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rod1.shape.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rod1.shape.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rod1.shape.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rod1.shape.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rod1.shape.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rod1.shape.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real rod1.shape.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rod1.shape.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rod1.shape.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rod1.shape.Material;
//   protected output Real rod1.shape.Extra;
//   parameter Real rod1.lengthDirection[1](unit = \"1\") = rod1.r[1] - rod1.r_shape[1] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real rod1.lengthDirection[2](unit = \"1\") = rod1.r[2] - rod1.r_shape[2] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real rod1.lengthDirection[3](unit = \"1\") = rod1.r[3] - rod1.r_shape[3] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real rod1.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({rod1.r[1] - rod1.r_shape[1],rod1.r[2] - rod1.r_shape[2],rod1.r[3] - rod1.r_shape[3]}) \" Length of shape\";
//   parameter Real rod1.width(quantity = \"Length\", unit = \"m\", min = 0.0) = rod1.length / world.defaultWidthFraction \" Width of shape\";
//   parameter Real rod1.height(quantity = \"Length\", unit = \"m\", min = 0.0) = rod1.width \" Height of shape.\";
//   Real rod2.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real rod2.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real rod2.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real rod2.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real rod2.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real rod2.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real rod2.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real rod2.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real rod2.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real rod2.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real rod2.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real rod2.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real rod2.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real rod2.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real rod2.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real rod2.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real rod2.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real rod2.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real rod2.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real rod2.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real rod2.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real rod2.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real rod2.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real rod2.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real rod2.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real rod2.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real rod2.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real rod2.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real rod2.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real rod2.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real rod2.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real rod2.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real rod2.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real rod2.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real rod2.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real rod2.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real rod2.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real rod2.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real rod2.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real rod2.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real rod2.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real rod2.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean rod2.animation = true \"= true, if animation shall be enabled\";
//   parameter Real rod2.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = rh[1] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real rod2.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = rh[2] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real rod2.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = rh[3] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter String rod2.shapeType = \"cylinder\" \" Type of shape\";
//   parameter Real rod2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real rod2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real rod2.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real rod2.widthDirection[1](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real rod2.widthDirection[2](unit = \"1\") = 1.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real rod2.widthDirection[3](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real rod2.extra = 0.0 \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer rod2.color[1](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer rod2.color[2](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer rod2.color[3](min = 0, max = 255) = 155 \" Color of shape\";
//   input Real rod2.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter String rod2.shape.shapeType = rod2.shapeType \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real rod2.shape.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real rod2.shape.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real rod2.shape.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real rod2.shape.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real rod2.shape.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real rod2.shape.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real rod2.shape.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real rod2.shape.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real rod2.shape.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real rod2.shape.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rod2.shape.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rod2.shape.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rod2.shape.r[1](quantity = \"Length\", unit = \"m\") = rod2.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rod2.shape.r[2](quantity = \"Length\", unit = \"m\") = rod2.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rod2.shape.r[3](quantity = \"Length\", unit = \"m\") = rod2.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rod2.shape.r_shape[1](quantity = \"Length\", unit = \"m\") = rod2.r_shape[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rod2.shape.r_shape[2](quantity = \"Length\", unit = \"m\") = rod2.r_shape[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rod2.shape.r_shape[3](quantity = \"Length\", unit = \"m\") = rod2.r_shape[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rod2.shape.lengthDirection[1](unit = \"1\") = rod2.lengthDirection[1] \"Vector in length direction, resolved in object frame\";
//   input Real rod2.shape.lengthDirection[2](unit = \"1\") = rod2.lengthDirection[2] \"Vector in length direction, resolved in object frame\";
//   input Real rod2.shape.lengthDirection[3](unit = \"1\") = rod2.lengthDirection[3] \"Vector in length direction, resolved in object frame\";
//   input Real rod2.shape.widthDirection[1](unit = \"1\") = rod2.widthDirection[1] \"Vector in width direction, resolved in object frame\";
//   input Real rod2.shape.widthDirection[2](unit = \"1\") = rod2.widthDirection[2] \"Vector in width direction, resolved in object frame\";
//   input Real rod2.shape.widthDirection[3](unit = \"1\") = rod2.widthDirection[3] \"Vector in width direction, resolved in object frame\";
//   input Real rod2.shape.length(quantity = \"Length\", unit = \"m\") = rod2.length \"Length of visual object\";
//   input Real rod2.shape.width(quantity = \"Length\", unit = \"m\") = rod2.width \"Width of visual object\";
//   input Real rod2.shape.height(quantity = \"Length\", unit = \"m\") = rod2.height \"Height of visual object\";
//   input Real rod2.shape.extra = rod2.extra \"Additional size data for some of the shape types\";
//   input Real rod2.shape.color[1] = Real(rod2.color[1]) \"Color of shape\";
//   input Real rod2.shape.color[2] = Real(rod2.color[2]) \"Color of shape\";
//   input Real rod2.shape.color[3] = Real(rod2.color[3]) \"Color of shape\";
//   input Real rod2.shape.specularCoefficient = rod2.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real rod2.shape.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({rod2.shape.lengthDirection[1],rod2.shape.lengthDirection[2],rod2.shape.lengthDirection[3]});
//   protected Real rod2.shape.e_x[1](unit = \"1\") = if noEvent(rod2.shape.abs_n_x < 1e-10) then 1.0 else rod2.shape.lengthDirection[1] / rod2.shape.abs_n_x;
//   protected Real rod2.shape.e_x[2](unit = \"1\") = if noEvent(rod2.shape.abs_n_x < 1e-10) then 0.0 else rod2.shape.lengthDirection[2] / rod2.shape.abs_n_x;
//   protected Real rod2.shape.e_x[3](unit = \"1\") = if noEvent(rod2.shape.abs_n_x < 1e-10) then 0.0 else rod2.shape.lengthDirection[3] / rod2.shape.abs_n_x;
//   protected Real rod2.shape.n_z_aux[1](unit = \"1\") = rod2.shape.e_x[2] * rod2.shape.widthDirection[3] - rod2.shape.e_x[3] * rod2.shape.widthDirection[2];
//   protected Real rod2.shape.n_z_aux[2](unit = \"1\") = rod2.shape.e_x[3] * rod2.shape.widthDirection[1] - rod2.shape.e_x[1] * rod2.shape.widthDirection[3];
//   protected Real rod2.shape.n_z_aux[3](unit = \"1\") = rod2.shape.e_x[1] * rod2.shape.widthDirection[2] - rod2.shape.e_x[2] * rod2.shape.widthDirection[1];
//   protected Real rod2.shape.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rod2.shape.e_x[1],rod2.shape.e_x[2],rod2.shape.e_x[3]},if noEvent(rod2.shape.n_z_aux[1] ^ 2.0 + (rod2.shape.n_z_aux[2] ^ 2.0 + rod2.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {rod2.shape.widthDirection[1],rod2.shape.widthDirection[2],rod2.shape.widthDirection[3]} else if noEvent(abs(rod2.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rod2.shape.e_x[1],rod2.shape.e_x[2],rod2.shape.e_x[3]})[1];
//   protected Real rod2.shape.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rod2.shape.e_x[1],rod2.shape.e_x[2],rod2.shape.e_x[3]},if noEvent(rod2.shape.n_z_aux[1] ^ 2.0 + (rod2.shape.n_z_aux[2] ^ 2.0 + rod2.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {rod2.shape.widthDirection[1],rod2.shape.widthDirection[2],rod2.shape.widthDirection[3]} else if noEvent(abs(rod2.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rod2.shape.e_x[1],rod2.shape.e_x[2],rod2.shape.e_x[3]})[2];
//   protected Real rod2.shape.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rod2.shape.e_x[1],rod2.shape.e_x[2],rod2.shape.e_x[3]},if noEvent(rod2.shape.n_z_aux[1] ^ 2.0 + (rod2.shape.n_z_aux[2] ^ 2.0 + rod2.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {rod2.shape.widthDirection[1],rod2.shape.widthDirection[2],rod2.shape.widthDirection[3]} else if noEvent(abs(rod2.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rod2.shape.e_x[1],rod2.shape.e_x[2],rod2.shape.e_x[3]})[3];
//   protected output Real rod2.shape.Form;
//   output Real rod2.shape.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rod2.shape.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rod2.shape.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rod2.shape.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rod2.shape.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rod2.shape.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rod2.shape.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rod2.shape.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rod2.shape.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real rod2.shape.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rod2.shape.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rod2.shape.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rod2.shape.Material;
//   protected output Real rod2.shape.Extra;
//   parameter Real rod2.lengthDirection[1](unit = \"1\") = rod2.r[1] - rod2.r_shape[1] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real rod2.lengthDirection[2](unit = \"1\") = rod2.r[2] - rod2.r_shape[2] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real rod2.lengthDirection[3](unit = \"1\") = rod2.r[3] - rod2.r_shape[3] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real rod2.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({rod2.r[1] - rod2.r_shape[1],rod2.r[2] - rod2.r_shape[2],rod2.r[3] - rod2.r_shape[3]}) \" Length of shape\";
//   parameter Real rod2.width(quantity = \"Length\", unit = \"m\", min = 0.0) = rod2.length / world.defaultWidthFraction \" Width of shape\";
//   parameter Real rod2.height(quantity = \"Length\", unit = \"m\", min = 0.0) = rod2.width \" Height of shape.\";
//   Real body1.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real body1.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real body1.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real body1.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real body1.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real body1.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real body1.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real body1.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real body1.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real body1.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real body1.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real body1.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real body1.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real body1.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real body1.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real body1.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real body1.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real body1.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real body1.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real body1.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real body1.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean body1.animation = true \"= true, if animation shall be enabled (show cylinder and sphere)\";
//   parameter Real body1.r_CM[1](quantity = \"Length\", unit = \"m\", start = 0.0) = jointRRR1.rRod1_ia[1] / 2.0 \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real body1.r_CM[2](quantity = \"Length\", unit = \"m\", start = 0.0) = jointRRR1.rRod1_ia[2] / 2.0 \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real body1.r_CM[3](quantity = \"Length\", unit = \"m\", start = 0.0) = jointRRR1.rRod1_ia[3] / 2.0 \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real body1.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 1.0) = 1.0 \"Mass of rigid body\";
//   parameter Real body1.I_11(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.001 \" (1,1) element of inertia tensor\";
//   parameter Real body1.I_22(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.001 \" (2,2) element of inertia tensor\";
//   parameter Real body1.I_33(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.001 \" (3,3) element of inertia tensor\";
//   parameter Real body1.I_21(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (2,1) element of inertia tensor\";
//   parameter Real body1.I_31(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (3,1) element of inertia tensor\";
//   parameter Real body1.I_32(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (3,2) element of inertia tensor\";
//   Real body1.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real body1.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real body1.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real body1.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real body1.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real body1.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real body1.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real body1.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real body1.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean body1.angles_fixed = false \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real body1.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real body1.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real body1.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer body1.sequence_start[1](min = 1, max = 3) = 1 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer body1.sequence_start[2](min = 1, max = 3) = 2 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer body1.sequence_start[3](min = 1, max = 3) = 3 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean body1.w_0_fixed = false \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real body1.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real body1.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real body1.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean body1.z_0_fixed = false \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real body1.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real body1.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real body1.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real body1.sphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultBodyDiameter \"Diameter of sphere\";
//   input Integer body1.sphereColor[1](min = 0, max = 255) = 0 \"Color of sphere\";
//   input Integer body1.sphereColor[2](min = 0, max = 255) = 128 \"Color of sphere\";
//   input Integer body1.sphereColor[3](min = 0, max = 255) = 255 \"Color of sphere\";
//   input Integer body1.cylinderColor[1](min = 0, max = 255) = 155 \"Color of cylinder\";
//   input Integer body1.cylinderColor[2](min = 0, max = 255) = 155 \"Color of cylinder\";
//   input Integer body1.cylinderColor[3](min = 0, max = 255) = 155 \"Color of cylinder\";
//   input Real body1.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean body1.enforceStates = false \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean body1.useQuaternions = true \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer body1.sequence_angleStates[1](min = 1, max = 3) = 1 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer body1.sequence_angleStates[2](min = 1, max = 3) = 2 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer body1.sequence_angleStates[3](min = 1, max = 3) = 3 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   Real body1.w_a[1](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body1.R_start,{body1.w_0_start[1],body1.w_0_start[2],body1.w_0_start[3]})[1], fixed = body1.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real body1.w_a[2](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body1.R_start,{body1.w_0_start[1],body1.w_0_start[2],body1.w_0_start[3]})[2], fixed = body1.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real body1.w_a[3](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body1.R_start,{body1.w_0_start[1],body1.w_0_start[2],body1.w_0_start[3]})[3], fixed = body1.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real body1.z_a[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body1.R_start,{body1.z_0_start[1],body1.z_0_start[2],body1.z_0_start[3]})[1], fixed = body1.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real body1.z_a[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body1.R_start,{body1.z_0_start[1],body1.z_0_start[2],body1.z_0_start[3]})[2], fixed = body1.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real body1.z_a[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body1.R_start,{body1.z_0_start[1],body1.z_0_start[2],body1.z_0_start[3]})[3], fixed = body1.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real body1.g_0[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real body1.g_0[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real body1.g_0[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   protected Real body1.Q[1](start = body1.Q_start[1], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real body1.Q[2](start = body1.Q_start[2], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real body1.Q[3](start = body1.Q_start[3], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real body1.Q[4](start = body1.Q_start[4], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real body1.phi[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = body1.phi_start[1], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real body1.phi[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = body1.phi_start[2], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real body1.phi[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = body1.phi_start[3], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real body1.phi_d[1](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real body1.phi_d[2](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real body1.phi_d[3](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real body1.phi_dd[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real body1.phi_dd[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real body1.phi_dd[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   parameter String body1.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body1.cylinder.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real body1.cylinder.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real body1.cylinder.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real body1.cylinder.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real body1.cylinder.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real body1.cylinder.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real body1.cylinder.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real body1.cylinder.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real body1.cylinder.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real body1.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.cylinder.r[1](quantity = \"Length\", unit = \"m\") = body1.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.cylinder.r[2](quantity = \"Length\", unit = \"m\") = body1.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.cylinder.r[3](quantity = \"Length\", unit = \"m\") = body1.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.cylinder.lengthDirection[1](unit = \"1\") = body1.r_CM[1] \"Vector in length direction, resolved in object frame\";
//   input Real body1.cylinder.lengthDirection[2](unit = \"1\") = body1.r_CM[2] \"Vector in length direction, resolved in object frame\";
//   input Real body1.cylinder.lengthDirection[3](unit = \"1\") = body1.r_CM[3] \"Vector in length direction, resolved in object frame\";
//   input Real body1.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.cylinder.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.cylinder.length(quantity = \"Length\", unit = \"m\") = if Modelica.Math.Vectors.length({body1.r_CM[1],body1.r_CM[2],body1.r_CM[3]}) > body1.sphereDiameter / 2.0 then Modelica.Math.Vectors.length({body1.r_CM[1],body1.r_CM[2],body1.r_CM[3]}) - (if body1.cylinderDiameter > 1.1 * body1.sphereDiameter then body1.sphereDiameter / 2.0 else 0.0) else 0.0 \"Length of visual object\";
//   input Real body1.cylinder.width(quantity = \"Length\", unit = \"m\") = body1.cylinderDiameter \"Width of visual object\";
//   input Real body1.cylinder.height(quantity = \"Length\", unit = \"m\") = body1.cylinderDiameter \"Height of visual object\";
//   input Real body1.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body1.cylinder.color[1] = Real(body1.cylinderColor[1]) \"Color of shape\";
//   input Real body1.cylinder.color[2] = Real(body1.cylinderColor[2]) \"Color of shape\";
//   input Real body1.cylinder.color[3] = Real(body1.cylinderColor[3]) \"Color of shape\";
//   input Real body1.cylinder.specularCoefficient = body1.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body1.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body1.cylinder.lengthDirection[1],body1.cylinder.lengthDirection[2],body1.cylinder.lengthDirection[3]});
//   protected Real body1.cylinder.e_x[1](unit = \"1\") = if noEvent(body1.cylinder.abs_n_x < 1e-10) then 1.0 else body1.cylinder.lengthDirection[1] / body1.cylinder.abs_n_x;
//   protected Real body1.cylinder.e_x[2](unit = \"1\") = if noEvent(body1.cylinder.abs_n_x < 1e-10) then 0.0 else body1.cylinder.lengthDirection[2] / body1.cylinder.abs_n_x;
//   protected Real body1.cylinder.e_x[3](unit = \"1\") = if noEvent(body1.cylinder.abs_n_x < 1e-10) then 0.0 else body1.cylinder.lengthDirection[3] / body1.cylinder.abs_n_x;
//   protected Real body1.cylinder.n_z_aux[1](unit = \"1\") = body1.cylinder.e_x[2] * body1.cylinder.widthDirection[3] - body1.cylinder.e_x[3] * body1.cylinder.widthDirection[2];
//   protected Real body1.cylinder.n_z_aux[2](unit = \"1\") = body1.cylinder.e_x[3] * body1.cylinder.widthDirection[1] - body1.cylinder.e_x[1] * body1.cylinder.widthDirection[3];
//   protected Real body1.cylinder.n_z_aux[3](unit = \"1\") = body1.cylinder.e_x[1] * body1.cylinder.widthDirection[2] - body1.cylinder.e_x[2] * body1.cylinder.widthDirection[1];
//   protected Real body1.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.cylinder.e_x[1],body1.cylinder.e_x[2],body1.cylinder.e_x[3]},if noEvent(body1.cylinder.n_z_aux[1] ^ 2.0 + (body1.cylinder.n_z_aux[2] ^ 2.0 + body1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.cylinder.widthDirection[1],body1.cylinder.widthDirection[2],body1.cylinder.widthDirection[3]} else if noEvent(abs(body1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.cylinder.e_x[1],body1.cylinder.e_x[2],body1.cylinder.e_x[3]})[1];
//   protected Real body1.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.cylinder.e_x[1],body1.cylinder.e_x[2],body1.cylinder.e_x[3]},if noEvent(body1.cylinder.n_z_aux[1] ^ 2.0 + (body1.cylinder.n_z_aux[2] ^ 2.0 + body1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.cylinder.widthDirection[1],body1.cylinder.widthDirection[2],body1.cylinder.widthDirection[3]} else if noEvent(abs(body1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.cylinder.e_x[1],body1.cylinder.e_x[2],body1.cylinder.e_x[3]})[2];
//   protected Real body1.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.cylinder.e_x[1],body1.cylinder.e_x[2],body1.cylinder.e_x[3]},if noEvent(body1.cylinder.n_z_aux[1] ^ 2.0 + (body1.cylinder.n_z_aux[2] ^ 2.0 + body1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.cylinder.widthDirection[1],body1.cylinder.widthDirection[2],body1.cylinder.widthDirection[3]} else if noEvent(abs(body1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.cylinder.e_x[1],body1.cylinder.e_x[2],body1.cylinder.e_x[3]})[3];
//   protected output Real body1.cylinder.Form;
//   output Real body1.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body1.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body1.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body1.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.cylinder.Material;
//   protected output Real body1.cylinder.Extra;
//   parameter Real body1.I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body1.I_11 \"inertia tensor\";
//   parameter Real body1.I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body1.I_21 \"inertia tensor\";
//   parameter Real body1.I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body1.I_31 \"inertia tensor\";
//   parameter Real body1.I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body1.I_21 \"inertia tensor\";
//   parameter Real body1.I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body1.I_22 \"inertia tensor\";
//   parameter Real body1.I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body1.I_32 \"inertia tensor\";
//   parameter Real body1.I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body1.I_31 \"inertia tensor\";
//   parameter Real body1.I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body1.I_32 \"inertia tensor\";
//   parameter Real body1.I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body1.I_33 \"inertia tensor\";
//   parameter Real body1.R_start.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real body1.R_start.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real body1.R_start.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real body1.R_start.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real body1.R_start.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real body1.R_start.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real body1.R_start.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real body1.R_start.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real body1.R_start.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real body1.R_start.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real body1.R_start.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real body1.R_start.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real body1.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = body1.sphereDiameter / 3.0 \"Diameter of cylinder\";
//   parameter String body1.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body1.sphere.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real body1.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body1.sphere.r[1](quantity = \"Length\", unit = \"m\") = body1.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r[2](quantity = \"Length\", unit = \"m\") = body1.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r[3](quantity = \"Length\", unit = \"m\") = body1.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body1.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = body1.r_CM[1] - body1.sphereDiameter / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = body1.r_CM[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = body1.r_CM[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[1](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body1.sphere.length(quantity = \"Length\", unit = \"m\") = body1.sphereDiameter \"Length of visual object\";
//   input Real body1.sphere.width(quantity = \"Length\", unit = \"m\") = body1.sphereDiameter \"Width of visual object\";
//   input Real body1.sphere.height(quantity = \"Length\", unit = \"m\") = body1.sphereDiameter \"Height of visual object\";
//   input Real body1.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body1.sphere.color[1] = Real(body1.sphereColor[1]) \"Color of shape\";
//   input Real body1.sphere.color[2] = Real(body1.sphereColor[2]) \"Color of shape\";
//   input Real body1.sphere.color[3] = Real(body1.sphereColor[3]) \"Color of shape\";
//   input Real body1.sphere.specularCoefficient = body1.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body1.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body1.sphere.lengthDirection[1],body1.sphere.lengthDirection[2],body1.sphere.lengthDirection[3]});
//   protected Real body1.sphere.e_x[1](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 1e-10) then 1.0 else body1.sphere.lengthDirection[1] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.e_x[2](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 1e-10) then 0.0 else body1.sphere.lengthDirection[2] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.e_x[3](unit = \"1\") = if noEvent(body1.sphere.abs_n_x < 1e-10) then 0.0 else body1.sphere.lengthDirection[3] / body1.sphere.abs_n_x;
//   protected Real body1.sphere.n_z_aux[1](unit = \"1\") = body1.sphere.e_x[2] * body1.sphere.widthDirection[3] - body1.sphere.e_x[3] * body1.sphere.widthDirection[2];
//   protected Real body1.sphere.n_z_aux[2](unit = \"1\") = body1.sphere.e_x[3] * body1.sphere.widthDirection[1] - body1.sphere.e_x[1] * body1.sphere.widthDirection[3];
//   protected Real body1.sphere.n_z_aux[3](unit = \"1\") = body1.sphere.e_x[1] * body1.sphere.widthDirection[2] - body1.sphere.e_x[2] * body1.sphere.widthDirection[1];
//   protected Real body1.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[1];
//   protected Real body1.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[2];
//   protected Real body1.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]},if noEvent(body1.sphere.n_z_aux[1] ^ 2.0 + (body1.sphere.n_z_aux[2] ^ 2.0 + body1.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body1.sphere.widthDirection[1],body1.sphere.widthDirection[2],body1.sphere.widthDirection[3]} else if noEvent(abs(body1.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body1.sphere.e_x[1],body1.sphere.e_x[2],body1.sphere.e_x[3]})[3];
//   protected output Real body1.sphere.Form;
//   output Real body1.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body1.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body1.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body1.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body1.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body1.sphere.Material;
//   protected output Real body1.sphere.Extra;
//   parameter Real body1.z_a_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(body1.R_start,{body1.z_0_start[1],body1.z_0_start[2],body1.z_0_start[3]})[1] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   parameter Real body1.z_a_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(body1.R_start,{body1.z_0_start[1],body1.z_0_start[2],body1.z_0_start[3]})[2] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   parameter Real body1.z_a_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(body1.R_start,{body1.z_0_start[1],body1.z_0_start[2],body1.z_0_start[3]})[3] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   protected parameter Real body1.Q_start[1] = Modelica.Mechanics.MultiBody.Frames.to_Q(body1.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[1] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real body1.Q_start[2] = Modelica.Mechanics.MultiBody.Frames.to_Q(body1.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[2] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real body1.Q_start[3] = Modelica.Mechanics.MultiBody.Frames.to_Q(body1.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[3] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real body1.Q_start[4] = Modelica.Mechanics.MultiBody.Frames.to_Q(body1.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[4] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real body1.phi_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if body1.sequence_start[1] == body1.sequence_angleStates[1] AND body1.sequence_start[2] == body1.sequence_angleStates[2] AND body1.sequence_start[3] == body1.sequence_angleStates[3] then body1.angles_start[1] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(body1.R_start,{body1.sequence_angleStates[1],body1.sequence_angleStates[2],body1.sequence_angleStates[3]},0.0)[1] \"Potential angle states at initial time\";
//   protected parameter Real body1.phi_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if body1.sequence_start[1] == body1.sequence_angleStates[1] AND body1.sequence_start[2] == body1.sequence_angleStates[2] AND body1.sequence_start[3] == body1.sequence_angleStates[3] then body1.angles_start[2] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(body1.R_start,{body1.sequence_angleStates[1],body1.sequence_angleStates[2],body1.sequence_angleStates[3]},0.0)[2] \"Potential angle states at initial time\";
//   protected parameter Real body1.phi_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if body1.sequence_start[1] == body1.sequence_angleStates[1] AND body1.sequence_start[2] == body1.sequence_angleStates[2] AND body1.sequence_start[3] == body1.sequence_angleStates[3] then body1.angles_start[3] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(body1.R_start,{body1.sequence_angleStates[1],body1.sequence_angleStates[2],body1.sequence_angleStates[3]},0.0)[3] \"Potential angle states at initial time\";
//   parameter Boolean position.useSupport = true \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real position.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real position.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real position.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   parameter Boolean position.exact = false \"true/false exact treatment/filtering the input signal\";
//   parameter Real position.f_crit(quantity = \"Frequency\", unit = \"Hz\") = 50.0 \"if exact=false, critical frequency of filter to filter input signal\";
//   Real position.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) \"Rotation angle of flange with respect to support\";
//   Real position.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, StateSelect = StateSelect.prefer) \"If exact=false, Angular velocity of flange with respect to support else dummy\";
//   Real position.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = 0.0) \"If exact=false, Angular acceleration of flange with respect to support else dummy\";
//   input Real position.phi_ref(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Reference angle of flange with respect to support as input signal\";
//   protected constant Real position.af = 1.3617 \"s coefficient of Bessel filter\";
//   protected constant Real position.bf = 0.618 \"s*s coefficient of Bessel filter\";
//   Real position.support.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = position.phi_support \"Absolute rotation angle of the support/housing\";
//   Real position.support.tau(quantity = \"Torque\", unit = \"N.m\") = -position.flange.tau \"Reaction torque in the support/housing\";
//   protected parameter Real position.w_crit(quantity = \"AngularFrequency\", unit = \"rad/s\") = 6.28318530717959 * position.f_crit \"Critical frequency\";
//   output Real sine.y \"Connector of Real output signal\";
//   parameter Real sine.amplitude = 0.7 \"Amplitude of sine wave\";
//   parameter Real sine.freqHz(quantity = \"Frequency\", unit = \"Hz\", start = 1.0) = 1.0 \"Frequency of sine wave\";
//   parameter Real sine.phase(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Phase of sine wave\";
//   parameter Real sine.offset = 0.0 \"Offset of output signal\";
//   parameter Real sine.startTime(quantity = \"Time\", unit = \"s\") = 0.0 \"Output = offset for time < startTime\";
//   protected constant Real sine.pi = 3.14159265358979;
//   Real jointRRR2.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.frame_ia.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.frame_ia.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.frame_ia.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.frame_ia.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_ia.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_ia.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_ia.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_ia.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_ia.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_ia.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_ia.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_ia.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_ia.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.frame_ia.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.frame_ia.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.frame_ia.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.frame_ia.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.frame_ia.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.frame_ia.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.frame_ia.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.frame_ia.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.frame_ib.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.frame_ib.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.frame_ib.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.frame_ib.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_ib.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_ib.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_ib.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_ib.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_ib.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_ib.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_ib.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_ib.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_ib.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.frame_ib.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.frame_ib.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.frame_ib.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.frame_ib.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.frame_ib.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.frame_ib.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.frame_ib.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.frame_ib.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.frame_im.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.frame_im.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.frame_im.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.frame_im.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_im.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_im.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_im.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_im.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_im.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_im.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_im.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_im.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.frame_im.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.frame_im.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.frame_im.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.frame_im.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.frame_im.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.frame_im.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.frame_im.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.frame_im.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.frame_im.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.axis.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real jointRRR2.axis.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real jointRRR2.bearing.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real jointRRR2.bearing.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Boolean jointRRR2.animation = true \"= true, if animation shall be enabled\";
//   parameter Real jointRRR2.n_a[1](unit = \"1\") = 0.0 \"Axes of revolute joints resolved in frame_a (all axes are parallel to each other)\";
//   parameter Real jointRRR2.n_a[2](unit = \"1\") = 0.0 \"Axes of revolute joints resolved in frame_a (all axes are parallel to each other)\";
//   parameter Real jointRRR2.n_a[3](unit = \"1\") = 1.0 \"Axes of revolute joints resolved in frame_a (all axes are parallel to each other)\";
//   parameter Real jointRRR2.n_b[1](unit = \"1\", fixed = false) = 0.0 \"Axis of revolute joint fixed and resolved in frame_b\";
//   parameter Real jointRRR2.n_b[2](unit = \"1\", fixed = false) = 0.0 \"Axis of revolute joint fixed and resolved in frame_b\";
//   parameter Real jointRRR2.n_b[3](unit = \"1\", fixed = false) = 1.0 \"Axis of revolute joint fixed and resolved in frame_b\";
//   parameter Real jointRRR2.rRod1_ia[1](quantity = \"Length\", unit = \"m\") = r2a[1] \"Vector from origin of frame_a to revolute joint in the middle, resolved in frame_ia\";
//   parameter Real jointRRR2.rRod1_ia[2](quantity = \"Length\", unit = \"m\") = r2a[2] \"Vector from origin of frame_a to revolute joint in the middle, resolved in frame_ia\";
//   parameter Real jointRRR2.rRod1_ia[3](quantity = \"Length\", unit = \"m\") = r2a[3] \"Vector from origin of frame_a to revolute joint in the middle, resolved in frame_ia\";
//   parameter Real jointRRR2.rRod2_ib[1](quantity = \"Length\", unit = \"m\") = r2b[1] \"Vector from origin of frame_ib to revolute joint in the middle, resolved in frame_ib\";
//   parameter Real jointRRR2.rRod2_ib[2](quantity = \"Length\", unit = \"m\") = r2b[2] \"Vector from origin of frame_ib to revolute joint in the middle, resolved in frame_ib\";
//   parameter Real jointRRR2.rRod2_ib[3](quantity = \"Length\", unit = \"m\") = r2b[3] \"Vector from origin of frame_ib to revolute joint in the middle, resolved in frame_ib\";
//   parameter Real jointRRR2.phi_offset(quantity = \"Angle\", unit = \"deg\") = 0.0 \"Relative angle offset of revolute joint at frame_b (angle = phi(t) + from_deg(phi_offset))\";
//   parameter Real jointRRR2.phi_guess(quantity = \"Angle\", unit = \"deg\") = 0.0 \"Select the configuration such that at initial time |phi(t0) - from_deg(phi_guess)|is minimal\";
//   parameter Real jointRRR2.cylinderLength(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultJointLength \"Length of cylinders representing the revolute joints\";
//   parameter Real jointRRR2.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultJointWidth \"Diameter of cylinders representing the revolute joints\";
//   input Integer jointRRR2.cylinderColor[1](min = 0, max = 255) = 255 \"Color of cylinders representing the revolute joints\";
//   input Integer jointRRR2.cylinderColor[2](min = 0, max = 255) = 0 \"Color of cylinders representing the revolute joints\";
//   input Integer jointRRR2.cylinderColor[3](min = 0, max = 255) = 0 \"Color of cylinders representing the revolute joints\";
//   input Integer jointRRR2.rodColor[1](min = 0, max = 255) = 155 \"Color of the two rods connecting the revolute joint\";
//   input Integer jointRRR2.rodColor[2](min = 0, max = 255) = 155 \"Color of the two rods connecting the revolute joint\";
//   input Integer jointRRR2.rodColor[3](min = 0, max = 255) = 155 \"Color of the two rods connecting the revolute joint\";
//   input Real jointRRR2.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean jointRRR2.checkTotalPower = true \"= true, if total power flowing into this component shall be determined (must be zero)\";
//   parameter Real jointRRR2.e_ia[1](unit = \"1\") = jointRRR2.jointUSR.e2_ia[1] \"Unit vector along axes of rotations, resolved in frame_ia\";
//   parameter Real jointRRR2.e_ia[2](unit = \"1\") = jointRRR2.jointUSR.e2_ia[2] \"Unit vector along axes of rotations, resolved in frame_ia\";
//   parameter Real jointRRR2.e_ia[3](unit = \"1\") = jointRRR2.jointUSR.e2_ia[3] \"Unit vector along axes of rotations, resolved in frame_ia\";
//   parameter Real jointRRR2.e_b[1](unit = \"1\") = jointRRR2.jointUSR.revolute.e[1] \"Unit vector along axes of rotations, resolved in frame_b, frame_ib and frame_im\";
//   parameter Real jointRRR2.e_b[2](unit = \"1\") = jointRRR2.jointUSR.revolute.e[2] \"Unit vector along axes of rotations, resolved in frame_b, frame_ib and frame_im\";
//   parameter Real jointRRR2.e_b[3](unit = \"1\") = jointRRR2.jointUSR.revolute.e[3] \"Unit vector along axes of rotations, resolved in frame_b, frame_ib and frame_im\";
//   Real jointRRR2.totalPower(quantity = \"Power\", unit = \"W\") = jointRRR2.jointUSR.totalPower \"Total power flowing into this element, if checkTotalPower=true (otherwise dummy)\";
//   Real jointRRR2.jointUSR.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.frame_ia.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.frame_ia.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.frame_ia.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.frame_ia.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_ia.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_ia.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_ia.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_ia.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_ia.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_ia.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_ia.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_ia.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_ia.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.frame_ia.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.frame_ia.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.frame_ia.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.frame_ia.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.frame_ia.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.frame_ia.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.frame_ia.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.frame_ia.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.frame_ib.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.frame_ib.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.frame_ib.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.frame_ib.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_ib.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_ib.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_ib.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_ib.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_ib.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_ib.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_ib.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_ib.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_ib.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.frame_ib.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.frame_ib.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.frame_ib.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.frame_ib.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.frame_ib.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.frame_ib.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.frame_ib.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.frame_ib.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.frame_im.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.frame_im.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.frame_im.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.frame_im.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_im.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_im.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_im.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_im.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_im.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_im.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_im.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_im.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.frame_im.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.frame_im.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.frame_im.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.frame_im.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.frame_im.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.frame_im.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.frame_im.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.frame_im.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.frame_im.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.axis.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real jointRRR2.jointUSR.axis.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real jointRRR2.jointUSR.bearing.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real jointRRR2.jointUSR.bearing.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Boolean jointRRR2.jointUSR.animation = false \"= true, if animation shall be enabled\";
//   parameter Boolean jointRRR2.jointUSR.showUniversalAxes = false \" = true, if universal joint shall be visualized with two cylinders, otherwise with a sphere (provided animation=true)\";
//   parameter Real jointRRR2.jointUSR.n1_a[1](unit = \"1\") = jointRRR2.n_a[1] \"Axis 1 of universal joint fixed and resolved in frame_a (axis 2 is orthogonal to axis 1 and to rod 1)\";
//   parameter Real jointRRR2.jointUSR.n1_a[2](unit = \"1\") = jointRRR2.n_a[2] \"Axis 1 of universal joint fixed and resolved in frame_a (axis 2 is orthogonal to axis 1 and to rod 1)\";
//   parameter Real jointRRR2.jointUSR.n1_a[3](unit = \"1\") = jointRRR2.n_a[3] \"Axis 1 of universal joint fixed and resolved in frame_a (axis 2 is orthogonal to axis 1 and to rod 1)\";
//   parameter Real jointRRR2.jointUSR.n_b[1](unit = \"1\") = jointRRR2.n_b[1] \"Axis of revolute joint fixed and resolved in frame_b\";
//   parameter Real jointRRR2.jointUSR.n_b[2](unit = \"1\") = jointRRR2.n_b[2] \"Axis of revolute joint fixed and resolved in frame_b\";
//   parameter Real jointRRR2.jointUSR.n_b[3](unit = \"1\") = jointRRR2.n_b[3] \"Axis of revolute joint fixed and resolved in frame_b\";
//   parameter Real jointRRR2.jointUSR.rRod1_ia[1](quantity = \"Length\", unit = \"m\") = jointRRR2.rRod1_ia[1] \"Vector from origin of frame_a to spherical joint, resolved in frame_ia\";
//   parameter Real jointRRR2.jointUSR.rRod1_ia[2](quantity = \"Length\", unit = \"m\") = jointRRR2.rRod1_ia[2] \"Vector from origin of frame_a to spherical joint, resolved in frame_ia\";
//   parameter Real jointRRR2.jointUSR.rRod1_ia[3](quantity = \"Length\", unit = \"m\") = jointRRR2.rRod1_ia[3] \"Vector from origin of frame_a to spherical joint, resolved in frame_ia\";
//   parameter Real jointRRR2.jointUSR.rRod2_ib[1](quantity = \"Length\", unit = \"m\") = jointRRR2.rRod2_ib[1] \"Vector from origin of frame_ib to spherical joint, resolved in frame_ib\";
//   parameter Real jointRRR2.jointUSR.rRod2_ib[2](quantity = \"Length\", unit = \"m\") = jointRRR2.rRod2_ib[2] \"Vector from origin of frame_ib to spherical joint, resolved in frame_ib\";
//   parameter Real jointRRR2.jointUSR.rRod2_ib[3](quantity = \"Length\", unit = \"m\") = jointRRR2.rRod2_ib[3] \"Vector from origin of frame_ib to spherical joint, resolved in frame_ib\";
//   parameter Real jointRRR2.jointUSR.phi_offset(quantity = \"Angle\", unit = \"deg\") = jointRRR2.phi_offset \"Relative angle offset of revolute joint (angle = phi(t) + from_deg(phi_offset))\";
//   parameter Real jointRRR2.jointUSR.phi_guess(quantity = \"Angle\", unit = \"deg\") = jointRRR2.phi_guess \"Select the configuration such that at initial time |phi(t0) - from_deg(phi_guess)|is minimal\";
//   parameter Real jointRRR2.jointUSR.sphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultJointLength \"Diameter of the spheres representing the universal and the spherical joint\";
//   input Integer jointRRR2.jointUSR.sphereColor[1](min = 0, max = 255) = 255 \"Color of the spheres representing the universal and the spherical joint\";
//   input Integer jointRRR2.jointUSR.sphereColor[2](min = 0, max = 255) = 0 \"Color of the spheres representing the universal and the spherical joint\";
//   input Integer jointRRR2.jointUSR.sphereColor[3](min = 0, max = 255) = 0 \"Color of the spheres representing the universal and the spherical joint\";
//   input Integer jointRRR2.jointUSR.rod1Color[1](min = 0, max = 255) = 155 \"Color of rod 1 connecting the universal and the spherical joint\";
//   input Integer jointRRR2.jointUSR.rod1Color[2](min = 0, max = 255) = 155 \"Color of rod 1 connecting the universal and the spherical joint\";
//   input Integer jointRRR2.jointUSR.rod1Color[3](min = 0, max = 255) = 155 \"Color of rod 1 connecting the universal and the spherical joint\";
//   input Integer jointRRR2.jointUSR.rod2Color[1](min = 0, max = 255) = jointRRR2.jointUSR.rod1Color[1] \"Color of rod 2 connecting the revolute and the spherical joint\";
//   input Integer jointRRR2.jointUSR.rod2Color[2](min = 0, max = 255) = jointRRR2.jointUSR.rod1Color[2] \"Color of rod 2 connecting the revolute and the spherical joint\";
//   input Integer jointRRR2.jointUSR.rod2Color[3](min = 0, max = 255) = jointRRR2.jointUSR.rod1Color[3] \"Color of rod 2 connecting the revolute and the spherical joint\";
//   parameter Real jointRRR2.jointUSR.revoluteDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultJointWidth \"Diameter of cylinder representing the revolute joint\";
//   parameter Real jointRRR2.jointUSR.revoluteLength(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultJointLength \"Length of cylinder representing the revolute joint\";
//   input Integer jointRRR2.jointUSR.revoluteColor[1](min = 0, max = 255) = 255 \"Color of cylinder representing the revolute joint\";
//   input Integer jointRRR2.jointUSR.revoluteColor[2](min = 0, max = 255) = 0 \"Color of cylinder representing the revolute joint\";
//   input Integer jointRRR2.jointUSR.revoluteColor[3](min = 0, max = 255) = 0 \"Color of cylinder representing the revolute joint\";
//   input Real jointRRR2.jointUSR.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Real jointRRR2.jointUSR.cylinderLength(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultJointLength \"Length of cylinders representing the two universal joint axes\";
//   parameter Real jointRRR2.jointUSR.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultJointWidth \"Diameter of cylinders representing the two universal joint axes\";
//   input Integer jointRRR2.jointUSR.cylinderColor[1](min = 0, max = 255) = 255 \"Color of cylinders representing the two universal joint axes\";
//   input Integer jointRRR2.jointUSR.cylinderColor[2](min = 0, max = 255) = 0 \"Color of cylinders representing the two universal joint axes\";
//   input Integer jointRRR2.jointUSR.cylinderColor[3](min = 0, max = 255) = 0 \"Color of cylinders representing the two universal joint axes\";
//   parameter Boolean jointRRR2.jointUSR.checkTotalPower = jointRRR2.checkTotalPower \"= true, if total power flowing into this component shall be determined (must be zero)\";
//   parameter Real jointRRR2.jointUSR.eRod1_ia[1](unit = \"1\") = jointRRR2.jointUSR.rod1.eRod_ia[1] \"Unit vector from origin of frame_a to origin of spherical joint, resolved in frame_ia\";
//   parameter Real jointRRR2.jointUSR.eRod1_ia[2](unit = \"1\") = jointRRR2.jointUSR.rod1.eRod_ia[2] \"Unit vector from origin of frame_a to origin of spherical joint, resolved in frame_ia\";
//   parameter Real jointRRR2.jointUSR.eRod1_ia[3](unit = \"1\") = jointRRR2.jointUSR.rod1.eRod_ia[3] \"Unit vector from origin of frame_a to origin of spherical joint, resolved in frame_ia\";
//   parameter Real jointRRR2.jointUSR.e2_ia[1](unit = \"1\") = jointRRR2.jointUSR.rod1.e2_ia[1] \"Unit vector in direction of axis 2 of universal joint, resolved in frame_ia\";
//   parameter Real jointRRR2.jointUSR.e2_ia[2](unit = \"1\") = jointRRR2.jointUSR.rod1.e2_ia[2] \"Unit vector in direction of axis 2 of universal joint, resolved in frame_ia\";
//   parameter Real jointRRR2.jointUSR.e2_ia[3](unit = \"1\") = jointRRR2.jointUSR.rod1.e2_ia[3] \"Unit vector in direction of axis 2 of universal joint, resolved in frame_ia\";
//   parameter Real jointRRR2.jointUSR.rod1Length(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR2.jointUSR.rod1.rodLength \"Length of rod 1 (= distance between universal and spherical joint\";
//   Real jointRRR2.jointUSR.totalPower(quantity = \"Power\", unit = \"W\") \"Total power flowing into this element, if checkTotalPower=true (otherwise dummy)\";
//   Real jointRRR2.jointUSR.aux(quantity = \"Length\", unit = \"m\") \"Denominator used to compute force in rod connecting universal and spherical joint\";
//   Real jointRRR2.jointUSR.f_rod(quantity = \"Force\", unit = \"N\") \"Constraint force in direction of the rod (positive, if rod is pressed)\";
//   Real jointRRR2.jointUSR.revolute.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.revolute.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.revolute.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.revolute.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.revolute.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.revolute.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.revolute.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.revolute.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.revolute.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.revolute.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.revolute.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.revolute.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.revolute.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.revolute.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.revolute.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.revolute.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.revolute.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.revolute.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.revolute.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.revolute.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.revolute.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.revolute.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.revolute.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.revolute.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.revolute.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.revolute.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.revolute.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.revolute.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.revolute.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.revolute.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.revolute.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.revolute.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.revolute.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.revolute.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.revolute.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.revolute.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.revolute.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.revolute.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.revolute.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.revolute.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.revolute.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.revolute.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.revolute.axis.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real jointRRR2.jointUSR.revolute.axis.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real jointRRR2.jointUSR.revolute.bearing.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real jointRRR2.jointUSR.revolute.bearing.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real jointRRR2.jointUSR.revolute.position_a[1](quantity = \"Position\", unit = \"m\") \"Position vector from frame_a to frame_a side of length constraint, resolved in frame_a of revolute joint\";
//   input Real jointRRR2.jointUSR.revolute.position_a[2](quantity = \"Position\", unit = \"m\") \"Position vector from frame_a to frame_a side of length constraint, resolved in frame_a of revolute joint\";
//   input Real jointRRR2.jointUSR.revolute.position_a[3](quantity = \"Position\", unit = \"m\") \"Position vector from frame_a to frame_a side of length constraint, resolved in frame_a of revolute joint\";
//   input Real jointRRR2.jointUSR.revolute.position_b[1](quantity = \"Position\", unit = \"m\") \"Position vector from frame_b to frame_b side of length constraint, resolved in frame_b of revolute joint\";
//   input Real jointRRR2.jointUSR.revolute.position_b[2](quantity = \"Position\", unit = \"m\") \"Position vector from frame_b to frame_b side of length constraint, resolved in frame_b of revolute joint\";
//   input Real jointRRR2.jointUSR.revolute.position_b[3](quantity = \"Position\", unit = \"m\") \"Position vector from frame_b to frame_b side of length constraint, resolved in frame_b of revolute joint\";
//   parameter Boolean jointRRR2.jointUSR.revolute.animation = jointRRR2.jointUSR.animation \"= true, if animation shall be enabled\";
//   parameter Real jointRRR2.jointUSR.revolute.lengthConstraint(quantity = \"Length\", unit = \"m\", start = 1.0) = jointRRR2.jointUSR.rod1Length \"Fixed length of length constraint\";
//   parameter Real jointRRR2.jointUSR.revolute.n[1](unit = \"1\") = jointRRR2.jointUSR.n_b[1] \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real jointRRR2.jointUSR.revolute.n[2](unit = \"1\") = jointRRR2.jointUSR.n_b[2] \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real jointRRR2.jointUSR.revolute.n[3](unit = \"1\") = jointRRR2.jointUSR.n_b[3] \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real jointRRR2.jointUSR.revolute.phi_offset(quantity = \"Angle\", unit = \"deg\") = jointRRR2.jointUSR.phi_offset \"Relative angle offset (angle = phi + from_deg(phi_offset))\";
//   parameter Real jointRRR2.jointUSR.revolute.phi_guess(quantity = \"Angle\", unit = \"deg\") = jointRRR2.jointUSR.phi_guess \"Select the configuration such that at initial time |phi - from_deg(phi_guess)|is minimal\";
//   parameter Real jointRRR2.jointUSR.revolute.cylinderLength(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR2.jointUSR.revoluteLength \"Length of cylinder representing the joint axis\";
//   parameter Real jointRRR2.jointUSR.revolute.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR2.jointUSR.revoluteDiameter \"Diameter of cylinder representing the joint axis\";
//   input Integer jointRRR2.jointUSR.revolute.cylinderColor[1](min = 0, max = 255) = jointRRR2.jointUSR.revoluteColor[1] \"Color of cylinder representing the joint axis\";
//   input Integer jointRRR2.jointUSR.revolute.cylinderColor[2](min = 0, max = 255) = jointRRR2.jointUSR.revoluteColor[2] \"Color of cylinder representing the joint axis\";
//   input Integer jointRRR2.jointUSR.revolute.cylinderColor[3](min = 0, max = 255) = jointRRR2.jointUSR.revoluteColor[3] \"Color of cylinder representing the joint axis\";
//   input Real jointRRR2.jointUSR.revolute.specularCoefficient = jointRRR2.jointUSR.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean jointRRR2.jointUSR.revolute.positiveBranch(fixed = false) \"Based on phi_guess, selection of one of the two solutions of the non-linear constraint equation\";
//   Real jointRRR2.jointUSR.revolute.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle of revolute joint\";
//   Real jointRRR2.jointUSR.revolute.R_rel.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.revolute.R_rel.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.revolute.R_rel.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.revolute.R_rel.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.revolute.R_rel.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.revolute.R_rel.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.revolute.R_rel.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.revolute.R_rel.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.revolute.R_rel.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.revolute.R_rel.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.revolute.R_rel.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.revolute.R_rel.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.revolute.angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"= phi + from_deg(phi_offset) (relative rotation angle between frame_a and frame_b)\";
//   Real jointRRR2.jointUSR.revolute.tau(quantity = \"Torque\", unit = \"N.m\") \"= axis.tau (driving torque in the axis)\";
//   protected Real jointRRR2.jointUSR.revolute.r_a[1](quantity = \"Length\", unit = \"m\") = jointRRR2.jointUSR.revolute.position_a[1] \"Position vector from frame_a to frame_a side of length constraint, resolved in frame_a of revolute joint\";
//   protected Real jointRRR2.jointUSR.revolute.r_a[2](quantity = \"Length\", unit = \"m\") = jointRRR2.jointUSR.revolute.position_a[2] \"Position vector from frame_a to frame_a side of length constraint, resolved in frame_a of revolute joint\";
//   protected Real jointRRR2.jointUSR.revolute.r_a[3](quantity = \"Length\", unit = \"m\") = jointRRR2.jointUSR.revolute.position_a[3] \"Position vector from frame_a to frame_a side of length constraint, resolved in frame_a of revolute joint\";
//   protected Real jointRRR2.jointUSR.revolute.r_b[1](quantity = \"Length\", unit = \"m\") = jointRRR2.jointUSR.revolute.position_b[1] \"Position vector from frame_b to frame_b side of length constraint, resolved in frame_b of revolute joint\";
//   protected Real jointRRR2.jointUSR.revolute.r_b[2](quantity = \"Length\", unit = \"m\") = jointRRR2.jointUSR.revolute.position_b[2] \"Position vector from frame_b to frame_b side of length constraint, resolved in frame_b of revolute joint\";
//   protected Real jointRRR2.jointUSR.revolute.r_b[3](quantity = \"Length\", unit = \"m\") = jointRRR2.jointUSR.revolute.position_b[3] \"Position vector from frame_b to frame_b side of length constraint, resolved in frame_b of revolute joint\";
//   protected Real jointRRR2.jointUSR.revolute.e_r_a \"Projection of r_a on e\";
//   protected Real jointRRR2.jointUSR.revolute.e_r_b \"Projection of r_b on e\";
//   protected Real jointRRR2.jointUSR.revolute.A \"Coefficient A of equation: A*cos(phi) + B*sin(phi) + C = 0\";
//   protected Real jointRRR2.jointUSR.revolute.B \"Coefficient B of equation: A*cos(phi) + B*sin(phi) + C = 0\";
//   protected Real jointRRR2.jointUSR.revolute.C \"Coefficient C of equation: A*cos(phi) + B*sin(phi) + C = 0\";
//   protected Real jointRRR2.jointUSR.revolute.k1 \"Constant of quadratic equation\";
//   protected Real jointRRR2.jointUSR.revolute.k2 \"Constant of quadratic equation\";
//   protected Real jointRRR2.jointUSR.revolute.k1a(start = 1.0);
//   protected Real jointRRR2.jointUSR.revolute.k1b;
//   protected Real jointRRR2.jointUSR.revolute.kcos_angle \"= k1*cos(angle)\";
//   protected Real jointRRR2.jointUSR.revolute.ksin_angle \"= k1*sin(angle)\";
//   parameter Real jointRRR2.jointUSR.revolute.e[1](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR2.jointUSR.revolute.n[1],jointRRR2.jointUSR.revolute.n[2],jointRRR2.jointUSR.revolute.n[3]},1e-13)[1] \"Unit vector in direction of rotation axis, resolved in frame_a\";
//   parameter Real jointRRR2.jointUSR.revolute.e[2](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR2.jointUSR.revolute.n[1],jointRRR2.jointUSR.revolute.n[2],jointRRR2.jointUSR.revolute.n[3]},1e-13)[2] \"Unit vector in direction of rotation axis, resolved in frame_a\";
//   parameter Real jointRRR2.jointUSR.revolute.e[3](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR2.jointUSR.revolute.n[1],jointRRR2.jointUSR.revolute.n[2],jointRRR2.jointUSR.revolute.n[3]},1e-13)[3] \"Unit vector in direction of rotation axis, resolved in frame_a\";
//   Real jointRRR2.jointUSR.rod1.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.rod1.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.rod1.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.rod1.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.rod1.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.rod1.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.rod1.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.rod1.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.rod1.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.rod1.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.rod1.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.rod1.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.rod1.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.rod1.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.rod1.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.rod1.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.rod1.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.rod1.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.rod1.frame_ia.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.rod1.frame_ia.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.rod1.frame_ia.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.rod1.frame_ia.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_ia.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_ia.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_ia.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_ia.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_ia.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_ia.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_ia.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_ia.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_ia.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_ia.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_ia.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.rod1.frame_ia.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.rod1.frame_ia.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.rod1.frame_ia.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.rod1.frame_ia.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.rod1.frame_ia.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.rod1.frame_ia.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean jointRRR2.jointUSR.rod1.animation = jointRRR2.jointUSR.animation \"= true, if animation shall be enabled\";
//   parameter Boolean jointRRR2.jointUSR.rod1.showUniversalAxes = jointRRR2.jointUSR.showUniversalAxes \" = true, if universal joint shall be visualized with two cylinders, otherwise with a sphere (provided animation=true)\";
//   parameter Boolean jointRRR2.jointUSR.rod1.computeRodLength = false \"= true, if distance between frame_a and frame_b shall be computed during initialization (see info)\";
//   parameter Real jointRRR2.jointUSR.rod1.n1_a[1](unit = \"1\") = jointRRR2.jointUSR.n1_a[1] \"Axis 1 of universal joint resolved in frame_a (axis 2 is orthogonal to axis 1 and to rod)\";
//   parameter Real jointRRR2.jointUSR.rod1.n1_a[2](unit = \"1\") = jointRRR2.jointUSR.n1_a[2] \"Axis 1 of universal joint resolved in frame_a (axis 2 is orthogonal to axis 1 and to rod)\";
//   parameter Real jointRRR2.jointUSR.rod1.n1_a[3](unit = \"1\") = jointRRR2.jointUSR.n1_a[3] \"Axis 1 of universal joint resolved in frame_a (axis 2 is orthogonal to axis 1 and to rod)\";
//   parameter Real jointRRR2.jointUSR.rod1.rRod_ia[1](quantity = \"Length\", unit = \"m\") = jointRRR2.jointUSR.rRod1_ia[1] \"Vector from origin of frame_a to origin of frame_b, resolved in frame_ia (if computeRodLength=true, rRod_ia is only an axis vector along the connecting rod)\";
//   parameter Real jointRRR2.jointUSR.rod1.rRod_ia[2](quantity = \"Length\", unit = \"m\") = jointRRR2.jointUSR.rRod1_ia[2] \"Vector from origin of frame_a to origin of frame_b, resolved in frame_ia (if computeRodLength=true, rRod_ia is only an axis vector along the connecting rod)\";
//   parameter Real jointRRR2.jointUSR.rod1.rRod_ia[3](quantity = \"Length\", unit = \"m\") = jointRRR2.jointUSR.rRod1_ia[3] \"Vector from origin of frame_a to origin of frame_b, resolved in frame_ia (if computeRodLength=true, rRod_ia is only an axis vector along the connecting rod)\";
//   parameter Real jointRRR2.jointUSR.rod1.sphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR2.jointUSR.sphereDiameter \"Diameter of spheres representing the universal and the spherical joint\";
//   input Integer jointRRR2.jointUSR.rod1.sphereColor[1](min = 0, max = 255) = jointRRR2.jointUSR.sphereColor[1] \"Color of spheres representing the universal and the spherical joint\";
//   input Integer jointRRR2.jointUSR.rod1.sphereColor[2](min = 0, max = 255) = jointRRR2.jointUSR.sphereColor[2] \"Color of spheres representing the universal and the spherical joint\";
//   input Integer jointRRR2.jointUSR.rod1.sphereColor[3](min = 0, max = 255) = jointRRR2.jointUSR.sphereColor[3] \"Color of spheres representing the universal and the spherical joint\";
//   parameter String jointRRR2.jointUSR.rod1.rodShapeType = \"cylinder\" \"Shape type of rod connecting the universal and the spherical joint\";
//   parameter Real jointRRR2.jointUSR.rod1.rodExtra = 0.0 \"Additional parameter depending on rodShapeType\";
//   input Integer jointRRR2.jointUSR.rod1.rodColor[1](min = 0, max = 255) = jointRRR2.jointUSR.rod1Color[1] \"Color of rod shape connecting the universal and the spherical joints\";
//   input Integer jointRRR2.jointUSR.rod1.rodColor[2](min = 0, max = 255) = jointRRR2.jointUSR.rod1Color[2] \"Color of rod shape connecting the universal and the spherical joints\";
//   input Integer jointRRR2.jointUSR.rod1.rodColor[3](min = 0, max = 255) = jointRRR2.jointUSR.rod1Color[3] \"Color of rod shape connecting the universal and the spherical joints\";
//   parameter Real jointRRR2.jointUSR.rod1.cylinderLength(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR2.jointUSR.cylinderLength \"Length of cylinders representing the two universal joint axes\";
//   parameter Real jointRRR2.jointUSR.rod1.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR2.jointUSR.cylinderDiameter \"Diameter of cylinders representing the two universal joint axes\";
//   input Integer jointRRR2.jointUSR.rod1.cylinderColor[1](min = 0, max = 255) = jointRRR2.jointUSR.cylinderColor[1] \"Color of cylinders representing the two universal joint axes\";
//   input Integer jointRRR2.jointUSR.rod1.cylinderColor[2](min = 0, max = 255) = jointRRR2.jointUSR.cylinderColor[2] \"Color of cylinders representing the two universal joint axes\";
//   input Integer jointRRR2.jointUSR.rod1.cylinderColor[3](min = 0, max = 255) = jointRRR2.jointUSR.cylinderColor[3] \"Color of cylinders representing the two universal joint axes\";
//   input Real jointRRR2.jointUSR.rod1.specularCoefficient = jointRRR2.jointUSR.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean jointRRR2.jointUSR.rod1.kinematicConstraint = false \"= false, if no constraint shall be defined, due to analytically solving a kinematic loop\";
//   Real jointRRR2.jointUSR.rod1.constraintResidue = jointRRR2.jointUSR.rod1.f_rod - jointRRR2.jointUSR.f_rod \"Constraint equation of joint in residue form: Either length constraint (= default) or equation to compute rod force (for analytic solution of loops in combination with Internal.RevoluteWithLengthConstraint/PrismaticWithLengthConstraint)\";
//   parameter Boolean jointRRR2.jointUSR.rod1.checkTotalPower = false \"= true, if total power flowing into this component shall be determined (must be zero)\";
//   Real jointRRR2.jointUSR.rod1.f_rod(quantity = \"Force\", unit = \"N\") \"Constraint force in direction of the rod (positive, if rod is pressed)\";
//   Real jointRRR2.jointUSR.rod1.totalPower(quantity = \"Power\", unit = \"W\") \"Total power flowing into this element, if checkTotalPower=true (otherwise dummy)\";
//   Real jointRRR2.jointUSR.rod1.f_b_a1[1](quantity = \"Force\", unit = \"N\") \"frame_b.f without f_rod part, resolved in frame_a (needed for analytic loop handling)\";
//   Real jointRRR2.jointUSR.rod1.f_b_a1[2](quantity = \"Force\", unit = \"N\") \"frame_b.f without f_rod part, resolved in frame_a (needed for analytic loop handling)\";
//   Real jointRRR2.jointUSR.rod1.f_b_a1[3](quantity = \"Force\", unit = \"N\") \"frame_b.f without f_rod part, resolved in frame_a (needed for analytic loop handling)\";
//   Real jointRRR2.jointUSR.rod1.eRod_a[1](unit = \"1\") \"Unit vector in direction of rRod_a, resolved in frame_a (needed for analytic loop handling)\";
//   Real jointRRR2.jointUSR.rod1.eRod_a[2](unit = \"1\") \"Unit vector in direction of rRod_a, resolved in frame_a (needed for analytic loop handling)\";
//   Real jointRRR2.jointUSR.rod1.eRod_a[3](unit = \"1\") \"Unit vector in direction of rRod_a, resolved in frame_a (needed for analytic loop handling)\";
//   Real jointRRR2.jointUSR.rod1.rRod_0[1](quantity = \"Length\", unit = \"m\", start = jointRRR2.jointUSR.rod1.rRod_ia[1]) \"Position vector from origin of frame_a to origin of frame_b resolved in world frame\";
//   Real jointRRR2.jointUSR.rod1.rRod_0[2](quantity = \"Length\", unit = \"m\", start = jointRRR2.jointUSR.rod1.rRod_ia[2]) \"Position vector from origin of frame_a to origin of frame_b resolved in world frame\";
//   Real jointRRR2.jointUSR.rod1.rRod_0[3](quantity = \"Length\", unit = \"m\", start = jointRRR2.jointUSR.rod1.rRod_ia[3]) \"Position vector from origin of frame_a to origin of frame_b resolved in world frame\";
//   Real jointRRR2.jointUSR.rod1.rRod_a[1](quantity = \"Length\", unit = \"m\", start = jointRRR2.jointUSR.rod1.rRod_ia[1]) \"Position vector from origin of frame_a to origin of frame_b resolved in frame_a\";
//   Real jointRRR2.jointUSR.rod1.rRod_a[2](quantity = \"Length\", unit = \"m\", start = jointRRR2.jointUSR.rod1.rRod_ia[2]) \"Position vector from origin of frame_a to origin of frame_b resolved in frame_a\";
//   Real jointRRR2.jointUSR.rod1.rRod_a[3](quantity = \"Length\", unit = \"m\", start = jointRRR2.jointUSR.rod1.rRod_ia[3]) \"Position vector from origin of frame_a to origin of frame_b resolved in frame_a\";
//   protected Real jointRRR2.jointUSR.rod1.f_b_a[1](quantity = \"Force\", unit = \"N\") \"frame_b.f resolved in frame_a\";
//   protected Real jointRRR2.jointUSR.rod1.f_b_a[2](quantity = \"Force\", unit = \"N\") \"frame_b.f resolved in frame_a\";
//   protected Real jointRRR2.jointUSR.rod1.f_b_a[3](quantity = \"Force\", unit = \"N\") \"frame_b.f resolved in frame_a\";
//   protected Real jointRRR2.jointUSR.rod1.f_ia_a[1](quantity = \"Force\", unit = \"N\") \"frame_ia.f resolved in frame_a\";
//   protected Real jointRRR2.jointUSR.rod1.f_ia_a[2](quantity = \"Force\", unit = \"N\") \"frame_ia.f resolved in frame_a\";
//   protected Real jointRRR2.jointUSR.rod1.f_ia_a[3](quantity = \"Force\", unit = \"N\") \"frame_ia.f resolved in frame_a\";
//   protected Real jointRRR2.jointUSR.rod1.t_ia_a[1](quantity = \"Torque\", unit = \"N.m\") \"frame_ia.t resolved in frame_a\";
//   protected Real jointRRR2.jointUSR.rod1.t_ia_a[2](quantity = \"Torque\", unit = \"N.m\") \"frame_ia.t resolved in frame_a\";
//   protected Real jointRRR2.jointUSR.rod1.t_ia_a[3](quantity = \"Torque\", unit = \"N.m\") \"frame_ia.t resolved in frame_a\";
//   protected Real jointRRR2.jointUSR.rod1.n2_a[1](unit = \"1\") \"Vector in direction of axis 2 of the universal joint (e2_ia), resolved in frame_a\";
//   protected Real jointRRR2.jointUSR.rod1.n2_a[2](unit = \"1\") \"Vector in direction of axis 2 of the universal joint (e2_ia), resolved in frame_a\";
//   protected Real jointRRR2.jointUSR.rod1.n2_a[3](unit = \"1\") \"Vector in direction of axis 2 of the universal joint (e2_ia), resolved in frame_a\";
//   protected Real jointRRR2.jointUSR.rod1.length2_n2_a(unit = \"m2\", start = 1.0) \"Square of length of vector n2_a\";
//   protected Real jointRRR2.jointUSR.rod1.length_n2_a(quantity = \"Length\", unit = \"m\") \"Length of vector n2_a\";
//   protected Real jointRRR2.jointUSR.rod1.e2_a[1](unit = \"1\") \"Unit vector in direction of axis 2 of the universal joint (e2_ia), resolved in frame_a\";
//   protected Real jointRRR2.jointUSR.rod1.e2_a[2](unit = \"1\") \"Unit vector in direction of axis 2 of the universal joint (e2_ia), resolved in frame_a\";
//   protected Real jointRRR2.jointUSR.rod1.e2_a[3](unit = \"1\") \"Unit vector in direction of axis 2 of the universal joint (e2_ia), resolved in frame_a\";
//   protected Real jointRRR2.jointUSR.rod1.e3_a[1](unit = \"1\") \"Unit vector perpendicular to eRod_ia and e2_a, resolved in frame_a\";
//   protected Real jointRRR2.jointUSR.rod1.e3_a[2](unit = \"1\") \"Unit vector perpendicular to eRod_ia and e2_a, resolved in frame_a\";
//   protected Real jointRRR2.jointUSR.rod1.e3_a[3](unit = \"1\") \"Unit vector perpendicular to eRod_ia and e2_a, resolved in frame_a\";
//   protected Real jointRRR2.jointUSR.rod1.der_rRod_a_L[1](unit = \"1/s\") \"= der(rRod_a)/rodLength\";
//   protected Real jointRRR2.jointUSR.rod1.der_rRod_a_L[2](unit = \"1/s\") \"= der(rRod_a)/rodLength\";
//   protected Real jointRRR2.jointUSR.rod1.der_rRod_a_L[3](unit = \"1/s\") \"= der(rRod_a)/rodLength\";
//   protected Real jointRRR2.jointUSR.rod1.w_rel_ia1[1](quantity = \"AngularVelocity\", unit = \"rad/s\");
//   protected Real jointRRR2.jointUSR.rod1.w_rel_ia1[2](quantity = \"AngularVelocity\", unit = \"rad/s\");
//   protected Real jointRRR2.jointUSR.rod1.w_rel_ia1[3](quantity = \"AngularVelocity\", unit = \"rad/s\");
//   Real jointRRR2.jointUSR.rod1.R_rel_ia1.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia1.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia1.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia1.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia1.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia1.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia1.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia1.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia1.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia1.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia1.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia1.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia2.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia2.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia2.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia2.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia2.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia2.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia2.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia2.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia2.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia2.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia2.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia2.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.rod1.R_rel_ia.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real jointRRR2.jointUSR.rod1.rodLength(quantity = \"Length\", unit = \"m\", min = 0.0, fixed =  NOT jointRRR2.jointUSR.rod1.computeRodLength) = Modelica.Math.Vectors.length({jointRRR2.jointUSR.rod1.rRod_ia[1],jointRRR2.jointUSR.rod1.rRod_ia[2],jointRRR2.jointUSR.rod1.rRod_ia[3]}) \"Length of rod (distance between origin of frame_a and origin of frame_b)\";
//   parameter Real jointRRR2.jointUSR.rod1.eRod_ia[1](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR2.jointUSR.rod1.rRod_ia[1],jointRRR2.jointUSR.rod1.rRod_ia[2],jointRRR2.jointUSR.rod1.rRod_ia[3]},1e-13)[1] \"Unit vector from origin of frame_a to origin of frame_b, resolved in frame_ia\";
//   parameter Real jointRRR2.jointUSR.rod1.eRod_ia[2](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR2.jointUSR.rod1.rRod_ia[1],jointRRR2.jointUSR.rod1.rRod_ia[2],jointRRR2.jointUSR.rod1.rRod_ia[3]},1e-13)[2] \"Unit vector from origin of frame_a to origin of frame_b, resolved in frame_ia\";
//   parameter Real jointRRR2.jointUSR.rod1.eRod_ia[3](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR2.jointUSR.rod1.rRod_ia[1],jointRRR2.jointUSR.rod1.rRod_ia[2],jointRRR2.jointUSR.rod1.rRod_ia[3]},1e-13)[3] \"Unit vector from origin of frame_a to origin of frame_b, resolved in frame_ia\";
//   parameter Real jointRRR2.jointUSR.rod1.rodWidth(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR2.jointUSR.rod1Diameter \"Width of rod shape in direction of axis 2 of universal joint.\";
//   parameter Real jointRRR2.jointUSR.rod1.e2_ia[1](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR2.jointUSR.rod1.n1_a[2] * jointRRR2.jointUSR.rod1.eRod_ia[3] - jointRRR2.jointUSR.rod1.n1_a[3] * jointRRR2.jointUSR.rod1.eRod_ia[2],jointRRR2.jointUSR.rod1.n1_a[3] * jointRRR2.jointUSR.rod1.eRod_ia[1] - jointRRR2.jointUSR.rod1.n1_a[1] * jointRRR2.jointUSR.rod1.eRod_ia[3],jointRRR2.jointUSR.rod1.n1_a[1] * jointRRR2.jointUSR.rod1.eRod_ia[2] - jointRRR2.jointUSR.rod1.n1_a[2] * jointRRR2.jointUSR.rod1.eRod_ia[1]},1e-13)[1] \"Unit vector in direction of axis 2 of universal joint, resolved in frame_ia (orthogonal to n1_a and eRod_ia; note: frame_ia is parallel to frame_a when the universal joint angles are zero)\";
//   parameter Real jointRRR2.jointUSR.rod1.e2_ia[2](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR2.jointUSR.rod1.n1_a[2] * jointRRR2.jointUSR.rod1.eRod_ia[3] - jointRRR2.jointUSR.rod1.n1_a[3] * jointRRR2.jointUSR.rod1.eRod_ia[2],jointRRR2.jointUSR.rod1.n1_a[3] * jointRRR2.jointUSR.rod1.eRod_ia[1] - jointRRR2.jointUSR.rod1.n1_a[1] * jointRRR2.jointUSR.rod1.eRod_ia[3],jointRRR2.jointUSR.rod1.n1_a[1] * jointRRR2.jointUSR.rod1.eRod_ia[2] - jointRRR2.jointUSR.rod1.n1_a[2] * jointRRR2.jointUSR.rod1.eRod_ia[1]},1e-13)[2] \"Unit vector in direction of axis 2 of universal joint, resolved in frame_ia (orthogonal to n1_a and eRod_ia; note: frame_ia is parallel to frame_a when the universal joint angles are zero)\";
//   parameter Real jointRRR2.jointUSR.rod1.e2_ia[3](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR2.jointUSR.rod1.n1_a[2] * jointRRR2.jointUSR.rod1.eRod_ia[3] - jointRRR2.jointUSR.rod1.n1_a[3] * jointRRR2.jointUSR.rod1.eRod_ia[2],jointRRR2.jointUSR.rod1.n1_a[3] * jointRRR2.jointUSR.rod1.eRod_ia[1] - jointRRR2.jointUSR.rod1.n1_a[1] * jointRRR2.jointUSR.rod1.eRod_ia[3],jointRRR2.jointUSR.rod1.n1_a[1] * jointRRR2.jointUSR.rod1.eRod_ia[2] - jointRRR2.jointUSR.rod1.n1_a[2] * jointRRR2.jointUSR.rod1.eRod_ia[1]},1e-13)[3] \"Unit vector in direction of axis 2 of universal joint, resolved in frame_ia (orthogonal to n1_a and eRod_ia; note: frame_ia is parallel to frame_a when the universal joint angles are zero)\";
//   parameter Real jointRRR2.jointUSR.rod1.rodHeight(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR2.jointUSR.rod1Diameter \"Height of rod shape in direction that is orthogonal to rod and to axis 2\";
//   parameter Real jointRRR2.jointUSR.rod1.e3_ia[1](unit = \"1\") = jointRRR2.jointUSR.rod1.eRod_ia[2] * jointRRR2.jointUSR.rod1.e2_ia[3] - jointRRR2.jointUSR.rod1.eRod_ia[3] * jointRRR2.jointUSR.rod1.e2_ia[2] \"Unit vector perpendicular to eRod_ia and e2_ia, resolved in frame_ia\";
//   parameter Real jointRRR2.jointUSR.rod1.e3_ia[2](unit = \"1\") = jointRRR2.jointUSR.rod1.eRod_ia[3] * jointRRR2.jointUSR.rod1.e2_ia[1] - jointRRR2.jointUSR.rod1.eRod_ia[1] * jointRRR2.jointUSR.rod1.e2_ia[3] \"Unit vector perpendicular to eRod_ia and e2_ia, resolved in frame_ia\";
//   parameter Real jointRRR2.jointUSR.rod1.e3_ia[3](unit = \"1\") = jointRRR2.jointUSR.rod1.eRod_ia[1] * jointRRR2.jointUSR.rod1.e2_ia[2] - jointRRR2.jointUSR.rod1.eRod_ia[2] * jointRRR2.jointUSR.rod1.e2_ia[1] \"Unit vector perpendicular to eRod_ia and e2_ia, resolved in frame_ia\";
//   Real jointRRR2.jointUSR.rod2.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.rod2.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.rod2.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.rod2.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod2.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod2.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod2.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod2.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod2.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod2.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod2.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod2.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod2.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.rod2.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.rod2.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.rod2.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.rod2.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.rod2.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.rod2.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.rod2.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.rod2.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.rod2.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.rod2.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.rod2.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.rod2.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod2.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod2.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod2.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod2.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod2.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod2.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod2.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod2.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.rod2.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.rod2.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.rod2.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.rod2.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.rod2.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.rod2.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.rod2.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.rod2.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.rod2.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean jointRRR2.jointUSR.rod2.animation = jointRRR2.jointUSR.animation \"= true, if animation shall be enabled\";
//   parameter Real jointRRR2.jointUSR.rod2.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = jointRRR2.jointUSR.rRod2_ib[1] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real jointRRR2.jointUSR.rod2.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = jointRRR2.jointUSR.rRod2_ib[2] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real jointRRR2.jointUSR.rod2.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = jointRRR2.jointUSR.rRod2_ib[3] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter String jointRRR2.jointUSR.rod2.shapeType = \"cylinder\" \" Type of shape\";
//   parameter Real jointRRR2.jointUSR.rod2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real jointRRR2.jointUSR.rod2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real jointRRR2.jointUSR.rod2.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real jointRRR2.jointUSR.rod2.widthDirection[1](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real jointRRR2.jointUSR.rod2.widthDirection[2](unit = \"1\") = 1.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real jointRRR2.jointUSR.rod2.widthDirection[3](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real jointRRR2.jointUSR.rod2.extra = 0.0 \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer jointRRR2.jointUSR.rod2.color[1](min = 0, max = 255) = jointRRR2.jointUSR.rod2Color[1] \" Color of shape\";
//   input Integer jointRRR2.jointUSR.rod2.color[2](min = 0, max = 255) = jointRRR2.jointUSR.rod2Color[2] \" Color of shape\";
//   input Integer jointRRR2.jointUSR.rod2.color[3](min = 0, max = 255) = jointRRR2.jointUSR.rod2Color[3] \" Color of shape\";
//   input Real jointRRR2.jointUSR.rod2.specularCoefficient = jointRRR2.jointUSR.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Real jointRRR2.jointUSR.rod2.lengthDirection[1](unit = \"1\") = jointRRR2.jointUSR.rod2.r[1] - jointRRR2.jointUSR.rod2.r_shape[1] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real jointRRR2.jointUSR.rod2.lengthDirection[2](unit = \"1\") = jointRRR2.jointUSR.rod2.r[2] - jointRRR2.jointUSR.rod2.r_shape[2] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real jointRRR2.jointUSR.rod2.lengthDirection[3](unit = \"1\") = jointRRR2.jointUSR.rod2.r[3] - jointRRR2.jointUSR.rod2.r_shape[3] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real jointRRR2.jointUSR.rod2.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({jointRRR2.jointUSR.rod2.r[1] - jointRRR2.jointUSR.rod2.r_shape[1],jointRRR2.jointUSR.rod2.r[2] - jointRRR2.jointUSR.rod2.r_shape[2],jointRRR2.jointUSR.rod2.r[3] - jointRRR2.jointUSR.rod2.r_shape[3]}) \" Length of shape\";
//   parameter Real jointRRR2.jointUSR.rod2.width(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR2.jointUSR.rod2Diameter \" Width of shape\";
//   parameter Real jointRRR2.jointUSR.rod2.height(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR2.jointUSR.rod2Diameter \" Height of shape.\";
//   Real jointRRR2.jointUSR.relativePosition.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.relativePosition.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   output Real jointRRR2.jointUSR.relativePosition.r_rel[1] \"Relative position vector resolved in frame defined by resolveInFrame\";
//   output Real jointRRR2.jointUSR.relativePosition.r_rel[2] \"Relative position vector resolved in frame defined by resolveInFrame\";
//   output Real jointRRR2.jointUSR.relativePosition.r_rel[3] \"Relative position vector resolved in frame defined by resolveInFrame\";
//   parameter enumeration(world, frame_a, frame_b, frame_resolve) jointRRR2.jointUSR.relativePosition.resolveInFrame = Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_a \"Frame in which output vector r_rel shall be resolved (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   output Real jointRRR2.jointUSR.relativePosition.relativePosition.r_rel[1](quantity = \"Position\", unit = \"m\") \"Relative position vector frame_b.r_0 - frame_a.r_0 resolved in frame defined by resolveInFrame\";
//   output Real jointRRR2.jointUSR.relativePosition.relativePosition.r_rel[2](quantity = \"Position\", unit = \"m\") \"Relative position vector frame_b.r_0 - frame_a.r_0 resolved in frame defined by resolveInFrame\";
//   output Real jointRRR2.jointUSR.relativePosition.relativePosition.r_rel[3](quantity = \"Position\", unit = \"m\") \"Relative position vector frame_b.r_0 - frame_a.r_0 resolved in frame defined by resolveInFrame\";
//   parameter enumeration(world, frame_a, frame_b, frame_resolve) jointRRR2.jointUSR.relativePosition.relativePosition.resolveInFrame = jointRRR2.jointUSR.relativePosition.resolveInFrame \"Frame in which output vector r_rel is resolved (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)\";
//   Real jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   output Real jointRRR2.jointUSR.position_b[1].y \"Connector of Real output signal\";
//   parameter Real jointRRR2.jointUSR.position_b[1].k(start = 1.0) = jointRRR2.jointUSR.rRod2_ib[1] \"Constant output value\";
//   output Real jointRRR2.jointUSR.position_b[2].y \"Connector of Real output signal\";
//   parameter Real jointRRR2.jointUSR.position_b[2].k(start = 1.0) = jointRRR2.jointUSR.rRod2_ib[2] \"Constant output value\";
//   output Real jointRRR2.jointUSR.position_b[3].y \"Connector of Real output signal\";
//   parameter Real jointRRR2.jointUSR.position_b[3].k(start = 1.0) = jointRRR2.jointUSR.rRod2_ib[3] \"Constant output value\";
//   parameter Real jointRRR2.jointUSR.rod1Diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR2.jointUSR.sphereDiameter / 2.0 \"Diameter of rod 1 connecting the universal and the spherical joint\";
//   parameter Real jointRRR2.jointUSR.rod2Diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR2.jointUSR.rod1Diameter \"Diameter of rod 2 connecting the revolute and the spherical joint\";
//   parameter String jointRRR2.shape_rev1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real jointRRR2.shape_rev1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rev1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rev1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rev1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rev1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rev1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rev1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rev1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rev1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rev1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR2.shape_rev1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR2.shape_rev1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR2.shape_rev1.r[1](quantity = \"Length\", unit = \"m\") = jointRRR2.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR2.shape_rev1.r[2](quantity = \"Length\", unit = \"m\") = jointRRR2.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR2.shape_rev1.r[3](quantity = \"Length\", unit = \"m\") = jointRRR2.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR2.shape_rev1.r_shape[1](quantity = \"Length\", unit = \"m\") = (-jointRRR2.cylinderLength) * jointRRR2.e_a[1] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR2.shape_rev1.r_shape[2](quantity = \"Length\", unit = \"m\") = (-jointRRR2.cylinderLength) * jointRRR2.e_a[2] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR2.shape_rev1.r_shape[3](quantity = \"Length\", unit = \"m\") = (-jointRRR2.cylinderLength) * jointRRR2.e_a[3] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR2.shape_rev1.lengthDirection[1](unit = \"1\") = jointRRR2.e_a[1] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR2.shape_rev1.lengthDirection[2](unit = \"1\") = jointRRR2.e_a[2] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR2.shape_rev1.lengthDirection[3](unit = \"1\") = jointRRR2.e_a[3] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR2.shape_rev1.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR2.shape_rev1.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR2.shape_rev1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR2.shape_rev1.length(quantity = \"Length\", unit = \"m\") = jointRRR2.cylinderLength \"Length of visual object\";
//   input Real jointRRR2.shape_rev1.width(quantity = \"Length\", unit = \"m\") = jointRRR2.cylinderDiameter \"Width of visual object\";
//   input Real jointRRR2.shape_rev1.height(quantity = \"Length\", unit = \"m\") = jointRRR2.cylinderDiameter \"Height of visual object\";
//   input Real jointRRR2.shape_rev1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real jointRRR2.shape_rev1.color[1] = Real(jointRRR2.cylinderColor[1]) \"Color of shape\";
//   input Real jointRRR2.shape_rev1.color[2] = Real(jointRRR2.cylinderColor[2]) \"Color of shape\";
//   input Real jointRRR2.shape_rev1.color[3] = Real(jointRRR2.cylinderColor[3]) \"Color of shape\";
//   input Real jointRRR2.shape_rev1.specularCoefficient = jointRRR2.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real jointRRR2.shape_rev1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({jointRRR2.shape_rev1.lengthDirection[1],jointRRR2.shape_rev1.lengthDirection[2],jointRRR2.shape_rev1.lengthDirection[3]});
//   protected Real jointRRR2.shape_rev1.e_x[1](unit = \"1\") = if noEvent(jointRRR2.shape_rev1.abs_n_x < 1e-10) then 1.0 else jointRRR2.shape_rev1.lengthDirection[1] / jointRRR2.shape_rev1.abs_n_x;
//   protected Real jointRRR2.shape_rev1.e_x[2](unit = \"1\") = if noEvent(jointRRR2.shape_rev1.abs_n_x < 1e-10) then 0.0 else jointRRR2.shape_rev1.lengthDirection[2] / jointRRR2.shape_rev1.abs_n_x;
//   protected Real jointRRR2.shape_rev1.e_x[3](unit = \"1\") = if noEvent(jointRRR2.shape_rev1.abs_n_x < 1e-10) then 0.0 else jointRRR2.shape_rev1.lengthDirection[3] / jointRRR2.shape_rev1.abs_n_x;
//   protected Real jointRRR2.shape_rev1.n_z_aux[1](unit = \"1\") = jointRRR2.shape_rev1.e_x[2] * jointRRR2.shape_rev1.widthDirection[3] - jointRRR2.shape_rev1.e_x[3] * jointRRR2.shape_rev1.widthDirection[2];
//   protected Real jointRRR2.shape_rev1.n_z_aux[2](unit = \"1\") = jointRRR2.shape_rev1.e_x[3] * jointRRR2.shape_rev1.widthDirection[1] - jointRRR2.shape_rev1.e_x[1] * jointRRR2.shape_rev1.widthDirection[3];
//   protected Real jointRRR2.shape_rev1.n_z_aux[3](unit = \"1\") = jointRRR2.shape_rev1.e_x[1] * jointRRR2.shape_rev1.widthDirection[2] - jointRRR2.shape_rev1.e_x[2] * jointRRR2.shape_rev1.widthDirection[1];
//   protected Real jointRRR2.shape_rev1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR2.shape_rev1.e_x[1],jointRRR2.shape_rev1.e_x[2],jointRRR2.shape_rev1.e_x[3]},if noEvent(jointRRR2.shape_rev1.n_z_aux[1] ^ 2.0 + (jointRRR2.shape_rev1.n_z_aux[2] ^ 2.0 + jointRRR2.shape_rev1.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR2.shape_rev1.widthDirection[1],jointRRR2.shape_rev1.widthDirection[2],jointRRR2.shape_rev1.widthDirection[3]} else if noEvent(abs(jointRRR2.shape_rev1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR2.shape_rev1.e_x[1],jointRRR2.shape_rev1.e_x[2],jointRRR2.shape_rev1.e_x[3]})[1];
//   protected Real jointRRR2.shape_rev1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR2.shape_rev1.e_x[1],jointRRR2.shape_rev1.e_x[2],jointRRR2.shape_rev1.e_x[3]},if noEvent(jointRRR2.shape_rev1.n_z_aux[1] ^ 2.0 + (jointRRR2.shape_rev1.n_z_aux[2] ^ 2.0 + jointRRR2.shape_rev1.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR2.shape_rev1.widthDirection[1],jointRRR2.shape_rev1.widthDirection[2],jointRRR2.shape_rev1.widthDirection[3]} else if noEvent(abs(jointRRR2.shape_rev1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR2.shape_rev1.e_x[1],jointRRR2.shape_rev1.e_x[2],jointRRR2.shape_rev1.e_x[3]})[2];
//   protected Real jointRRR2.shape_rev1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR2.shape_rev1.e_x[1],jointRRR2.shape_rev1.e_x[2],jointRRR2.shape_rev1.e_x[3]},if noEvent(jointRRR2.shape_rev1.n_z_aux[1] ^ 2.0 + (jointRRR2.shape_rev1.n_z_aux[2] ^ 2.0 + jointRRR2.shape_rev1.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR2.shape_rev1.widthDirection[1],jointRRR2.shape_rev1.widthDirection[2],jointRRR2.shape_rev1.widthDirection[3]} else if noEvent(abs(jointRRR2.shape_rev1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR2.shape_rev1.e_x[1],jointRRR2.shape_rev1.e_x[2],jointRRR2.shape_rev1.e_x[3]})[3];
//   protected output Real jointRRR2.shape_rev1.Form;
//   output Real jointRRR2.shape_rev1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR2.shape_rev1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR2.shape_rev1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR2.shape_rev1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR2.shape_rev1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR2.shape_rev1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR2.shape_rev1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real jointRRR2.shape_rev1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real jointRRR2.shape_rev1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real jointRRR2.shape_rev1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR2.shape_rev1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR2.shape_rev1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR2.shape_rev1.Material;
//   protected output Real jointRRR2.shape_rev1.Extra;
//   parameter String jointRRR2.shape_rev2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real jointRRR2.shape_rev2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rev2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rev2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rev2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rev2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rev2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rev2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rev2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rev2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rev2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR2.shape_rev2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR2.shape_rev2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR2.shape_rev2.r[1](quantity = \"Length\", unit = \"m\") = jointRRR2.frame_im.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR2.shape_rev2.r[2](quantity = \"Length\", unit = \"m\") = jointRRR2.frame_im.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR2.shape_rev2.r[3](quantity = \"Length\", unit = \"m\") = jointRRR2.frame_im.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR2.shape_rev2.r_shape[1](quantity = \"Length\", unit = \"m\") = (-jointRRR2.cylinderLength) * jointRRR2.e_b[1] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR2.shape_rev2.r_shape[2](quantity = \"Length\", unit = \"m\") = (-jointRRR2.cylinderLength) * jointRRR2.e_b[2] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR2.shape_rev2.r_shape[3](quantity = \"Length\", unit = \"m\") = (-jointRRR2.cylinderLength) * jointRRR2.e_b[3] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR2.shape_rev2.lengthDirection[1](unit = \"1\") = jointRRR2.e_b[1] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR2.shape_rev2.lengthDirection[2](unit = \"1\") = jointRRR2.e_b[2] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR2.shape_rev2.lengthDirection[3](unit = \"1\") = jointRRR2.e_b[3] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR2.shape_rev2.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR2.shape_rev2.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR2.shape_rev2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR2.shape_rev2.length(quantity = \"Length\", unit = \"m\") = jointRRR2.cylinderLength \"Length of visual object\";
//   input Real jointRRR2.shape_rev2.width(quantity = \"Length\", unit = \"m\") = jointRRR2.cylinderDiameter \"Width of visual object\";
//   input Real jointRRR2.shape_rev2.height(quantity = \"Length\", unit = \"m\") = jointRRR2.cylinderDiameter \"Height of visual object\";
//   input Real jointRRR2.shape_rev2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real jointRRR2.shape_rev2.color[1] = Real(jointRRR2.cylinderColor[1]) \"Color of shape\";
//   input Real jointRRR2.shape_rev2.color[2] = Real(jointRRR2.cylinderColor[2]) \"Color of shape\";
//   input Real jointRRR2.shape_rev2.color[3] = Real(jointRRR2.cylinderColor[3]) \"Color of shape\";
//   input Real jointRRR2.shape_rev2.specularCoefficient = jointRRR2.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real jointRRR2.shape_rev2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({jointRRR2.shape_rev2.lengthDirection[1],jointRRR2.shape_rev2.lengthDirection[2],jointRRR2.shape_rev2.lengthDirection[3]});
//   protected Real jointRRR2.shape_rev2.e_x[1](unit = \"1\") = if noEvent(jointRRR2.shape_rev2.abs_n_x < 1e-10) then 1.0 else jointRRR2.shape_rev2.lengthDirection[1] / jointRRR2.shape_rev2.abs_n_x;
//   protected Real jointRRR2.shape_rev2.e_x[2](unit = \"1\") = if noEvent(jointRRR2.shape_rev2.abs_n_x < 1e-10) then 0.0 else jointRRR2.shape_rev2.lengthDirection[2] / jointRRR2.shape_rev2.abs_n_x;
//   protected Real jointRRR2.shape_rev2.e_x[3](unit = \"1\") = if noEvent(jointRRR2.shape_rev2.abs_n_x < 1e-10) then 0.0 else jointRRR2.shape_rev2.lengthDirection[3] / jointRRR2.shape_rev2.abs_n_x;
//   protected Real jointRRR2.shape_rev2.n_z_aux[1](unit = \"1\") = jointRRR2.shape_rev2.e_x[2] * jointRRR2.shape_rev2.widthDirection[3] - jointRRR2.shape_rev2.e_x[3] * jointRRR2.shape_rev2.widthDirection[2];
//   protected Real jointRRR2.shape_rev2.n_z_aux[2](unit = \"1\") = jointRRR2.shape_rev2.e_x[3] * jointRRR2.shape_rev2.widthDirection[1] - jointRRR2.shape_rev2.e_x[1] * jointRRR2.shape_rev2.widthDirection[3];
//   protected Real jointRRR2.shape_rev2.n_z_aux[3](unit = \"1\") = jointRRR2.shape_rev2.e_x[1] * jointRRR2.shape_rev2.widthDirection[2] - jointRRR2.shape_rev2.e_x[2] * jointRRR2.shape_rev2.widthDirection[1];
//   protected Real jointRRR2.shape_rev2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR2.shape_rev2.e_x[1],jointRRR2.shape_rev2.e_x[2],jointRRR2.shape_rev2.e_x[3]},if noEvent(jointRRR2.shape_rev2.n_z_aux[1] ^ 2.0 + (jointRRR2.shape_rev2.n_z_aux[2] ^ 2.0 + jointRRR2.shape_rev2.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR2.shape_rev2.widthDirection[1],jointRRR2.shape_rev2.widthDirection[2],jointRRR2.shape_rev2.widthDirection[3]} else if noEvent(abs(jointRRR2.shape_rev2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR2.shape_rev2.e_x[1],jointRRR2.shape_rev2.e_x[2],jointRRR2.shape_rev2.e_x[3]})[1];
//   protected Real jointRRR2.shape_rev2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR2.shape_rev2.e_x[1],jointRRR2.shape_rev2.e_x[2],jointRRR2.shape_rev2.e_x[3]},if noEvent(jointRRR2.shape_rev2.n_z_aux[1] ^ 2.0 + (jointRRR2.shape_rev2.n_z_aux[2] ^ 2.0 + jointRRR2.shape_rev2.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR2.shape_rev2.widthDirection[1],jointRRR2.shape_rev2.widthDirection[2],jointRRR2.shape_rev2.widthDirection[3]} else if noEvent(abs(jointRRR2.shape_rev2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR2.shape_rev2.e_x[1],jointRRR2.shape_rev2.e_x[2],jointRRR2.shape_rev2.e_x[3]})[2];
//   protected Real jointRRR2.shape_rev2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR2.shape_rev2.e_x[1],jointRRR2.shape_rev2.e_x[2],jointRRR2.shape_rev2.e_x[3]},if noEvent(jointRRR2.shape_rev2.n_z_aux[1] ^ 2.0 + (jointRRR2.shape_rev2.n_z_aux[2] ^ 2.0 + jointRRR2.shape_rev2.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR2.shape_rev2.widthDirection[1],jointRRR2.shape_rev2.widthDirection[2],jointRRR2.shape_rev2.widthDirection[3]} else if noEvent(abs(jointRRR2.shape_rev2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR2.shape_rev2.e_x[1],jointRRR2.shape_rev2.e_x[2],jointRRR2.shape_rev2.e_x[3]})[3];
//   protected output Real jointRRR2.shape_rev2.Form;
//   output Real jointRRR2.shape_rev2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR2.shape_rev2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR2.shape_rev2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR2.shape_rev2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR2.shape_rev2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR2.shape_rev2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR2.shape_rev2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real jointRRR2.shape_rev2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real jointRRR2.shape_rev2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real jointRRR2.shape_rev2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR2.shape_rev2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR2.shape_rev2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR2.shape_rev2.Material;
//   protected output Real jointRRR2.shape_rev2.Extra;
//   parameter String jointRRR2.shape_rev3.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real jointRRR2.shape_rev3.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rev3.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rev3.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rev3.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rev3.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rev3.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rev3.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rev3.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rev3.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rev3.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR2.shape_rev3.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR2.shape_rev3.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR2.shape_rev3.r[1](quantity = \"Length\", unit = \"m\") = jointRRR2.frame_b.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR2.shape_rev3.r[2](quantity = \"Length\", unit = \"m\") = jointRRR2.frame_b.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR2.shape_rev3.r[3](quantity = \"Length\", unit = \"m\") = jointRRR2.frame_b.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR2.shape_rev3.r_shape[1](quantity = \"Length\", unit = \"m\") = (-jointRRR2.cylinderLength) * jointRRR2.e_b[1] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR2.shape_rev3.r_shape[2](quantity = \"Length\", unit = \"m\") = (-jointRRR2.cylinderLength) * jointRRR2.e_b[2] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR2.shape_rev3.r_shape[3](quantity = \"Length\", unit = \"m\") = (-jointRRR2.cylinderLength) * jointRRR2.e_b[3] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR2.shape_rev3.lengthDirection[1](unit = \"1\") = jointRRR2.e_b[1] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR2.shape_rev3.lengthDirection[2](unit = \"1\") = jointRRR2.e_b[2] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR2.shape_rev3.lengthDirection[3](unit = \"1\") = jointRRR2.e_b[3] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR2.shape_rev3.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR2.shape_rev3.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR2.shape_rev3.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR2.shape_rev3.length(quantity = \"Length\", unit = \"m\") = jointRRR2.cylinderLength \"Length of visual object\";
//   input Real jointRRR2.shape_rev3.width(quantity = \"Length\", unit = \"m\") = jointRRR2.cylinderDiameter \"Width of visual object\";
//   input Real jointRRR2.shape_rev3.height(quantity = \"Length\", unit = \"m\") = jointRRR2.cylinderDiameter \"Height of visual object\";
//   input Real jointRRR2.shape_rev3.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real jointRRR2.shape_rev3.color[1] = Real(jointRRR2.cylinderColor[1]) \"Color of shape\";
//   input Real jointRRR2.shape_rev3.color[2] = Real(jointRRR2.cylinderColor[2]) \"Color of shape\";
//   input Real jointRRR2.shape_rev3.color[3] = Real(jointRRR2.cylinderColor[3]) \"Color of shape\";
//   input Real jointRRR2.shape_rev3.specularCoefficient = jointRRR2.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real jointRRR2.shape_rev3.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({jointRRR2.shape_rev3.lengthDirection[1],jointRRR2.shape_rev3.lengthDirection[2],jointRRR2.shape_rev3.lengthDirection[3]});
//   protected Real jointRRR2.shape_rev3.e_x[1](unit = \"1\") = if noEvent(jointRRR2.shape_rev3.abs_n_x < 1e-10) then 1.0 else jointRRR2.shape_rev3.lengthDirection[1] / jointRRR2.shape_rev3.abs_n_x;
//   protected Real jointRRR2.shape_rev3.e_x[2](unit = \"1\") = if noEvent(jointRRR2.shape_rev3.abs_n_x < 1e-10) then 0.0 else jointRRR2.shape_rev3.lengthDirection[2] / jointRRR2.shape_rev3.abs_n_x;
//   protected Real jointRRR2.shape_rev3.e_x[3](unit = \"1\") = if noEvent(jointRRR2.shape_rev3.abs_n_x < 1e-10) then 0.0 else jointRRR2.shape_rev3.lengthDirection[3] / jointRRR2.shape_rev3.abs_n_x;
//   protected Real jointRRR2.shape_rev3.n_z_aux[1](unit = \"1\") = jointRRR2.shape_rev3.e_x[2] * jointRRR2.shape_rev3.widthDirection[3] - jointRRR2.shape_rev3.e_x[3] * jointRRR2.shape_rev3.widthDirection[2];
//   protected Real jointRRR2.shape_rev3.n_z_aux[2](unit = \"1\") = jointRRR2.shape_rev3.e_x[3] * jointRRR2.shape_rev3.widthDirection[1] - jointRRR2.shape_rev3.e_x[1] * jointRRR2.shape_rev3.widthDirection[3];
//   protected Real jointRRR2.shape_rev3.n_z_aux[3](unit = \"1\") = jointRRR2.shape_rev3.e_x[1] * jointRRR2.shape_rev3.widthDirection[2] - jointRRR2.shape_rev3.e_x[2] * jointRRR2.shape_rev3.widthDirection[1];
//   protected Real jointRRR2.shape_rev3.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR2.shape_rev3.e_x[1],jointRRR2.shape_rev3.e_x[2],jointRRR2.shape_rev3.e_x[3]},if noEvent(jointRRR2.shape_rev3.n_z_aux[1] ^ 2.0 + (jointRRR2.shape_rev3.n_z_aux[2] ^ 2.0 + jointRRR2.shape_rev3.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR2.shape_rev3.widthDirection[1],jointRRR2.shape_rev3.widthDirection[2],jointRRR2.shape_rev3.widthDirection[3]} else if noEvent(abs(jointRRR2.shape_rev3.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR2.shape_rev3.e_x[1],jointRRR2.shape_rev3.e_x[2],jointRRR2.shape_rev3.e_x[3]})[1];
//   protected Real jointRRR2.shape_rev3.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR2.shape_rev3.e_x[1],jointRRR2.shape_rev3.e_x[2],jointRRR2.shape_rev3.e_x[3]},if noEvent(jointRRR2.shape_rev3.n_z_aux[1] ^ 2.0 + (jointRRR2.shape_rev3.n_z_aux[2] ^ 2.0 + jointRRR2.shape_rev3.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR2.shape_rev3.widthDirection[1],jointRRR2.shape_rev3.widthDirection[2],jointRRR2.shape_rev3.widthDirection[3]} else if noEvent(abs(jointRRR2.shape_rev3.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR2.shape_rev3.e_x[1],jointRRR2.shape_rev3.e_x[2],jointRRR2.shape_rev3.e_x[3]})[2];
//   protected Real jointRRR2.shape_rev3.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR2.shape_rev3.e_x[1],jointRRR2.shape_rev3.e_x[2],jointRRR2.shape_rev3.e_x[3]},if noEvent(jointRRR2.shape_rev3.n_z_aux[1] ^ 2.0 + (jointRRR2.shape_rev3.n_z_aux[2] ^ 2.0 + jointRRR2.shape_rev3.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR2.shape_rev3.widthDirection[1],jointRRR2.shape_rev3.widthDirection[2],jointRRR2.shape_rev3.widthDirection[3]} else if noEvent(abs(jointRRR2.shape_rev3.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR2.shape_rev3.e_x[1],jointRRR2.shape_rev3.e_x[2],jointRRR2.shape_rev3.e_x[3]})[3];
//   protected output Real jointRRR2.shape_rev3.Form;
//   output Real jointRRR2.shape_rev3.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR2.shape_rev3.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR2.shape_rev3.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR2.shape_rev3.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR2.shape_rev3.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR2.shape_rev3.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR2.shape_rev3.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real jointRRR2.shape_rev3.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real jointRRR2.shape_rev3.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real jointRRR2.shape_rev3.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR2.shape_rev3.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR2.shape_rev3.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR2.shape_rev3.Material;
//   protected output Real jointRRR2.shape_rev3.Extra;
//   parameter String jointRRR2.shape_rod1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real jointRRR2.shape_rod1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rod1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rod1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rod1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rod1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rod1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rod1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rod1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rod1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rod1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR2.shape_rod1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR2.shape_rod1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR2.shape_rod1.r[1](quantity = \"Length\", unit = \"m\") = jointRRR2.frame_ia.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR2.shape_rod1.r[2](quantity = \"Length\", unit = \"m\") = jointRRR2.frame_ia.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR2.shape_rod1.r[3](quantity = \"Length\", unit = \"m\") = jointRRR2.frame_ia.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR2.shape_rod1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR2.shape_rod1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR2.shape_rod1.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR2.shape_rod1.lengthDirection[1](unit = \"1\") = jointRRR2.rRod1_ia[1] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR2.shape_rod1.lengthDirection[2](unit = \"1\") = jointRRR2.rRod1_ia[2] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR2.shape_rod1.lengthDirection[3](unit = \"1\") = jointRRR2.rRod1_ia[3] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR2.shape_rod1.widthDirection[1](unit = \"1\") = jointRRR2.e_ia[1] \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR2.shape_rod1.widthDirection[2](unit = \"1\") = jointRRR2.e_ia[2] \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR2.shape_rod1.widthDirection[3](unit = \"1\") = jointRRR2.e_ia[3] \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR2.shape_rod1.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({jointRRR2.rRod1_ia[1],jointRRR2.rRod1_ia[2],jointRRR2.rRod1_ia[3]}) \"Length of visual object\";
//   input Real jointRRR2.shape_rod1.width(quantity = \"Length\", unit = \"m\") = jointRRR2.rodDiameter \"Width of visual object\";
//   input Real jointRRR2.shape_rod1.height(quantity = \"Length\", unit = \"m\") = jointRRR2.rodDiameter \"Height of visual object\";
//   input Real jointRRR2.shape_rod1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real jointRRR2.shape_rod1.color[1] = Real(jointRRR2.rodColor[1]) \"Color of shape\";
//   input Real jointRRR2.shape_rod1.color[2] = Real(jointRRR2.rodColor[2]) \"Color of shape\";
//   input Real jointRRR2.shape_rod1.color[3] = Real(jointRRR2.rodColor[3]) \"Color of shape\";
//   input Real jointRRR2.shape_rod1.specularCoefficient = jointRRR2.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real jointRRR2.shape_rod1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({jointRRR2.shape_rod1.lengthDirection[1],jointRRR2.shape_rod1.lengthDirection[2],jointRRR2.shape_rod1.lengthDirection[3]});
//   protected Real jointRRR2.shape_rod1.e_x[1](unit = \"1\") = if noEvent(jointRRR2.shape_rod1.abs_n_x < 1e-10) then 1.0 else jointRRR2.shape_rod1.lengthDirection[1] / jointRRR2.shape_rod1.abs_n_x;
//   protected Real jointRRR2.shape_rod1.e_x[2](unit = \"1\") = if noEvent(jointRRR2.shape_rod1.abs_n_x < 1e-10) then 0.0 else jointRRR2.shape_rod1.lengthDirection[2] / jointRRR2.shape_rod1.abs_n_x;
//   protected Real jointRRR2.shape_rod1.e_x[3](unit = \"1\") = if noEvent(jointRRR2.shape_rod1.abs_n_x < 1e-10) then 0.0 else jointRRR2.shape_rod1.lengthDirection[3] / jointRRR2.shape_rod1.abs_n_x;
//   protected Real jointRRR2.shape_rod1.n_z_aux[1](unit = \"1\") = jointRRR2.shape_rod1.e_x[2] * jointRRR2.shape_rod1.widthDirection[3] - jointRRR2.shape_rod1.e_x[3] * jointRRR2.shape_rod1.widthDirection[2];
//   protected Real jointRRR2.shape_rod1.n_z_aux[2](unit = \"1\") = jointRRR2.shape_rod1.e_x[3] * jointRRR2.shape_rod1.widthDirection[1] - jointRRR2.shape_rod1.e_x[1] * jointRRR2.shape_rod1.widthDirection[3];
//   protected Real jointRRR2.shape_rod1.n_z_aux[3](unit = \"1\") = jointRRR2.shape_rod1.e_x[1] * jointRRR2.shape_rod1.widthDirection[2] - jointRRR2.shape_rod1.e_x[2] * jointRRR2.shape_rod1.widthDirection[1];
//   protected Real jointRRR2.shape_rod1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR2.shape_rod1.e_x[1],jointRRR2.shape_rod1.e_x[2],jointRRR2.shape_rod1.e_x[3]},if noEvent(jointRRR2.shape_rod1.n_z_aux[1] ^ 2.0 + (jointRRR2.shape_rod1.n_z_aux[2] ^ 2.0 + jointRRR2.shape_rod1.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR2.shape_rod1.widthDirection[1],jointRRR2.shape_rod1.widthDirection[2],jointRRR2.shape_rod1.widthDirection[3]} else if noEvent(abs(jointRRR2.shape_rod1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR2.shape_rod1.e_x[1],jointRRR2.shape_rod1.e_x[2],jointRRR2.shape_rod1.e_x[3]})[1];
//   protected Real jointRRR2.shape_rod1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR2.shape_rod1.e_x[1],jointRRR2.shape_rod1.e_x[2],jointRRR2.shape_rod1.e_x[3]},if noEvent(jointRRR2.shape_rod1.n_z_aux[1] ^ 2.0 + (jointRRR2.shape_rod1.n_z_aux[2] ^ 2.0 + jointRRR2.shape_rod1.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR2.shape_rod1.widthDirection[1],jointRRR2.shape_rod1.widthDirection[2],jointRRR2.shape_rod1.widthDirection[3]} else if noEvent(abs(jointRRR2.shape_rod1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR2.shape_rod1.e_x[1],jointRRR2.shape_rod1.e_x[2],jointRRR2.shape_rod1.e_x[3]})[2];
//   protected Real jointRRR2.shape_rod1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR2.shape_rod1.e_x[1],jointRRR2.shape_rod1.e_x[2],jointRRR2.shape_rod1.e_x[3]},if noEvent(jointRRR2.shape_rod1.n_z_aux[1] ^ 2.0 + (jointRRR2.shape_rod1.n_z_aux[2] ^ 2.0 + jointRRR2.shape_rod1.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR2.shape_rod1.widthDirection[1],jointRRR2.shape_rod1.widthDirection[2],jointRRR2.shape_rod1.widthDirection[3]} else if noEvent(abs(jointRRR2.shape_rod1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR2.shape_rod1.e_x[1],jointRRR2.shape_rod1.e_x[2],jointRRR2.shape_rod1.e_x[3]})[3];
//   protected output Real jointRRR2.shape_rod1.Form;
//   output Real jointRRR2.shape_rod1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR2.shape_rod1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR2.shape_rod1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR2.shape_rod1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR2.shape_rod1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR2.shape_rod1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR2.shape_rod1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real jointRRR2.shape_rod1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real jointRRR2.shape_rod1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real jointRRR2.shape_rod1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR2.shape_rod1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR2.shape_rod1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR2.shape_rod1.Material;
//   protected output Real jointRRR2.shape_rod1.Extra;
//   parameter String jointRRR2.shape_rod2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real jointRRR2.shape_rod2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rod2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rod2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rod2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rod2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rod2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rod2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rod2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rod2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR2.shape_rod2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR2.shape_rod2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR2.shape_rod2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR2.shape_rod2.r[1](quantity = \"Length\", unit = \"m\") = jointRRR2.frame_ib.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR2.shape_rod2.r[2](quantity = \"Length\", unit = \"m\") = jointRRR2.frame_ib.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR2.shape_rod2.r[3](quantity = \"Length\", unit = \"m\") = jointRRR2.frame_ib.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR2.shape_rod2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR2.shape_rod2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR2.shape_rod2.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR2.shape_rod2.lengthDirection[1](unit = \"1\") = jointRRR2.rRod2_ib[1] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR2.shape_rod2.lengthDirection[2](unit = \"1\") = jointRRR2.rRod2_ib[2] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR2.shape_rod2.lengthDirection[3](unit = \"1\") = jointRRR2.rRod2_ib[3] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR2.shape_rod2.widthDirection[1](unit = \"1\") = jointRRR2.e_b[1] \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR2.shape_rod2.widthDirection[2](unit = \"1\") = jointRRR2.e_b[2] \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR2.shape_rod2.widthDirection[3](unit = \"1\") = jointRRR2.e_b[3] \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR2.shape_rod2.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({jointRRR2.rRod2_ib[1],jointRRR2.rRod2_ib[2],jointRRR2.rRod2_ib[3]}) \"Length of visual object\";
//   input Real jointRRR2.shape_rod2.width(quantity = \"Length\", unit = \"m\") = jointRRR2.rodDiameter \"Width of visual object\";
//   input Real jointRRR2.shape_rod2.height(quantity = \"Length\", unit = \"m\") = jointRRR2.rodDiameter \"Height of visual object\";
//   input Real jointRRR2.shape_rod2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real jointRRR2.shape_rod2.color[1] = Real(jointRRR2.rodColor[1]) \"Color of shape\";
//   input Real jointRRR2.shape_rod2.color[2] = Real(jointRRR2.rodColor[2]) \"Color of shape\";
//   input Real jointRRR2.shape_rod2.color[3] = Real(jointRRR2.rodColor[3]) \"Color of shape\";
//   input Real jointRRR2.shape_rod2.specularCoefficient = jointRRR2.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real jointRRR2.shape_rod2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({jointRRR2.shape_rod2.lengthDirection[1],jointRRR2.shape_rod2.lengthDirection[2],jointRRR2.shape_rod2.lengthDirection[3]});
//   protected Real jointRRR2.shape_rod2.e_x[1](unit = \"1\") = if noEvent(jointRRR2.shape_rod2.abs_n_x < 1e-10) then 1.0 else jointRRR2.shape_rod2.lengthDirection[1] / jointRRR2.shape_rod2.abs_n_x;
//   protected Real jointRRR2.shape_rod2.e_x[2](unit = \"1\") = if noEvent(jointRRR2.shape_rod2.abs_n_x < 1e-10) then 0.0 else jointRRR2.shape_rod2.lengthDirection[2] / jointRRR2.shape_rod2.abs_n_x;
//   protected Real jointRRR2.shape_rod2.e_x[3](unit = \"1\") = if noEvent(jointRRR2.shape_rod2.abs_n_x < 1e-10) then 0.0 else jointRRR2.shape_rod2.lengthDirection[3] / jointRRR2.shape_rod2.abs_n_x;
//   protected Real jointRRR2.shape_rod2.n_z_aux[1](unit = \"1\") = jointRRR2.shape_rod2.e_x[2] * jointRRR2.shape_rod2.widthDirection[3] - jointRRR2.shape_rod2.e_x[3] * jointRRR2.shape_rod2.widthDirection[2];
//   protected Real jointRRR2.shape_rod2.n_z_aux[2](unit = \"1\") = jointRRR2.shape_rod2.e_x[3] * jointRRR2.shape_rod2.widthDirection[1] - jointRRR2.shape_rod2.e_x[1] * jointRRR2.shape_rod2.widthDirection[3];
//   protected Real jointRRR2.shape_rod2.n_z_aux[3](unit = \"1\") = jointRRR2.shape_rod2.e_x[1] * jointRRR2.shape_rod2.widthDirection[2] - jointRRR2.shape_rod2.e_x[2] * jointRRR2.shape_rod2.widthDirection[1];
//   protected Real jointRRR2.shape_rod2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR2.shape_rod2.e_x[1],jointRRR2.shape_rod2.e_x[2],jointRRR2.shape_rod2.e_x[3]},if noEvent(jointRRR2.shape_rod2.n_z_aux[1] ^ 2.0 + (jointRRR2.shape_rod2.n_z_aux[2] ^ 2.0 + jointRRR2.shape_rod2.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR2.shape_rod2.widthDirection[1],jointRRR2.shape_rod2.widthDirection[2],jointRRR2.shape_rod2.widthDirection[3]} else if noEvent(abs(jointRRR2.shape_rod2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR2.shape_rod2.e_x[1],jointRRR2.shape_rod2.e_x[2],jointRRR2.shape_rod2.e_x[3]})[1];
//   protected Real jointRRR2.shape_rod2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR2.shape_rod2.e_x[1],jointRRR2.shape_rod2.e_x[2],jointRRR2.shape_rod2.e_x[3]},if noEvent(jointRRR2.shape_rod2.n_z_aux[1] ^ 2.0 + (jointRRR2.shape_rod2.n_z_aux[2] ^ 2.0 + jointRRR2.shape_rod2.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR2.shape_rod2.widthDirection[1],jointRRR2.shape_rod2.widthDirection[2],jointRRR2.shape_rod2.widthDirection[3]} else if noEvent(abs(jointRRR2.shape_rod2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR2.shape_rod2.e_x[1],jointRRR2.shape_rod2.e_x[2],jointRRR2.shape_rod2.e_x[3]})[2];
//   protected Real jointRRR2.shape_rod2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR2.shape_rod2.e_x[1],jointRRR2.shape_rod2.e_x[2],jointRRR2.shape_rod2.e_x[3]},if noEvent(jointRRR2.shape_rod2.n_z_aux[1] ^ 2.0 + (jointRRR2.shape_rod2.n_z_aux[2] ^ 2.0 + jointRRR2.shape_rod2.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR2.shape_rod2.widthDirection[1],jointRRR2.shape_rod2.widthDirection[2],jointRRR2.shape_rod2.widthDirection[3]} else if noEvent(abs(jointRRR2.shape_rod2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR2.shape_rod2.e_x[1],jointRRR2.shape_rod2.e_x[2],jointRRR2.shape_rod2.e_x[3]})[3];
//   protected output Real jointRRR2.shape_rod2.Form;
//   output Real jointRRR2.shape_rod2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR2.shape_rod2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR2.shape_rod2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR2.shape_rod2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR2.shape_rod2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR2.shape_rod2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR2.shape_rod2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real jointRRR2.shape_rod2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real jointRRR2.shape_rod2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real jointRRR2.shape_rod2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR2.shape_rod2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR2.shape_rod2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR2.shape_rod2.Material;
//   protected output Real jointRRR2.shape_rod2.Extra;
//   parameter Real jointRRR2.e_a[1](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR2.n_a[1],jointRRR2.n_a[2],jointRRR2.n_a[3]},1e-13)[1] \"Unit vector along axes of rotations, resolved in frame_a\";
//   parameter Real jointRRR2.e_a[2](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR2.n_a[1],jointRRR2.n_a[2],jointRRR2.n_a[3]},1e-13)[2] \"Unit vector along axes of rotations, resolved in frame_a\";
//   parameter Real jointRRR2.e_a[3](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR2.n_a[1],jointRRR2.n_a[2],jointRRR2.n_a[3]},1e-13)[3] \"Unit vector along axes of rotations, resolved in frame_a\";
//   parameter Real jointRRR2.rodDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 1.1 * jointRRR2.cylinderDiameter \"Diameter of the two rods connecting the revolute joints\";
//   Real rod3.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real rod3.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real rod3.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real rod3.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real rod3.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real rod3.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real rod3.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real rod3.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real rod3.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real rod3.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real rod3.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real rod3.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real rod3.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real rod3.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real rod3.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real rod3.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real rod3.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real rod3.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real rod3.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real rod3.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real rod3.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real rod3.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real rod3.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real rod3.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real rod3.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real rod3.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real rod3.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real rod3.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real rod3.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real rod3.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real rod3.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real rod3.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real rod3.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real rod3.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real rod3.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real rod3.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real rod3.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real rod3.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real rod3.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real rod3.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real rod3.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real rod3.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean rod3.animation = true \"= true, if animation shall be enabled\";
//   parameter Real rod3.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = rh[1] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real rod3.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = rh[2] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real rod3.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = rh[3] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter String rod3.shapeType = \"cylinder\" \" Type of shape\";
//   parameter Real rod3.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real rod3.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real rod3.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real rod3.widthDirection[1](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real rod3.widthDirection[2](unit = \"1\") = 1.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real rod3.widthDirection[3](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real rod3.extra = 0.0 \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer rod3.color[1](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer rod3.color[2](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer rod3.color[3](min = 0, max = 255) = 155 \" Color of shape\";
//   input Real rod3.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter String rod3.shape.shapeType = rod3.shapeType \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real rod3.shape.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real rod3.shape.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real rod3.shape.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real rod3.shape.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real rod3.shape.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real rod3.shape.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real rod3.shape.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real rod3.shape.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real rod3.shape.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real rod3.shape.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rod3.shape.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rod3.shape.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rod3.shape.r[1](quantity = \"Length\", unit = \"m\") = rod3.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rod3.shape.r[2](quantity = \"Length\", unit = \"m\") = rod3.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rod3.shape.r[3](quantity = \"Length\", unit = \"m\") = rod3.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rod3.shape.r_shape[1](quantity = \"Length\", unit = \"m\") = rod3.r_shape[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rod3.shape.r_shape[2](quantity = \"Length\", unit = \"m\") = rod3.r_shape[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rod3.shape.r_shape[3](quantity = \"Length\", unit = \"m\") = rod3.r_shape[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rod3.shape.lengthDirection[1](unit = \"1\") = rod3.lengthDirection[1] \"Vector in length direction, resolved in object frame\";
//   input Real rod3.shape.lengthDirection[2](unit = \"1\") = rod3.lengthDirection[2] \"Vector in length direction, resolved in object frame\";
//   input Real rod3.shape.lengthDirection[3](unit = \"1\") = rod3.lengthDirection[3] \"Vector in length direction, resolved in object frame\";
//   input Real rod3.shape.widthDirection[1](unit = \"1\") = rod3.widthDirection[1] \"Vector in width direction, resolved in object frame\";
//   input Real rod3.shape.widthDirection[2](unit = \"1\") = rod3.widthDirection[2] \"Vector in width direction, resolved in object frame\";
//   input Real rod3.shape.widthDirection[3](unit = \"1\") = rod3.widthDirection[3] \"Vector in width direction, resolved in object frame\";
//   input Real rod3.shape.length(quantity = \"Length\", unit = \"m\") = rod3.length \"Length of visual object\";
//   input Real rod3.shape.width(quantity = \"Length\", unit = \"m\") = rod3.width \"Width of visual object\";
//   input Real rod3.shape.height(quantity = \"Length\", unit = \"m\") = rod3.height \"Height of visual object\";
//   input Real rod3.shape.extra = rod3.extra \"Additional size data for some of the shape types\";
//   input Real rod3.shape.color[1] = Real(rod3.color[1]) \"Color of shape\";
//   input Real rod3.shape.color[2] = Real(rod3.color[2]) \"Color of shape\";
//   input Real rod3.shape.color[3] = Real(rod3.color[3]) \"Color of shape\";
//   input Real rod3.shape.specularCoefficient = rod3.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real rod3.shape.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({rod3.shape.lengthDirection[1],rod3.shape.lengthDirection[2],rod3.shape.lengthDirection[3]});
//   protected Real rod3.shape.e_x[1](unit = \"1\") = if noEvent(rod3.shape.abs_n_x < 1e-10) then 1.0 else rod3.shape.lengthDirection[1] / rod3.shape.abs_n_x;
//   protected Real rod3.shape.e_x[2](unit = \"1\") = if noEvent(rod3.shape.abs_n_x < 1e-10) then 0.0 else rod3.shape.lengthDirection[2] / rod3.shape.abs_n_x;
//   protected Real rod3.shape.e_x[3](unit = \"1\") = if noEvent(rod3.shape.abs_n_x < 1e-10) then 0.0 else rod3.shape.lengthDirection[3] / rod3.shape.abs_n_x;
//   protected Real rod3.shape.n_z_aux[1](unit = \"1\") = rod3.shape.e_x[2] * rod3.shape.widthDirection[3] - rod3.shape.e_x[3] * rod3.shape.widthDirection[2];
//   protected Real rod3.shape.n_z_aux[2](unit = \"1\") = rod3.shape.e_x[3] * rod3.shape.widthDirection[1] - rod3.shape.e_x[1] * rod3.shape.widthDirection[3];
//   protected Real rod3.shape.n_z_aux[3](unit = \"1\") = rod3.shape.e_x[1] * rod3.shape.widthDirection[2] - rod3.shape.e_x[2] * rod3.shape.widthDirection[1];
//   protected Real rod3.shape.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rod3.shape.e_x[1],rod3.shape.e_x[2],rod3.shape.e_x[3]},if noEvent(rod3.shape.n_z_aux[1] ^ 2.0 + (rod3.shape.n_z_aux[2] ^ 2.0 + rod3.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {rod3.shape.widthDirection[1],rod3.shape.widthDirection[2],rod3.shape.widthDirection[3]} else if noEvent(abs(rod3.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rod3.shape.e_x[1],rod3.shape.e_x[2],rod3.shape.e_x[3]})[1];
//   protected Real rod3.shape.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rod3.shape.e_x[1],rod3.shape.e_x[2],rod3.shape.e_x[3]},if noEvent(rod3.shape.n_z_aux[1] ^ 2.0 + (rod3.shape.n_z_aux[2] ^ 2.0 + rod3.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {rod3.shape.widthDirection[1],rod3.shape.widthDirection[2],rod3.shape.widthDirection[3]} else if noEvent(abs(rod3.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rod3.shape.e_x[1],rod3.shape.e_x[2],rod3.shape.e_x[3]})[2];
//   protected Real rod3.shape.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rod3.shape.e_x[1],rod3.shape.e_x[2],rod3.shape.e_x[3]},if noEvent(rod3.shape.n_z_aux[1] ^ 2.0 + (rod3.shape.n_z_aux[2] ^ 2.0 + rod3.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {rod3.shape.widthDirection[1],rod3.shape.widthDirection[2],rod3.shape.widthDirection[3]} else if noEvent(abs(rod3.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rod3.shape.e_x[1],rod3.shape.e_x[2],rod3.shape.e_x[3]})[3];
//   protected output Real rod3.shape.Form;
//   output Real rod3.shape.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rod3.shape.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rod3.shape.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rod3.shape.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rod3.shape.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rod3.shape.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rod3.shape.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rod3.shape.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rod3.shape.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real rod3.shape.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rod3.shape.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rod3.shape.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rod3.shape.Material;
//   protected output Real rod3.shape.Extra;
//   parameter Real rod3.lengthDirection[1](unit = \"1\") = rod3.r[1] - rod3.r_shape[1] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real rod3.lengthDirection[2](unit = \"1\") = rod3.r[2] - rod3.r_shape[2] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real rod3.lengthDirection[3](unit = \"1\") = rod3.r[3] - rod3.r_shape[3] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real rod3.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({rod3.r[1] - rod3.r_shape[1],rod3.r[2] - rod3.r_shape[2],rod3.r[3] - rod3.r_shape[3]}) \" Length of shape\";
//   parameter Real rod3.width(quantity = \"Length\", unit = \"m\", min = 0.0) = rod3.length / world.defaultWidthFraction \" Width of shape\";
//   parameter Real rod3.height(quantity = \"Length\", unit = \"m\", min = 0.0) = rod3.width \" Height of shape.\";
//   Real body2.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real body2.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real body2.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real body2.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real body2.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real body2.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real body2.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real body2.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real body2.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real body2.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real body2.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real body2.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real body2.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real body2.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real body2.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real body2.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real body2.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real body2.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real body2.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real body2.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real body2.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean body2.animation = true \"= true, if animation shall be enabled (show cylinder and sphere)\";
//   parameter Real body2.r_CM[1](quantity = \"Length\", unit = \"m\", start = 0.0) = jointRRR2.rRod1_ia[1] / 2.0 \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real body2.r_CM[2](quantity = \"Length\", unit = \"m\", start = 0.0) = jointRRR2.rRod1_ia[2] / 2.0 \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real body2.r_CM[3](quantity = \"Length\", unit = \"m\", start = 0.0) = jointRRR2.rRod1_ia[3] / 2.0 \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real body2.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 1.0) = 1.0 \"Mass of rigid body\";
//   parameter Real body2.I_11(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.001 \" (1,1) element of inertia tensor\";
//   parameter Real body2.I_22(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.001 \" (2,2) element of inertia tensor\";
//   parameter Real body2.I_33(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.001 \" (3,3) element of inertia tensor\";
//   parameter Real body2.I_21(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (2,1) element of inertia tensor\";
//   parameter Real body2.I_31(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (3,1) element of inertia tensor\";
//   parameter Real body2.I_32(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (3,2) element of inertia tensor\";
//   Real body2.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real body2.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real body2.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real body2.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real body2.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real body2.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real body2.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real body2.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real body2.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean body2.angles_fixed = false \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real body2.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real body2.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real body2.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer body2.sequence_start[1](min = 1, max = 3) = 1 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer body2.sequence_start[2](min = 1, max = 3) = 2 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer body2.sequence_start[3](min = 1, max = 3) = 3 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean body2.w_0_fixed = false \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real body2.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real body2.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real body2.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean body2.z_0_fixed = false \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real body2.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real body2.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real body2.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real body2.sphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultBodyDiameter \"Diameter of sphere\";
//   input Integer body2.sphereColor[1](min = 0, max = 255) = 0 \"Color of sphere\";
//   input Integer body2.sphereColor[2](min = 0, max = 255) = 128 \"Color of sphere\";
//   input Integer body2.sphereColor[3](min = 0, max = 255) = 255 \"Color of sphere\";
//   input Integer body2.cylinderColor[1](min = 0, max = 255) = 155 \"Color of cylinder\";
//   input Integer body2.cylinderColor[2](min = 0, max = 255) = 155 \"Color of cylinder\";
//   input Integer body2.cylinderColor[3](min = 0, max = 255) = 155 \"Color of cylinder\";
//   input Real body2.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean body2.enforceStates = false \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean body2.useQuaternions = true \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer body2.sequence_angleStates[1](min = 1, max = 3) = 1 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer body2.sequence_angleStates[2](min = 1, max = 3) = 2 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer body2.sequence_angleStates[3](min = 1, max = 3) = 3 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   Real body2.w_a[1](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body2.R_start,{body2.w_0_start[1],body2.w_0_start[2],body2.w_0_start[3]})[1], fixed = body2.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real body2.w_a[2](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body2.R_start,{body2.w_0_start[1],body2.w_0_start[2],body2.w_0_start[3]})[2], fixed = body2.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real body2.w_a[3](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body2.R_start,{body2.w_0_start[1],body2.w_0_start[2],body2.w_0_start[3]})[3], fixed = body2.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real body2.z_a[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body2.R_start,{body2.z_0_start[1],body2.z_0_start[2],body2.z_0_start[3]})[1], fixed = body2.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real body2.z_a[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body2.R_start,{body2.z_0_start[1],body2.z_0_start[2],body2.z_0_start[3]})[2], fixed = body2.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real body2.z_a[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body2.R_start,{body2.z_0_start[1],body2.z_0_start[2],body2.z_0_start[3]})[3], fixed = body2.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real body2.g_0[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real body2.g_0[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real body2.g_0[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   protected Real body2.Q[1](start = body2.Q_start[1], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real body2.Q[2](start = body2.Q_start[2], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real body2.Q[3](start = body2.Q_start[3], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real body2.Q[4](start = body2.Q_start[4], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real body2.phi[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = body2.phi_start[1], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real body2.phi[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = body2.phi_start[2], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real body2.phi[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = body2.phi_start[3], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real body2.phi_d[1](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real body2.phi_d[2](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real body2.phi_d[3](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real body2.phi_dd[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real body2.phi_dd[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real body2.phi_dd[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   parameter String body2.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body2.cylinder.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real body2.cylinder.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real body2.cylinder.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real body2.cylinder.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real body2.cylinder.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real body2.cylinder.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real body2.cylinder.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real body2.cylinder.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real body2.cylinder.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real body2.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body2.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body2.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body2.cylinder.r[1](quantity = \"Length\", unit = \"m\") = body2.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body2.cylinder.r[2](quantity = \"Length\", unit = \"m\") = body2.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body2.cylinder.r[3](quantity = \"Length\", unit = \"m\") = body2.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body2.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body2.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body2.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body2.cylinder.lengthDirection[1](unit = \"1\") = body2.r_CM[1] \"Vector in length direction, resolved in object frame\";
//   input Real body2.cylinder.lengthDirection[2](unit = \"1\") = body2.r_CM[2] \"Vector in length direction, resolved in object frame\";
//   input Real body2.cylinder.lengthDirection[3](unit = \"1\") = body2.r_CM[3] \"Vector in length direction, resolved in object frame\";
//   input Real body2.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body2.cylinder.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body2.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body2.cylinder.length(quantity = \"Length\", unit = \"m\") = if Modelica.Math.Vectors.length({body2.r_CM[1],body2.r_CM[2],body2.r_CM[3]}) > body2.sphereDiameter / 2.0 then Modelica.Math.Vectors.length({body2.r_CM[1],body2.r_CM[2],body2.r_CM[3]}) - (if body2.cylinderDiameter > 1.1 * body2.sphereDiameter then body2.sphereDiameter / 2.0 else 0.0) else 0.0 \"Length of visual object\";
//   input Real body2.cylinder.width(quantity = \"Length\", unit = \"m\") = body2.cylinderDiameter \"Width of visual object\";
//   input Real body2.cylinder.height(quantity = \"Length\", unit = \"m\") = body2.cylinderDiameter \"Height of visual object\";
//   input Real body2.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body2.cylinder.color[1] = Real(body2.cylinderColor[1]) \"Color of shape\";
//   input Real body2.cylinder.color[2] = Real(body2.cylinderColor[2]) \"Color of shape\";
//   input Real body2.cylinder.color[3] = Real(body2.cylinderColor[3]) \"Color of shape\";
//   input Real body2.cylinder.specularCoefficient = body2.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body2.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body2.cylinder.lengthDirection[1],body2.cylinder.lengthDirection[2],body2.cylinder.lengthDirection[3]});
//   protected Real body2.cylinder.e_x[1](unit = \"1\") = if noEvent(body2.cylinder.abs_n_x < 1e-10) then 1.0 else body2.cylinder.lengthDirection[1] / body2.cylinder.abs_n_x;
//   protected Real body2.cylinder.e_x[2](unit = \"1\") = if noEvent(body2.cylinder.abs_n_x < 1e-10) then 0.0 else body2.cylinder.lengthDirection[2] / body2.cylinder.abs_n_x;
//   protected Real body2.cylinder.e_x[3](unit = \"1\") = if noEvent(body2.cylinder.abs_n_x < 1e-10) then 0.0 else body2.cylinder.lengthDirection[3] / body2.cylinder.abs_n_x;
//   protected Real body2.cylinder.n_z_aux[1](unit = \"1\") = body2.cylinder.e_x[2] * body2.cylinder.widthDirection[3] - body2.cylinder.e_x[3] * body2.cylinder.widthDirection[2];
//   protected Real body2.cylinder.n_z_aux[2](unit = \"1\") = body2.cylinder.e_x[3] * body2.cylinder.widthDirection[1] - body2.cylinder.e_x[1] * body2.cylinder.widthDirection[3];
//   protected Real body2.cylinder.n_z_aux[3](unit = \"1\") = body2.cylinder.e_x[1] * body2.cylinder.widthDirection[2] - body2.cylinder.e_x[2] * body2.cylinder.widthDirection[1];
//   protected Real body2.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body2.cylinder.e_x[1],body2.cylinder.e_x[2],body2.cylinder.e_x[3]},if noEvent(body2.cylinder.n_z_aux[1] ^ 2.0 + (body2.cylinder.n_z_aux[2] ^ 2.0 + body2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {body2.cylinder.widthDirection[1],body2.cylinder.widthDirection[2],body2.cylinder.widthDirection[3]} else if noEvent(abs(body2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body2.cylinder.e_x[1],body2.cylinder.e_x[2],body2.cylinder.e_x[3]})[1];
//   protected Real body2.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body2.cylinder.e_x[1],body2.cylinder.e_x[2],body2.cylinder.e_x[3]},if noEvent(body2.cylinder.n_z_aux[1] ^ 2.0 + (body2.cylinder.n_z_aux[2] ^ 2.0 + body2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {body2.cylinder.widthDirection[1],body2.cylinder.widthDirection[2],body2.cylinder.widthDirection[3]} else if noEvent(abs(body2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body2.cylinder.e_x[1],body2.cylinder.e_x[2],body2.cylinder.e_x[3]})[2];
//   protected Real body2.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body2.cylinder.e_x[1],body2.cylinder.e_x[2],body2.cylinder.e_x[3]},if noEvent(body2.cylinder.n_z_aux[1] ^ 2.0 + (body2.cylinder.n_z_aux[2] ^ 2.0 + body2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {body2.cylinder.widthDirection[1],body2.cylinder.widthDirection[2],body2.cylinder.widthDirection[3]} else if noEvent(abs(body2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body2.cylinder.e_x[1],body2.cylinder.e_x[2],body2.cylinder.e_x[3]})[3];
//   protected output Real body2.cylinder.Form;
//   output Real body2.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body2.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body2.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body2.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body2.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body2.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body2.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body2.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body2.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body2.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body2.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body2.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body2.cylinder.Material;
//   protected output Real body2.cylinder.Extra;
//   parameter Real body2.I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body2.I_11 \"inertia tensor\";
//   parameter Real body2.I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body2.I_21 \"inertia tensor\";
//   parameter Real body2.I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body2.I_31 \"inertia tensor\";
//   parameter Real body2.I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body2.I_21 \"inertia tensor\";
//   parameter Real body2.I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body2.I_22 \"inertia tensor\";
//   parameter Real body2.I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body2.I_32 \"inertia tensor\";
//   parameter Real body2.I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body2.I_31 \"inertia tensor\";
//   parameter Real body2.I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body2.I_32 \"inertia tensor\";
//   parameter Real body2.I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body2.I_33 \"inertia tensor\";
//   parameter Real body2.R_start.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real body2.R_start.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real body2.R_start.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real body2.R_start.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real body2.R_start.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real body2.R_start.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real body2.R_start.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real body2.R_start.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real body2.R_start.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real body2.R_start.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real body2.R_start.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real body2.R_start.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real body2.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = body2.sphereDiameter / 3.0 \"Diameter of cylinder\";
//   parameter String body2.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body2.sphere.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real body2.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body2.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body2.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body2.sphere.r[1](quantity = \"Length\", unit = \"m\") = body2.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body2.sphere.r[2](quantity = \"Length\", unit = \"m\") = body2.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body2.sphere.r[3](quantity = \"Length\", unit = \"m\") = body2.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body2.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = body2.r_CM[1] - body2.sphereDiameter / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body2.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = body2.r_CM[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body2.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = body2.r_CM[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body2.sphere.lengthDirection[1](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body2.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body2.sphere.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body2.sphere.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body2.sphere.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body2.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body2.sphere.length(quantity = \"Length\", unit = \"m\") = body2.sphereDiameter \"Length of visual object\";
//   input Real body2.sphere.width(quantity = \"Length\", unit = \"m\") = body2.sphereDiameter \"Width of visual object\";
//   input Real body2.sphere.height(quantity = \"Length\", unit = \"m\") = body2.sphereDiameter \"Height of visual object\";
//   input Real body2.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body2.sphere.color[1] = Real(body2.sphereColor[1]) \"Color of shape\";
//   input Real body2.sphere.color[2] = Real(body2.sphereColor[2]) \"Color of shape\";
//   input Real body2.sphere.color[3] = Real(body2.sphereColor[3]) \"Color of shape\";
//   input Real body2.sphere.specularCoefficient = body2.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body2.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body2.sphere.lengthDirection[1],body2.sphere.lengthDirection[2],body2.sphere.lengthDirection[3]});
//   protected Real body2.sphere.e_x[1](unit = \"1\") = if noEvent(body2.sphere.abs_n_x < 1e-10) then 1.0 else body2.sphere.lengthDirection[1] / body2.sphere.abs_n_x;
//   protected Real body2.sphere.e_x[2](unit = \"1\") = if noEvent(body2.sphere.abs_n_x < 1e-10) then 0.0 else body2.sphere.lengthDirection[2] / body2.sphere.abs_n_x;
//   protected Real body2.sphere.e_x[3](unit = \"1\") = if noEvent(body2.sphere.abs_n_x < 1e-10) then 0.0 else body2.sphere.lengthDirection[3] / body2.sphere.abs_n_x;
//   protected Real body2.sphere.n_z_aux[1](unit = \"1\") = body2.sphere.e_x[2] * body2.sphere.widthDirection[3] - body2.sphere.e_x[3] * body2.sphere.widthDirection[2];
//   protected Real body2.sphere.n_z_aux[2](unit = \"1\") = body2.sphere.e_x[3] * body2.sphere.widthDirection[1] - body2.sphere.e_x[1] * body2.sphere.widthDirection[3];
//   protected Real body2.sphere.n_z_aux[3](unit = \"1\") = body2.sphere.e_x[1] * body2.sphere.widthDirection[2] - body2.sphere.e_x[2] * body2.sphere.widthDirection[1];
//   protected Real body2.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body2.sphere.e_x[1],body2.sphere.e_x[2],body2.sphere.e_x[3]},if noEvent(body2.sphere.n_z_aux[1] ^ 2.0 + (body2.sphere.n_z_aux[2] ^ 2.0 + body2.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body2.sphere.widthDirection[1],body2.sphere.widthDirection[2],body2.sphere.widthDirection[3]} else if noEvent(abs(body2.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body2.sphere.e_x[1],body2.sphere.e_x[2],body2.sphere.e_x[3]})[1];
//   protected Real body2.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body2.sphere.e_x[1],body2.sphere.e_x[2],body2.sphere.e_x[3]},if noEvent(body2.sphere.n_z_aux[1] ^ 2.0 + (body2.sphere.n_z_aux[2] ^ 2.0 + body2.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body2.sphere.widthDirection[1],body2.sphere.widthDirection[2],body2.sphere.widthDirection[3]} else if noEvent(abs(body2.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body2.sphere.e_x[1],body2.sphere.e_x[2],body2.sphere.e_x[3]})[2];
//   protected Real body2.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body2.sphere.e_x[1],body2.sphere.e_x[2],body2.sphere.e_x[3]},if noEvent(body2.sphere.n_z_aux[1] ^ 2.0 + (body2.sphere.n_z_aux[2] ^ 2.0 + body2.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body2.sphere.widthDirection[1],body2.sphere.widthDirection[2],body2.sphere.widthDirection[3]} else if noEvent(abs(body2.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body2.sphere.e_x[1],body2.sphere.e_x[2],body2.sphere.e_x[3]})[3];
//   protected output Real body2.sphere.Form;
//   output Real body2.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body2.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body2.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body2.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body2.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body2.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body2.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body2.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body2.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body2.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body2.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body2.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body2.sphere.Material;
//   protected output Real body2.sphere.Extra;
//   parameter Real body2.z_a_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(body2.R_start,{body2.z_0_start[1],body2.z_0_start[2],body2.z_0_start[3]})[1] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   parameter Real body2.z_a_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(body2.R_start,{body2.z_0_start[1],body2.z_0_start[2],body2.z_0_start[3]})[2] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   parameter Real body2.z_a_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(body2.R_start,{body2.z_0_start[1],body2.z_0_start[2],body2.z_0_start[3]})[3] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   protected parameter Real body2.Q_start[1] = Modelica.Mechanics.MultiBody.Frames.to_Q(body2.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[1] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real body2.Q_start[2] = Modelica.Mechanics.MultiBody.Frames.to_Q(body2.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[2] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real body2.Q_start[3] = Modelica.Mechanics.MultiBody.Frames.to_Q(body2.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[3] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real body2.Q_start[4] = Modelica.Mechanics.MultiBody.Frames.to_Q(body2.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[4] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real body2.phi_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if body2.sequence_start[1] == body2.sequence_angleStates[1] AND body2.sequence_start[2] == body2.sequence_angleStates[2] AND body2.sequence_start[3] == body2.sequence_angleStates[3] then body2.angles_start[1] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(body2.R_start,{body2.sequence_angleStates[1],body2.sequence_angleStates[2],body2.sequence_angleStates[3]},0.0)[1] \"Potential angle states at initial time\";
//   protected parameter Real body2.phi_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if body2.sequence_start[1] == body2.sequence_angleStates[1] AND body2.sequence_start[2] == body2.sequence_angleStates[2] AND body2.sequence_start[3] == body2.sequence_angleStates[3] then body2.angles_start[2] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(body2.R_start,{body2.sequence_angleStates[1],body2.sequence_angleStates[2],body2.sequence_angleStates[3]},0.0)[2] \"Potential angle states at initial time\";
//   protected parameter Real body2.phi_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if body2.sequence_start[1] == body2.sequence_angleStates[1] AND body2.sequence_start[2] == body2.sequence_angleStates[2] AND body2.sequence_start[3] == body2.sequence_angleStates[3] then body2.angles_start[3] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(body2.R_start,{body2.sequence_angleStates[1],body2.sequence_angleStates[2],body2.sequence_angleStates[3]},0.0)[3] \"Potential angle states at initial time\";
//   Real jointRRR3.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.frame_ia.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.frame_ia.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.frame_ia.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.frame_ia.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_ia.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_ia.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_ia.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_ia.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_ia.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_ia.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_ia.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_ia.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_ia.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.frame_ia.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.frame_ia.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.frame_ia.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.frame_ia.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.frame_ia.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.frame_ia.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.frame_ia.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.frame_ia.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.frame_ib.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.frame_ib.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.frame_ib.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.frame_ib.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_ib.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_ib.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_ib.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_ib.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_ib.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_ib.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_ib.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_ib.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_ib.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.frame_ib.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.frame_ib.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.frame_ib.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.frame_ib.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.frame_ib.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.frame_ib.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.frame_ib.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.frame_ib.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.frame_im.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.frame_im.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.frame_im.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.frame_im.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_im.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_im.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_im.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_im.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_im.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_im.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_im.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_im.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.frame_im.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.frame_im.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.frame_im.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.frame_im.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.frame_im.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.frame_im.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.frame_im.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.frame_im.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.frame_im.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.axis.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real jointRRR3.axis.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real jointRRR3.bearing.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real jointRRR3.bearing.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Boolean jointRRR3.animation = true \"= true, if animation shall be enabled\";
//   parameter Real jointRRR3.n_a[1](unit = \"1\") = 0.0 \"Axes of revolute joints resolved in frame_a (all axes are parallel to each other)\";
//   parameter Real jointRRR3.n_a[2](unit = \"1\") = 0.0 \"Axes of revolute joints resolved in frame_a (all axes are parallel to each other)\";
//   parameter Real jointRRR3.n_a[3](unit = \"1\") = 1.0 \"Axes of revolute joints resolved in frame_a (all axes are parallel to each other)\";
//   parameter Real jointRRR3.n_b[1](unit = \"1\", fixed = false) = 0.0 \"Axis of revolute joint fixed and resolved in frame_b\";
//   parameter Real jointRRR3.n_b[2](unit = \"1\", fixed = false) = 0.0 \"Axis of revolute joint fixed and resolved in frame_b\";
//   parameter Real jointRRR3.n_b[3](unit = \"1\", fixed = false) = 1.0 \"Axis of revolute joint fixed and resolved in frame_b\";
//   parameter Real jointRRR3.rRod1_ia[1](quantity = \"Length\", unit = \"m\") = r3a[1] \"Vector from origin of frame_a to revolute joint in the middle, resolved in frame_ia\";
//   parameter Real jointRRR3.rRod1_ia[2](quantity = \"Length\", unit = \"m\") = r3a[2] \"Vector from origin of frame_a to revolute joint in the middle, resolved in frame_ia\";
//   parameter Real jointRRR3.rRod1_ia[3](quantity = \"Length\", unit = \"m\") = r3a[3] \"Vector from origin of frame_a to revolute joint in the middle, resolved in frame_ia\";
//   parameter Real jointRRR3.rRod2_ib[1](quantity = \"Length\", unit = \"m\") = r3b[1] \"Vector from origin of frame_ib to revolute joint in the middle, resolved in frame_ib\";
//   parameter Real jointRRR3.rRod2_ib[2](quantity = \"Length\", unit = \"m\") = r3b[2] \"Vector from origin of frame_ib to revolute joint in the middle, resolved in frame_ib\";
//   parameter Real jointRRR3.rRod2_ib[3](quantity = \"Length\", unit = \"m\") = r3b[3] \"Vector from origin of frame_ib to revolute joint in the middle, resolved in frame_ib\";
//   parameter Real jointRRR3.phi_offset(quantity = \"Angle\", unit = \"deg\") = 0.0 \"Relative angle offset of revolute joint at frame_b (angle = phi(t) + from_deg(phi_offset))\";
//   parameter Real jointRRR3.phi_guess(quantity = \"Angle\", unit = \"deg\") = 0.0 \"Select the configuration such that at initial time |phi(t0) - from_deg(phi_guess)|is minimal\";
//   parameter Real jointRRR3.cylinderLength(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultJointLength \"Length of cylinders representing the revolute joints\";
//   parameter Real jointRRR3.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultJointWidth \"Diameter of cylinders representing the revolute joints\";
//   input Integer jointRRR3.cylinderColor[1](min = 0, max = 255) = 255 \"Color of cylinders representing the revolute joints\";
//   input Integer jointRRR3.cylinderColor[2](min = 0, max = 255) = 0 \"Color of cylinders representing the revolute joints\";
//   input Integer jointRRR3.cylinderColor[3](min = 0, max = 255) = 0 \"Color of cylinders representing the revolute joints\";
//   input Integer jointRRR3.rodColor[1](min = 0, max = 255) = 155 \"Color of the two rods connecting the revolute joint\";
//   input Integer jointRRR3.rodColor[2](min = 0, max = 255) = 155 \"Color of the two rods connecting the revolute joint\";
//   input Integer jointRRR3.rodColor[3](min = 0, max = 255) = 155 \"Color of the two rods connecting the revolute joint\";
//   input Real jointRRR3.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean jointRRR3.checkTotalPower = true \"= true, if total power flowing into this component shall be determined (must be zero)\";
//   parameter Real jointRRR3.e_ia[1](unit = \"1\") = jointRRR3.jointUSR.e2_ia[1] \"Unit vector along axes of rotations, resolved in frame_ia\";
//   parameter Real jointRRR3.e_ia[2](unit = \"1\") = jointRRR3.jointUSR.e2_ia[2] \"Unit vector along axes of rotations, resolved in frame_ia\";
//   parameter Real jointRRR3.e_ia[3](unit = \"1\") = jointRRR3.jointUSR.e2_ia[3] \"Unit vector along axes of rotations, resolved in frame_ia\";
//   parameter Real jointRRR3.e_b[1](unit = \"1\") = jointRRR3.jointUSR.revolute.e[1] \"Unit vector along axes of rotations, resolved in frame_b, frame_ib and frame_im\";
//   parameter Real jointRRR3.e_b[2](unit = \"1\") = jointRRR3.jointUSR.revolute.e[2] \"Unit vector along axes of rotations, resolved in frame_b, frame_ib and frame_im\";
//   parameter Real jointRRR3.e_b[3](unit = \"1\") = jointRRR3.jointUSR.revolute.e[3] \"Unit vector along axes of rotations, resolved in frame_b, frame_ib and frame_im\";
//   Real jointRRR3.totalPower(quantity = \"Power\", unit = \"W\") = jointRRR3.jointUSR.totalPower \"Total power flowing into this element, if checkTotalPower=true (otherwise dummy)\";
//   Real jointRRR3.jointUSR.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.frame_ia.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.frame_ia.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.frame_ia.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.frame_ia.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_ia.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_ia.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_ia.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_ia.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_ia.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_ia.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_ia.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_ia.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_ia.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.frame_ia.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.frame_ia.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.frame_ia.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.frame_ia.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.frame_ia.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.frame_ia.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.frame_ia.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.frame_ia.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.frame_ib.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.frame_ib.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.frame_ib.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.frame_ib.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_ib.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_ib.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_ib.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_ib.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_ib.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_ib.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_ib.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_ib.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_ib.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.frame_ib.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.frame_ib.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.frame_ib.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.frame_ib.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.frame_ib.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.frame_ib.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.frame_ib.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.frame_ib.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.frame_im.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.frame_im.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.frame_im.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.frame_im.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_im.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_im.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_im.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_im.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_im.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_im.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_im.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_im.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.frame_im.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.frame_im.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.frame_im.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.frame_im.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.frame_im.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.frame_im.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.frame_im.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.frame_im.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.frame_im.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.axis.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real jointRRR3.jointUSR.axis.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real jointRRR3.jointUSR.bearing.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real jointRRR3.jointUSR.bearing.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Boolean jointRRR3.jointUSR.animation = false \"= true, if animation shall be enabled\";
//   parameter Boolean jointRRR3.jointUSR.showUniversalAxes = false \" = true, if universal joint shall be visualized with two cylinders, otherwise with a sphere (provided animation=true)\";
//   parameter Real jointRRR3.jointUSR.n1_a[1](unit = \"1\") = jointRRR3.n_a[1] \"Axis 1 of universal joint fixed and resolved in frame_a (axis 2 is orthogonal to axis 1 and to rod 1)\";
//   parameter Real jointRRR3.jointUSR.n1_a[2](unit = \"1\") = jointRRR3.n_a[2] \"Axis 1 of universal joint fixed and resolved in frame_a (axis 2 is orthogonal to axis 1 and to rod 1)\";
//   parameter Real jointRRR3.jointUSR.n1_a[3](unit = \"1\") = jointRRR3.n_a[3] \"Axis 1 of universal joint fixed and resolved in frame_a (axis 2 is orthogonal to axis 1 and to rod 1)\";
//   parameter Real jointRRR3.jointUSR.n_b[1](unit = \"1\") = jointRRR3.n_b[1] \"Axis of revolute joint fixed and resolved in frame_b\";
//   parameter Real jointRRR3.jointUSR.n_b[2](unit = \"1\") = jointRRR3.n_b[2] \"Axis of revolute joint fixed and resolved in frame_b\";
//   parameter Real jointRRR3.jointUSR.n_b[3](unit = \"1\") = jointRRR3.n_b[3] \"Axis of revolute joint fixed and resolved in frame_b\";
//   parameter Real jointRRR3.jointUSR.rRod1_ia[1](quantity = \"Length\", unit = \"m\") = jointRRR3.rRod1_ia[1] \"Vector from origin of frame_a to spherical joint, resolved in frame_ia\";
//   parameter Real jointRRR3.jointUSR.rRod1_ia[2](quantity = \"Length\", unit = \"m\") = jointRRR3.rRod1_ia[2] \"Vector from origin of frame_a to spherical joint, resolved in frame_ia\";
//   parameter Real jointRRR3.jointUSR.rRod1_ia[3](quantity = \"Length\", unit = \"m\") = jointRRR3.rRod1_ia[3] \"Vector from origin of frame_a to spherical joint, resolved in frame_ia\";
//   parameter Real jointRRR3.jointUSR.rRod2_ib[1](quantity = \"Length\", unit = \"m\") = jointRRR3.rRod2_ib[1] \"Vector from origin of frame_ib to spherical joint, resolved in frame_ib\";
//   parameter Real jointRRR3.jointUSR.rRod2_ib[2](quantity = \"Length\", unit = \"m\") = jointRRR3.rRod2_ib[2] \"Vector from origin of frame_ib to spherical joint, resolved in frame_ib\";
//   parameter Real jointRRR3.jointUSR.rRod2_ib[3](quantity = \"Length\", unit = \"m\") = jointRRR3.rRod2_ib[3] \"Vector from origin of frame_ib to spherical joint, resolved in frame_ib\";
//   parameter Real jointRRR3.jointUSR.phi_offset(quantity = \"Angle\", unit = \"deg\") = jointRRR3.phi_offset \"Relative angle offset of revolute joint (angle = phi(t) + from_deg(phi_offset))\";
//   parameter Real jointRRR3.jointUSR.phi_guess(quantity = \"Angle\", unit = \"deg\") = jointRRR3.phi_guess \"Select the configuration such that at initial time |phi(t0) - from_deg(phi_guess)|is minimal\";
//   parameter Real jointRRR3.jointUSR.sphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultJointLength \"Diameter of the spheres representing the universal and the spherical joint\";
//   input Integer jointRRR3.jointUSR.sphereColor[1](min = 0, max = 255) = 255 \"Color of the spheres representing the universal and the spherical joint\";
//   input Integer jointRRR3.jointUSR.sphereColor[2](min = 0, max = 255) = 0 \"Color of the spheres representing the universal and the spherical joint\";
//   input Integer jointRRR3.jointUSR.sphereColor[3](min = 0, max = 255) = 0 \"Color of the spheres representing the universal and the spherical joint\";
//   input Integer jointRRR3.jointUSR.rod1Color[1](min = 0, max = 255) = 155 \"Color of rod 1 connecting the universal and the spherical joint\";
//   input Integer jointRRR3.jointUSR.rod1Color[2](min = 0, max = 255) = 155 \"Color of rod 1 connecting the universal and the spherical joint\";
//   input Integer jointRRR3.jointUSR.rod1Color[3](min = 0, max = 255) = 155 \"Color of rod 1 connecting the universal and the spherical joint\";
//   input Integer jointRRR3.jointUSR.rod2Color[1](min = 0, max = 255) = jointRRR3.jointUSR.rod1Color[1] \"Color of rod 2 connecting the revolute and the spherical joint\";
//   input Integer jointRRR3.jointUSR.rod2Color[2](min = 0, max = 255) = jointRRR3.jointUSR.rod1Color[2] \"Color of rod 2 connecting the revolute and the spherical joint\";
//   input Integer jointRRR3.jointUSR.rod2Color[3](min = 0, max = 255) = jointRRR3.jointUSR.rod1Color[3] \"Color of rod 2 connecting the revolute and the spherical joint\";
//   parameter Real jointRRR3.jointUSR.revoluteDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultJointWidth \"Diameter of cylinder representing the revolute joint\";
//   parameter Real jointRRR3.jointUSR.revoluteLength(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultJointLength \"Length of cylinder representing the revolute joint\";
//   input Integer jointRRR3.jointUSR.revoluteColor[1](min = 0, max = 255) = 255 \"Color of cylinder representing the revolute joint\";
//   input Integer jointRRR3.jointUSR.revoluteColor[2](min = 0, max = 255) = 0 \"Color of cylinder representing the revolute joint\";
//   input Integer jointRRR3.jointUSR.revoluteColor[3](min = 0, max = 255) = 0 \"Color of cylinder representing the revolute joint\";
//   input Real jointRRR3.jointUSR.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Real jointRRR3.jointUSR.cylinderLength(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultJointLength \"Length of cylinders representing the two universal joint axes\";
//   parameter Real jointRRR3.jointUSR.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultJointWidth \"Diameter of cylinders representing the two universal joint axes\";
//   input Integer jointRRR3.jointUSR.cylinderColor[1](min = 0, max = 255) = 255 \"Color of cylinders representing the two universal joint axes\";
//   input Integer jointRRR3.jointUSR.cylinderColor[2](min = 0, max = 255) = 0 \"Color of cylinders representing the two universal joint axes\";
//   input Integer jointRRR3.jointUSR.cylinderColor[3](min = 0, max = 255) = 0 \"Color of cylinders representing the two universal joint axes\";
//   parameter Boolean jointRRR3.jointUSR.checkTotalPower = jointRRR3.checkTotalPower \"= true, if total power flowing into this component shall be determined (must be zero)\";
//   parameter Real jointRRR3.jointUSR.eRod1_ia[1](unit = \"1\") = jointRRR3.jointUSR.rod1.eRod_ia[1] \"Unit vector from origin of frame_a to origin of spherical joint, resolved in frame_ia\";
//   parameter Real jointRRR3.jointUSR.eRod1_ia[2](unit = \"1\") = jointRRR3.jointUSR.rod1.eRod_ia[2] \"Unit vector from origin of frame_a to origin of spherical joint, resolved in frame_ia\";
//   parameter Real jointRRR3.jointUSR.eRod1_ia[3](unit = \"1\") = jointRRR3.jointUSR.rod1.eRod_ia[3] \"Unit vector from origin of frame_a to origin of spherical joint, resolved in frame_ia\";
//   parameter Real jointRRR3.jointUSR.e2_ia[1](unit = \"1\") = jointRRR3.jointUSR.rod1.e2_ia[1] \"Unit vector in direction of axis 2 of universal joint, resolved in frame_ia\";
//   parameter Real jointRRR3.jointUSR.e2_ia[2](unit = \"1\") = jointRRR3.jointUSR.rod1.e2_ia[2] \"Unit vector in direction of axis 2 of universal joint, resolved in frame_ia\";
//   parameter Real jointRRR3.jointUSR.e2_ia[3](unit = \"1\") = jointRRR3.jointUSR.rod1.e2_ia[3] \"Unit vector in direction of axis 2 of universal joint, resolved in frame_ia\";
//   parameter Real jointRRR3.jointUSR.rod1Length(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR3.jointUSR.rod1.rodLength \"Length of rod 1 (= distance between universal and spherical joint\";
//   Real jointRRR3.jointUSR.totalPower(quantity = \"Power\", unit = \"W\") \"Total power flowing into this element, if checkTotalPower=true (otherwise dummy)\";
//   Real jointRRR3.jointUSR.aux(quantity = \"Length\", unit = \"m\") \"Denominator used to compute force in rod connecting universal and spherical joint\";
//   Real jointRRR3.jointUSR.f_rod(quantity = \"Force\", unit = \"N\") \"Constraint force in direction of the rod (positive, if rod is pressed)\";
//   Real jointRRR3.jointUSR.revolute.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.revolute.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.revolute.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.revolute.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.revolute.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.revolute.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.revolute.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.revolute.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.revolute.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.revolute.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.revolute.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.revolute.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.revolute.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.revolute.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.revolute.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.revolute.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.revolute.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.revolute.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.revolute.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.revolute.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.revolute.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.revolute.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.revolute.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.revolute.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.revolute.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.revolute.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.revolute.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.revolute.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.revolute.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.revolute.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.revolute.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.revolute.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.revolute.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.revolute.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.revolute.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.revolute.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.revolute.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.revolute.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.revolute.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.revolute.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.revolute.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.revolute.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.revolute.axis.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real jointRRR3.jointUSR.revolute.axis.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real jointRRR3.jointUSR.revolute.bearing.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real jointRRR3.jointUSR.revolute.bearing.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real jointRRR3.jointUSR.revolute.position_a[1](quantity = \"Position\", unit = \"m\") \"Position vector from frame_a to frame_a side of length constraint, resolved in frame_a of revolute joint\";
//   input Real jointRRR3.jointUSR.revolute.position_a[2](quantity = \"Position\", unit = \"m\") \"Position vector from frame_a to frame_a side of length constraint, resolved in frame_a of revolute joint\";
//   input Real jointRRR3.jointUSR.revolute.position_a[3](quantity = \"Position\", unit = \"m\") \"Position vector from frame_a to frame_a side of length constraint, resolved in frame_a of revolute joint\";
//   input Real jointRRR3.jointUSR.revolute.position_b[1](quantity = \"Position\", unit = \"m\") \"Position vector from frame_b to frame_b side of length constraint, resolved in frame_b of revolute joint\";
//   input Real jointRRR3.jointUSR.revolute.position_b[2](quantity = \"Position\", unit = \"m\") \"Position vector from frame_b to frame_b side of length constraint, resolved in frame_b of revolute joint\";
//   input Real jointRRR3.jointUSR.revolute.position_b[3](quantity = \"Position\", unit = \"m\") \"Position vector from frame_b to frame_b side of length constraint, resolved in frame_b of revolute joint\";
//   parameter Boolean jointRRR3.jointUSR.revolute.animation = jointRRR3.jointUSR.animation \"= true, if animation shall be enabled\";
//   parameter Real jointRRR3.jointUSR.revolute.lengthConstraint(quantity = \"Length\", unit = \"m\", start = 1.0) = jointRRR3.jointUSR.rod1Length \"Fixed length of length constraint\";
//   parameter Real jointRRR3.jointUSR.revolute.n[1](unit = \"1\") = jointRRR3.jointUSR.n_b[1] \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real jointRRR3.jointUSR.revolute.n[2](unit = \"1\") = jointRRR3.jointUSR.n_b[2] \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real jointRRR3.jointUSR.revolute.n[3](unit = \"1\") = jointRRR3.jointUSR.n_b[3] \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real jointRRR3.jointUSR.revolute.phi_offset(quantity = \"Angle\", unit = \"deg\") = jointRRR3.jointUSR.phi_offset \"Relative angle offset (angle = phi + from_deg(phi_offset))\";
//   parameter Real jointRRR3.jointUSR.revolute.phi_guess(quantity = \"Angle\", unit = \"deg\") = jointRRR3.jointUSR.phi_guess \"Select the configuration such that at initial time |phi - from_deg(phi_guess)|is minimal\";
//   parameter Real jointRRR3.jointUSR.revolute.cylinderLength(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR3.jointUSR.revoluteLength \"Length of cylinder representing the joint axis\";
//   parameter Real jointRRR3.jointUSR.revolute.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR3.jointUSR.revoluteDiameter \"Diameter of cylinder representing the joint axis\";
//   input Integer jointRRR3.jointUSR.revolute.cylinderColor[1](min = 0, max = 255) = jointRRR3.jointUSR.revoluteColor[1] \"Color of cylinder representing the joint axis\";
//   input Integer jointRRR3.jointUSR.revolute.cylinderColor[2](min = 0, max = 255) = jointRRR3.jointUSR.revoluteColor[2] \"Color of cylinder representing the joint axis\";
//   input Integer jointRRR3.jointUSR.revolute.cylinderColor[3](min = 0, max = 255) = jointRRR3.jointUSR.revoluteColor[3] \"Color of cylinder representing the joint axis\";
//   input Real jointRRR3.jointUSR.revolute.specularCoefficient = jointRRR3.jointUSR.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean jointRRR3.jointUSR.revolute.positiveBranch(fixed = false) \"Based on phi_guess, selection of one of the two solutions of the non-linear constraint equation\";
//   Real jointRRR3.jointUSR.revolute.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle of revolute joint\";
//   Real jointRRR3.jointUSR.revolute.R_rel.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.revolute.R_rel.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.revolute.R_rel.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.revolute.R_rel.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.revolute.R_rel.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.revolute.R_rel.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.revolute.R_rel.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.revolute.R_rel.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.revolute.R_rel.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.revolute.R_rel.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.revolute.R_rel.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.revolute.R_rel.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.revolute.angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"= phi + from_deg(phi_offset) (relative rotation angle between frame_a and frame_b)\";
//   Real jointRRR3.jointUSR.revolute.tau(quantity = \"Torque\", unit = \"N.m\") \"= axis.tau (driving torque in the axis)\";
//   protected Real jointRRR3.jointUSR.revolute.r_a[1](quantity = \"Length\", unit = \"m\") = jointRRR3.jointUSR.revolute.position_a[1] \"Position vector from frame_a to frame_a side of length constraint, resolved in frame_a of revolute joint\";
//   protected Real jointRRR3.jointUSR.revolute.r_a[2](quantity = \"Length\", unit = \"m\") = jointRRR3.jointUSR.revolute.position_a[2] \"Position vector from frame_a to frame_a side of length constraint, resolved in frame_a of revolute joint\";
//   protected Real jointRRR3.jointUSR.revolute.r_a[3](quantity = \"Length\", unit = \"m\") = jointRRR3.jointUSR.revolute.position_a[3] \"Position vector from frame_a to frame_a side of length constraint, resolved in frame_a of revolute joint\";
//   protected Real jointRRR3.jointUSR.revolute.r_b[1](quantity = \"Length\", unit = \"m\") = jointRRR3.jointUSR.revolute.position_b[1] \"Position vector from frame_b to frame_b side of length constraint, resolved in frame_b of revolute joint\";
//   protected Real jointRRR3.jointUSR.revolute.r_b[2](quantity = \"Length\", unit = \"m\") = jointRRR3.jointUSR.revolute.position_b[2] \"Position vector from frame_b to frame_b side of length constraint, resolved in frame_b of revolute joint\";
//   protected Real jointRRR3.jointUSR.revolute.r_b[3](quantity = \"Length\", unit = \"m\") = jointRRR3.jointUSR.revolute.position_b[3] \"Position vector from frame_b to frame_b side of length constraint, resolved in frame_b of revolute joint\";
//   protected Real jointRRR3.jointUSR.revolute.e_r_a \"Projection of r_a on e\";
//   protected Real jointRRR3.jointUSR.revolute.e_r_b \"Projection of r_b on e\";
//   protected Real jointRRR3.jointUSR.revolute.A \"Coefficient A of equation: A*cos(phi) + B*sin(phi) + C = 0\";
//   protected Real jointRRR3.jointUSR.revolute.B \"Coefficient B of equation: A*cos(phi) + B*sin(phi) + C = 0\";
//   protected Real jointRRR3.jointUSR.revolute.C \"Coefficient C of equation: A*cos(phi) + B*sin(phi) + C = 0\";
//   protected Real jointRRR3.jointUSR.revolute.k1 \"Constant of quadratic equation\";
//   protected Real jointRRR3.jointUSR.revolute.k2 \"Constant of quadratic equation\";
//   protected Real jointRRR3.jointUSR.revolute.k1a(start = 1.0);
//   protected Real jointRRR3.jointUSR.revolute.k1b;
//   protected Real jointRRR3.jointUSR.revolute.kcos_angle \"= k1*cos(angle)\";
//   protected Real jointRRR3.jointUSR.revolute.ksin_angle \"= k1*sin(angle)\";
//   parameter Real jointRRR3.jointUSR.revolute.e[1](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR3.jointUSR.revolute.n[1],jointRRR3.jointUSR.revolute.n[2],jointRRR3.jointUSR.revolute.n[3]},1e-13)[1] \"Unit vector in direction of rotation axis, resolved in frame_a\";
//   parameter Real jointRRR3.jointUSR.revolute.e[2](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR3.jointUSR.revolute.n[1],jointRRR3.jointUSR.revolute.n[2],jointRRR3.jointUSR.revolute.n[3]},1e-13)[2] \"Unit vector in direction of rotation axis, resolved in frame_a\";
//   parameter Real jointRRR3.jointUSR.revolute.e[3](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR3.jointUSR.revolute.n[1],jointRRR3.jointUSR.revolute.n[2],jointRRR3.jointUSR.revolute.n[3]},1e-13)[3] \"Unit vector in direction of rotation axis, resolved in frame_a\";
//   Real jointRRR3.jointUSR.rod1.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.rod1.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.rod1.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.rod1.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.rod1.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.rod1.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.rod1.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.rod1.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.rod1.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.rod1.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.rod1.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.rod1.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.rod1.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.rod1.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.rod1.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.rod1.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.rod1.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.rod1.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.rod1.frame_ia.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.rod1.frame_ia.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.rod1.frame_ia.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.rod1.frame_ia.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_ia.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_ia.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_ia.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_ia.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_ia.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_ia.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_ia.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_ia.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_ia.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_ia.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_ia.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.rod1.frame_ia.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.rod1.frame_ia.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.rod1.frame_ia.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.rod1.frame_ia.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.rod1.frame_ia.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.rod1.frame_ia.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean jointRRR3.jointUSR.rod1.animation = jointRRR3.jointUSR.animation \"= true, if animation shall be enabled\";
//   parameter Boolean jointRRR3.jointUSR.rod1.showUniversalAxes = jointRRR3.jointUSR.showUniversalAxes \" = true, if universal joint shall be visualized with two cylinders, otherwise with a sphere (provided animation=true)\";
//   parameter Boolean jointRRR3.jointUSR.rod1.computeRodLength = false \"= true, if distance between frame_a and frame_b shall be computed during initialization (see info)\";
//   parameter Real jointRRR3.jointUSR.rod1.n1_a[1](unit = \"1\") = jointRRR3.jointUSR.n1_a[1] \"Axis 1 of universal joint resolved in frame_a (axis 2 is orthogonal to axis 1 and to rod)\";
//   parameter Real jointRRR3.jointUSR.rod1.n1_a[2](unit = \"1\") = jointRRR3.jointUSR.n1_a[2] \"Axis 1 of universal joint resolved in frame_a (axis 2 is orthogonal to axis 1 and to rod)\";
//   parameter Real jointRRR3.jointUSR.rod1.n1_a[3](unit = \"1\") = jointRRR3.jointUSR.n1_a[3] \"Axis 1 of universal joint resolved in frame_a (axis 2 is orthogonal to axis 1 and to rod)\";
//   parameter Real jointRRR3.jointUSR.rod1.rRod_ia[1](quantity = \"Length\", unit = \"m\") = jointRRR3.jointUSR.rRod1_ia[1] \"Vector from origin of frame_a to origin of frame_b, resolved in frame_ia (if computeRodLength=true, rRod_ia is only an axis vector along the connecting rod)\";
//   parameter Real jointRRR3.jointUSR.rod1.rRod_ia[2](quantity = \"Length\", unit = \"m\") = jointRRR3.jointUSR.rRod1_ia[2] \"Vector from origin of frame_a to origin of frame_b, resolved in frame_ia (if computeRodLength=true, rRod_ia is only an axis vector along the connecting rod)\";
//   parameter Real jointRRR3.jointUSR.rod1.rRod_ia[3](quantity = \"Length\", unit = \"m\") = jointRRR3.jointUSR.rRod1_ia[3] \"Vector from origin of frame_a to origin of frame_b, resolved in frame_ia (if computeRodLength=true, rRod_ia is only an axis vector along the connecting rod)\";
//   parameter Real jointRRR3.jointUSR.rod1.sphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR3.jointUSR.sphereDiameter \"Diameter of spheres representing the universal and the spherical joint\";
//   input Integer jointRRR3.jointUSR.rod1.sphereColor[1](min = 0, max = 255) = jointRRR3.jointUSR.sphereColor[1] \"Color of spheres representing the universal and the spherical joint\";
//   input Integer jointRRR3.jointUSR.rod1.sphereColor[2](min = 0, max = 255) = jointRRR3.jointUSR.sphereColor[2] \"Color of spheres representing the universal and the spherical joint\";
//   input Integer jointRRR3.jointUSR.rod1.sphereColor[3](min = 0, max = 255) = jointRRR3.jointUSR.sphereColor[3] \"Color of spheres representing the universal and the spherical joint\";
//   parameter String jointRRR3.jointUSR.rod1.rodShapeType = \"cylinder\" \"Shape type of rod connecting the universal and the spherical joint\";
//   parameter Real jointRRR3.jointUSR.rod1.rodExtra = 0.0 \"Additional parameter depending on rodShapeType\";
//   input Integer jointRRR3.jointUSR.rod1.rodColor[1](min = 0, max = 255) = jointRRR3.jointUSR.rod1Color[1] \"Color of rod shape connecting the universal and the spherical joints\";
//   input Integer jointRRR3.jointUSR.rod1.rodColor[2](min = 0, max = 255) = jointRRR3.jointUSR.rod1Color[2] \"Color of rod shape connecting the universal and the spherical joints\";
//   input Integer jointRRR3.jointUSR.rod1.rodColor[3](min = 0, max = 255) = jointRRR3.jointUSR.rod1Color[3] \"Color of rod shape connecting the universal and the spherical joints\";
//   parameter Real jointRRR3.jointUSR.rod1.cylinderLength(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR3.jointUSR.cylinderLength \"Length of cylinders representing the two universal joint axes\";
//   parameter Real jointRRR3.jointUSR.rod1.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR3.jointUSR.cylinderDiameter \"Diameter of cylinders representing the two universal joint axes\";
//   input Integer jointRRR3.jointUSR.rod1.cylinderColor[1](min = 0, max = 255) = jointRRR3.jointUSR.cylinderColor[1] \"Color of cylinders representing the two universal joint axes\";
//   input Integer jointRRR3.jointUSR.rod1.cylinderColor[2](min = 0, max = 255) = jointRRR3.jointUSR.cylinderColor[2] \"Color of cylinders representing the two universal joint axes\";
//   input Integer jointRRR3.jointUSR.rod1.cylinderColor[3](min = 0, max = 255) = jointRRR3.jointUSR.cylinderColor[3] \"Color of cylinders representing the two universal joint axes\";
//   input Real jointRRR3.jointUSR.rod1.specularCoefficient = jointRRR3.jointUSR.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean jointRRR3.jointUSR.rod1.kinematicConstraint = false \"= false, if no constraint shall be defined, due to analytically solving a kinematic loop\";
//   Real jointRRR3.jointUSR.rod1.constraintResidue = jointRRR3.jointUSR.rod1.f_rod - jointRRR3.jointUSR.f_rod \"Constraint equation of joint in residue form: Either length constraint (= default) or equation to compute rod force (for analytic solution of loops in combination with Internal.RevoluteWithLengthConstraint/PrismaticWithLengthConstraint)\";
//   parameter Boolean jointRRR3.jointUSR.rod1.checkTotalPower = false \"= true, if total power flowing into this component shall be determined (must be zero)\";
//   Real jointRRR3.jointUSR.rod1.f_rod(quantity = \"Force\", unit = \"N\") \"Constraint force in direction of the rod (positive, if rod is pressed)\";
//   Real jointRRR3.jointUSR.rod1.totalPower(quantity = \"Power\", unit = \"W\") \"Total power flowing into this element, if checkTotalPower=true (otherwise dummy)\";
//   Real jointRRR3.jointUSR.rod1.f_b_a1[1](quantity = \"Force\", unit = \"N\") \"frame_b.f without f_rod part, resolved in frame_a (needed for analytic loop handling)\";
//   Real jointRRR3.jointUSR.rod1.f_b_a1[2](quantity = \"Force\", unit = \"N\") \"frame_b.f without f_rod part, resolved in frame_a (needed for analytic loop handling)\";
//   Real jointRRR3.jointUSR.rod1.f_b_a1[3](quantity = \"Force\", unit = \"N\") \"frame_b.f without f_rod part, resolved in frame_a (needed for analytic loop handling)\";
//   Real jointRRR3.jointUSR.rod1.eRod_a[1](unit = \"1\") \"Unit vector in direction of rRod_a, resolved in frame_a (needed for analytic loop handling)\";
//   Real jointRRR3.jointUSR.rod1.eRod_a[2](unit = \"1\") \"Unit vector in direction of rRod_a, resolved in frame_a (needed for analytic loop handling)\";
//   Real jointRRR3.jointUSR.rod1.eRod_a[3](unit = \"1\") \"Unit vector in direction of rRod_a, resolved in frame_a (needed for analytic loop handling)\";
//   Real jointRRR3.jointUSR.rod1.rRod_0[1](quantity = \"Length\", unit = \"m\", start = jointRRR3.jointUSR.rod1.rRod_ia[1]) \"Position vector from origin of frame_a to origin of frame_b resolved in world frame\";
//   Real jointRRR3.jointUSR.rod1.rRod_0[2](quantity = \"Length\", unit = \"m\", start = jointRRR3.jointUSR.rod1.rRod_ia[2]) \"Position vector from origin of frame_a to origin of frame_b resolved in world frame\";
//   Real jointRRR3.jointUSR.rod1.rRod_0[3](quantity = \"Length\", unit = \"m\", start = jointRRR3.jointUSR.rod1.rRod_ia[3]) \"Position vector from origin of frame_a to origin of frame_b resolved in world frame\";
//   Real jointRRR3.jointUSR.rod1.rRod_a[1](quantity = \"Length\", unit = \"m\", start = jointRRR3.jointUSR.rod1.rRod_ia[1]) \"Position vector from origin of frame_a to origin of frame_b resolved in frame_a\";
//   Real jointRRR3.jointUSR.rod1.rRod_a[2](quantity = \"Length\", unit = \"m\", start = jointRRR3.jointUSR.rod1.rRod_ia[2]) \"Position vector from origin of frame_a to origin of frame_b resolved in frame_a\";
//   Real jointRRR3.jointUSR.rod1.rRod_a[3](quantity = \"Length\", unit = \"m\", start = jointRRR3.jointUSR.rod1.rRod_ia[3]) \"Position vector from origin of frame_a to origin of frame_b resolved in frame_a\";
//   protected Real jointRRR3.jointUSR.rod1.f_b_a[1](quantity = \"Force\", unit = \"N\") \"frame_b.f resolved in frame_a\";
//   protected Real jointRRR3.jointUSR.rod1.f_b_a[2](quantity = \"Force\", unit = \"N\") \"frame_b.f resolved in frame_a\";
//   protected Real jointRRR3.jointUSR.rod1.f_b_a[3](quantity = \"Force\", unit = \"N\") \"frame_b.f resolved in frame_a\";
//   protected Real jointRRR3.jointUSR.rod1.f_ia_a[1](quantity = \"Force\", unit = \"N\") \"frame_ia.f resolved in frame_a\";
//   protected Real jointRRR3.jointUSR.rod1.f_ia_a[2](quantity = \"Force\", unit = \"N\") \"frame_ia.f resolved in frame_a\";
//   protected Real jointRRR3.jointUSR.rod1.f_ia_a[3](quantity = \"Force\", unit = \"N\") \"frame_ia.f resolved in frame_a\";
//   protected Real jointRRR3.jointUSR.rod1.t_ia_a[1](quantity = \"Torque\", unit = \"N.m\") \"frame_ia.t resolved in frame_a\";
//   protected Real jointRRR3.jointUSR.rod1.t_ia_a[2](quantity = \"Torque\", unit = \"N.m\") \"frame_ia.t resolved in frame_a\";
//   protected Real jointRRR3.jointUSR.rod1.t_ia_a[3](quantity = \"Torque\", unit = \"N.m\") \"frame_ia.t resolved in frame_a\";
//   protected Real jointRRR3.jointUSR.rod1.n2_a[1](unit = \"1\") \"Vector in direction of axis 2 of the universal joint (e2_ia), resolved in frame_a\";
//   protected Real jointRRR3.jointUSR.rod1.n2_a[2](unit = \"1\") \"Vector in direction of axis 2 of the universal joint (e2_ia), resolved in frame_a\";
//   protected Real jointRRR3.jointUSR.rod1.n2_a[3](unit = \"1\") \"Vector in direction of axis 2 of the universal joint (e2_ia), resolved in frame_a\";
//   protected Real jointRRR3.jointUSR.rod1.length2_n2_a(unit = \"m2\", start = 1.0) \"Square of length of vector n2_a\";
//   protected Real jointRRR3.jointUSR.rod1.length_n2_a(quantity = \"Length\", unit = \"m\") \"Length of vector n2_a\";
//   protected Real jointRRR3.jointUSR.rod1.e2_a[1](unit = \"1\") \"Unit vector in direction of axis 2 of the universal joint (e2_ia), resolved in frame_a\";
//   protected Real jointRRR3.jointUSR.rod1.e2_a[2](unit = \"1\") \"Unit vector in direction of axis 2 of the universal joint (e2_ia), resolved in frame_a\";
//   protected Real jointRRR3.jointUSR.rod1.e2_a[3](unit = \"1\") \"Unit vector in direction of axis 2 of the universal joint (e2_ia), resolved in frame_a\";
//   protected Real jointRRR3.jointUSR.rod1.e3_a[1](unit = \"1\") \"Unit vector perpendicular to eRod_ia and e2_a, resolved in frame_a\";
//   protected Real jointRRR3.jointUSR.rod1.e3_a[2](unit = \"1\") \"Unit vector perpendicular to eRod_ia and e2_a, resolved in frame_a\";
//   protected Real jointRRR3.jointUSR.rod1.e3_a[3](unit = \"1\") \"Unit vector perpendicular to eRod_ia and e2_a, resolved in frame_a\";
//   protected Real jointRRR3.jointUSR.rod1.der_rRod_a_L[1](unit = \"1/s\") \"= der(rRod_a)/rodLength\";
//   protected Real jointRRR3.jointUSR.rod1.der_rRod_a_L[2](unit = \"1/s\") \"= der(rRod_a)/rodLength\";
//   protected Real jointRRR3.jointUSR.rod1.der_rRod_a_L[3](unit = \"1/s\") \"= der(rRod_a)/rodLength\";
//   protected Real jointRRR3.jointUSR.rod1.w_rel_ia1[1](quantity = \"AngularVelocity\", unit = \"rad/s\");
//   protected Real jointRRR3.jointUSR.rod1.w_rel_ia1[2](quantity = \"AngularVelocity\", unit = \"rad/s\");
//   protected Real jointRRR3.jointUSR.rod1.w_rel_ia1[3](quantity = \"AngularVelocity\", unit = \"rad/s\");
//   Real jointRRR3.jointUSR.rod1.R_rel_ia1.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia1.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia1.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia1.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia1.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia1.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia1.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia1.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia1.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia1.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia1.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia1.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia2.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia2.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia2.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia2.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia2.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia2.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia2.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia2.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia2.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia2.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia2.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia2.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.rod1.R_rel_ia.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real jointRRR3.jointUSR.rod1.rodLength(quantity = \"Length\", unit = \"m\", min = 0.0, fixed =  NOT jointRRR3.jointUSR.rod1.computeRodLength) = Modelica.Math.Vectors.length({jointRRR3.jointUSR.rod1.rRod_ia[1],jointRRR3.jointUSR.rod1.rRod_ia[2],jointRRR3.jointUSR.rod1.rRod_ia[3]}) \"Length of rod (distance between origin of frame_a and origin of frame_b)\";
//   parameter Real jointRRR3.jointUSR.rod1.eRod_ia[1](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR3.jointUSR.rod1.rRod_ia[1],jointRRR3.jointUSR.rod1.rRod_ia[2],jointRRR3.jointUSR.rod1.rRod_ia[3]},1e-13)[1] \"Unit vector from origin of frame_a to origin of frame_b, resolved in frame_ia\";
//   parameter Real jointRRR3.jointUSR.rod1.eRod_ia[2](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR3.jointUSR.rod1.rRod_ia[1],jointRRR3.jointUSR.rod1.rRod_ia[2],jointRRR3.jointUSR.rod1.rRod_ia[3]},1e-13)[2] \"Unit vector from origin of frame_a to origin of frame_b, resolved in frame_ia\";
//   parameter Real jointRRR3.jointUSR.rod1.eRod_ia[3](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR3.jointUSR.rod1.rRod_ia[1],jointRRR3.jointUSR.rod1.rRod_ia[2],jointRRR3.jointUSR.rod1.rRod_ia[3]},1e-13)[3] \"Unit vector from origin of frame_a to origin of frame_b, resolved in frame_ia\";
//   parameter Real jointRRR3.jointUSR.rod1.rodWidth(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR3.jointUSR.rod1Diameter \"Width of rod shape in direction of axis 2 of universal joint.\";
//   parameter Real jointRRR3.jointUSR.rod1.e2_ia[1](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR3.jointUSR.rod1.n1_a[2] * jointRRR3.jointUSR.rod1.eRod_ia[3] - jointRRR3.jointUSR.rod1.n1_a[3] * jointRRR3.jointUSR.rod1.eRod_ia[2],jointRRR3.jointUSR.rod1.n1_a[3] * jointRRR3.jointUSR.rod1.eRod_ia[1] - jointRRR3.jointUSR.rod1.n1_a[1] * jointRRR3.jointUSR.rod1.eRod_ia[3],jointRRR3.jointUSR.rod1.n1_a[1] * jointRRR3.jointUSR.rod1.eRod_ia[2] - jointRRR3.jointUSR.rod1.n1_a[2] * jointRRR3.jointUSR.rod1.eRod_ia[1]},1e-13)[1] \"Unit vector in direction of axis 2 of universal joint, resolved in frame_ia (orthogonal to n1_a and eRod_ia; note: frame_ia is parallel to frame_a when the universal joint angles are zero)\";
//   parameter Real jointRRR3.jointUSR.rod1.e2_ia[2](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR3.jointUSR.rod1.n1_a[2] * jointRRR3.jointUSR.rod1.eRod_ia[3] - jointRRR3.jointUSR.rod1.n1_a[3] * jointRRR3.jointUSR.rod1.eRod_ia[2],jointRRR3.jointUSR.rod1.n1_a[3] * jointRRR3.jointUSR.rod1.eRod_ia[1] - jointRRR3.jointUSR.rod1.n1_a[1] * jointRRR3.jointUSR.rod1.eRod_ia[3],jointRRR3.jointUSR.rod1.n1_a[1] * jointRRR3.jointUSR.rod1.eRod_ia[2] - jointRRR3.jointUSR.rod1.n1_a[2] * jointRRR3.jointUSR.rod1.eRod_ia[1]},1e-13)[2] \"Unit vector in direction of axis 2 of universal joint, resolved in frame_ia (orthogonal to n1_a and eRod_ia; note: frame_ia is parallel to frame_a when the universal joint angles are zero)\";
//   parameter Real jointRRR3.jointUSR.rod1.e2_ia[3](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR3.jointUSR.rod1.n1_a[2] * jointRRR3.jointUSR.rod1.eRod_ia[3] - jointRRR3.jointUSR.rod1.n1_a[3] * jointRRR3.jointUSR.rod1.eRod_ia[2],jointRRR3.jointUSR.rod1.n1_a[3] * jointRRR3.jointUSR.rod1.eRod_ia[1] - jointRRR3.jointUSR.rod1.n1_a[1] * jointRRR3.jointUSR.rod1.eRod_ia[3],jointRRR3.jointUSR.rod1.n1_a[1] * jointRRR3.jointUSR.rod1.eRod_ia[2] - jointRRR3.jointUSR.rod1.n1_a[2] * jointRRR3.jointUSR.rod1.eRod_ia[1]},1e-13)[3] \"Unit vector in direction of axis 2 of universal joint, resolved in frame_ia (orthogonal to n1_a and eRod_ia; note: frame_ia is parallel to frame_a when the universal joint angles are zero)\";
//   parameter Real jointRRR3.jointUSR.rod1.rodHeight(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR3.jointUSR.rod1Diameter \"Height of rod shape in direction that is orthogonal to rod and to axis 2\";
//   parameter Real jointRRR3.jointUSR.rod1.e3_ia[1](unit = \"1\") = jointRRR3.jointUSR.rod1.eRod_ia[2] * jointRRR3.jointUSR.rod1.e2_ia[3] - jointRRR3.jointUSR.rod1.eRod_ia[3] * jointRRR3.jointUSR.rod1.e2_ia[2] \"Unit vector perpendicular to eRod_ia and e2_ia, resolved in frame_ia\";
//   parameter Real jointRRR3.jointUSR.rod1.e3_ia[2](unit = \"1\") = jointRRR3.jointUSR.rod1.eRod_ia[3] * jointRRR3.jointUSR.rod1.e2_ia[1] - jointRRR3.jointUSR.rod1.eRod_ia[1] * jointRRR3.jointUSR.rod1.e2_ia[3] \"Unit vector perpendicular to eRod_ia and e2_ia, resolved in frame_ia\";
//   parameter Real jointRRR3.jointUSR.rod1.e3_ia[3](unit = \"1\") = jointRRR3.jointUSR.rod1.eRod_ia[1] * jointRRR3.jointUSR.rod1.e2_ia[2] - jointRRR3.jointUSR.rod1.eRod_ia[2] * jointRRR3.jointUSR.rod1.e2_ia[1] \"Unit vector perpendicular to eRod_ia and e2_ia, resolved in frame_ia\";
//   Real jointRRR3.jointUSR.rod2.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.rod2.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.rod2.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.rod2.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod2.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod2.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod2.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod2.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod2.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod2.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod2.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod2.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod2.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.rod2.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.rod2.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.rod2.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.rod2.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.rod2.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.rod2.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.rod2.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.rod2.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.rod2.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.rod2.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.rod2.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.rod2.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod2.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod2.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod2.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod2.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod2.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod2.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod2.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod2.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.rod2.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.rod2.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.rod2.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.rod2.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.rod2.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.rod2.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.rod2.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.rod2.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.rod2.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean jointRRR3.jointUSR.rod2.animation = jointRRR3.jointUSR.animation \"= true, if animation shall be enabled\";
//   parameter Real jointRRR3.jointUSR.rod2.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = jointRRR3.jointUSR.rRod2_ib[1] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real jointRRR3.jointUSR.rod2.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = jointRRR3.jointUSR.rRod2_ib[2] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real jointRRR3.jointUSR.rod2.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = jointRRR3.jointUSR.rRod2_ib[3] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter String jointRRR3.jointUSR.rod2.shapeType = \"cylinder\" \" Type of shape\";
//   parameter Real jointRRR3.jointUSR.rod2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real jointRRR3.jointUSR.rod2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real jointRRR3.jointUSR.rod2.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real jointRRR3.jointUSR.rod2.widthDirection[1](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real jointRRR3.jointUSR.rod2.widthDirection[2](unit = \"1\") = 1.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real jointRRR3.jointUSR.rod2.widthDirection[3](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real jointRRR3.jointUSR.rod2.extra = 0.0 \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer jointRRR3.jointUSR.rod2.color[1](min = 0, max = 255) = jointRRR3.jointUSR.rod2Color[1] \" Color of shape\";
//   input Integer jointRRR3.jointUSR.rod2.color[2](min = 0, max = 255) = jointRRR3.jointUSR.rod2Color[2] \" Color of shape\";
//   input Integer jointRRR3.jointUSR.rod2.color[3](min = 0, max = 255) = jointRRR3.jointUSR.rod2Color[3] \" Color of shape\";
//   input Real jointRRR3.jointUSR.rod2.specularCoefficient = jointRRR3.jointUSR.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Real jointRRR3.jointUSR.rod2.lengthDirection[1](unit = \"1\") = jointRRR3.jointUSR.rod2.r[1] - jointRRR3.jointUSR.rod2.r_shape[1] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real jointRRR3.jointUSR.rod2.lengthDirection[2](unit = \"1\") = jointRRR3.jointUSR.rod2.r[2] - jointRRR3.jointUSR.rod2.r_shape[2] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real jointRRR3.jointUSR.rod2.lengthDirection[3](unit = \"1\") = jointRRR3.jointUSR.rod2.r[3] - jointRRR3.jointUSR.rod2.r_shape[3] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real jointRRR3.jointUSR.rod2.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({jointRRR3.jointUSR.rod2.r[1] - jointRRR3.jointUSR.rod2.r_shape[1],jointRRR3.jointUSR.rod2.r[2] - jointRRR3.jointUSR.rod2.r_shape[2],jointRRR3.jointUSR.rod2.r[3] - jointRRR3.jointUSR.rod2.r_shape[3]}) \" Length of shape\";
//   parameter Real jointRRR3.jointUSR.rod2.width(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR3.jointUSR.rod2Diameter \" Width of shape\";
//   parameter Real jointRRR3.jointUSR.rod2.height(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR3.jointUSR.rod2Diameter \" Height of shape.\";
//   Real jointRRR3.jointUSR.relativePosition.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.relativePosition.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   output Real jointRRR3.jointUSR.relativePosition.r_rel[1] \"Relative position vector resolved in frame defined by resolveInFrame\";
//   output Real jointRRR3.jointUSR.relativePosition.r_rel[2] \"Relative position vector resolved in frame defined by resolveInFrame\";
//   output Real jointRRR3.jointUSR.relativePosition.r_rel[3] \"Relative position vector resolved in frame defined by resolveInFrame\";
//   parameter enumeration(world, frame_a, frame_b, frame_resolve) jointRRR3.jointUSR.relativePosition.resolveInFrame = Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_a \"Frame in which output vector r_rel shall be resolved (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   output Real jointRRR3.jointUSR.relativePosition.relativePosition.r_rel[1](quantity = \"Position\", unit = \"m\") \"Relative position vector frame_b.r_0 - frame_a.r_0 resolved in frame defined by resolveInFrame\";
//   output Real jointRRR3.jointUSR.relativePosition.relativePosition.r_rel[2](quantity = \"Position\", unit = \"m\") \"Relative position vector frame_b.r_0 - frame_a.r_0 resolved in frame defined by resolveInFrame\";
//   output Real jointRRR3.jointUSR.relativePosition.relativePosition.r_rel[3](quantity = \"Position\", unit = \"m\") \"Relative position vector frame_b.r_0 - frame_a.r_0 resolved in frame defined by resolveInFrame\";
//   parameter enumeration(world, frame_a, frame_b, frame_resolve) jointRRR3.jointUSR.relativePosition.relativePosition.resolveInFrame = jointRRR3.jointUSR.relativePosition.resolveInFrame \"Frame in which output vector r_rel is resolved (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)\";
//   Real jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   output Real jointRRR3.jointUSR.position_b[1].y \"Connector of Real output signal\";
//   parameter Real jointRRR3.jointUSR.position_b[1].k(start = 1.0) = jointRRR3.jointUSR.rRod2_ib[1] \"Constant output value\";
//   output Real jointRRR3.jointUSR.position_b[2].y \"Connector of Real output signal\";
//   parameter Real jointRRR3.jointUSR.position_b[2].k(start = 1.0) = jointRRR3.jointUSR.rRod2_ib[2] \"Constant output value\";
//   output Real jointRRR3.jointUSR.position_b[3].y \"Connector of Real output signal\";
//   parameter Real jointRRR3.jointUSR.position_b[3].k(start = 1.0) = jointRRR3.jointUSR.rRod2_ib[3] \"Constant output value\";
//   parameter Real jointRRR3.jointUSR.rod1Diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR3.jointUSR.sphereDiameter / 2.0 \"Diameter of rod 1 connecting the universal and the spherical joint\";
//   parameter Real jointRRR3.jointUSR.rod2Diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = jointRRR3.jointUSR.rod1Diameter \"Diameter of rod 2 connecting the revolute and the spherical joint\";
//   parameter String jointRRR3.shape_rev1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real jointRRR3.shape_rev1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rev1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rev1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rev1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rev1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rev1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rev1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rev1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rev1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rev1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR3.shape_rev1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR3.shape_rev1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR3.shape_rev1.r[1](quantity = \"Length\", unit = \"m\") = jointRRR3.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR3.shape_rev1.r[2](quantity = \"Length\", unit = \"m\") = jointRRR3.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR3.shape_rev1.r[3](quantity = \"Length\", unit = \"m\") = jointRRR3.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR3.shape_rev1.r_shape[1](quantity = \"Length\", unit = \"m\") = (-jointRRR3.cylinderLength) * jointRRR3.e_a[1] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR3.shape_rev1.r_shape[2](quantity = \"Length\", unit = \"m\") = (-jointRRR3.cylinderLength) * jointRRR3.e_a[2] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR3.shape_rev1.r_shape[3](quantity = \"Length\", unit = \"m\") = (-jointRRR3.cylinderLength) * jointRRR3.e_a[3] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR3.shape_rev1.lengthDirection[1](unit = \"1\") = jointRRR3.e_a[1] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR3.shape_rev1.lengthDirection[2](unit = \"1\") = jointRRR3.e_a[2] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR3.shape_rev1.lengthDirection[3](unit = \"1\") = jointRRR3.e_a[3] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR3.shape_rev1.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR3.shape_rev1.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR3.shape_rev1.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR3.shape_rev1.length(quantity = \"Length\", unit = \"m\") = jointRRR3.cylinderLength \"Length of visual object\";
//   input Real jointRRR3.shape_rev1.width(quantity = \"Length\", unit = \"m\") = jointRRR3.cylinderDiameter \"Width of visual object\";
//   input Real jointRRR3.shape_rev1.height(quantity = \"Length\", unit = \"m\") = jointRRR3.cylinderDiameter \"Height of visual object\";
//   input Real jointRRR3.shape_rev1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real jointRRR3.shape_rev1.color[1] = Real(jointRRR3.cylinderColor[1]) \"Color of shape\";
//   input Real jointRRR3.shape_rev1.color[2] = Real(jointRRR3.cylinderColor[2]) \"Color of shape\";
//   input Real jointRRR3.shape_rev1.color[3] = Real(jointRRR3.cylinderColor[3]) \"Color of shape\";
//   input Real jointRRR3.shape_rev1.specularCoefficient = jointRRR3.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real jointRRR3.shape_rev1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({jointRRR3.shape_rev1.lengthDirection[1],jointRRR3.shape_rev1.lengthDirection[2],jointRRR3.shape_rev1.lengthDirection[3]});
//   protected Real jointRRR3.shape_rev1.e_x[1](unit = \"1\") = if noEvent(jointRRR3.shape_rev1.abs_n_x < 1e-10) then 1.0 else jointRRR3.shape_rev1.lengthDirection[1] / jointRRR3.shape_rev1.abs_n_x;
//   protected Real jointRRR3.shape_rev1.e_x[2](unit = \"1\") = if noEvent(jointRRR3.shape_rev1.abs_n_x < 1e-10) then 0.0 else jointRRR3.shape_rev1.lengthDirection[2] / jointRRR3.shape_rev1.abs_n_x;
//   protected Real jointRRR3.shape_rev1.e_x[3](unit = \"1\") = if noEvent(jointRRR3.shape_rev1.abs_n_x < 1e-10) then 0.0 else jointRRR3.shape_rev1.lengthDirection[3] / jointRRR3.shape_rev1.abs_n_x;
//   protected Real jointRRR3.shape_rev1.n_z_aux[1](unit = \"1\") = jointRRR3.shape_rev1.e_x[2] * jointRRR3.shape_rev1.widthDirection[3] - jointRRR3.shape_rev1.e_x[3] * jointRRR3.shape_rev1.widthDirection[2];
//   protected Real jointRRR3.shape_rev1.n_z_aux[2](unit = \"1\") = jointRRR3.shape_rev1.e_x[3] * jointRRR3.shape_rev1.widthDirection[1] - jointRRR3.shape_rev1.e_x[1] * jointRRR3.shape_rev1.widthDirection[3];
//   protected Real jointRRR3.shape_rev1.n_z_aux[3](unit = \"1\") = jointRRR3.shape_rev1.e_x[1] * jointRRR3.shape_rev1.widthDirection[2] - jointRRR3.shape_rev1.e_x[2] * jointRRR3.shape_rev1.widthDirection[1];
//   protected Real jointRRR3.shape_rev1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR3.shape_rev1.e_x[1],jointRRR3.shape_rev1.e_x[2],jointRRR3.shape_rev1.e_x[3]},if noEvent(jointRRR3.shape_rev1.n_z_aux[1] ^ 2.0 + (jointRRR3.shape_rev1.n_z_aux[2] ^ 2.0 + jointRRR3.shape_rev1.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR3.shape_rev1.widthDirection[1],jointRRR3.shape_rev1.widthDirection[2],jointRRR3.shape_rev1.widthDirection[3]} else if noEvent(abs(jointRRR3.shape_rev1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR3.shape_rev1.e_x[1],jointRRR3.shape_rev1.e_x[2],jointRRR3.shape_rev1.e_x[3]})[1];
//   protected Real jointRRR3.shape_rev1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR3.shape_rev1.e_x[1],jointRRR3.shape_rev1.e_x[2],jointRRR3.shape_rev1.e_x[3]},if noEvent(jointRRR3.shape_rev1.n_z_aux[1] ^ 2.0 + (jointRRR3.shape_rev1.n_z_aux[2] ^ 2.0 + jointRRR3.shape_rev1.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR3.shape_rev1.widthDirection[1],jointRRR3.shape_rev1.widthDirection[2],jointRRR3.shape_rev1.widthDirection[3]} else if noEvent(abs(jointRRR3.shape_rev1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR3.shape_rev1.e_x[1],jointRRR3.shape_rev1.e_x[2],jointRRR3.shape_rev1.e_x[3]})[2];
//   protected Real jointRRR3.shape_rev1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR3.shape_rev1.e_x[1],jointRRR3.shape_rev1.e_x[2],jointRRR3.shape_rev1.e_x[3]},if noEvent(jointRRR3.shape_rev1.n_z_aux[1] ^ 2.0 + (jointRRR3.shape_rev1.n_z_aux[2] ^ 2.0 + jointRRR3.shape_rev1.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR3.shape_rev1.widthDirection[1],jointRRR3.shape_rev1.widthDirection[2],jointRRR3.shape_rev1.widthDirection[3]} else if noEvent(abs(jointRRR3.shape_rev1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR3.shape_rev1.e_x[1],jointRRR3.shape_rev1.e_x[2],jointRRR3.shape_rev1.e_x[3]})[3];
//   protected output Real jointRRR3.shape_rev1.Form;
//   output Real jointRRR3.shape_rev1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR3.shape_rev1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR3.shape_rev1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR3.shape_rev1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR3.shape_rev1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR3.shape_rev1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR3.shape_rev1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real jointRRR3.shape_rev1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real jointRRR3.shape_rev1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real jointRRR3.shape_rev1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR3.shape_rev1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR3.shape_rev1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR3.shape_rev1.Material;
//   protected output Real jointRRR3.shape_rev1.Extra;
//   parameter String jointRRR3.shape_rev2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real jointRRR3.shape_rev2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rev2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rev2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rev2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rev2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rev2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rev2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rev2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rev2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rev2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR3.shape_rev2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR3.shape_rev2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR3.shape_rev2.r[1](quantity = \"Length\", unit = \"m\") = jointRRR3.frame_im.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR3.shape_rev2.r[2](quantity = \"Length\", unit = \"m\") = jointRRR3.frame_im.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR3.shape_rev2.r[3](quantity = \"Length\", unit = \"m\") = jointRRR3.frame_im.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR3.shape_rev2.r_shape[1](quantity = \"Length\", unit = \"m\") = (-jointRRR3.cylinderLength) * jointRRR3.e_b[1] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR3.shape_rev2.r_shape[2](quantity = \"Length\", unit = \"m\") = (-jointRRR3.cylinderLength) * jointRRR3.e_b[2] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR3.shape_rev2.r_shape[3](quantity = \"Length\", unit = \"m\") = (-jointRRR3.cylinderLength) * jointRRR3.e_b[3] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR3.shape_rev2.lengthDirection[1](unit = \"1\") = jointRRR3.e_b[1] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR3.shape_rev2.lengthDirection[2](unit = \"1\") = jointRRR3.e_b[2] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR3.shape_rev2.lengthDirection[3](unit = \"1\") = jointRRR3.e_b[3] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR3.shape_rev2.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR3.shape_rev2.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR3.shape_rev2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR3.shape_rev2.length(quantity = \"Length\", unit = \"m\") = jointRRR3.cylinderLength \"Length of visual object\";
//   input Real jointRRR3.shape_rev2.width(quantity = \"Length\", unit = \"m\") = jointRRR3.cylinderDiameter \"Width of visual object\";
//   input Real jointRRR3.shape_rev2.height(quantity = \"Length\", unit = \"m\") = jointRRR3.cylinderDiameter \"Height of visual object\";
//   input Real jointRRR3.shape_rev2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real jointRRR3.shape_rev2.color[1] = Real(jointRRR3.cylinderColor[1]) \"Color of shape\";
//   input Real jointRRR3.shape_rev2.color[2] = Real(jointRRR3.cylinderColor[2]) \"Color of shape\";
//   input Real jointRRR3.shape_rev2.color[3] = Real(jointRRR3.cylinderColor[3]) \"Color of shape\";
//   input Real jointRRR3.shape_rev2.specularCoefficient = jointRRR3.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real jointRRR3.shape_rev2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({jointRRR3.shape_rev2.lengthDirection[1],jointRRR3.shape_rev2.lengthDirection[2],jointRRR3.shape_rev2.lengthDirection[3]});
//   protected Real jointRRR3.shape_rev2.e_x[1](unit = \"1\") = if noEvent(jointRRR3.shape_rev2.abs_n_x < 1e-10) then 1.0 else jointRRR3.shape_rev2.lengthDirection[1] / jointRRR3.shape_rev2.abs_n_x;
//   protected Real jointRRR3.shape_rev2.e_x[2](unit = \"1\") = if noEvent(jointRRR3.shape_rev2.abs_n_x < 1e-10) then 0.0 else jointRRR3.shape_rev2.lengthDirection[2] / jointRRR3.shape_rev2.abs_n_x;
//   protected Real jointRRR3.shape_rev2.e_x[3](unit = \"1\") = if noEvent(jointRRR3.shape_rev2.abs_n_x < 1e-10) then 0.0 else jointRRR3.shape_rev2.lengthDirection[3] / jointRRR3.shape_rev2.abs_n_x;
//   protected Real jointRRR3.shape_rev2.n_z_aux[1](unit = \"1\") = jointRRR3.shape_rev2.e_x[2] * jointRRR3.shape_rev2.widthDirection[3] - jointRRR3.shape_rev2.e_x[3] * jointRRR3.shape_rev2.widthDirection[2];
//   protected Real jointRRR3.shape_rev2.n_z_aux[2](unit = \"1\") = jointRRR3.shape_rev2.e_x[3] * jointRRR3.shape_rev2.widthDirection[1] - jointRRR3.shape_rev2.e_x[1] * jointRRR3.shape_rev2.widthDirection[3];
//   protected Real jointRRR3.shape_rev2.n_z_aux[3](unit = \"1\") = jointRRR3.shape_rev2.e_x[1] * jointRRR3.shape_rev2.widthDirection[2] - jointRRR3.shape_rev2.e_x[2] * jointRRR3.shape_rev2.widthDirection[1];
//   protected Real jointRRR3.shape_rev2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR3.shape_rev2.e_x[1],jointRRR3.shape_rev2.e_x[2],jointRRR3.shape_rev2.e_x[3]},if noEvent(jointRRR3.shape_rev2.n_z_aux[1] ^ 2.0 + (jointRRR3.shape_rev2.n_z_aux[2] ^ 2.0 + jointRRR3.shape_rev2.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR3.shape_rev2.widthDirection[1],jointRRR3.shape_rev2.widthDirection[2],jointRRR3.shape_rev2.widthDirection[3]} else if noEvent(abs(jointRRR3.shape_rev2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR3.shape_rev2.e_x[1],jointRRR3.shape_rev2.e_x[2],jointRRR3.shape_rev2.e_x[3]})[1];
//   protected Real jointRRR3.shape_rev2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR3.shape_rev2.e_x[1],jointRRR3.shape_rev2.e_x[2],jointRRR3.shape_rev2.e_x[3]},if noEvent(jointRRR3.shape_rev2.n_z_aux[1] ^ 2.0 + (jointRRR3.shape_rev2.n_z_aux[2] ^ 2.0 + jointRRR3.shape_rev2.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR3.shape_rev2.widthDirection[1],jointRRR3.shape_rev2.widthDirection[2],jointRRR3.shape_rev2.widthDirection[3]} else if noEvent(abs(jointRRR3.shape_rev2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR3.shape_rev2.e_x[1],jointRRR3.shape_rev2.e_x[2],jointRRR3.shape_rev2.e_x[3]})[2];
//   protected Real jointRRR3.shape_rev2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR3.shape_rev2.e_x[1],jointRRR3.shape_rev2.e_x[2],jointRRR3.shape_rev2.e_x[3]},if noEvent(jointRRR3.shape_rev2.n_z_aux[1] ^ 2.0 + (jointRRR3.shape_rev2.n_z_aux[2] ^ 2.0 + jointRRR3.shape_rev2.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR3.shape_rev2.widthDirection[1],jointRRR3.shape_rev2.widthDirection[2],jointRRR3.shape_rev2.widthDirection[3]} else if noEvent(abs(jointRRR3.shape_rev2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR3.shape_rev2.e_x[1],jointRRR3.shape_rev2.e_x[2],jointRRR3.shape_rev2.e_x[3]})[3];
//   protected output Real jointRRR3.shape_rev2.Form;
//   output Real jointRRR3.shape_rev2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR3.shape_rev2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR3.shape_rev2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR3.shape_rev2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR3.shape_rev2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR3.shape_rev2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR3.shape_rev2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real jointRRR3.shape_rev2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real jointRRR3.shape_rev2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real jointRRR3.shape_rev2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR3.shape_rev2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR3.shape_rev2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR3.shape_rev2.Material;
//   protected output Real jointRRR3.shape_rev2.Extra;
//   parameter String jointRRR3.shape_rev3.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real jointRRR3.shape_rev3.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rev3.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rev3.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rev3.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rev3.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rev3.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rev3.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rev3.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rev3.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rev3.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR3.shape_rev3.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR3.shape_rev3.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR3.shape_rev3.r[1](quantity = \"Length\", unit = \"m\") = jointRRR3.frame_b.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR3.shape_rev3.r[2](quantity = \"Length\", unit = \"m\") = jointRRR3.frame_b.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR3.shape_rev3.r[3](quantity = \"Length\", unit = \"m\") = jointRRR3.frame_b.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR3.shape_rev3.r_shape[1](quantity = \"Length\", unit = \"m\") = (-jointRRR3.cylinderLength) * jointRRR3.e_b[1] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR3.shape_rev3.r_shape[2](quantity = \"Length\", unit = \"m\") = (-jointRRR3.cylinderLength) * jointRRR3.e_b[2] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR3.shape_rev3.r_shape[3](quantity = \"Length\", unit = \"m\") = (-jointRRR3.cylinderLength) * jointRRR3.e_b[3] / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR3.shape_rev3.lengthDirection[1](unit = \"1\") = jointRRR3.e_b[1] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR3.shape_rev3.lengthDirection[2](unit = \"1\") = jointRRR3.e_b[2] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR3.shape_rev3.lengthDirection[3](unit = \"1\") = jointRRR3.e_b[3] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR3.shape_rev3.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR3.shape_rev3.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR3.shape_rev3.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR3.shape_rev3.length(quantity = \"Length\", unit = \"m\") = jointRRR3.cylinderLength \"Length of visual object\";
//   input Real jointRRR3.shape_rev3.width(quantity = \"Length\", unit = \"m\") = jointRRR3.cylinderDiameter \"Width of visual object\";
//   input Real jointRRR3.shape_rev3.height(quantity = \"Length\", unit = \"m\") = jointRRR3.cylinderDiameter \"Height of visual object\";
//   input Real jointRRR3.shape_rev3.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real jointRRR3.shape_rev3.color[1] = Real(jointRRR3.cylinderColor[1]) \"Color of shape\";
//   input Real jointRRR3.shape_rev3.color[2] = Real(jointRRR3.cylinderColor[2]) \"Color of shape\";
//   input Real jointRRR3.shape_rev3.color[3] = Real(jointRRR3.cylinderColor[3]) \"Color of shape\";
//   input Real jointRRR3.shape_rev3.specularCoefficient = jointRRR3.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real jointRRR3.shape_rev3.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({jointRRR3.shape_rev3.lengthDirection[1],jointRRR3.shape_rev3.lengthDirection[2],jointRRR3.shape_rev3.lengthDirection[3]});
//   protected Real jointRRR3.shape_rev3.e_x[1](unit = \"1\") = if noEvent(jointRRR3.shape_rev3.abs_n_x < 1e-10) then 1.0 else jointRRR3.shape_rev3.lengthDirection[1] / jointRRR3.shape_rev3.abs_n_x;
//   protected Real jointRRR3.shape_rev3.e_x[2](unit = \"1\") = if noEvent(jointRRR3.shape_rev3.abs_n_x < 1e-10) then 0.0 else jointRRR3.shape_rev3.lengthDirection[2] / jointRRR3.shape_rev3.abs_n_x;
//   protected Real jointRRR3.shape_rev3.e_x[3](unit = \"1\") = if noEvent(jointRRR3.shape_rev3.abs_n_x < 1e-10) then 0.0 else jointRRR3.shape_rev3.lengthDirection[3] / jointRRR3.shape_rev3.abs_n_x;
//   protected Real jointRRR3.shape_rev3.n_z_aux[1](unit = \"1\") = jointRRR3.shape_rev3.e_x[2] * jointRRR3.shape_rev3.widthDirection[3] - jointRRR3.shape_rev3.e_x[3] * jointRRR3.shape_rev3.widthDirection[2];
//   protected Real jointRRR3.shape_rev3.n_z_aux[2](unit = \"1\") = jointRRR3.shape_rev3.e_x[3] * jointRRR3.shape_rev3.widthDirection[1] - jointRRR3.shape_rev3.e_x[1] * jointRRR3.shape_rev3.widthDirection[3];
//   protected Real jointRRR3.shape_rev3.n_z_aux[3](unit = \"1\") = jointRRR3.shape_rev3.e_x[1] * jointRRR3.shape_rev3.widthDirection[2] - jointRRR3.shape_rev3.e_x[2] * jointRRR3.shape_rev3.widthDirection[1];
//   protected Real jointRRR3.shape_rev3.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR3.shape_rev3.e_x[1],jointRRR3.shape_rev3.e_x[2],jointRRR3.shape_rev3.e_x[3]},if noEvent(jointRRR3.shape_rev3.n_z_aux[1] ^ 2.0 + (jointRRR3.shape_rev3.n_z_aux[2] ^ 2.0 + jointRRR3.shape_rev3.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR3.shape_rev3.widthDirection[1],jointRRR3.shape_rev3.widthDirection[2],jointRRR3.shape_rev3.widthDirection[3]} else if noEvent(abs(jointRRR3.shape_rev3.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR3.shape_rev3.e_x[1],jointRRR3.shape_rev3.e_x[2],jointRRR3.shape_rev3.e_x[3]})[1];
//   protected Real jointRRR3.shape_rev3.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR3.shape_rev3.e_x[1],jointRRR3.shape_rev3.e_x[2],jointRRR3.shape_rev3.e_x[3]},if noEvent(jointRRR3.shape_rev3.n_z_aux[1] ^ 2.0 + (jointRRR3.shape_rev3.n_z_aux[2] ^ 2.0 + jointRRR3.shape_rev3.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR3.shape_rev3.widthDirection[1],jointRRR3.shape_rev3.widthDirection[2],jointRRR3.shape_rev3.widthDirection[3]} else if noEvent(abs(jointRRR3.shape_rev3.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR3.shape_rev3.e_x[1],jointRRR3.shape_rev3.e_x[2],jointRRR3.shape_rev3.e_x[3]})[2];
//   protected Real jointRRR3.shape_rev3.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR3.shape_rev3.e_x[1],jointRRR3.shape_rev3.e_x[2],jointRRR3.shape_rev3.e_x[3]},if noEvent(jointRRR3.shape_rev3.n_z_aux[1] ^ 2.0 + (jointRRR3.shape_rev3.n_z_aux[2] ^ 2.0 + jointRRR3.shape_rev3.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR3.shape_rev3.widthDirection[1],jointRRR3.shape_rev3.widthDirection[2],jointRRR3.shape_rev3.widthDirection[3]} else if noEvent(abs(jointRRR3.shape_rev3.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR3.shape_rev3.e_x[1],jointRRR3.shape_rev3.e_x[2],jointRRR3.shape_rev3.e_x[3]})[3];
//   protected output Real jointRRR3.shape_rev3.Form;
//   output Real jointRRR3.shape_rev3.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR3.shape_rev3.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR3.shape_rev3.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR3.shape_rev3.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR3.shape_rev3.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR3.shape_rev3.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR3.shape_rev3.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real jointRRR3.shape_rev3.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real jointRRR3.shape_rev3.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real jointRRR3.shape_rev3.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR3.shape_rev3.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR3.shape_rev3.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR3.shape_rev3.Material;
//   protected output Real jointRRR3.shape_rev3.Extra;
//   parameter String jointRRR3.shape_rod1.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real jointRRR3.shape_rod1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rod1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rod1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rod1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rod1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rod1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rod1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rod1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rod1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rod1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR3.shape_rod1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR3.shape_rod1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR3.shape_rod1.r[1](quantity = \"Length\", unit = \"m\") = jointRRR3.frame_ia.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR3.shape_rod1.r[2](quantity = \"Length\", unit = \"m\") = jointRRR3.frame_ia.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR3.shape_rod1.r[3](quantity = \"Length\", unit = \"m\") = jointRRR3.frame_ia.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR3.shape_rod1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR3.shape_rod1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR3.shape_rod1.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR3.shape_rod1.lengthDirection[1](unit = \"1\") = jointRRR3.rRod1_ia[1] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR3.shape_rod1.lengthDirection[2](unit = \"1\") = jointRRR3.rRod1_ia[2] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR3.shape_rod1.lengthDirection[3](unit = \"1\") = jointRRR3.rRod1_ia[3] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR3.shape_rod1.widthDirection[1](unit = \"1\") = jointRRR3.e_ia[1] \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR3.shape_rod1.widthDirection[2](unit = \"1\") = jointRRR3.e_ia[2] \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR3.shape_rod1.widthDirection[3](unit = \"1\") = jointRRR3.e_ia[3] \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR3.shape_rod1.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({jointRRR3.rRod1_ia[1],jointRRR3.rRod1_ia[2],jointRRR3.rRod1_ia[3]}) \"Length of visual object\";
//   input Real jointRRR3.shape_rod1.width(quantity = \"Length\", unit = \"m\") = jointRRR3.rodDiameter \"Width of visual object\";
//   input Real jointRRR3.shape_rod1.height(quantity = \"Length\", unit = \"m\") = jointRRR3.rodDiameter \"Height of visual object\";
//   input Real jointRRR3.shape_rod1.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real jointRRR3.shape_rod1.color[1] = Real(jointRRR3.rodColor[1]) \"Color of shape\";
//   input Real jointRRR3.shape_rod1.color[2] = Real(jointRRR3.rodColor[2]) \"Color of shape\";
//   input Real jointRRR3.shape_rod1.color[3] = Real(jointRRR3.rodColor[3]) \"Color of shape\";
//   input Real jointRRR3.shape_rod1.specularCoefficient = jointRRR3.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real jointRRR3.shape_rod1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({jointRRR3.shape_rod1.lengthDirection[1],jointRRR3.shape_rod1.lengthDirection[2],jointRRR3.shape_rod1.lengthDirection[3]});
//   protected Real jointRRR3.shape_rod1.e_x[1](unit = \"1\") = if noEvent(jointRRR3.shape_rod1.abs_n_x < 1e-10) then 1.0 else jointRRR3.shape_rod1.lengthDirection[1] / jointRRR3.shape_rod1.abs_n_x;
//   protected Real jointRRR3.shape_rod1.e_x[2](unit = \"1\") = if noEvent(jointRRR3.shape_rod1.abs_n_x < 1e-10) then 0.0 else jointRRR3.shape_rod1.lengthDirection[2] / jointRRR3.shape_rod1.abs_n_x;
//   protected Real jointRRR3.shape_rod1.e_x[3](unit = \"1\") = if noEvent(jointRRR3.shape_rod1.abs_n_x < 1e-10) then 0.0 else jointRRR3.shape_rod1.lengthDirection[3] / jointRRR3.shape_rod1.abs_n_x;
//   protected Real jointRRR3.shape_rod1.n_z_aux[1](unit = \"1\") = jointRRR3.shape_rod1.e_x[2] * jointRRR3.shape_rod1.widthDirection[3] - jointRRR3.shape_rod1.e_x[3] * jointRRR3.shape_rod1.widthDirection[2];
//   protected Real jointRRR3.shape_rod1.n_z_aux[2](unit = \"1\") = jointRRR3.shape_rod1.e_x[3] * jointRRR3.shape_rod1.widthDirection[1] - jointRRR3.shape_rod1.e_x[1] * jointRRR3.shape_rod1.widthDirection[3];
//   protected Real jointRRR3.shape_rod1.n_z_aux[3](unit = \"1\") = jointRRR3.shape_rod1.e_x[1] * jointRRR3.shape_rod1.widthDirection[2] - jointRRR3.shape_rod1.e_x[2] * jointRRR3.shape_rod1.widthDirection[1];
//   protected Real jointRRR3.shape_rod1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR3.shape_rod1.e_x[1],jointRRR3.shape_rod1.e_x[2],jointRRR3.shape_rod1.e_x[3]},if noEvent(jointRRR3.shape_rod1.n_z_aux[1] ^ 2.0 + (jointRRR3.shape_rod1.n_z_aux[2] ^ 2.0 + jointRRR3.shape_rod1.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR3.shape_rod1.widthDirection[1],jointRRR3.shape_rod1.widthDirection[2],jointRRR3.shape_rod1.widthDirection[3]} else if noEvent(abs(jointRRR3.shape_rod1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR3.shape_rod1.e_x[1],jointRRR3.shape_rod1.e_x[2],jointRRR3.shape_rod1.e_x[3]})[1];
//   protected Real jointRRR3.shape_rod1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR3.shape_rod1.e_x[1],jointRRR3.shape_rod1.e_x[2],jointRRR3.shape_rod1.e_x[3]},if noEvent(jointRRR3.shape_rod1.n_z_aux[1] ^ 2.0 + (jointRRR3.shape_rod1.n_z_aux[2] ^ 2.0 + jointRRR3.shape_rod1.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR3.shape_rod1.widthDirection[1],jointRRR3.shape_rod1.widthDirection[2],jointRRR3.shape_rod1.widthDirection[3]} else if noEvent(abs(jointRRR3.shape_rod1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR3.shape_rod1.e_x[1],jointRRR3.shape_rod1.e_x[2],jointRRR3.shape_rod1.e_x[3]})[2];
//   protected Real jointRRR3.shape_rod1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR3.shape_rod1.e_x[1],jointRRR3.shape_rod1.e_x[2],jointRRR3.shape_rod1.e_x[3]},if noEvent(jointRRR3.shape_rod1.n_z_aux[1] ^ 2.0 + (jointRRR3.shape_rod1.n_z_aux[2] ^ 2.0 + jointRRR3.shape_rod1.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR3.shape_rod1.widthDirection[1],jointRRR3.shape_rod1.widthDirection[2],jointRRR3.shape_rod1.widthDirection[3]} else if noEvent(abs(jointRRR3.shape_rod1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR3.shape_rod1.e_x[1],jointRRR3.shape_rod1.e_x[2],jointRRR3.shape_rod1.e_x[3]})[3];
//   protected output Real jointRRR3.shape_rod1.Form;
//   output Real jointRRR3.shape_rod1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR3.shape_rod1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR3.shape_rod1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR3.shape_rod1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR3.shape_rod1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR3.shape_rod1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR3.shape_rod1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real jointRRR3.shape_rod1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real jointRRR3.shape_rod1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real jointRRR3.shape_rod1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR3.shape_rod1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR3.shape_rod1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR3.shape_rod1.Material;
//   protected output Real jointRRR3.shape_rod1.Extra;
//   parameter String jointRRR3.shape_rod2.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real jointRRR3.shape_rod2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rod2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rod2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rod2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rod2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rod2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rod2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rod2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rod2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real jointRRR3.shape_rod2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR3.shape_rod2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR3.shape_rod2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real jointRRR3.shape_rod2.r[1](quantity = \"Length\", unit = \"m\") = jointRRR3.frame_ib.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR3.shape_rod2.r[2](quantity = \"Length\", unit = \"m\") = jointRRR3.frame_ib.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR3.shape_rod2.r[3](quantity = \"Length\", unit = \"m\") = jointRRR3.frame_ib.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real jointRRR3.shape_rod2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR3.shape_rod2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR3.shape_rod2.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real jointRRR3.shape_rod2.lengthDirection[1](unit = \"1\") = jointRRR3.rRod2_ib[1] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR3.shape_rod2.lengthDirection[2](unit = \"1\") = jointRRR3.rRod2_ib[2] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR3.shape_rod2.lengthDirection[3](unit = \"1\") = jointRRR3.rRod2_ib[3] \"Vector in length direction, resolved in object frame\";
//   input Real jointRRR3.shape_rod2.widthDirection[1](unit = \"1\") = jointRRR3.e_b[1] \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR3.shape_rod2.widthDirection[2](unit = \"1\") = jointRRR3.e_b[2] \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR3.shape_rod2.widthDirection[3](unit = \"1\") = jointRRR3.e_b[3] \"Vector in width direction, resolved in object frame\";
//   input Real jointRRR3.shape_rod2.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({jointRRR3.rRod2_ib[1],jointRRR3.rRod2_ib[2],jointRRR3.rRod2_ib[3]}) \"Length of visual object\";
//   input Real jointRRR3.shape_rod2.width(quantity = \"Length\", unit = \"m\") = jointRRR3.rodDiameter \"Width of visual object\";
//   input Real jointRRR3.shape_rod2.height(quantity = \"Length\", unit = \"m\") = jointRRR3.rodDiameter \"Height of visual object\";
//   input Real jointRRR3.shape_rod2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real jointRRR3.shape_rod2.color[1] = Real(jointRRR3.rodColor[1]) \"Color of shape\";
//   input Real jointRRR3.shape_rod2.color[2] = Real(jointRRR3.rodColor[2]) \"Color of shape\";
//   input Real jointRRR3.shape_rod2.color[3] = Real(jointRRR3.rodColor[3]) \"Color of shape\";
//   input Real jointRRR3.shape_rod2.specularCoefficient = jointRRR3.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real jointRRR3.shape_rod2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({jointRRR3.shape_rod2.lengthDirection[1],jointRRR3.shape_rod2.lengthDirection[2],jointRRR3.shape_rod2.lengthDirection[3]});
//   protected Real jointRRR3.shape_rod2.e_x[1](unit = \"1\") = if noEvent(jointRRR3.shape_rod2.abs_n_x < 1e-10) then 1.0 else jointRRR3.shape_rod2.lengthDirection[1] / jointRRR3.shape_rod2.abs_n_x;
//   protected Real jointRRR3.shape_rod2.e_x[2](unit = \"1\") = if noEvent(jointRRR3.shape_rod2.abs_n_x < 1e-10) then 0.0 else jointRRR3.shape_rod2.lengthDirection[2] / jointRRR3.shape_rod2.abs_n_x;
//   protected Real jointRRR3.shape_rod2.e_x[3](unit = \"1\") = if noEvent(jointRRR3.shape_rod2.abs_n_x < 1e-10) then 0.0 else jointRRR3.shape_rod2.lengthDirection[3] / jointRRR3.shape_rod2.abs_n_x;
//   protected Real jointRRR3.shape_rod2.n_z_aux[1](unit = \"1\") = jointRRR3.shape_rod2.e_x[2] * jointRRR3.shape_rod2.widthDirection[3] - jointRRR3.shape_rod2.e_x[3] * jointRRR3.shape_rod2.widthDirection[2];
//   protected Real jointRRR3.shape_rod2.n_z_aux[2](unit = \"1\") = jointRRR3.shape_rod2.e_x[3] * jointRRR3.shape_rod2.widthDirection[1] - jointRRR3.shape_rod2.e_x[1] * jointRRR3.shape_rod2.widthDirection[3];
//   protected Real jointRRR3.shape_rod2.n_z_aux[3](unit = \"1\") = jointRRR3.shape_rod2.e_x[1] * jointRRR3.shape_rod2.widthDirection[2] - jointRRR3.shape_rod2.e_x[2] * jointRRR3.shape_rod2.widthDirection[1];
//   protected Real jointRRR3.shape_rod2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR3.shape_rod2.e_x[1],jointRRR3.shape_rod2.e_x[2],jointRRR3.shape_rod2.e_x[3]},if noEvent(jointRRR3.shape_rod2.n_z_aux[1] ^ 2.0 + (jointRRR3.shape_rod2.n_z_aux[2] ^ 2.0 + jointRRR3.shape_rod2.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR3.shape_rod2.widthDirection[1],jointRRR3.shape_rod2.widthDirection[2],jointRRR3.shape_rod2.widthDirection[3]} else if noEvent(abs(jointRRR3.shape_rod2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR3.shape_rod2.e_x[1],jointRRR3.shape_rod2.e_x[2],jointRRR3.shape_rod2.e_x[3]})[1];
//   protected Real jointRRR3.shape_rod2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR3.shape_rod2.e_x[1],jointRRR3.shape_rod2.e_x[2],jointRRR3.shape_rod2.e_x[3]},if noEvent(jointRRR3.shape_rod2.n_z_aux[1] ^ 2.0 + (jointRRR3.shape_rod2.n_z_aux[2] ^ 2.0 + jointRRR3.shape_rod2.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR3.shape_rod2.widthDirection[1],jointRRR3.shape_rod2.widthDirection[2],jointRRR3.shape_rod2.widthDirection[3]} else if noEvent(abs(jointRRR3.shape_rod2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR3.shape_rod2.e_x[1],jointRRR3.shape_rod2.e_x[2],jointRRR3.shape_rod2.e_x[3]})[2];
//   protected Real jointRRR3.shape_rod2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({jointRRR3.shape_rod2.e_x[1],jointRRR3.shape_rod2.e_x[2],jointRRR3.shape_rod2.e_x[3]},if noEvent(jointRRR3.shape_rod2.n_z_aux[1] ^ 2.0 + (jointRRR3.shape_rod2.n_z_aux[2] ^ 2.0 + jointRRR3.shape_rod2.n_z_aux[3] ^ 2.0) > 1e-06) then {jointRRR3.shape_rod2.widthDirection[1],jointRRR3.shape_rod2.widthDirection[2],jointRRR3.shape_rod2.widthDirection[3]} else if noEvent(abs(jointRRR3.shape_rod2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{jointRRR3.shape_rod2.e_x[1],jointRRR3.shape_rod2.e_x[2],jointRRR3.shape_rod2.e_x[3]})[3];
//   protected output Real jointRRR3.shape_rod2.Form;
//   output Real jointRRR3.shape_rod2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR3.shape_rod2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR3.shape_rod2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR3.shape_rod2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR3.shape_rod2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR3.shape_rod2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real jointRRR3.shape_rod2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real jointRRR3.shape_rod2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real jointRRR3.shape_rod2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real jointRRR3.shape_rod2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR3.shape_rod2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR3.shape_rod2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real jointRRR3.shape_rod2.Material;
//   protected output Real jointRRR3.shape_rod2.Extra;
//   parameter Real jointRRR3.e_a[1](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR3.n_a[1],jointRRR3.n_a[2],jointRRR3.n_a[3]},1e-13)[1] \"Unit vector along axes of rotations, resolved in frame_a\";
//   parameter Real jointRRR3.e_a[2](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR3.n_a[1],jointRRR3.n_a[2],jointRRR3.n_a[3]},1e-13)[2] \"Unit vector along axes of rotations, resolved in frame_a\";
//   parameter Real jointRRR3.e_a[3](unit = \"1\") = Modelica.Math.Vectors.normalize({jointRRR3.n_a[1],jointRRR3.n_a[2],jointRRR3.n_a[3]},1e-13)[3] \"Unit vector along axes of rotations, resolved in frame_a\";
//   parameter Real jointRRR3.rodDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 1.1 * jointRRR3.cylinderDiameter \"Diameter of the two rods connecting the revolute joints\";
//   Real rod4.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real rod4.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real rod4.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real rod4.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real rod4.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real rod4.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real rod4.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real rod4.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real rod4.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real rod4.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real rod4.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real rod4.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real rod4.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real rod4.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real rod4.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real rod4.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real rod4.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real rod4.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real rod4.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real rod4.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real rod4.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real rod4.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real rod4.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real rod4.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real rod4.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real rod4.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real rod4.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real rod4.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real rod4.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real rod4.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real rod4.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real rod4.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real rod4.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real rod4.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real rod4.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real rod4.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real rod4.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real rod4.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real rod4.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real rod4.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real rod4.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real rod4.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean rod4.animation = true \"= true, if animation shall be enabled\";
//   parameter Real rod4.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = rh[1] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real rod4.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = rh[2] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real rod4.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = rh[3] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter String rod4.shapeType = \"cylinder\" \" Type of shape\";
//   parameter Real rod4.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real rod4.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real rod4.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real rod4.widthDirection[1](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real rod4.widthDirection[2](unit = \"1\") = 1.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real rod4.widthDirection[3](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real rod4.extra = 0.0 \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer rod4.color[1](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer rod4.color[2](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer rod4.color[3](min = 0, max = 255) = 155 \" Color of shape\";
//   input Real rod4.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter String rod4.shape.shapeType = rod4.shapeType \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real rod4.shape.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real rod4.shape.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real rod4.shape.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real rod4.shape.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real rod4.shape.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real rod4.shape.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real rod4.shape.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real rod4.shape.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real rod4.shape.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real rod4.shape.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rod4.shape.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rod4.shape.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real rod4.shape.r[1](quantity = \"Length\", unit = \"m\") = rod4.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rod4.shape.r[2](quantity = \"Length\", unit = \"m\") = rod4.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rod4.shape.r[3](quantity = \"Length\", unit = \"m\") = rod4.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real rod4.shape.r_shape[1](quantity = \"Length\", unit = \"m\") = rod4.r_shape[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rod4.shape.r_shape[2](quantity = \"Length\", unit = \"m\") = rod4.r_shape[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rod4.shape.r_shape[3](quantity = \"Length\", unit = \"m\") = rod4.r_shape[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real rod4.shape.lengthDirection[1](unit = \"1\") = rod4.lengthDirection[1] \"Vector in length direction, resolved in object frame\";
//   input Real rod4.shape.lengthDirection[2](unit = \"1\") = rod4.lengthDirection[2] \"Vector in length direction, resolved in object frame\";
//   input Real rod4.shape.lengthDirection[3](unit = \"1\") = rod4.lengthDirection[3] \"Vector in length direction, resolved in object frame\";
//   input Real rod4.shape.widthDirection[1](unit = \"1\") = rod4.widthDirection[1] \"Vector in width direction, resolved in object frame\";
//   input Real rod4.shape.widthDirection[2](unit = \"1\") = rod4.widthDirection[2] \"Vector in width direction, resolved in object frame\";
//   input Real rod4.shape.widthDirection[3](unit = \"1\") = rod4.widthDirection[3] \"Vector in width direction, resolved in object frame\";
//   input Real rod4.shape.length(quantity = \"Length\", unit = \"m\") = rod4.length \"Length of visual object\";
//   input Real rod4.shape.width(quantity = \"Length\", unit = \"m\") = rod4.width \"Width of visual object\";
//   input Real rod4.shape.height(quantity = \"Length\", unit = \"m\") = rod4.height \"Height of visual object\";
//   input Real rod4.shape.extra = rod4.extra \"Additional size data for some of the shape types\";
//   input Real rod4.shape.color[1] = Real(rod4.color[1]) \"Color of shape\";
//   input Real rod4.shape.color[2] = Real(rod4.color[2]) \"Color of shape\";
//   input Real rod4.shape.color[3] = Real(rod4.color[3]) \"Color of shape\";
//   input Real rod4.shape.specularCoefficient = rod4.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real rod4.shape.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({rod4.shape.lengthDirection[1],rod4.shape.lengthDirection[2],rod4.shape.lengthDirection[3]});
//   protected Real rod4.shape.e_x[1](unit = \"1\") = if noEvent(rod4.shape.abs_n_x < 1e-10) then 1.0 else rod4.shape.lengthDirection[1] / rod4.shape.abs_n_x;
//   protected Real rod4.shape.e_x[2](unit = \"1\") = if noEvent(rod4.shape.abs_n_x < 1e-10) then 0.0 else rod4.shape.lengthDirection[2] / rod4.shape.abs_n_x;
//   protected Real rod4.shape.e_x[3](unit = \"1\") = if noEvent(rod4.shape.abs_n_x < 1e-10) then 0.0 else rod4.shape.lengthDirection[3] / rod4.shape.abs_n_x;
//   protected Real rod4.shape.n_z_aux[1](unit = \"1\") = rod4.shape.e_x[2] * rod4.shape.widthDirection[3] - rod4.shape.e_x[3] * rod4.shape.widthDirection[2];
//   protected Real rod4.shape.n_z_aux[2](unit = \"1\") = rod4.shape.e_x[3] * rod4.shape.widthDirection[1] - rod4.shape.e_x[1] * rod4.shape.widthDirection[3];
//   protected Real rod4.shape.n_z_aux[3](unit = \"1\") = rod4.shape.e_x[1] * rod4.shape.widthDirection[2] - rod4.shape.e_x[2] * rod4.shape.widthDirection[1];
//   protected Real rod4.shape.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rod4.shape.e_x[1],rod4.shape.e_x[2],rod4.shape.e_x[3]},if noEvent(rod4.shape.n_z_aux[1] ^ 2.0 + (rod4.shape.n_z_aux[2] ^ 2.0 + rod4.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {rod4.shape.widthDirection[1],rod4.shape.widthDirection[2],rod4.shape.widthDirection[3]} else if noEvent(abs(rod4.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rod4.shape.e_x[1],rod4.shape.e_x[2],rod4.shape.e_x[3]})[1];
//   protected Real rod4.shape.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rod4.shape.e_x[1],rod4.shape.e_x[2],rod4.shape.e_x[3]},if noEvent(rod4.shape.n_z_aux[1] ^ 2.0 + (rod4.shape.n_z_aux[2] ^ 2.0 + rod4.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {rod4.shape.widthDirection[1],rod4.shape.widthDirection[2],rod4.shape.widthDirection[3]} else if noEvent(abs(rod4.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rod4.shape.e_x[1],rod4.shape.e_x[2],rod4.shape.e_x[3]})[2];
//   protected Real rod4.shape.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({rod4.shape.e_x[1],rod4.shape.e_x[2],rod4.shape.e_x[3]},if noEvent(rod4.shape.n_z_aux[1] ^ 2.0 + (rod4.shape.n_z_aux[2] ^ 2.0 + rod4.shape.n_z_aux[3] ^ 2.0) > 1e-06) then {rod4.shape.widthDirection[1],rod4.shape.widthDirection[2],rod4.shape.widthDirection[3]} else if noEvent(abs(rod4.shape.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{rod4.shape.e_x[1],rod4.shape.e_x[2],rod4.shape.e_x[3]})[3];
//   protected output Real rod4.shape.Form;
//   output Real rod4.shape.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rod4.shape.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rod4.shape.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real rod4.shape.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rod4.shape.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rod4.shape.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real rod4.shape.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rod4.shape.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real rod4.shape.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real rod4.shape.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rod4.shape.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rod4.shape.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real rod4.shape.Material;
//   protected output Real rod4.shape.Extra;
//   parameter Real rod4.lengthDirection[1](unit = \"1\") = rod4.r[1] - rod4.r_shape[1] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real rod4.lengthDirection[2](unit = \"1\") = rod4.r[2] - rod4.r_shape[2] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real rod4.lengthDirection[3](unit = \"1\") = rod4.r[3] - rod4.r_shape[3] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real rod4.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({rod4.r[1] - rod4.r_shape[1],rod4.r[2] - rod4.r_shape[2],rod4.r[3] - rod4.r_shape[3]}) \" Length of shape\";
//   parameter Real rod4.width(quantity = \"Length\", unit = \"m\", min = 0.0) = rod4.length / world.defaultWidthFraction \" Width of shape\";
//   parameter Real rod4.height(quantity = \"Length\", unit = \"m\", min = 0.0) = rod4.width \" Height of shape.\";
//   Real body3.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real body3.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real body3.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real body3.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real body3.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real body3.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real body3.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real body3.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real body3.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real body3.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real body3.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real body3.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real body3.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real body3.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real body3.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real body3.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real body3.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real body3.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real body3.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real body3.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real body3.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean body3.animation = true \"= true, if animation shall be enabled (show cylinder and sphere)\";
//   parameter Real body3.r_CM[1](quantity = \"Length\", unit = \"m\", start = 0.0) = jointRRR3.rRod1_ia[1] / 2.0 \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real body3.r_CM[2](quantity = \"Length\", unit = \"m\", start = 0.0) = jointRRR3.rRod1_ia[2] / 2.0 \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real body3.r_CM[3](quantity = \"Length\", unit = \"m\", start = 0.0) = jointRRR3.rRod1_ia[3] / 2.0 \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real body3.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 1.0) = 1.0 \"Mass of rigid body\";
//   parameter Real body3.I_11(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.001 \" (1,1) element of inertia tensor\";
//   parameter Real body3.I_22(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.001 \" (2,2) element of inertia tensor\";
//   parameter Real body3.I_33(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.001 \" (3,3) element of inertia tensor\";
//   parameter Real body3.I_21(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (2,1) element of inertia tensor\";
//   parameter Real body3.I_31(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (3,1) element of inertia tensor\";
//   parameter Real body3.I_32(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (3,2) element of inertia tensor\";
//   Real body3.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real body3.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real body3.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real body3.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real body3.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real body3.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real body3.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real body3.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real body3.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean body3.angles_fixed = false \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real body3.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real body3.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real body3.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer body3.sequence_start[1](min = 1, max = 3) = 1 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer body3.sequence_start[2](min = 1, max = 3) = 2 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer body3.sequence_start[3](min = 1, max = 3) = 3 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean body3.w_0_fixed = false \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real body3.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real body3.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real body3.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean body3.z_0_fixed = false \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real body3.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real body3.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real body3.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real body3.sphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = world.defaultBodyDiameter \"Diameter of sphere\";
//   input Integer body3.sphereColor[1](min = 0, max = 255) = 0 \"Color of sphere\";
//   input Integer body3.sphereColor[2](min = 0, max = 255) = 128 \"Color of sphere\";
//   input Integer body3.sphereColor[3](min = 0, max = 255) = 255 \"Color of sphere\";
//   input Integer body3.cylinderColor[1](min = 0, max = 255) = 155 \"Color of cylinder\";
//   input Integer body3.cylinderColor[2](min = 0, max = 255) = 155 \"Color of cylinder\";
//   input Integer body3.cylinderColor[3](min = 0, max = 255) = 155 \"Color of cylinder\";
//   input Real body3.specularCoefficient = world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean body3.enforceStates = false \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean body3.useQuaternions = true \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer body3.sequence_angleStates[1](min = 1, max = 3) = 1 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer body3.sequence_angleStates[2](min = 1, max = 3) = 2 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer body3.sequence_angleStates[3](min = 1, max = 3) = 3 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   Real body3.w_a[1](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body3.R_start,{body3.w_0_start[1],body3.w_0_start[2],body3.w_0_start[3]})[1], fixed = body3.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real body3.w_a[2](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body3.R_start,{body3.w_0_start[1],body3.w_0_start[2],body3.w_0_start[3]})[2], fixed = body3.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real body3.w_a[3](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body3.R_start,{body3.w_0_start[1],body3.w_0_start[2],body3.w_0_start[3]})[3], fixed = body3.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real body3.z_a[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body3.R_start,{body3.z_0_start[1],body3.z_0_start[2],body3.z_0_start[3]})[1], fixed = body3.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real body3.z_a[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body3.R_start,{body3.z_0_start[1],body3.z_0_start[2],body3.z_0_start[3]})[2], fixed = body3.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real body3.z_a[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(body3.R_start,{body3.z_0_start[1],body3.z_0_start[2],body3.z_0_start[3]})[3], fixed = body3.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real body3.g_0[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real body3.g_0[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real body3.g_0[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   protected Real body3.Q[1](start = body3.Q_start[1], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real body3.Q[2](start = body3.Q_start[2], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real body3.Q[3](start = body3.Q_start[3], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real body3.Q[4](start = body3.Q_start[4], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real body3.phi[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = body3.phi_start[1], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real body3.phi[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = body3.phi_start[2], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real body3.phi[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = body3.phi_start[3], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real body3.phi_d[1](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real body3.phi_d[2](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real body3.phi_d[3](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real body3.phi_dd[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real body3.phi_dd[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real body3.phi_dd[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   parameter String body3.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body3.cylinder.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real body3.cylinder.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real body3.cylinder.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real body3.cylinder.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real body3.cylinder.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real body3.cylinder.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real body3.cylinder.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real body3.cylinder.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real body3.cylinder.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real body3.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body3.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body3.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body3.cylinder.r[1](quantity = \"Length\", unit = \"m\") = body3.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body3.cylinder.r[2](quantity = \"Length\", unit = \"m\") = body3.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body3.cylinder.r[3](quantity = \"Length\", unit = \"m\") = body3.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body3.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body3.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body3.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body3.cylinder.lengthDirection[1](unit = \"1\") = body3.r_CM[1] \"Vector in length direction, resolved in object frame\";
//   input Real body3.cylinder.lengthDirection[2](unit = \"1\") = body3.r_CM[2] \"Vector in length direction, resolved in object frame\";
//   input Real body3.cylinder.lengthDirection[3](unit = \"1\") = body3.r_CM[3] \"Vector in length direction, resolved in object frame\";
//   input Real body3.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body3.cylinder.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body3.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body3.cylinder.length(quantity = \"Length\", unit = \"m\") = if Modelica.Math.Vectors.length({body3.r_CM[1],body3.r_CM[2],body3.r_CM[3]}) > body3.sphereDiameter / 2.0 then Modelica.Math.Vectors.length({body3.r_CM[1],body3.r_CM[2],body3.r_CM[3]}) - (if body3.cylinderDiameter > 1.1 * body3.sphereDiameter then body3.sphereDiameter / 2.0 else 0.0) else 0.0 \"Length of visual object\";
//   input Real body3.cylinder.width(quantity = \"Length\", unit = \"m\") = body3.cylinderDiameter \"Width of visual object\";
//   input Real body3.cylinder.height(quantity = \"Length\", unit = \"m\") = body3.cylinderDiameter \"Height of visual object\";
//   input Real body3.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body3.cylinder.color[1] = Real(body3.cylinderColor[1]) \"Color of shape\";
//   input Real body3.cylinder.color[2] = Real(body3.cylinderColor[2]) \"Color of shape\";
//   input Real body3.cylinder.color[3] = Real(body3.cylinderColor[3]) \"Color of shape\";
//   input Real body3.cylinder.specularCoefficient = body3.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body3.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body3.cylinder.lengthDirection[1],body3.cylinder.lengthDirection[2],body3.cylinder.lengthDirection[3]});
//   protected Real body3.cylinder.e_x[1](unit = \"1\") = if noEvent(body3.cylinder.abs_n_x < 1e-10) then 1.0 else body3.cylinder.lengthDirection[1] / body3.cylinder.abs_n_x;
//   protected Real body3.cylinder.e_x[2](unit = \"1\") = if noEvent(body3.cylinder.abs_n_x < 1e-10) then 0.0 else body3.cylinder.lengthDirection[2] / body3.cylinder.abs_n_x;
//   protected Real body3.cylinder.e_x[3](unit = \"1\") = if noEvent(body3.cylinder.abs_n_x < 1e-10) then 0.0 else body3.cylinder.lengthDirection[3] / body3.cylinder.abs_n_x;
//   protected Real body3.cylinder.n_z_aux[1](unit = \"1\") = body3.cylinder.e_x[2] * body3.cylinder.widthDirection[3] - body3.cylinder.e_x[3] * body3.cylinder.widthDirection[2];
//   protected Real body3.cylinder.n_z_aux[2](unit = \"1\") = body3.cylinder.e_x[3] * body3.cylinder.widthDirection[1] - body3.cylinder.e_x[1] * body3.cylinder.widthDirection[3];
//   protected Real body3.cylinder.n_z_aux[3](unit = \"1\") = body3.cylinder.e_x[1] * body3.cylinder.widthDirection[2] - body3.cylinder.e_x[2] * body3.cylinder.widthDirection[1];
//   protected Real body3.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body3.cylinder.e_x[1],body3.cylinder.e_x[2],body3.cylinder.e_x[3]},if noEvent(body3.cylinder.n_z_aux[1] ^ 2.0 + (body3.cylinder.n_z_aux[2] ^ 2.0 + body3.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {body3.cylinder.widthDirection[1],body3.cylinder.widthDirection[2],body3.cylinder.widthDirection[3]} else if noEvent(abs(body3.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body3.cylinder.e_x[1],body3.cylinder.e_x[2],body3.cylinder.e_x[3]})[1];
//   protected Real body3.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body3.cylinder.e_x[1],body3.cylinder.e_x[2],body3.cylinder.e_x[3]},if noEvent(body3.cylinder.n_z_aux[1] ^ 2.0 + (body3.cylinder.n_z_aux[2] ^ 2.0 + body3.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {body3.cylinder.widthDirection[1],body3.cylinder.widthDirection[2],body3.cylinder.widthDirection[3]} else if noEvent(abs(body3.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body3.cylinder.e_x[1],body3.cylinder.e_x[2],body3.cylinder.e_x[3]})[2];
//   protected Real body3.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body3.cylinder.e_x[1],body3.cylinder.e_x[2],body3.cylinder.e_x[3]},if noEvent(body3.cylinder.n_z_aux[1] ^ 2.0 + (body3.cylinder.n_z_aux[2] ^ 2.0 + body3.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {body3.cylinder.widthDirection[1],body3.cylinder.widthDirection[2],body3.cylinder.widthDirection[3]} else if noEvent(abs(body3.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body3.cylinder.e_x[1],body3.cylinder.e_x[2],body3.cylinder.e_x[3]})[3];
//   protected output Real body3.cylinder.Form;
//   output Real body3.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body3.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body3.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body3.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body3.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body3.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body3.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body3.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body3.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body3.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body3.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body3.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body3.cylinder.Material;
//   protected output Real body3.cylinder.Extra;
//   parameter Real body3.I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body3.I_11 \"inertia tensor\";
//   parameter Real body3.I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body3.I_21 \"inertia tensor\";
//   parameter Real body3.I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body3.I_31 \"inertia tensor\";
//   parameter Real body3.I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body3.I_21 \"inertia tensor\";
//   parameter Real body3.I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body3.I_22 \"inertia tensor\";
//   parameter Real body3.I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body3.I_32 \"inertia tensor\";
//   parameter Real body3.I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body3.I_31 \"inertia tensor\";
//   parameter Real body3.I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body3.I_32 \"inertia tensor\";
//   parameter Real body3.I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = body3.I_33 \"inertia tensor\";
//   parameter Real body3.R_start.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real body3.R_start.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real body3.R_start.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real body3.R_start.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real body3.R_start.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real body3.R_start.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real body3.R_start.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real body3.R_start.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real body3.R_start.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   parameter Real body3.R_start.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real body3.R_start.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real body3.R_start.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real body3.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = body3.sphereDiameter / 3.0 \"Diameter of cylinder\";
//   parameter String body3.sphere.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real body3.sphere.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real body3.sphere.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real body3.sphere.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real body3.sphere.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real body3.sphere.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real body3.sphere.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real body3.sphere.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real body3.sphere.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real body3.sphere.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real body3.sphere.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body3.sphere.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body3.sphere.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real body3.sphere.r[1](quantity = \"Length\", unit = \"m\") = body3.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body3.sphere.r[2](quantity = \"Length\", unit = \"m\") = body3.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body3.sphere.r[3](quantity = \"Length\", unit = \"m\") = body3.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real body3.sphere.r_shape[1](quantity = \"Length\", unit = \"m\") = body3.r_CM[1] - body3.sphereDiameter / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body3.sphere.r_shape[2](quantity = \"Length\", unit = \"m\") = body3.r_CM[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body3.sphere.r_shape[3](quantity = \"Length\", unit = \"m\") = body3.r_CM[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real body3.sphere.lengthDirection[1](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real body3.sphere.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body3.sphere.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real body3.sphere.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body3.sphere.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real body3.sphere.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real body3.sphere.length(quantity = \"Length\", unit = \"m\") = body3.sphereDiameter \"Length of visual object\";
//   input Real body3.sphere.width(quantity = \"Length\", unit = \"m\") = body3.sphereDiameter \"Width of visual object\";
//   input Real body3.sphere.height(quantity = \"Length\", unit = \"m\") = body3.sphereDiameter \"Height of visual object\";
//   input Real body3.sphere.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real body3.sphere.color[1] = Real(body3.sphereColor[1]) \"Color of shape\";
//   input Real body3.sphere.color[2] = Real(body3.sphereColor[2]) \"Color of shape\";
//   input Real body3.sphere.color[3] = Real(body3.sphereColor[3]) \"Color of shape\";
//   input Real body3.sphere.specularCoefficient = body3.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real body3.sphere.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({body3.sphere.lengthDirection[1],body3.sphere.lengthDirection[2],body3.sphere.lengthDirection[3]});
//   protected Real body3.sphere.e_x[1](unit = \"1\") = if noEvent(body3.sphere.abs_n_x < 1e-10) then 1.0 else body3.sphere.lengthDirection[1] / body3.sphere.abs_n_x;
//   protected Real body3.sphere.e_x[2](unit = \"1\") = if noEvent(body3.sphere.abs_n_x < 1e-10) then 0.0 else body3.sphere.lengthDirection[2] / body3.sphere.abs_n_x;
//   protected Real body3.sphere.e_x[3](unit = \"1\") = if noEvent(body3.sphere.abs_n_x < 1e-10) then 0.0 else body3.sphere.lengthDirection[3] / body3.sphere.abs_n_x;
//   protected Real body3.sphere.n_z_aux[1](unit = \"1\") = body3.sphere.e_x[2] * body3.sphere.widthDirection[3] - body3.sphere.e_x[3] * body3.sphere.widthDirection[2];
//   protected Real body3.sphere.n_z_aux[2](unit = \"1\") = body3.sphere.e_x[3] * body3.sphere.widthDirection[1] - body3.sphere.e_x[1] * body3.sphere.widthDirection[3];
//   protected Real body3.sphere.n_z_aux[3](unit = \"1\") = body3.sphere.e_x[1] * body3.sphere.widthDirection[2] - body3.sphere.e_x[2] * body3.sphere.widthDirection[1];
//   protected Real body3.sphere.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body3.sphere.e_x[1],body3.sphere.e_x[2],body3.sphere.e_x[3]},if noEvent(body3.sphere.n_z_aux[1] ^ 2.0 + (body3.sphere.n_z_aux[2] ^ 2.0 + body3.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body3.sphere.widthDirection[1],body3.sphere.widthDirection[2],body3.sphere.widthDirection[3]} else if noEvent(abs(body3.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body3.sphere.e_x[1],body3.sphere.e_x[2],body3.sphere.e_x[3]})[1];
//   protected Real body3.sphere.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body3.sphere.e_x[1],body3.sphere.e_x[2],body3.sphere.e_x[3]},if noEvent(body3.sphere.n_z_aux[1] ^ 2.0 + (body3.sphere.n_z_aux[2] ^ 2.0 + body3.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body3.sphere.widthDirection[1],body3.sphere.widthDirection[2],body3.sphere.widthDirection[3]} else if noEvent(abs(body3.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body3.sphere.e_x[1],body3.sphere.e_x[2],body3.sphere.e_x[3]})[2];
//   protected Real body3.sphere.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({body3.sphere.e_x[1],body3.sphere.e_x[2],body3.sphere.e_x[3]},if noEvent(body3.sphere.n_z_aux[1] ^ 2.0 + (body3.sphere.n_z_aux[2] ^ 2.0 + body3.sphere.n_z_aux[3] ^ 2.0) > 1e-06) then {body3.sphere.widthDirection[1],body3.sphere.widthDirection[2],body3.sphere.widthDirection[3]} else if noEvent(abs(body3.sphere.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{body3.sphere.e_x[1],body3.sphere.e_x[2],body3.sphere.e_x[3]})[3];
//   protected output Real body3.sphere.Form;
//   output Real body3.sphere.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body3.sphere.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body3.sphere.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real body3.sphere.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body3.sphere.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body3.sphere.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real body3.sphere.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body3.sphere.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real body3.sphere.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real body3.sphere.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body3.sphere.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body3.sphere.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real body3.sphere.Material;
//   protected output Real body3.sphere.Extra;
//   parameter Real body3.z_a_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(body3.R_start,{body3.z_0_start[1],body3.z_0_start[2],body3.z_0_start[3]})[1] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   parameter Real body3.z_a_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(body3.R_start,{body3.z_0_start[1],body3.z_0_start[2],body3.z_0_start[3]})[2] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   parameter Real body3.z_a_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(body3.R_start,{body3.z_0_start[1],body3.z_0_start[2],body3.z_0_start[3]})[3] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   protected parameter Real body3.Q_start[1] = Modelica.Mechanics.MultiBody.Frames.to_Q(body3.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[1] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real body3.Q_start[2] = Modelica.Mechanics.MultiBody.Frames.to_Q(body3.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[2] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real body3.Q_start[3] = Modelica.Mechanics.MultiBody.Frames.to_Q(body3.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[3] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real body3.Q_start[4] = Modelica.Mechanics.MultiBody.Frames.to_Q(body3.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[4] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real body3.phi_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if body3.sequence_start[1] == body3.sequence_angleStates[1] AND body3.sequence_start[2] == body3.sequence_angleStates[2] AND body3.sequence_start[3] == body3.sequence_angleStates[3] then body3.angles_start[1] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(body3.R_start,{body3.sequence_angleStates[1],body3.sequence_angleStates[2],body3.sequence_angleStates[3]},0.0)[1] \"Potential angle states at initial time\";
//   protected parameter Real body3.phi_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if body3.sequence_start[1] == body3.sequence_angleStates[1] AND body3.sequence_start[2] == body3.sequence_angleStates[2] AND body3.sequence_start[3] == body3.sequence_angleStates[3] then body3.angles_start[2] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(body3.R_start,{body3.sequence_angleStates[1],body3.sequence_angleStates[2],body3.sequence_angleStates[3]},0.0)[2] \"Potential angle states at initial time\";
//   protected parameter Real body3.phi_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if body3.sequence_start[1] == body3.sequence_angleStates[1] AND body3.sequence_start[2] == body3.sequence_angleStates[2] AND body3.sequence_start[3] == body3.sequence_angleStates[3] then body3.angles_start[3] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(body3.R_start,{body3.sequence_angleStates[1],body3.sequence_angleStates[2],body3.sequence_angleStates[3]},0.0)[3] \"Potential angle states at initial time\";
//   parameter Real mounting1D.phi0(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Fixed offset angle of housing\";
//   parameter Real mounting1D.n[1](unit = \"1\") = 1.0 \"Axis of rotation = axis of support torque (resolved in frame_a)\";
//   parameter Real mounting1D.n[2](unit = \"1\") = 0.0 \"Axis of rotation = axis of support torque (resolved in frame_a)\";
//   parameter Real mounting1D.n[3](unit = \"1\") = 0.0 \"Axis of rotation = axis of support torque (resolved in frame_a)\";
//   Real mounting1D.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real mounting1D.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real mounting1D.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mounting1D.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mounting1D.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mounting1D.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mounting1D.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mounting1D.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mounting1D.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mounting1D.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mounting1D.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mounting1D.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mounting1D.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mounting1D.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mounting1D.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mounting1D.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mounting1D.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mounting1D.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mounting1D.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mounting1D.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mounting1D.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mounting1D.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mounting1D.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   input Real mounting1D.housing.t[1](quantity = \"Torque\", unit = \"N.m\") = (-mounting1D.flange_b.tau) * mounting1D.n[1];
//   input Real mounting1D.housing.t[2](quantity = \"Torque\", unit = \"N.m\") = (-mounting1D.flange_b.tau) * mounting1D.n[2];
//   input Real mounting1D.housing.t[3](quantity = \"Torque\", unit = \"N.m\") = (-mounting1D.flange_b.tau) * mounting1D.n[3];
//   Real mounting1D.housing.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mounting1D.housing.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mounting1D.housing.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mounting1D.housing.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mounting1D.housing.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mounting1D.housing.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mounting1D.housing.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mounting1D.housing.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mounting1D.housing.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mounting1D.housing.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mounting1D.housing.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mounting1D.housing.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mounting1D.housing.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mounting1D.housing.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mounting1D.housing.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mounting1D.housing.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mounting1D.housing.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mounting1D.housing.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mounting1D.housing.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mounting1D.housing.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mounting1D.housing.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Real r1a[1](quantity = \"Length\", unit = \"m\") = r1b[1] + rh[1] - rv[1] \"Position vector from 'upper left' revolute to 'upper right' revolute joint in the first loop\";
//   parameter Real r1a[2](quantity = \"Length\", unit = \"m\") = r1b[2] + rh[2] - rv[2] \"Position vector from 'upper left' revolute to 'upper right' revolute joint in the first loop\";
//   parameter Real r1a[3](quantity = \"Length\", unit = \"m\") = r1b[3] + rh[3] - rv[3] \"Position vector from 'upper left' revolute to 'upper right' revolute joint in the first loop\";
//   parameter Real r2a[1](quantity = \"Length\", unit = \"m\") = r2b[1] + rh[1] - r1b[1] \"Position vector from 'upper left' revolute to 'upper right' revolute joint in the second loop\";
//   parameter Real r2a[2](quantity = \"Length\", unit = \"m\") = r2b[2] + rh[2] - r1b[2] \"Position vector from 'upper left' revolute to 'upper right' revolute joint in the second loop\";
//   parameter Real r2a[3](quantity = \"Length\", unit = \"m\") = r2b[3] + rh[3] - r1b[3] \"Position vector from 'upper left' revolute to 'upper right' revolute joint in the second loop\";
//   parameter Real r3a[1](quantity = \"Length\", unit = \"m\") = r3b[1] + rh[1] - r2b[1] \"Position vector from 'upper left' revolute to 'upper right' revolute joint in the third loop\";
//   parameter Real r3a[2](quantity = \"Length\", unit = \"m\") = r3b[2] + rh[2] - r2b[2] \"Position vector from 'upper left' revolute to 'upper right' revolute joint in the third loop\";
//   parameter Real r3a[3](quantity = \"Length\", unit = \"m\") = r3b[3] + rh[3] - r2b[3] \"Position vector from 'upper left' revolute to 'upper right' revolute joint in the third loop\";
// initial equation
//   jointRRR1.jointUSR.revolute.positiveBranch = Modelica.Mechanics.MultiBody.Joints.Internal.RevoluteWithLengthConstraint.selectBranch(jointRRR1.jointUSR.revolute.lengthConstraint,{jointRRR1.jointUSR.revolute.e[1],jointRRR1.jointUSR.revolute.e[2],jointRRR1.jointUSR.revolute.e[3]},Modelica.SIunits.Conversions.from_deg(jointRRR1.jointUSR.revolute.phi_offset + jointRRR1.jointUSR.revolute.phi_guess),{jointRRR1.jointUSR.revolute.r_a[1],jointRRR1.jointUSR.revolute.r_a[2],jointRRR1.jointUSR.revolute.r_a[3]},{jointRRR1.jointUSR.revolute.r_b[1],jointRRR1.jointUSR.revolute.r_b[2],jointRRR1.jointUSR.revolute.r_b[3]});
//   jointRRR1.n_b = Modelica.Mechanics.MultiBody.Frames.resolve2(jointRRR1.frame_b.R,Modelica.Mechanics.MultiBody.Frames.resolve1(jointRRR1.frame_a.R,{jointRRR1.n_a[1],jointRRR1.n_a[2],jointRRR1.n_a[3]}));
//   position.phi = position.phi_ref;
//   jointRRR2.jointUSR.revolute.positiveBranch = Modelica.Mechanics.MultiBody.Joints.Internal.RevoluteWithLengthConstraint.selectBranch(jointRRR2.jointUSR.revolute.lengthConstraint,{jointRRR2.jointUSR.revolute.e[1],jointRRR2.jointUSR.revolute.e[2],jointRRR2.jointUSR.revolute.e[3]},Modelica.SIunits.Conversions.from_deg(jointRRR2.jointUSR.revolute.phi_offset + jointRRR2.jointUSR.revolute.phi_guess),{jointRRR2.jointUSR.revolute.r_a[1],jointRRR2.jointUSR.revolute.r_a[2],jointRRR2.jointUSR.revolute.r_a[3]},{jointRRR2.jointUSR.revolute.r_b[1],jointRRR2.jointUSR.revolute.r_b[2],jointRRR2.jointUSR.revolute.r_b[3]});
//   jointRRR2.n_b = Modelica.Mechanics.MultiBody.Frames.resolve2(jointRRR2.frame_b.R,Modelica.Mechanics.MultiBody.Frames.resolve1(jointRRR2.frame_a.R,{jointRRR2.n_a[1],jointRRR2.n_a[2],jointRRR2.n_a[3]}));
//   jointRRR3.jointUSR.revolute.positiveBranch = Modelica.Mechanics.MultiBody.Joints.Internal.RevoluteWithLengthConstraint.selectBranch(jointRRR3.jointUSR.revolute.lengthConstraint,{jointRRR3.jointUSR.revolute.e[1],jointRRR3.jointUSR.revolute.e[2],jointRRR3.jointUSR.revolute.e[3]},Modelica.SIunits.Conversions.from_deg(jointRRR3.jointUSR.revolute.phi_offset + jointRRR3.jointUSR.revolute.phi_guess),{jointRRR3.jointUSR.revolute.r_a[1],jointRRR3.jointUSR.revolute.r_a[2],jointRRR3.jointUSR.revolute.r_a[3]},{jointRRR3.jointUSR.revolute.r_b[1],jointRRR3.jointUSR.revolute.r_b[2],jointRRR3.jointUSR.revolute.r_b[3]});
//   jointRRR3.n_b = Modelica.Mechanics.MultiBody.Frames.resolve2(jointRRR3.frame_b.R,Modelica.Mechanics.MultiBody.Frames.resolve1(jointRRR3.frame_a.R,{jointRRR3.n_a[1],jointRRR3.n_a[2],jointRRR3.n_a[3]}));
// equation
//   world.x_arrowLine.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.x_arrowLine.shapeType);
//   world.x_arrowLine.rxvisobj[1] = world.x_arrowLine.R.T[1,1] * world.x_arrowLine.e_x[1] + (world.x_arrowLine.R.T[2,1] * world.x_arrowLine.e_x[2] + world.x_arrowLine.R.T[3,1] * world.x_arrowLine.e_x[3]);
//   world.x_arrowLine.rxvisobj[2] = world.x_arrowLine.R.T[1,2] * world.x_arrowLine.e_x[1] + (world.x_arrowLine.R.T[2,2] * world.x_arrowLine.e_x[2] + world.x_arrowLine.R.T[3,2] * world.x_arrowLine.e_x[3]);
//   world.x_arrowLine.rxvisobj[3] = world.x_arrowLine.R.T[1,3] * world.x_arrowLine.e_x[1] + (world.x_arrowLine.R.T[2,3] * world.x_arrowLine.e_x[2] + world.x_arrowLine.R.T[3,3] * world.x_arrowLine.e_x[3]);
//   world.x_arrowLine.ryvisobj[1] = world.x_arrowLine.R.T[1,1] * world.x_arrowLine.e_y[1] + (world.x_arrowLine.R.T[2,1] * world.x_arrowLine.e_y[2] + world.x_arrowLine.R.T[3,1] * world.x_arrowLine.e_y[3]);
//   world.x_arrowLine.ryvisobj[2] = world.x_arrowLine.R.T[1,2] * world.x_arrowLine.e_y[1] + (world.x_arrowLine.R.T[2,2] * world.x_arrowLine.e_y[2] + world.x_arrowLine.R.T[3,2] * world.x_arrowLine.e_y[3]);
//   world.x_arrowLine.ryvisobj[3] = world.x_arrowLine.R.T[1,3] * world.x_arrowLine.e_y[1] + (world.x_arrowLine.R.T[2,3] * world.x_arrowLine.e_y[2] + world.x_arrowLine.R.T[3,3] * world.x_arrowLine.e_y[3]);
//   world.x_arrowLine.rvisobj = world.x_arrowLine.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_arrowLine.R.T[1,1],world.x_arrowLine.R.T[1,2],world.x_arrowLine.R.T[1,3]},{world.x_arrowLine.R.T[2,1],world.x_arrowLine.R.T[2,2],world.x_arrowLine.R.T[2,3]},{world.x_arrowLine.R.T[3,1],world.x_arrowLine.R.T[3,2],world.x_arrowLine.R.T[3,3]}},{world.x_arrowLine.r_shape[1],world.x_arrowLine.r_shape[2],world.x_arrowLine.r_shape[3]});
//   world.x_arrowLine.size[1] = world.x_arrowLine.length;
//   world.x_arrowLine.size[2] = world.x_arrowLine.width;
//   world.x_arrowLine.size[3] = world.x_arrowLine.height;
//   world.x_arrowLine.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.x_arrowLine.color[1] / 255.0,world.x_arrowLine.color[2] / 255.0,world.x_arrowLine.color[3] / 255.0,world.x_arrowLine.specularCoefficient);
//   world.x_arrowLine.Extra = world.x_arrowLine.extra;
//   world.x_arrowHead.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.x_arrowHead.shapeType);
//   world.x_arrowHead.rxvisobj[1] = world.x_arrowHead.R.T[1,1] * world.x_arrowHead.e_x[1] + (world.x_arrowHead.R.T[2,1] * world.x_arrowHead.e_x[2] + world.x_arrowHead.R.T[3,1] * world.x_arrowHead.e_x[3]);
//   world.x_arrowHead.rxvisobj[2] = world.x_arrowHead.R.T[1,2] * world.x_arrowHead.e_x[1] + (world.x_arrowHead.R.T[2,2] * world.x_arrowHead.e_x[2] + world.x_arrowHead.R.T[3,2] * world.x_arrowHead.e_x[3]);
//   world.x_arrowHead.rxvisobj[3] = world.x_arrowHead.R.T[1,3] * world.x_arrowHead.e_x[1] + (world.x_arrowHead.R.T[2,3] * world.x_arrowHead.e_x[2] + world.x_arrowHead.R.T[3,3] * world.x_arrowHead.e_x[3]);
//   world.x_arrowHead.ryvisobj[1] = world.x_arrowHead.R.T[1,1] * world.x_arrowHead.e_y[1] + (world.x_arrowHead.R.T[2,1] * world.x_arrowHead.e_y[2] + world.x_arrowHead.R.T[3,1] * world.x_arrowHead.e_y[3]);
//   world.x_arrowHead.ryvisobj[2] = world.x_arrowHead.R.T[1,2] * world.x_arrowHead.e_y[1] + (world.x_arrowHead.R.T[2,2] * world.x_arrowHead.e_y[2] + world.x_arrowHead.R.T[3,2] * world.x_arrowHead.e_y[3]);
//   world.x_arrowHead.ryvisobj[3] = world.x_arrowHead.R.T[1,3] * world.x_arrowHead.e_y[1] + (world.x_arrowHead.R.T[2,3] * world.x_arrowHead.e_y[2] + world.x_arrowHead.R.T[3,3] * world.x_arrowHead.e_y[3]);
//   world.x_arrowHead.rvisobj = world.x_arrowHead.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_arrowHead.R.T[1,1],world.x_arrowHead.R.T[1,2],world.x_arrowHead.R.T[1,3]},{world.x_arrowHead.R.T[2,1],world.x_arrowHead.R.T[2,2],world.x_arrowHead.R.T[2,3]},{world.x_arrowHead.R.T[3,1],world.x_arrowHead.R.T[3,2],world.x_arrowHead.R.T[3,3]}},{world.x_arrowHead.r_shape[1],world.x_arrowHead.r_shape[2],world.x_arrowHead.r_shape[3]});
//   world.x_arrowHead.size[1] = world.x_arrowHead.length;
//   world.x_arrowHead.size[2] = world.x_arrowHead.width;
//   world.x_arrowHead.size[3] = world.x_arrowHead.height;
//   world.x_arrowHead.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.x_arrowHead.color[1] / 255.0,world.x_arrowHead.color[2] / 255.0,world.x_arrowHead.color[3] / 255.0,world.x_arrowHead.specularCoefficient);
//   world.x_arrowHead.Extra = world.x_arrowHead.extra;
//   world.y_arrowLine.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.y_arrowLine.shapeType);
//   world.y_arrowLine.rxvisobj[1] = world.y_arrowLine.R.T[1,1] * world.y_arrowLine.e_x[1] + (world.y_arrowLine.R.T[2,1] * world.y_arrowLine.e_x[2] + world.y_arrowLine.R.T[3,1] * world.y_arrowLine.e_x[3]);
//   world.y_arrowLine.rxvisobj[2] = world.y_arrowLine.R.T[1,2] * world.y_arrowLine.e_x[1] + (world.y_arrowLine.R.T[2,2] * world.y_arrowLine.e_x[2] + world.y_arrowLine.R.T[3,2] * world.y_arrowLine.e_x[3]);
//   world.y_arrowLine.rxvisobj[3] = world.y_arrowLine.R.T[1,3] * world.y_arrowLine.e_x[1] + (world.y_arrowLine.R.T[2,3] * world.y_arrowLine.e_x[2] + world.y_arrowLine.R.T[3,3] * world.y_arrowLine.e_x[3]);
//   world.y_arrowLine.ryvisobj[1] = world.y_arrowLine.R.T[1,1] * world.y_arrowLine.e_y[1] + (world.y_arrowLine.R.T[2,1] * world.y_arrowLine.e_y[2] + world.y_arrowLine.R.T[3,1] * world.y_arrowLine.e_y[3]);
//   world.y_arrowLine.ryvisobj[2] = world.y_arrowLine.R.T[1,2] * world.y_arrowLine.e_y[1] + (world.y_arrowLine.R.T[2,2] * world.y_arrowLine.e_y[2] + world.y_arrowLine.R.T[3,2] * world.y_arrowLine.e_y[3]);
//   world.y_arrowLine.ryvisobj[3] = world.y_arrowLine.R.T[1,3] * world.y_arrowLine.e_y[1] + (world.y_arrowLine.R.T[2,3] * world.y_arrowLine.e_y[2] + world.y_arrowLine.R.T[3,3] * world.y_arrowLine.e_y[3]);
//   world.y_arrowLine.rvisobj = world.y_arrowLine.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_arrowLine.R.T[1,1],world.y_arrowLine.R.T[1,2],world.y_arrowLine.R.T[1,3]},{world.y_arrowLine.R.T[2,1],world.y_arrowLine.R.T[2,2],world.y_arrowLine.R.T[2,3]},{world.y_arrowLine.R.T[3,1],world.y_arrowLine.R.T[3,2],world.y_arrowLine.R.T[3,3]}},{world.y_arrowLine.r_shape[1],world.y_arrowLine.r_shape[2],world.y_arrowLine.r_shape[3]});
//   world.y_arrowLine.size[1] = world.y_arrowLine.length;
//   world.y_arrowLine.size[2] = world.y_arrowLine.width;
//   world.y_arrowLine.size[3] = world.y_arrowLine.height;
//   world.y_arrowLine.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.y_arrowLine.color[1] / 255.0,world.y_arrowLine.color[2] / 255.0,world.y_arrowLine.color[3] / 255.0,world.y_arrowLine.specularCoefficient);
//   world.y_arrowLine.Extra = world.y_arrowLine.extra;
//   world.y_arrowHead.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.y_arrowHead.shapeType);
//   world.y_arrowHead.rxvisobj[1] = world.y_arrowHead.R.T[1,1] * world.y_arrowHead.e_x[1] + (world.y_arrowHead.R.T[2,1] * world.y_arrowHead.e_x[2] + world.y_arrowHead.R.T[3,1] * world.y_arrowHead.e_x[3]);
//   world.y_arrowHead.rxvisobj[2] = world.y_arrowHead.R.T[1,2] * world.y_arrowHead.e_x[1] + (world.y_arrowHead.R.T[2,2] * world.y_arrowHead.e_x[2] + world.y_arrowHead.R.T[3,2] * world.y_arrowHead.e_x[3]);
//   world.y_arrowHead.rxvisobj[3] = world.y_arrowHead.R.T[1,3] * world.y_arrowHead.e_x[1] + (world.y_arrowHead.R.T[2,3] * world.y_arrowHead.e_x[2] + world.y_arrowHead.R.T[3,3] * world.y_arrowHead.e_x[3]);
//   world.y_arrowHead.ryvisobj[1] = world.y_arrowHead.R.T[1,1] * world.y_arrowHead.e_y[1] + (world.y_arrowHead.R.T[2,1] * world.y_arrowHead.e_y[2] + world.y_arrowHead.R.T[3,1] * world.y_arrowHead.e_y[3]);
//   world.y_arrowHead.ryvisobj[2] = world.y_arrowHead.R.T[1,2] * world.y_arrowHead.e_y[1] + (world.y_arrowHead.R.T[2,2] * world.y_arrowHead.e_y[2] + world.y_arrowHead.R.T[3,2] * world.y_arrowHead.e_y[3]);
//   world.y_arrowHead.ryvisobj[3] = world.y_arrowHead.R.T[1,3] * world.y_arrowHead.e_y[1] + (world.y_arrowHead.R.T[2,3] * world.y_arrowHead.e_y[2] + world.y_arrowHead.R.T[3,3] * world.y_arrowHead.e_y[3]);
//   world.y_arrowHead.rvisobj = world.y_arrowHead.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_arrowHead.R.T[1,1],world.y_arrowHead.R.T[1,2],world.y_arrowHead.R.T[1,3]},{world.y_arrowHead.R.T[2,1],world.y_arrowHead.R.T[2,2],world.y_arrowHead.R.T[2,3]},{world.y_arrowHead.R.T[3,1],world.y_arrowHead.R.T[3,2],world.y_arrowHead.R.T[3,3]}},{world.y_arrowHead.r_shape[1],world.y_arrowHead.r_shape[2],world.y_arrowHead.r_shape[3]});
//   world.y_arrowHead.size[1] = world.y_arrowHead.length;
//   world.y_arrowHead.size[2] = world.y_arrowHead.width;
//   world.y_arrowHead.size[3] = world.y_arrowHead.height;
//   world.y_arrowHead.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.y_arrowHead.color[1] / 255.0,world.y_arrowHead.color[2] / 255.0,world.y_arrowHead.color[3] / 255.0,world.y_arrowHead.specularCoefficient);
//   world.y_arrowHead.Extra = world.y_arrowHead.extra;
//   world.z_arrowLine.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_arrowLine.shapeType);
//   world.z_arrowLine.rxvisobj[1] = world.z_arrowLine.R.T[1,1] * world.z_arrowLine.e_x[1] + (world.z_arrowLine.R.T[2,1] * world.z_arrowLine.e_x[2] + world.z_arrowLine.R.T[3,1] * world.z_arrowLine.e_x[3]);
//   world.z_arrowLine.rxvisobj[2] = world.z_arrowLine.R.T[1,2] * world.z_arrowLine.e_x[1] + (world.z_arrowLine.R.T[2,2] * world.z_arrowLine.e_x[2] + world.z_arrowLine.R.T[3,2] * world.z_arrowLine.e_x[3]);
//   world.z_arrowLine.rxvisobj[3] = world.z_arrowLine.R.T[1,3] * world.z_arrowLine.e_x[1] + (world.z_arrowLine.R.T[2,3] * world.z_arrowLine.e_x[2] + world.z_arrowLine.R.T[3,3] * world.z_arrowLine.e_x[3]);
//   world.z_arrowLine.ryvisobj[1] = world.z_arrowLine.R.T[1,1] * world.z_arrowLine.e_y[1] + (world.z_arrowLine.R.T[2,1] * world.z_arrowLine.e_y[2] + world.z_arrowLine.R.T[3,1] * world.z_arrowLine.e_y[3]);
//   world.z_arrowLine.ryvisobj[2] = world.z_arrowLine.R.T[1,2] * world.z_arrowLine.e_y[1] + (world.z_arrowLine.R.T[2,2] * world.z_arrowLine.e_y[2] + world.z_arrowLine.R.T[3,2] * world.z_arrowLine.e_y[3]);
//   world.z_arrowLine.ryvisobj[3] = world.z_arrowLine.R.T[1,3] * world.z_arrowLine.e_y[1] + (world.z_arrowLine.R.T[2,3] * world.z_arrowLine.e_y[2] + world.z_arrowLine.R.T[3,3] * world.z_arrowLine.e_y[3]);
//   world.z_arrowLine.rvisobj = world.z_arrowLine.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_arrowLine.R.T[1,1],world.z_arrowLine.R.T[1,2],world.z_arrowLine.R.T[1,3]},{world.z_arrowLine.R.T[2,1],world.z_arrowLine.R.T[2,2],world.z_arrowLine.R.T[2,3]},{world.z_arrowLine.R.T[3,1],world.z_arrowLine.R.T[3,2],world.z_arrowLine.R.T[3,3]}},{world.z_arrowLine.r_shape[1],world.z_arrowLine.r_shape[2],world.z_arrowLine.r_shape[3]});
//   world.z_arrowLine.size[1] = world.z_arrowLine.length;
//   world.z_arrowLine.size[2] = world.z_arrowLine.width;
//   world.z_arrowLine.size[3] = world.z_arrowLine.height;
//   world.z_arrowLine.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_arrowLine.color[1] / 255.0,world.z_arrowLine.color[2] / 255.0,world.z_arrowLine.color[3] / 255.0,world.z_arrowLine.specularCoefficient);
//   world.z_arrowLine.Extra = world.z_arrowLine.extra;
//   world.z_arrowHead.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_arrowHead.shapeType);
//   world.z_arrowHead.rxvisobj[1] = world.z_arrowHead.R.T[1,1] * world.z_arrowHead.e_x[1] + (world.z_arrowHead.R.T[2,1] * world.z_arrowHead.e_x[2] + world.z_arrowHead.R.T[3,1] * world.z_arrowHead.e_x[3]);
//   world.z_arrowHead.rxvisobj[2] = world.z_arrowHead.R.T[1,2] * world.z_arrowHead.e_x[1] + (world.z_arrowHead.R.T[2,2] * world.z_arrowHead.e_x[2] + world.z_arrowHead.R.T[3,2] * world.z_arrowHead.e_x[3]);
//   world.z_arrowHead.rxvisobj[3] = world.z_arrowHead.R.T[1,3] * world.z_arrowHead.e_x[1] + (world.z_arrowHead.R.T[2,3] * world.z_arrowHead.e_x[2] + world.z_arrowHead.R.T[3,3] * world.z_arrowHead.e_x[3]);
//   world.z_arrowHead.ryvisobj[1] = world.z_arrowHead.R.T[1,1] * world.z_arrowHead.e_y[1] + (world.z_arrowHead.R.T[2,1] * world.z_arrowHead.e_y[2] + world.z_arrowHead.R.T[3,1] * world.z_arrowHead.e_y[3]);
//   world.z_arrowHead.ryvisobj[2] = world.z_arrowHead.R.T[1,2] * world.z_arrowHead.e_y[1] + (world.z_arrowHead.R.T[2,2] * world.z_arrowHead.e_y[2] + world.z_arrowHead.R.T[3,2] * world.z_arrowHead.e_y[3]);
//   world.z_arrowHead.ryvisobj[3] = world.z_arrowHead.R.T[1,3] * world.z_arrowHead.e_y[1] + (world.z_arrowHead.R.T[2,3] * world.z_arrowHead.e_y[2] + world.z_arrowHead.R.T[3,3] * world.z_arrowHead.e_y[3]);
//   world.z_arrowHead.rvisobj = world.z_arrowHead.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_arrowHead.R.T[1,1],world.z_arrowHead.R.T[1,2],world.z_arrowHead.R.T[1,3]},{world.z_arrowHead.R.T[2,1],world.z_arrowHead.R.T[2,2],world.z_arrowHead.R.T[2,3]},{world.z_arrowHead.R.T[3,1],world.z_arrowHead.R.T[3,2],world.z_arrowHead.R.T[3,3]}},{world.z_arrowHead.r_shape[1],world.z_arrowHead.r_shape[2],world.z_arrowHead.r_shape[3]});
//   world.z_arrowHead.size[1] = world.z_arrowHead.length;
//   world.z_arrowHead.size[2] = world.z_arrowHead.width;
//   world.z_arrowHead.size[3] = world.z_arrowHead.height;
//   world.z_arrowHead.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_arrowHead.color[1] / 255.0,world.z_arrowHead.color[2] / 255.0,world.z_arrowHead.color[3] / 255.0,world.z_arrowHead.specularCoefficient);
//   world.z_arrowHead.Extra = world.z_arrowHead.extra;
//   world.gravityArrowLine.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.gravityArrowLine.shapeType);
//   world.gravityArrowLine.rxvisobj[1] = world.gravityArrowLine.R.T[1,1] * world.gravityArrowLine.e_x[1] + (world.gravityArrowLine.R.T[2,1] * world.gravityArrowLine.e_x[2] + world.gravityArrowLine.R.T[3,1] * world.gravityArrowLine.e_x[3]);
//   world.gravityArrowLine.rxvisobj[2] = world.gravityArrowLine.R.T[1,2] * world.gravityArrowLine.e_x[1] + (world.gravityArrowLine.R.T[2,2] * world.gravityArrowLine.e_x[2] + world.gravityArrowLine.R.T[3,2] * world.gravityArrowLine.e_x[3]);
//   world.gravityArrowLine.rxvisobj[3] = world.gravityArrowLine.R.T[1,3] * world.gravityArrowLine.e_x[1] + (world.gravityArrowLine.R.T[2,3] * world.gravityArrowLine.e_x[2] + world.gravityArrowLine.R.T[3,3] * world.gravityArrowLine.e_x[3]);
//   world.gravityArrowLine.ryvisobj[1] = world.gravityArrowLine.R.T[1,1] * world.gravityArrowLine.e_y[1] + (world.gravityArrowLine.R.T[2,1] * world.gravityArrowLine.e_y[2] + world.gravityArrowLine.R.T[3,1] * world.gravityArrowLine.e_y[3]);
//   world.gravityArrowLine.ryvisobj[2] = world.gravityArrowLine.R.T[1,2] * world.gravityArrowLine.e_y[1] + (world.gravityArrowLine.R.T[2,2] * world.gravityArrowLine.e_y[2] + world.gravityArrowLine.R.T[3,2] * world.gravityArrowLine.e_y[3]);
//   world.gravityArrowLine.ryvisobj[3] = world.gravityArrowLine.R.T[1,3] * world.gravityArrowLine.e_y[1] + (world.gravityArrowLine.R.T[2,3] * world.gravityArrowLine.e_y[2] + world.gravityArrowLine.R.T[3,3] * world.gravityArrowLine.e_y[3]);
//   world.gravityArrowLine.rvisobj = world.gravityArrowLine.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.gravityArrowLine.R.T[1,1],world.gravityArrowLine.R.T[1,2],world.gravityArrowLine.R.T[1,3]},{world.gravityArrowLine.R.T[2,1],world.gravityArrowLine.R.T[2,2],world.gravityArrowLine.R.T[2,3]},{world.gravityArrowLine.R.T[3,1],world.gravityArrowLine.R.T[3,2],world.gravityArrowLine.R.T[3,3]}},{world.gravityArrowLine.r_shape[1],world.gravityArrowLine.r_shape[2],world.gravityArrowLine.r_shape[3]});
//   world.gravityArrowLine.size[1] = world.gravityArrowLine.length;
//   world.gravityArrowLine.size[2] = world.gravityArrowLine.width;
//   world.gravityArrowLine.size[3] = world.gravityArrowLine.height;
//   world.gravityArrowLine.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.gravityArrowLine.color[1] / 255.0,world.gravityArrowLine.color[2] / 255.0,world.gravityArrowLine.color[3] / 255.0,world.gravityArrowLine.specularCoefficient);
//   world.gravityArrowLine.Extra = world.gravityArrowLine.extra;
//   world.gravityArrowHead.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.gravityArrowHead.shapeType);
//   world.gravityArrowHead.rxvisobj[1] = world.gravityArrowHead.R.T[1,1] * world.gravityArrowHead.e_x[1] + (world.gravityArrowHead.R.T[2,1] * world.gravityArrowHead.e_x[2] + world.gravityArrowHead.R.T[3,1] * world.gravityArrowHead.e_x[3]);
//   world.gravityArrowHead.rxvisobj[2] = world.gravityArrowHead.R.T[1,2] * world.gravityArrowHead.e_x[1] + (world.gravityArrowHead.R.T[2,2] * world.gravityArrowHead.e_x[2] + world.gravityArrowHead.R.T[3,2] * world.gravityArrowHead.e_x[3]);
//   world.gravityArrowHead.rxvisobj[3] = world.gravityArrowHead.R.T[1,3] * world.gravityArrowHead.e_x[1] + (world.gravityArrowHead.R.T[2,3] * world.gravityArrowHead.e_x[2] + world.gravityArrowHead.R.T[3,3] * world.gravityArrowHead.e_x[3]);
//   world.gravityArrowHead.ryvisobj[1] = world.gravityArrowHead.R.T[1,1] * world.gravityArrowHead.e_y[1] + (world.gravityArrowHead.R.T[2,1] * world.gravityArrowHead.e_y[2] + world.gravityArrowHead.R.T[3,1] * world.gravityArrowHead.e_y[3]);
//   world.gravityArrowHead.ryvisobj[2] = world.gravityArrowHead.R.T[1,2] * world.gravityArrowHead.e_y[1] + (world.gravityArrowHead.R.T[2,2] * world.gravityArrowHead.e_y[2] + world.gravityArrowHead.R.T[3,2] * world.gravityArrowHead.e_y[3]);
//   world.gravityArrowHead.ryvisobj[3] = world.gravityArrowHead.R.T[1,3] * world.gravityArrowHead.e_y[1] + (world.gravityArrowHead.R.T[2,3] * world.gravityArrowHead.e_y[2] + world.gravityArrowHead.R.T[3,3] * world.gravityArrowHead.e_y[3]);
//   world.gravityArrowHead.rvisobj = world.gravityArrowHead.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.gravityArrowHead.R.T[1,1],world.gravityArrowHead.R.T[1,2],world.gravityArrowHead.R.T[1,3]},{world.gravityArrowHead.R.T[2,1],world.gravityArrowHead.R.T[2,2],world.gravityArrowHead.R.T[2,3]},{world.gravityArrowHead.R.T[3,1],world.gravityArrowHead.R.T[3,2],world.gravityArrowHead.R.T[3,3]}},{world.gravityArrowHead.r_shape[1],world.gravityArrowHead.r_shape[2],world.gravityArrowHead.r_shape[3]});
//   world.gravityArrowHead.size[1] = world.gravityArrowHead.length;
//   world.gravityArrowHead.size[2] = world.gravityArrowHead.width;
//   world.gravityArrowHead.size[3] = world.gravityArrowHead.height;
//   world.gravityArrowHead.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.gravityArrowHead.color[1] / 255.0,world.gravityArrowHead.color[2] / 255.0,world.gravityArrowHead.color[3] / 255.0,world.gravityArrowHead.specularCoefficient);
//   world.gravityArrowHead.Extra = world.gravityArrowHead.extra;
//   world.x_label.cylinders[1].R.T[1,1] = world.x_label.R.T[1,1];
//   world.x_label.cylinders[1].R.T[1,2] = world.x_label.R.T[1,2];
//   world.x_label.cylinders[1].R.T[1,3] = world.x_label.R.T[1,3];
//   world.x_label.cylinders[1].R.T[2,1] = world.x_label.R.T[2,1];
//   world.x_label.cylinders[1].R.T[2,2] = world.x_label.R.T[2,2];
//   world.x_label.cylinders[1].R.T[2,3] = world.x_label.R.T[2,3];
//   world.x_label.cylinders[1].R.T[3,1] = world.x_label.R.T[3,1];
//   world.x_label.cylinders[1].R.T[3,2] = world.x_label.R.T[3,2];
//   world.x_label.cylinders[1].R.T[3,3] = world.x_label.R.T[3,3];
//   world.x_label.cylinders[1].R.w[1] = world.x_label.R.w[1];
//   world.x_label.cylinders[1].R.w[2] = world.x_label.R.w[2];
//   world.x_label.cylinders[1].R.w[3] = world.x_label.R.w[3];
//   world.x_label.cylinders[1].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.x_label.cylinders[1].shapeType);
//   world.x_label.cylinders[1].rxvisobj[1] = world.x_label.cylinders[1].R.T[1,1] * world.x_label.cylinders[1].e_x[1] + (world.x_label.cylinders[1].R.T[2,1] * world.x_label.cylinders[1].e_x[2] + world.x_label.cylinders[1].R.T[3,1] * world.x_label.cylinders[1].e_x[3]);
//   world.x_label.cylinders[1].rxvisobj[2] = world.x_label.cylinders[1].R.T[1,2] * world.x_label.cylinders[1].e_x[1] + (world.x_label.cylinders[1].R.T[2,2] * world.x_label.cylinders[1].e_x[2] + world.x_label.cylinders[1].R.T[3,2] * world.x_label.cylinders[1].e_x[3]);
//   world.x_label.cylinders[1].rxvisobj[3] = world.x_label.cylinders[1].R.T[1,3] * world.x_label.cylinders[1].e_x[1] + (world.x_label.cylinders[1].R.T[2,3] * world.x_label.cylinders[1].e_x[2] + world.x_label.cylinders[1].R.T[3,3] * world.x_label.cylinders[1].e_x[3]);
//   world.x_label.cylinders[1].ryvisobj[1] = world.x_label.cylinders[1].R.T[1,1] * world.x_label.cylinders[1].e_y[1] + (world.x_label.cylinders[1].R.T[2,1] * world.x_label.cylinders[1].e_y[2] + world.x_label.cylinders[1].R.T[3,1] * world.x_label.cylinders[1].e_y[3]);
//   world.x_label.cylinders[1].ryvisobj[2] = world.x_label.cylinders[1].R.T[1,2] * world.x_label.cylinders[1].e_y[1] + (world.x_label.cylinders[1].R.T[2,2] * world.x_label.cylinders[1].e_y[2] + world.x_label.cylinders[1].R.T[3,2] * world.x_label.cylinders[1].e_y[3]);
//   world.x_label.cylinders[1].ryvisobj[3] = world.x_label.cylinders[1].R.T[1,3] * world.x_label.cylinders[1].e_y[1] + (world.x_label.cylinders[1].R.T[2,3] * world.x_label.cylinders[1].e_y[2] + world.x_label.cylinders[1].R.T[3,3] * world.x_label.cylinders[1].e_y[3]);
//   world.x_label.cylinders[1].rvisobj = world.x_label.cylinders[1].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.cylinders[1].R.T[1,1],world.x_label.cylinders[1].R.T[1,2],world.x_label.cylinders[1].R.T[1,3]},{world.x_label.cylinders[1].R.T[2,1],world.x_label.cylinders[1].R.T[2,2],world.x_label.cylinders[1].R.T[2,3]},{world.x_label.cylinders[1].R.T[3,1],world.x_label.cylinders[1].R.T[3,2],world.x_label.cylinders[1].R.T[3,3]}},{world.x_label.cylinders[1].r_shape[1],world.x_label.cylinders[1].r_shape[2],world.x_label.cylinders[1].r_shape[3]});
//   world.x_label.cylinders[1].size[1] = world.x_label.cylinders[1].length;
//   world.x_label.cylinders[1].size[2] = world.x_label.cylinders[1].width;
//   world.x_label.cylinders[1].size[3] = world.x_label.cylinders[1].height;
//   world.x_label.cylinders[1].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.x_label.cylinders[1].color[1] / 255.0,world.x_label.cylinders[1].color[2] / 255.0,world.x_label.cylinders[1].color[3] / 255.0,world.x_label.cylinders[1].specularCoefficient);
//   world.x_label.cylinders[1].Extra = world.x_label.cylinders[1].extra;
//   world.x_label.cylinders[2].R.T[1,1] = world.x_label.R.T[1,1];
//   world.x_label.cylinders[2].R.T[1,2] = world.x_label.R.T[1,2];
//   world.x_label.cylinders[2].R.T[1,3] = world.x_label.R.T[1,3];
//   world.x_label.cylinders[2].R.T[2,1] = world.x_label.R.T[2,1];
//   world.x_label.cylinders[2].R.T[2,2] = world.x_label.R.T[2,2];
//   world.x_label.cylinders[2].R.T[2,3] = world.x_label.R.T[2,3];
//   world.x_label.cylinders[2].R.T[3,1] = world.x_label.R.T[3,1];
//   world.x_label.cylinders[2].R.T[3,2] = world.x_label.R.T[3,2];
//   world.x_label.cylinders[2].R.T[3,3] = world.x_label.R.T[3,3];
//   world.x_label.cylinders[2].R.w[1] = world.x_label.R.w[1];
//   world.x_label.cylinders[2].R.w[2] = world.x_label.R.w[2];
//   world.x_label.cylinders[2].R.w[3] = world.x_label.R.w[3];
//   world.x_label.cylinders[2].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.x_label.cylinders[2].shapeType);
//   world.x_label.cylinders[2].rxvisobj[1] = world.x_label.cylinders[2].R.T[1,1] * world.x_label.cylinders[2].e_x[1] + (world.x_label.cylinders[2].R.T[2,1] * world.x_label.cylinders[2].e_x[2] + world.x_label.cylinders[2].R.T[3,1] * world.x_label.cylinders[2].e_x[3]);
//   world.x_label.cylinders[2].rxvisobj[2] = world.x_label.cylinders[2].R.T[1,2] * world.x_label.cylinders[2].e_x[1] + (world.x_label.cylinders[2].R.T[2,2] * world.x_label.cylinders[2].e_x[2] + world.x_label.cylinders[2].R.T[3,2] * world.x_label.cylinders[2].e_x[3]);
//   world.x_label.cylinders[2].rxvisobj[3] = world.x_label.cylinders[2].R.T[1,3] * world.x_label.cylinders[2].e_x[1] + (world.x_label.cylinders[2].R.T[2,3] * world.x_label.cylinders[2].e_x[2] + world.x_label.cylinders[2].R.T[3,3] * world.x_label.cylinders[2].e_x[3]);
//   world.x_label.cylinders[2].ryvisobj[1] = world.x_label.cylinders[2].R.T[1,1] * world.x_label.cylinders[2].e_y[1] + (world.x_label.cylinders[2].R.T[2,1] * world.x_label.cylinders[2].e_y[2] + world.x_label.cylinders[2].R.T[3,1] * world.x_label.cylinders[2].e_y[3]);
//   world.x_label.cylinders[2].ryvisobj[2] = world.x_label.cylinders[2].R.T[1,2] * world.x_label.cylinders[2].e_y[1] + (world.x_label.cylinders[2].R.T[2,2] * world.x_label.cylinders[2].e_y[2] + world.x_label.cylinders[2].R.T[3,2] * world.x_label.cylinders[2].e_y[3]);
//   world.x_label.cylinders[2].ryvisobj[3] = world.x_label.cylinders[2].R.T[1,3] * world.x_label.cylinders[2].e_y[1] + (world.x_label.cylinders[2].R.T[2,3] * world.x_label.cylinders[2].e_y[2] + world.x_label.cylinders[2].R.T[3,3] * world.x_label.cylinders[2].e_y[3]);
//   world.x_label.cylinders[2].rvisobj = world.x_label.cylinders[2].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.x_label.cylinders[2].R.T[1,1],world.x_label.cylinders[2].R.T[1,2],world.x_label.cylinders[2].R.T[1,3]},{world.x_label.cylinders[2].R.T[2,1],world.x_label.cylinders[2].R.T[2,2],world.x_label.cylinders[2].R.T[2,3]},{world.x_label.cylinders[2].R.T[3,1],world.x_label.cylinders[2].R.T[3,2],world.x_label.cylinders[2].R.T[3,3]}},{world.x_label.cylinders[2].r_shape[1],world.x_label.cylinders[2].r_shape[2],world.x_label.cylinders[2].r_shape[3]});
//   world.x_label.cylinders[2].size[1] = world.x_label.cylinders[2].length;
//   world.x_label.cylinders[2].size[2] = world.x_label.cylinders[2].width;
//   world.x_label.cylinders[2].size[3] = world.x_label.cylinders[2].height;
//   world.x_label.cylinders[2].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.x_label.cylinders[2].color[1] / 255.0,world.x_label.cylinders[2].color[2] / 255.0,world.x_label.cylinders[2].color[3] / 255.0,world.x_label.cylinders[2].specularCoefficient);
//   world.x_label.cylinders[2].Extra = world.x_label.cylinders[2].extra;
//   world.y_label.cylinders[1].R.T[1,1] = world.y_label.R.T[1,1];
//   world.y_label.cylinders[1].R.T[1,2] = world.y_label.R.T[1,2];
//   world.y_label.cylinders[1].R.T[1,3] = world.y_label.R.T[1,3];
//   world.y_label.cylinders[1].R.T[2,1] = world.y_label.R.T[2,1];
//   world.y_label.cylinders[1].R.T[2,2] = world.y_label.R.T[2,2];
//   world.y_label.cylinders[1].R.T[2,3] = world.y_label.R.T[2,3];
//   world.y_label.cylinders[1].R.T[3,1] = world.y_label.R.T[3,1];
//   world.y_label.cylinders[1].R.T[3,2] = world.y_label.R.T[3,2];
//   world.y_label.cylinders[1].R.T[3,3] = world.y_label.R.T[3,3];
//   world.y_label.cylinders[1].R.w[1] = world.y_label.R.w[1];
//   world.y_label.cylinders[1].R.w[2] = world.y_label.R.w[2];
//   world.y_label.cylinders[1].R.w[3] = world.y_label.R.w[3];
//   world.y_label.cylinders[1].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.y_label.cylinders[1].shapeType);
//   world.y_label.cylinders[1].rxvisobj[1] = world.y_label.cylinders[1].R.T[1,1] * world.y_label.cylinders[1].e_x[1] + (world.y_label.cylinders[1].R.T[2,1] * world.y_label.cylinders[1].e_x[2] + world.y_label.cylinders[1].R.T[3,1] * world.y_label.cylinders[1].e_x[3]);
//   world.y_label.cylinders[1].rxvisobj[2] = world.y_label.cylinders[1].R.T[1,2] * world.y_label.cylinders[1].e_x[1] + (world.y_label.cylinders[1].R.T[2,2] * world.y_label.cylinders[1].e_x[2] + world.y_label.cylinders[1].R.T[3,2] * world.y_label.cylinders[1].e_x[3]);
//   world.y_label.cylinders[1].rxvisobj[3] = world.y_label.cylinders[1].R.T[1,3] * world.y_label.cylinders[1].e_x[1] + (world.y_label.cylinders[1].R.T[2,3] * world.y_label.cylinders[1].e_x[2] + world.y_label.cylinders[1].R.T[3,3] * world.y_label.cylinders[1].e_x[3]);
//   world.y_label.cylinders[1].ryvisobj[1] = world.y_label.cylinders[1].R.T[1,1] * world.y_label.cylinders[1].e_y[1] + (world.y_label.cylinders[1].R.T[2,1] * world.y_label.cylinders[1].e_y[2] + world.y_label.cylinders[1].R.T[3,1] * world.y_label.cylinders[1].e_y[3]);
//   world.y_label.cylinders[1].ryvisobj[2] = world.y_label.cylinders[1].R.T[1,2] * world.y_label.cylinders[1].e_y[1] + (world.y_label.cylinders[1].R.T[2,2] * world.y_label.cylinders[1].e_y[2] + world.y_label.cylinders[1].R.T[3,2] * world.y_label.cylinders[1].e_y[3]);
//   world.y_label.cylinders[1].ryvisobj[3] = world.y_label.cylinders[1].R.T[1,3] * world.y_label.cylinders[1].e_y[1] + (world.y_label.cylinders[1].R.T[2,3] * world.y_label.cylinders[1].e_y[2] + world.y_label.cylinders[1].R.T[3,3] * world.y_label.cylinders[1].e_y[3]);
//   world.y_label.cylinders[1].rvisobj = world.y_label.cylinders[1].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.cylinders[1].R.T[1,1],world.y_label.cylinders[1].R.T[1,2],world.y_label.cylinders[1].R.T[1,3]},{world.y_label.cylinders[1].R.T[2,1],world.y_label.cylinders[1].R.T[2,2],world.y_label.cylinders[1].R.T[2,3]},{world.y_label.cylinders[1].R.T[3,1],world.y_label.cylinders[1].R.T[3,2],world.y_label.cylinders[1].R.T[3,3]}},{world.y_label.cylinders[1].r_shape[1],world.y_label.cylinders[1].r_shape[2],world.y_label.cylinders[1].r_shape[3]});
//   world.y_label.cylinders[1].size[1] = world.y_label.cylinders[1].length;
//   world.y_label.cylinders[1].size[2] = world.y_label.cylinders[1].width;
//   world.y_label.cylinders[1].size[3] = world.y_label.cylinders[1].height;
//   world.y_label.cylinders[1].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.y_label.cylinders[1].color[1] / 255.0,world.y_label.cylinders[1].color[2] / 255.0,world.y_label.cylinders[1].color[3] / 255.0,world.y_label.cylinders[1].specularCoefficient);
//   world.y_label.cylinders[1].Extra = world.y_label.cylinders[1].extra;
//   world.y_label.cylinders[2].R.T[1,1] = world.y_label.R.T[1,1];
//   world.y_label.cylinders[2].R.T[1,2] = world.y_label.R.T[1,2];
//   world.y_label.cylinders[2].R.T[1,3] = world.y_label.R.T[1,3];
//   world.y_label.cylinders[2].R.T[2,1] = world.y_label.R.T[2,1];
//   world.y_label.cylinders[2].R.T[2,2] = world.y_label.R.T[2,2];
//   world.y_label.cylinders[2].R.T[2,3] = world.y_label.R.T[2,3];
//   world.y_label.cylinders[2].R.T[3,1] = world.y_label.R.T[3,1];
//   world.y_label.cylinders[2].R.T[3,2] = world.y_label.R.T[3,2];
//   world.y_label.cylinders[2].R.T[3,3] = world.y_label.R.T[3,3];
//   world.y_label.cylinders[2].R.w[1] = world.y_label.R.w[1];
//   world.y_label.cylinders[2].R.w[2] = world.y_label.R.w[2];
//   world.y_label.cylinders[2].R.w[3] = world.y_label.R.w[3];
//   world.y_label.cylinders[2].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.y_label.cylinders[2].shapeType);
//   world.y_label.cylinders[2].rxvisobj[1] = world.y_label.cylinders[2].R.T[1,1] * world.y_label.cylinders[2].e_x[1] + (world.y_label.cylinders[2].R.T[2,1] * world.y_label.cylinders[2].e_x[2] + world.y_label.cylinders[2].R.T[3,1] * world.y_label.cylinders[2].e_x[3]);
//   world.y_label.cylinders[2].rxvisobj[2] = world.y_label.cylinders[2].R.T[1,2] * world.y_label.cylinders[2].e_x[1] + (world.y_label.cylinders[2].R.T[2,2] * world.y_label.cylinders[2].e_x[2] + world.y_label.cylinders[2].R.T[3,2] * world.y_label.cylinders[2].e_x[3]);
//   world.y_label.cylinders[2].rxvisobj[3] = world.y_label.cylinders[2].R.T[1,3] * world.y_label.cylinders[2].e_x[1] + (world.y_label.cylinders[2].R.T[2,3] * world.y_label.cylinders[2].e_x[2] + world.y_label.cylinders[2].R.T[3,3] * world.y_label.cylinders[2].e_x[3]);
//   world.y_label.cylinders[2].ryvisobj[1] = world.y_label.cylinders[2].R.T[1,1] * world.y_label.cylinders[2].e_y[1] + (world.y_label.cylinders[2].R.T[2,1] * world.y_label.cylinders[2].e_y[2] + world.y_label.cylinders[2].R.T[3,1] * world.y_label.cylinders[2].e_y[3]);
//   world.y_label.cylinders[2].ryvisobj[2] = world.y_label.cylinders[2].R.T[1,2] * world.y_label.cylinders[2].e_y[1] + (world.y_label.cylinders[2].R.T[2,2] * world.y_label.cylinders[2].e_y[2] + world.y_label.cylinders[2].R.T[3,2] * world.y_label.cylinders[2].e_y[3]);
//   world.y_label.cylinders[2].ryvisobj[3] = world.y_label.cylinders[2].R.T[1,3] * world.y_label.cylinders[2].e_y[1] + (world.y_label.cylinders[2].R.T[2,3] * world.y_label.cylinders[2].e_y[2] + world.y_label.cylinders[2].R.T[3,3] * world.y_label.cylinders[2].e_y[3]);
//   world.y_label.cylinders[2].rvisobj = world.y_label.cylinders[2].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.y_label.cylinders[2].R.T[1,1],world.y_label.cylinders[2].R.T[1,2],world.y_label.cylinders[2].R.T[1,3]},{world.y_label.cylinders[2].R.T[2,1],world.y_label.cylinders[2].R.T[2,2],world.y_label.cylinders[2].R.T[2,3]},{world.y_label.cylinders[2].R.T[3,1],world.y_label.cylinders[2].R.T[3,2],world.y_label.cylinders[2].R.T[3,3]}},{world.y_label.cylinders[2].r_shape[1],world.y_label.cylinders[2].r_shape[2],world.y_label.cylinders[2].r_shape[3]});
//   world.y_label.cylinders[2].size[1] = world.y_label.cylinders[2].length;
//   world.y_label.cylinders[2].size[2] = world.y_label.cylinders[2].width;
//   world.y_label.cylinders[2].size[3] = world.y_label.cylinders[2].height;
//   world.y_label.cylinders[2].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.y_label.cylinders[2].color[1] / 255.0,world.y_label.cylinders[2].color[2] / 255.0,world.y_label.cylinders[2].color[3] / 255.0,world.y_label.cylinders[2].specularCoefficient);
//   world.y_label.cylinders[2].Extra = world.y_label.cylinders[2].extra;
//   world.z_label.cylinders[1].R.T[1,1] = world.z_label.R.T[1,1];
//   world.z_label.cylinders[1].R.T[1,2] = world.z_label.R.T[1,2];
//   world.z_label.cylinders[1].R.T[1,3] = world.z_label.R.T[1,3];
//   world.z_label.cylinders[1].R.T[2,1] = world.z_label.R.T[2,1];
//   world.z_label.cylinders[1].R.T[2,2] = world.z_label.R.T[2,2];
//   world.z_label.cylinders[1].R.T[2,3] = world.z_label.R.T[2,3];
//   world.z_label.cylinders[1].R.T[3,1] = world.z_label.R.T[3,1];
//   world.z_label.cylinders[1].R.T[3,2] = world.z_label.R.T[3,2];
//   world.z_label.cylinders[1].R.T[3,3] = world.z_label.R.T[3,3];
//   world.z_label.cylinders[1].R.w[1] = world.z_label.R.w[1];
//   world.z_label.cylinders[1].R.w[2] = world.z_label.R.w[2];
//   world.z_label.cylinders[1].R.w[3] = world.z_label.R.w[3];
//   world.z_label.cylinders[1].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_label.cylinders[1].shapeType);
//   world.z_label.cylinders[1].rxvisobj[1] = world.z_label.cylinders[1].R.T[1,1] * world.z_label.cylinders[1].e_x[1] + (world.z_label.cylinders[1].R.T[2,1] * world.z_label.cylinders[1].e_x[2] + world.z_label.cylinders[1].R.T[3,1] * world.z_label.cylinders[1].e_x[3]);
//   world.z_label.cylinders[1].rxvisobj[2] = world.z_label.cylinders[1].R.T[1,2] * world.z_label.cylinders[1].e_x[1] + (world.z_label.cylinders[1].R.T[2,2] * world.z_label.cylinders[1].e_x[2] + world.z_label.cylinders[1].R.T[3,2] * world.z_label.cylinders[1].e_x[3]);
//   world.z_label.cylinders[1].rxvisobj[3] = world.z_label.cylinders[1].R.T[1,3] * world.z_label.cylinders[1].e_x[1] + (world.z_label.cylinders[1].R.T[2,3] * world.z_label.cylinders[1].e_x[2] + world.z_label.cylinders[1].R.T[3,3] * world.z_label.cylinders[1].e_x[3]);
//   world.z_label.cylinders[1].ryvisobj[1] = world.z_label.cylinders[1].R.T[1,1] * world.z_label.cylinders[1].e_y[1] + (world.z_label.cylinders[1].R.T[2,1] * world.z_label.cylinders[1].e_y[2] + world.z_label.cylinders[1].R.T[3,1] * world.z_label.cylinders[1].e_y[3]);
//   world.z_label.cylinders[1].ryvisobj[2] = world.z_label.cylinders[1].R.T[1,2] * world.z_label.cylinders[1].e_y[1] + (world.z_label.cylinders[1].R.T[2,2] * world.z_label.cylinders[1].e_y[2] + world.z_label.cylinders[1].R.T[3,2] * world.z_label.cylinders[1].e_y[3]);
//   world.z_label.cylinders[1].ryvisobj[3] = world.z_label.cylinders[1].R.T[1,3] * world.z_label.cylinders[1].e_y[1] + (world.z_label.cylinders[1].R.T[2,3] * world.z_label.cylinders[1].e_y[2] + world.z_label.cylinders[1].R.T[3,3] * world.z_label.cylinders[1].e_y[3]);
//   world.z_label.cylinders[1].rvisobj = world.z_label.cylinders[1].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.cylinders[1].R.T[1,1],world.z_label.cylinders[1].R.T[1,2],world.z_label.cylinders[1].R.T[1,3]},{world.z_label.cylinders[1].R.T[2,1],world.z_label.cylinders[1].R.T[2,2],world.z_label.cylinders[1].R.T[2,3]},{world.z_label.cylinders[1].R.T[3,1],world.z_label.cylinders[1].R.T[3,2],world.z_label.cylinders[1].R.T[3,3]}},{world.z_label.cylinders[1].r_shape[1],world.z_label.cylinders[1].r_shape[2],world.z_label.cylinders[1].r_shape[3]});
//   world.z_label.cylinders[1].size[1] = world.z_label.cylinders[1].length;
//   world.z_label.cylinders[1].size[2] = world.z_label.cylinders[1].width;
//   world.z_label.cylinders[1].size[3] = world.z_label.cylinders[1].height;
//   world.z_label.cylinders[1].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_label.cylinders[1].color[1] / 255.0,world.z_label.cylinders[1].color[2] / 255.0,world.z_label.cylinders[1].color[3] / 255.0,world.z_label.cylinders[1].specularCoefficient);
//   world.z_label.cylinders[1].Extra = world.z_label.cylinders[1].extra;
//   world.z_label.cylinders[2].R.T[1,1] = world.z_label.R.T[1,1];
//   world.z_label.cylinders[2].R.T[1,2] = world.z_label.R.T[1,2];
//   world.z_label.cylinders[2].R.T[1,3] = world.z_label.R.T[1,3];
//   world.z_label.cylinders[2].R.T[2,1] = world.z_label.R.T[2,1];
//   world.z_label.cylinders[2].R.T[2,2] = world.z_label.R.T[2,2];
//   world.z_label.cylinders[2].R.T[2,3] = world.z_label.R.T[2,3];
//   world.z_label.cylinders[2].R.T[3,1] = world.z_label.R.T[3,1];
//   world.z_label.cylinders[2].R.T[3,2] = world.z_label.R.T[3,2];
//   world.z_label.cylinders[2].R.T[3,3] = world.z_label.R.T[3,3];
//   world.z_label.cylinders[2].R.w[1] = world.z_label.R.w[1];
//   world.z_label.cylinders[2].R.w[2] = world.z_label.R.w[2];
//   world.z_label.cylinders[2].R.w[3] = world.z_label.R.w[3];
//   world.z_label.cylinders[2].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_label.cylinders[2].shapeType);
//   world.z_label.cylinders[2].rxvisobj[1] = world.z_label.cylinders[2].R.T[1,1] * world.z_label.cylinders[2].e_x[1] + (world.z_label.cylinders[2].R.T[2,1] * world.z_label.cylinders[2].e_x[2] + world.z_label.cylinders[2].R.T[3,1] * world.z_label.cylinders[2].e_x[3]);
//   world.z_label.cylinders[2].rxvisobj[2] = world.z_label.cylinders[2].R.T[1,2] * world.z_label.cylinders[2].e_x[1] + (world.z_label.cylinders[2].R.T[2,2] * world.z_label.cylinders[2].e_x[2] + world.z_label.cylinders[2].R.T[3,2] * world.z_label.cylinders[2].e_x[3]);
//   world.z_label.cylinders[2].rxvisobj[3] = world.z_label.cylinders[2].R.T[1,3] * world.z_label.cylinders[2].e_x[1] + (world.z_label.cylinders[2].R.T[2,3] * world.z_label.cylinders[2].e_x[2] + world.z_label.cylinders[2].R.T[3,3] * world.z_label.cylinders[2].e_x[3]);
//   world.z_label.cylinders[2].ryvisobj[1] = world.z_label.cylinders[2].R.T[1,1] * world.z_label.cylinders[2].e_y[1] + (world.z_label.cylinders[2].R.T[2,1] * world.z_label.cylinders[2].e_y[2] + world.z_label.cylinders[2].R.T[3,1] * world.z_label.cylinders[2].e_y[3]);
//   world.z_label.cylinders[2].ryvisobj[2] = world.z_label.cylinders[2].R.T[1,2] * world.z_label.cylinders[2].e_y[1] + (world.z_label.cylinders[2].R.T[2,2] * world.z_label.cylinders[2].e_y[2] + world.z_label.cylinders[2].R.T[3,2] * world.z_label.cylinders[2].e_y[3]);
//   world.z_label.cylinders[2].ryvisobj[3] = world.z_label.cylinders[2].R.T[1,3] * world.z_label.cylinders[2].e_y[1] + (world.z_label.cylinders[2].R.T[2,3] * world.z_label.cylinders[2].e_y[2] + world.z_label.cylinders[2].R.T[3,3] * world.z_label.cylinders[2].e_y[3]);
//   world.z_label.cylinders[2].rvisobj = world.z_label.cylinders[2].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.cylinders[2].R.T[1,1],world.z_label.cylinders[2].R.T[1,2],world.z_label.cylinders[2].R.T[1,3]},{world.z_label.cylinders[2].R.T[2,1],world.z_label.cylinders[2].R.T[2,2],world.z_label.cylinders[2].R.T[2,3]},{world.z_label.cylinders[2].R.T[3,1],world.z_label.cylinders[2].R.T[3,2],world.z_label.cylinders[2].R.T[3,3]}},{world.z_label.cylinders[2].r_shape[1],world.z_label.cylinders[2].r_shape[2],world.z_label.cylinders[2].r_shape[3]});
//   world.z_label.cylinders[2].size[1] = world.z_label.cylinders[2].length;
//   world.z_label.cylinders[2].size[2] = world.z_label.cylinders[2].width;
//   world.z_label.cylinders[2].size[3] = world.z_label.cylinders[2].height;
//   world.z_label.cylinders[2].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_label.cylinders[2].color[1] / 255.0,world.z_label.cylinders[2].color[2] / 255.0,world.z_label.cylinders[2].color[3] / 255.0,world.z_label.cylinders[2].specularCoefficient);
//   world.z_label.cylinders[2].Extra = world.z_label.cylinders[2].extra;
//   world.z_label.cylinders[3].R.T[1,1] = world.z_label.R.T[1,1];
//   world.z_label.cylinders[3].R.T[1,2] = world.z_label.R.T[1,2];
//   world.z_label.cylinders[3].R.T[1,3] = world.z_label.R.T[1,3];
//   world.z_label.cylinders[3].R.T[2,1] = world.z_label.R.T[2,1];
//   world.z_label.cylinders[3].R.T[2,2] = world.z_label.R.T[2,2];
//   world.z_label.cylinders[3].R.T[2,3] = world.z_label.R.T[2,3];
//   world.z_label.cylinders[3].R.T[3,1] = world.z_label.R.T[3,1];
//   world.z_label.cylinders[3].R.T[3,2] = world.z_label.R.T[3,2];
//   world.z_label.cylinders[3].R.T[3,3] = world.z_label.R.T[3,3];
//   world.z_label.cylinders[3].R.w[1] = world.z_label.R.w[1];
//   world.z_label.cylinders[3].R.w[2] = world.z_label.R.w[2];
//   world.z_label.cylinders[3].R.w[3] = world.z_label.R.w[3];
//   world.z_label.cylinders[3].Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(world.z_label.cylinders[3].shapeType);
//   world.z_label.cylinders[3].rxvisobj[1] = world.z_label.cylinders[3].R.T[1,1] * world.z_label.cylinders[3].e_x[1] + (world.z_label.cylinders[3].R.T[2,1] * world.z_label.cylinders[3].e_x[2] + world.z_label.cylinders[3].R.T[3,1] * world.z_label.cylinders[3].e_x[3]);
//   world.z_label.cylinders[3].rxvisobj[2] = world.z_label.cylinders[3].R.T[1,2] * world.z_label.cylinders[3].e_x[1] + (world.z_label.cylinders[3].R.T[2,2] * world.z_label.cylinders[3].e_x[2] + world.z_label.cylinders[3].R.T[3,2] * world.z_label.cylinders[3].e_x[3]);
//   world.z_label.cylinders[3].rxvisobj[3] = world.z_label.cylinders[3].R.T[1,3] * world.z_label.cylinders[3].e_x[1] + (world.z_label.cylinders[3].R.T[2,3] * world.z_label.cylinders[3].e_x[2] + world.z_label.cylinders[3].R.T[3,3] * world.z_label.cylinders[3].e_x[3]);
//   world.z_label.cylinders[3].ryvisobj[1] = world.z_label.cylinders[3].R.T[1,1] * world.z_label.cylinders[3].e_y[1] + (world.z_label.cylinders[3].R.T[2,1] * world.z_label.cylinders[3].e_y[2] + world.z_label.cylinders[3].R.T[3,1] * world.z_label.cylinders[3].e_y[3]);
//   world.z_label.cylinders[3].ryvisobj[2] = world.z_label.cylinders[3].R.T[1,2] * world.z_label.cylinders[3].e_y[1] + (world.z_label.cylinders[3].R.T[2,2] * world.z_label.cylinders[3].e_y[2] + world.z_label.cylinders[3].R.T[3,2] * world.z_label.cylinders[3].e_y[3]);
//   world.z_label.cylinders[3].ryvisobj[3] = world.z_label.cylinders[3].R.T[1,3] * world.z_label.cylinders[3].e_y[1] + (world.z_label.cylinders[3].R.T[2,3] * world.z_label.cylinders[3].e_y[2] + world.z_label.cylinders[3].R.T[3,3] * world.z_label.cylinders[3].e_y[3]);
//   world.z_label.cylinders[3].rvisobj = world.z_label.cylinders[3].r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{world.z_label.cylinders[3].R.T[1,1],world.z_label.cylinders[3].R.T[1,2],world.z_label.cylinders[3].R.T[1,3]},{world.z_label.cylinders[3].R.T[2,1],world.z_label.cylinders[3].R.T[2,2],world.z_label.cylinders[3].R.T[2,3]},{world.z_label.cylinders[3].R.T[3,1],world.z_label.cylinders[3].R.T[3,2],world.z_label.cylinders[3].R.T[3,3]}},{world.z_label.cylinders[3].r_shape[1],world.z_label.cylinders[3].r_shape[2],world.z_label.cylinders[3].r_shape[3]});
//   world.z_label.cylinders[3].size[1] = world.z_label.cylinders[3].length;
//   world.z_label.cylinders[3].size[2] = world.z_label.cylinders[3].width;
//   world.z_label.cylinders[3].size[3] = world.z_label.cylinders[3].height;
//   world.z_label.cylinders[3].Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(world.z_label.cylinders[3].color[1] / 255.0,world.z_label.cylinders[3].color[2] / 255.0,world.z_label.cylinders[3].color[3] / 255.0,world.z_label.cylinders[3].specularCoefficient);
//   world.z_label.cylinders[3].Extra = world.z_label.cylinders[3].extra;
//   assert(Modelica.Math.Vectors.length({world.n[1],world.n[2],world.n[3]}) > 1e-10,\"Parameter n of World object is wrong (lenght(n) > 0 required)\");
//   world.frame_b.r_0[1] = 0.0;
//   world.frame_b.r_0[2] = 0.0;
//   world.frame_b.r_0[3] = 0.0;
//   world.frame_b.R.w[3] = 0.0;
//   world.frame_b.R.w[2] = 0.0;
//   world.frame_b.R.w[1] = 0.0;
//   world.frame_b.R.T[3,3] = 1.0;
//   world.frame_b.R.T[3,2] = 0.0;
//   world.frame_b.R.T[3,1] = 0.0;
//   world.frame_b.R.T[2,3] = 0.0;
//   world.frame_b.R.T[2,2] = 1.0;
//   world.frame_b.R.T[2,1] = 0.0;
//   world.frame_b.R.T[1,3] = 0.0;
//   world.frame_b.R.T[1,2] = 0.0;
//   world.frame_b.R.T[1,1] = 1.0;
//   jointRRR1.jointUSR.revolute.axis.tau = jointRRR1.jointUSR.revolute.tau;
//   jointRRR1.jointUSR.revolute.axis.phi = jointRRR1.jointUSR.revolute.phi;
//   jointRRR1.jointUSR.revolute.bearing.phi = 0.0;
//   jointRRR1.jointUSR.revolute.angle = Modelica.SIunits.Conversions.from_deg(jointRRR1.jointUSR.revolute.phi_offset) + jointRRR1.jointUSR.revolute.phi;
//   jointRRR1.jointUSR.revolute.frame_b.r_0[1] = jointRRR1.jointUSR.revolute.frame_a.r_0[1];
//   jointRRR1.jointUSR.revolute.frame_b.r_0[2] = jointRRR1.jointUSR.revolute.frame_a.r_0[2];
//   jointRRR1.jointUSR.revolute.frame_b.r_0[3] = jointRRR1.jointUSR.revolute.frame_a.r_0[3];
//   jointRRR1.jointUSR.revolute.R_rel = Modelica.Mechanics.MultiBody.Frames.planarRotation({jointRRR1.jointUSR.revolute.e[1],jointRRR1.jointUSR.revolute.e[2],jointRRR1.jointUSR.revolute.e[3]},jointRRR1.jointUSR.revolute.angle,der(jointRRR1.jointUSR.revolute.angle));
//   jointRRR1.jointUSR.revolute.frame_b.R = Modelica.Mechanics.MultiBody.Frames.absoluteRotation(jointRRR1.jointUSR.revolute.frame_a.R,jointRRR1.jointUSR.revolute.R_rel);
//   {0.0,0.0,0.0} = jointRRR1.jointUSR.revolute.frame_a.f + Modelica.Mechanics.MultiBody.Frames.resolve1(jointRRR1.jointUSR.revolute.R_rel,{jointRRR1.jointUSR.revolute.frame_b.f[1],jointRRR1.jointUSR.revolute.frame_b.f[2],jointRRR1.jointUSR.revolute.frame_b.f[3]});
//   {0.0,0.0,0.0} = jointRRR1.jointUSR.revolute.frame_a.t + Modelica.Mechanics.MultiBody.Frames.resolve1(jointRRR1.jointUSR.revolute.R_rel,{jointRRR1.jointUSR.revolute.frame_b.t[1],jointRRR1.jointUSR.revolute.frame_b.t[2],jointRRR1.jointUSR.revolute.frame_b.t[3]});
//   jointRRR1.jointUSR.revolute.e_r_a = jointRRR1.jointUSR.revolute.e[1] * jointRRR1.jointUSR.revolute.r_a[1] + (jointRRR1.jointUSR.revolute.e[2] * jointRRR1.jointUSR.revolute.r_a[2] + jointRRR1.jointUSR.revolute.e[3] * jointRRR1.jointUSR.revolute.r_a[3]);
//   jointRRR1.jointUSR.revolute.e_r_b = jointRRR1.jointUSR.revolute.e[1] * jointRRR1.jointUSR.revolute.r_b[1] + (jointRRR1.jointUSR.revolute.e[2] * jointRRR1.jointUSR.revolute.r_b[2] + jointRRR1.jointUSR.revolute.e[3] * jointRRR1.jointUSR.revolute.r_b[3]);
//   jointRRR1.jointUSR.revolute.A = -2.0 * (jointRRR1.jointUSR.revolute.r_b[1] * jointRRR1.jointUSR.revolute.r_a[1] + (jointRRR1.jointUSR.revolute.r_b[2] * jointRRR1.jointUSR.revolute.r_a[2] + jointRRR1.jointUSR.revolute.r_b[3] * jointRRR1.jointUSR.revolute.r_a[3]) - jointRRR1.jointUSR.revolute.e_r_b * jointRRR1.jointUSR.revolute.e_r_a);
//   jointRRR1.jointUSR.revolute.B = 2.0 * (jointRRR1.jointUSR.revolute.r_b[1] * (jointRRR1.jointUSR.revolute.e[2] * jointRRR1.jointUSR.revolute.r_a[3] - jointRRR1.jointUSR.revolute.e[3] * jointRRR1.jointUSR.revolute.r_a[2])) + (2.0 * (jointRRR1.jointUSR.revolute.r_b[2] * (jointRRR1.jointUSR.revolute.e[3] * jointRRR1.jointUSR.revolute.r_a[1] - jointRRR1.jointUSR.revolute.e[1] * jointRRR1.jointUSR.revolute.r_a[3])) + 2.0 * (jointRRR1.jointUSR.revolute.r_b[3] * (jointRRR1.jointUSR.revolute.e[1] * jointRRR1.jointUSR.revolute.r_a[2] - jointRRR1.jointUSR.revolute.e[2] * jointRRR1.jointUSR.revolute.r_a[1])));
//   jointRRR1.jointUSR.revolute.C = jointRRR1.jointUSR.revolute.r_a[1] ^ 2.0 + (jointRRR1.jointUSR.revolute.r_a[2] ^ 2.0 + (jointRRR1.jointUSR.revolute.r_a[3] ^ 2.0 + (jointRRR1.jointUSR.revolute.r_b[1] ^ 2.0 + (jointRRR1.jointUSR.revolute.r_b[2] ^ 2.0 + jointRRR1.jointUSR.revolute.r_b[3] ^ 2.0)))) - jointRRR1.jointUSR.revolute.lengthConstraint ^ 2.0 - 2.0 * (jointRRR1.jointUSR.revolute.e_r_b * jointRRR1.jointUSR.revolute.e_r_a);
//   jointRRR1.jointUSR.revolute.k1 = jointRRR1.jointUSR.revolute.A ^ 2.0 + jointRRR1.jointUSR.revolute.B ^ 2.0;
//   jointRRR1.jointUSR.revolute.k1a = jointRRR1.jointUSR.revolute.k1 - jointRRR1.jointUSR.revolute.C ^ 2.0;
//   assert(jointRRR1.jointUSR.revolute.k1a > 1e-10,\"
// Singular position of loop (either no or two analytic solutions;
// the mechanism has lost one-degree-of freedom in this position).
// Try first to use another Modelica.Mechanics.MultiBody.Joints.Assemblies.JointXXX component.
// In most cases it is best that the joints outside of the JointXXX
// component are revolute and NOT prismatic joints. If this also
// lead to singular positions, it could be that this kinematic loop
// cannot be solved analytically. In this case you have to build
// up the loop with basic joints (NO aggregation JointXXX components)
// and rely on dynamic state selection, i.e., during simulation
// the states will be dynamically selected in such a way that in no
// position a degree of freedom is lost.
// \");
//   jointRRR1.jointUSR.revolute.k1b = Modelica.Mechanics.MultiBody.Frames.Internal.maxWithoutEvent(jointRRR1.jointUSR.revolute.k1a,1e-12);
//   jointRRR1.jointUSR.revolute.k2 = sqrt(jointRRR1.jointUSR.revolute.k1b);
//   jointRRR1.jointUSR.revolute.kcos_angle = (-jointRRR1.jointUSR.revolute.A) * jointRRR1.jointUSR.revolute.C + (if jointRRR1.jointUSR.revolute.positiveBranch then jointRRR1.jointUSR.revolute.B else -jointRRR1.jointUSR.revolute.B) * jointRRR1.jointUSR.revolute.k2;
//   jointRRR1.jointUSR.revolute.ksin_angle = (-jointRRR1.jointUSR.revolute.B) * jointRRR1.jointUSR.revolute.C + (if jointRRR1.jointUSR.revolute.positiveBranch then -jointRRR1.jointUSR.revolute.A else jointRRR1.jointUSR.revolute.A) * jointRRR1.jointUSR.revolute.k2;
//   jointRRR1.jointUSR.revolute.angle = atan2(jointRRR1.jointUSR.revolute.ksin_angle,jointRRR1.jointUSR.revolute.kcos_angle);
//   assert(true,\"Connector frame_a of component is not connected\");
//   assert(true,\"Connector frame_b of component is not connected\");
//   jointRRR1.jointUSR.rod1.rRod_0[1] = jointRRR1.jointUSR.rod1.frame_b.r_0[1] - jointRRR1.jointUSR.rod1.frame_a.r_0[1];
//   jointRRR1.jointUSR.rod1.rRod_0[2] = jointRRR1.jointUSR.rod1.frame_b.r_0[2] - jointRRR1.jointUSR.rod1.frame_a.r_0[2];
//   jointRRR1.jointUSR.rod1.rRod_0[3] = jointRRR1.jointUSR.rod1.frame_b.r_0[3] - jointRRR1.jointUSR.rod1.frame_a.r_0[3];
//   jointRRR1.jointUSR.rod1.rRod_a = Modelica.Mechanics.MultiBody.Frames.resolve2(jointRRR1.jointUSR.rod1.frame_a.R,{jointRRR1.jointUSR.rod1.rRod_0[1],jointRRR1.jointUSR.rod1.rRod_0[2],jointRRR1.jointUSR.rod1.rRod_0[3]});
//   jointRRR1.jointUSR.rod1.constraintResidue = 0.0;
//   jointRRR1.jointUSR.rod1.eRod_a[1] = jointRRR1.jointUSR.rod1.rRod_a[1] / jointRRR1.jointUSR.rod1.rodLength;
//   jointRRR1.jointUSR.rod1.eRod_a[2] = jointRRR1.jointUSR.rod1.rRod_a[2] / jointRRR1.jointUSR.rod1.rodLength;
//   jointRRR1.jointUSR.rod1.eRod_a[3] = jointRRR1.jointUSR.rod1.rRod_a[3] / jointRRR1.jointUSR.rod1.rodLength;
//   jointRRR1.jointUSR.rod1.n2_a[1] = jointRRR1.jointUSR.rod1.n1_a[2] * jointRRR1.jointUSR.rod1.eRod_a[3] - jointRRR1.jointUSR.rod1.n1_a[3] * jointRRR1.jointUSR.rod1.eRod_a[2];
//   jointRRR1.jointUSR.rod1.n2_a[2] = jointRRR1.jointUSR.rod1.n1_a[3] * jointRRR1.jointUSR.rod1.eRod_a[1] - jointRRR1.jointUSR.rod1.n1_a[1] * jointRRR1.jointUSR.rod1.eRod_a[3];
//   jointRRR1.jointUSR.rod1.n2_a[3] = jointRRR1.jointUSR.rod1.n1_a[1] * jointRRR1.jointUSR.rod1.eRod_a[2] - jointRRR1.jointUSR.rod1.n1_a[2] * jointRRR1.jointUSR.rod1.eRod_a[1];
//   jointRRR1.jointUSR.rod1.length2_n2_a = jointRRR1.jointUSR.rod1.n2_a[1] ^ 2.0 + (jointRRR1.jointUSR.rod1.n2_a[2] ^ 2.0 + jointRRR1.jointUSR.rod1.n2_a[3] ^ 2.0);
//   assert(jointRRR1.jointUSR.rod1.length2_n2_a > 1e-10,\"
// A Modelica.Mechanics.MultiBody.Joints.UniversalSpherical joint (consisting of
// a universal joint and a spherical joint connected together
// by a rigid rod) is in the singular configuration of the
// universal joint. This means that axis 1 of the universal
// joint defined via parameter \\\"n1_a\\\" is parallel to vector
// \\\"rRod_ia\\\" that is directed from the origin of frame_a to the
// origin of frame_b.
//    You may try to use another \\\"n1_a\\\" vector. If this fails,
// use instead Modelica.Mechanics.MultiBody.Joints.SphericalSpherical, if this is
// possible, because this joint aggregation does not have a
// singular configuration.
// \");
//   jointRRR1.jointUSR.rod1.length_n2_a = sqrt(jointRRR1.jointUSR.rod1.length2_n2_a);
//   jointRRR1.jointUSR.rod1.e2_a[1] = jointRRR1.jointUSR.rod1.n2_a[1] / jointRRR1.jointUSR.rod1.length_n2_a;
//   jointRRR1.jointUSR.rod1.e2_a[2] = jointRRR1.jointUSR.rod1.n2_a[2] / jointRRR1.jointUSR.rod1.length_n2_a;
//   jointRRR1.jointUSR.rod1.e2_a[3] = jointRRR1.jointUSR.rod1.n2_a[3] / jointRRR1.jointUSR.rod1.length_n2_a;
//   jointRRR1.jointUSR.rod1.e3_a[1] = jointRRR1.jointUSR.rod1.eRod_a[2] * jointRRR1.jointUSR.rod1.e2_a[3] - jointRRR1.jointUSR.rod1.eRod_a[3] * jointRRR1.jointUSR.rod1.e2_a[2];
//   jointRRR1.jointUSR.rod1.e3_a[2] = jointRRR1.jointUSR.rod1.eRod_a[3] * jointRRR1.jointUSR.rod1.e2_a[1] - jointRRR1.jointUSR.rod1.eRod_a[1] * jointRRR1.jointUSR.rod1.e2_a[3];
//   jointRRR1.jointUSR.rod1.e3_a[3] = jointRRR1.jointUSR.rod1.eRod_a[1] * jointRRR1.jointUSR.rod1.e2_a[2] - jointRRR1.jointUSR.rod1.eRod_a[2] * jointRRR1.jointUSR.rod1.e2_a[1];
//   jointRRR1.jointUSR.rod1.der_rRod_a_L = (Modelica.Mechanics.MultiBody.Frames.resolve2(jointRRR1.jointUSR.rod1.frame_a.R,{der(jointRRR1.jointUSR.rod1.rRod_0[1]),der(jointRRR1.jointUSR.rod1.rRod_0[2]),der(jointRRR1.jointUSR.rod1.rRod_0[3])}) - {jointRRR1.jointUSR.rod1.frame_a.R.w[2] * jointRRR1.jointUSR.rod1.rRod_a[3] - jointRRR1.jointUSR.rod1.frame_a.R.w[3] * jointRRR1.jointUSR.rod1.rRod_a[2],jointRRR1.jointUSR.rod1.frame_a.R.w[3] * jointRRR1.jointUSR.rod1.rRod_a[1] - jointRRR1.jointUSR.rod1.frame_a.R.w[1] * jointRRR1.jointUSR.rod1.rRod_a[3],jointRRR1.jointUSR.rod1.frame_a.R.w[1] * jointRRR1.jointUSR.rod1.rRod_a[2] - jointRRR1.jointUSR.rod1.frame_a.R.w[2] * jointRRR1.jointUSR.rod1.rRod_a[1]}) / jointRRR1.jointUSR.rod1.rodLength;
//   jointRRR1.jointUSR.rod1.w_rel_ia1[1] = (jointRRR1.jointUSR.rod1.e3_a[1] * (jointRRR1.jointUSR.rod1.n1_a[2] * jointRRR1.jointUSR.rod1.der_rRod_a_L[3] - jointRRR1.jointUSR.rod1.n1_a[3] * jointRRR1.jointUSR.rod1.der_rRod_a_L[2]) + (jointRRR1.jointUSR.rod1.e3_a[2] * (jointRRR1.jointUSR.rod1.n1_a[3] * jointRRR1.jointUSR.rod1.der_rRod_a_L[1] - jointRRR1.jointUSR.rod1.n1_a[1] * jointRRR1.jointUSR.rod1.der_rRod_a_L[3]) + jointRRR1.jointUSR.rod1.e3_a[3] * (jointRRR1.jointUSR.rod1.n1_a[1] * jointRRR1.jointUSR.rod1.der_rRod_a_L[2] - jointRRR1.jointUSR.rod1.n1_a[2] * jointRRR1.jointUSR.rod1.der_rRod_a_L[1]))) / jointRRR1.jointUSR.rod1.length_n2_a;
//   jointRRR1.jointUSR.rod1.w_rel_ia1[2] = (-jointRRR1.jointUSR.rod1.e3_a[1]) * jointRRR1.jointUSR.rod1.der_rRod_a_L[1] + ((-jointRRR1.jointUSR.rod1.e3_a[2]) * jointRRR1.jointUSR.rod1.der_rRod_a_L[2] + (-jointRRR1.jointUSR.rod1.e3_a[3]) * jointRRR1.jointUSR.rod1.der_rRod_a_L[3]);
//   jointRRR1.jointUSR.rod1.w_rel_ia1[3] = jointRRR1.jointUSR.rod1.e2_a[1] * jointRRR1.jointUSR.rod1.der_rRod_a_L[1] + (jointRRR1.jointUSR.rod1.e2_a[2] * jointRRR1.jointUSR.rod1.der_rRod_a_L[2] + jointRRR1.jointUSR.rod1.e2_a[3] * jointRRR1.jointUSR.rod1.der_rRod_a_L[3]);
//   jointRRR1.jointUSR.rod1.R_rel_ia1 = Modelica.Mechanics.MultiBody.Frames.from_T({{jointRRR1.jointUSR.rod1.eRod_a[1],jointRRR1.jointUSR.rod1.eRod_a[2],jointRRR1.jointUSR.rod1.eRod_a[3]},{jointRRR1.jointUSR.rod1.e2_a[1],jointRRR1.jointUSR.rod1.e2_a[2],jointRRR1.jointUSR.rod1.e2_a[3]},{jointRRR1.jointUSR.rod1.e3_a[1],jointRRR1.jointUSR.rod1.e3_a[2],jointRRR1.jointUSR.rod1.e3_a[3]}},{jointRRR1.jointUSR.rod1.w_rel_ia1[1],jointRRR1.jointUSR.rod1.w_rel_ia1[2],jointRRR1.jointUSR.rod1.w_rel_ia1[3]});
//   jointRRR1.jointUSR.rod1.R_rel_ia2 = Modelica.Mechanics.MultiBody.Frames.from_T({{jointRRR1.jointUSR.rod1.eRod_ia[1],jointRRR1.jointUSR.rod1.e2_ia[1],jointRRR1.jointUSR.rod1.e3_ia[1]},{jointRRR1.jointUSR.rod1.eRod_ia[2],jointRRR1.jointUSR.rod1.e2_ia[2],jointRRR1.jointUSR.rod1.e3_ia[2]},{jointRRR1.jointUSR.rod1.eRod_ia[3],jointRRR1.jointUSR.rod1.e2_ia[3],jointRRR1.jointUSR.rod1.e3_ia[3]}},{0.0,0.0,0.0});
//   jointRRR1.jointUSR.rod1.R_rel_ia = Modelica.Mechanics.MultiBody.Frames.absoluteRotation(jointRRR1.jointUSR.rod1.R_rel_ia1,jointRRR1.jointUSR.rod1.R_rel_ia2);
//   jointRRR1.jointUSR.rod1.frame_ia.r_0[1] = jointRRR1.jointUSR.rod1.frame_a.r_0[1];
//   jointRRR1.jointUSR.rod1.frame_ia.r_0[2] = jointRRR1.jointUSR.rod1.frame_a.r_0[2];
//   jointRRR1.jointUSR.rod1.frame_ia.r_0[3] = jointRRR1.jointUSR.rod1.frame_a.r_0[3];
//   jointRRR1.jointUSR.rod1.frame_ia.R = Modelica.Mechanics.MultiBody.Frames.absoluteRotation(jointRRR1.jointUSR.rod1.frame_a.R,jointRRR1.jointUSR.rod1.R_rel_ia);
//   jointRRR1.jointUSR.rod1.f_ia_a = Modelica.Mechanics.MultiBody.Frames.resolve1(jointRRR1.jointUSR.rod1.R_rel_ia,{jointRRR1.jointUSR.rod1.frame_ia.f[1],jointRRR1.jointUSR.rod1.frame_ia.f[2],jointRRR1.jointUSR.rod1.frame_ia.f[3]});
//   jointRRR1.jointUSR.rod1.t_ia_a = Modelica.Mechanics.MultiBody.Frames.resolve1(jointRRR1.jointUSR.rod1.R_rel_ia,{jointRRR1.jointUSR.rod1.frame_ia.t[1],jointRRR1.jointUSR.rod1.frame_ia.t[2],jointRRR1.jointUSR.rod1.frame_ia.t[3]});
//   jointRRR1.jointUSR.rod1.f_b_a1[1] = ((-jointRRR1.jointUSR.rod1.n1_a[1]) * jointRRR1.jointUSR.rod1.t_ia_a[1] + ((-jointRRR1.jointUSR.rod1.n1_a[2]) * jointRRR1.jointUSR.rod1.t_ia_a[2] + (-jointRRR1.jointUSR.rod1.n1_a[3]) * jointRRR1.jointUSR.rod1.t_ia_a[3])) * (jointRRR1.jointUSR.rod1.e2_a[1] * 1.0 / (jointRRR1.jointUSR.rod1.n1_a[1] * jointRRR1.jointUSR.rod1.e3_a[1] + (jointRRR1.jointUSR.rod1.n1_a[2] * jointRRR1.jointUSR.rod1.e3_a[2] + jointRRR1.jointUSR.rod1.n1_a[3] * jointRRR1.jointUSR.rod1.e3_a[3])) / jointRRR1.jointUSR.rod1.rodLength) + (jointRRR1.jointUSR.rod1.e2_a[1] * jointRRR1.jointUSR.rod1.t_ia_a[1] + (jointRRR1.jointUSR.rod1.e2_a[2] * jointRRR1.jointUSR.rod1.t_ia_a[2] + jointRRR1.jointUSR.rod1.e2_a[3] * jointRRR1.jointUSR.rod1.t_ia_a[3])) * jointRRR1.jointUSR.rod1.e3_a[1] / jointRRR1.jointUSR.rod1.rodLength;
//   jointRRR1.jointUSR.rod1.f_b_a1[2] = ((-jointRRR1.jointUSR.rod1.n1_a[1]) * jointRRR1.jointUSR.rod1.t_ia_a[1] + ((-jointRRR1.jointUSR.rod1.n1_a[2]) * jointRRR1.jointUSR.rod1.t_ia_a[2] + (-jointRRR1.jointUSR.rod1.n1_a[3]) * jointRRR1.jointUSR.rod1.t_ia_a[3])) * (jointRRR1.jointUSR.rod1.e2_a[2] * 1.0 / (jointRRR1.jointUSR.rod1.n1_a[1] * jointRRR1.jointUSR.rod1.e3_a[1] + (jointRRR1.jointUSR.rod1.n1_a[2] * jointRRR1.jointUSR.rod1.e3_a[2] + jointRRR1.jointUSR.rod1.n1_a[3] * jointRRR1.jointUSR.rod1.e3_a[3])) / jointRRR1.jointUSR.rod1.rodLength) + (jointRRR1.jointUSR.rod1.e2_a[1] * jointRRR1.jointUSR.rod1.t_ia_a[1] + (jointRRR1.jointUSR.rod1.e2_a[2] * jointRRR1.jointUSR.rod1.t_ia_a[2] + jointRRR1.jointUSR.rod1.e2_a[3] * jointRRR1.jointUSR.rod1.t_ia_a[3])) * jointRRR1.jointUSR.rod1.e3_a[2] / jointRRR1.jointUSR.rod1.rodLength;
//   jointRRR1.jointUSR.rod1.f_b_a1[3] = ((-jointRRR1.jointUSR.rod1.n1_a[1]) * jointRRR1.jointUSR.rod1.t_ia_a[1] + ((-jointRRR1.jointUSR.rod1.n1_a[2]) * jointRRR1.jointUSR.rod1.t_ia_a[2] + (-jointRRR1.jointUSR.rod1.n1_a[3]) * jointRRR1.jointUSR.rod1.t_ia_a[3])) * (jointRRR1.jointUSR.rod1.e2_a[3] * 1.0 / (jointRRR1.jointUSR.rod1.n1_a[1] * jointRRR1.jointUSR.rod1.e3_a[1] + (jointRRR1.jointUSR.rod1.n1_a[2] * jointRRR1.jointUSR.rod1.e3_a[2] + jointRRR1.jointUSR.rod1.n1_a[3] * jointRRR1.jointUSR.rod1.e3_a[3])) / jointRRR1.jointUSR.rod1.rodLength) + (jointRRR1.jointUSR.rod1.e2_a[1] * jointRRR1.jointUSR.rod1.t_ia_a[1] + (jointRRR1.jointUSR.rod1.e2_a[2] * jointRRR1.jointUSR.rod1.t_ia_a[2] + jointRRR1.jointUSR.rod1.e2_a[3] * jointRRR1.jointUSR.rod1.t_ia_a[3])) * jointRRR1.jointUSR.rod1.e3_a[3] / jointRRR1.jointUSR.rod1.rodLength;
//   jointRRR1.jointUSR.rod1.f_b_a[1] = (-jointRRR1.jointUSR.rod1.f_rod) * jointRRR1.jointUSR.rod1.eRod_a[1] + jointRRR1.jointUSR.rod1.f_b_a1[1];
//   jointRRR1.jointUSR.rod1.f_b_a[2] = (-jointRRR1.jointUSR.rod1.f_rod) * jointRRR1.jointUSR.rod1.eRod_a[2] + jointRRR1.jointUSR.rod1.f_b_a1[2];
//   jointRRR1.jointUSR.rod1.f_b_a[3] = (-jointRRR1.jointUSR.rod1.f_rod) * jointRRR1.jointUSR.rod1.eRod_a[3] + jointRRR1.jointUSR.rod1.f_b_a1[3];
//   jointRRR1.jointUSR.rod1.frame_b.f = Modelica.Mechanics.MultiBody.Frames.resolveRelative({jointRRR1.jointUSR.rod1.f_b_a[1],jointRRR1.jointUSR.rod1.f_b_a[2],jointRRR1.jointUSR.rod1.f_b_a[3]},jointRRR1.jointUSR.rod1.frame_a.R,jointRRR1.jointUSR.rod1.frame_b.R);
//   jointRRR1.jointUSR.rod1.frame_b.t[1] = 0.0;
//   jointRRR1.jointUSR.rod1.frame_b.t[2] = 0.0;
//   jointRRR1.jointUSR.rod1.frame_b.t[3] = 0.0;
//   0.0 = jointRRR1.jointUSR.rod1.frame_a.f[1] + (jointRRR1.jointUSR.rod1.f_b_a[1] + jointRRR1.jointUSR.rod1.f_ia_a[1]);
//   0.0 = jointRRR1.jointUSR.rod1.frame_a.f[2] + (jointRRR1.jointUSR.rod1.f_b_a[2] + jointRRR1.jointUSR.rod1.f_ia_a[2]);
//   0.0 = jointRRR1.jointUSR.rod1.frame_a.f[3] + (jointRRR1.jointUSR.rod1.f_b_a[3] + jointRRR1.jointUSR.rod1.f_ia_a[3]);
//   0.0 = jointRRR1.jointUSR.rod1.frame_a.t[1] + (jointRRR1.jointUSR.rod1.t_ia_a[1] + (jointRRR1.jointUSR.rod1.rRod_a[2] * jointRRR1.jointUSR.rod1.f_b_a[3] + (-jointRRR1.jointUSR.rod1.rRod_a[3] * jointRRR1.jointUSR.rod1.f_b_a[2])));
//   0.0 = jointRRR1.jointUSR.rod1.frame_a.t[2] + (jointRRR1.jointUSR.rod1.t_ia_a[2] + (jointRRR1.jointUSR.rod1.rRod_a[3] * jointRRR1.jointUSR.rod1.f_b_a[1] + (-jointRRR1.jointUSR.rod1.rRod_a[1] * jointRRR1.jointUSR.rod1.f_b_a[3])));
//   0.0 = jointRRR1.jointUSR.rod1.frame_a.t[3] + (jointRRR1.jointUSR.rod1.t_ia_a[3] + (jointRRR1.jointUSR.rod1.rRod_a[1] * jointRRR1.jointUSR.rod1.f_b_a[2] + (-jointRRR1.jointUSR.rod1.rRod_a[2] * jointRRR1.jointUSR.rod1.f_b_a[1])));
//   jointRRR1.jointUSR.rod1.totalPower = 0.0;
//   assert(true,\"Connector frame_a of component is not connected\");
//   assert(true,\"Connector frame_b of component is not connected\");
//   assert(true,\"Neither connector frame_a nor frame_b of FixedTranslation object is connected\");
//   jointRRR1.jointUSR.rod2.frame_b.r_0 = jointRRR1.jointUSR.rod2.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(jointRRR1.jointUSR.rod2.frame_a.R,{jointRRR1.jointUSR.rod2.r[1],jointRRR1.jointUSR.rod2.r[2],jointRRR1.jointUSR.rod2.r[3]});
//   jointRRR1.jointUSR.rod2.frame_b.R.T[1,1] = jointRRR1.jointUSR.rod2.frame_a.R.T[1,1];
//   jointRRR1.jointUSR.rod2.frame_b.R.T[1,2] = jointRRR1.jointUSR.rod2.frame_a.R.T[1,2];
//   jointRRR1.jointUSR.rod2.frame_b.R.T[1,3] = jointRRR1.jointUSR.rod2.frame_a.R.T[1,3];
//   jointRRR1.jointUSR.rod2.frame_b.R.T[2,1] = jointRRR1.jointUSR.rod2.frame_a.R.T[2,1];
//   jointRRR1.jointUSR.rod2.frame_b.R.T[2,2] = jointRRR1.jointUSR.rod2.frame_a.R.T[2,2];
//   jointRRR1.jointUSR.rod2.frame_b.R.T[2,3] = jointRRR1.jointUSR.rod2.frame_a.R.T[2,3];
//   jointRRR1.jointUSR.rod2.frame_b.R.T[3,1] = jointRRR1.jointUSR.rod2.frame_a.R.T[3,1];
//   jointRRR1.jointUSR.rod2.frame_b.R.T[3,2] = jointRRR1.jointUSR.rod2.frame_a.R.T[3,2];
//   jointRRR1.jointUSR.rod2.frame_b.R.T[3,3] = jointRRR1.jointUSR.rod2.frame_a.R.T[3,3];
//   jointRRR1.jointUSR.rod2.frame_b.R.w[1] = jointRRR1.jointUSR.rod2.frame_a.R.w[1];
//   jointRRR1.jointUSR.rod2.frame_b.R.w[2] = jointRRR1.jointUSR.rod2.frame_a.R.w[2];
//   jointRRR1.jointUSR.rod2.frame_b.R.w[3] = jointRRR1.jointUSR.rod2.frame_a.R.w[3];
//   0.0 = jointRRR1.jointUSR.rod2.frame_a.f[1] + jointRRR1.jointUSR.rod2.frame_b.f[1];
//   0.0 = jointRRR1.jointUSR.rod2.frame_a.f[2] + jointRRR1.jointUSR.rod2.frame_b.f[2];
//   0.0 = jointRRR1.jointUSR.rod2.frame_a.f[3] + jointRRR1.jointUSR.rod2.frame_b.f[3];
//   0.0 = jointRRR1.jointUSR.rod2.frame_a.t[1] + (jointRRR1.jointUSR.rod2.frame_b.t[1] + (jointRRR1.jointUSR.rod2.r[2] * jointRRR1.jointUSR.rod2.frame_b.f[3] + (-jointRRR1.jointUSR.rod2.r[3] * jointRRR1.jointUSR.rod2.frame_b.f[2])));
//   0.0 = jointRRR1.jointUSR.rod2.frame_a.t[2] + (jointRRR1.jointUSR.rod2.frame_b.t[2] + (jointRRR1.jointUSR.rod2.r[3] * jointRRR1.jointUSR.rod2.frame_b.f[1] + (-jointRRR1.jointUSR.rod2.r[1] * jointRRR1.jointUSR.rod2.frame_b.f[3])));
//   0.0 = jointRRR1.jointUSR.rod2.frame_a.t[3] + (jointRRR1.jointUSR.rod2.frame_b.t[3] + (jointRRR1.jointUSR.rod2.r[1] * jointRRR1.jointUSR.rod2.frame_b.f[2] + (-jointRRR1.jointUSR.rod2.r[2] * jointRRR1.jointUSR.rod2.frame_b.f[1])));
//   jointRRR1.jointUSR.relativePosition.relativePosition.r_rel = Modelica.Mechanics.MultiBody.Frames.resolve2(jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.R,{jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.r_0[1] - jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.r_0[1],jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.r_0[2] - jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.r_0[2],jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.r_0[3] - jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.r_0[3]});
//   assert(true,\"Connector frame_a must be connected at least once\");
//   assert(true,\"Connector frame_b must be connected at least once\");
//   assert(true,\"Connector frame_resolve must be connected exactly once\");
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.f[1] = 0.0;
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.f[2] = 0.0;
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.f[3] = 0.0;
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.t[1] = 0.0;
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.t[2] = 0.0;
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.t[3] = 0.0;
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.f[1] = 0.0;
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.f[2] = 0.0;
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.f[3] = 0.0;
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.t[1] = 0.0;
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.t[2] = 0.0;
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.t[3] = 0.0;
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.f[1] = 0.0;
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.f[2] = 0.0;
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.f[3] = 0.0;
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.t[1] = 0.0;
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.t[2] = 0.0;
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.t[3] = 0.0;
//   jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.w[3] = 0.0;
//   jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.w[2] = 0.0;
//   jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.w[1] = 0.0;
//   jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[3,3] = 1.0;
//   jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[3,2] = 0.0;
//   jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[3,1] = 0.0;
//   jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[2,3] = 0.0;
//   jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[2,2] = 1.0;
//   jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[2,1] = 0.0;
//   jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[1,3] = 0.0;
//   jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[1,2] = 0.0;
//   jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[1,1] = 1.0;
//   jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.r_0[1] = 0.0;
//   jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.r_0[2] = 0.0;
//   jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.r_0[3] = 0.0;
//   assert(true,\"Connector frame_a must be connected at least once\");
//   assert(true,\"Connector frame_b must be connected at least once\");
//   jointRRR1.jointUSR.position_b[1].y = jointRRR1.jointUSR.position_b[1].k;
//   jointRRR1.jointUSR.position_b[2].y = jointRRR1.jointUSR.position_b[2].k;
//   jointRRR1.jointUSR.position_b[3].y = jointRRR1.jointUSR.position_b[3].k;
//   jointRRR1.jointUSR.aux = {jointRRR1.jointUSR.revolute.e[2] * jointRRR1.jointUSR.rRod2_ib[3] - jointRRR1.jointUSR.revolute.e[3] * jointRRR1.jointUSR.rRod2_ib[2],jointRRR1.jointUSR.revolute.e[3] * jointRRR1.jointUSR.rRod2_ib[1] - jointRRR1.jointUSR.revolute.e[1] * jointRRR1.jointUSR.rRod2_ib[3],jointRRR1.jointUSR.revolute.e[1] * jointRRR1.jointUSR.rRod2_ib[2] - jointRRR1.jointUSR.revolute.e[2] * jointRRR1.jointUSR.rRod2_ib[1]} * Modelica.Mechanics.MultiBody.Frames.resolveRelative({jointRRR1.jointUSR.rod1.eRod_a[1],jointRRR1.jointUSR.rod1.eRod_a[2],jointRRR1.jointUSR.rod1.eRod_a[3]},jointRRR1.jointUSR.rod1.frame_a.R,jointRRR1.jointUSR.rod1.frame_b.R);
//   jointRRR1.jointUSR.f_rod = ((-jointRRR1.jointUSR.revolute.tau) - {jointRRR1.jointUSR.revolute.e[1],jointRRR1.jointUSR.revolute.e[2],jointRRR1.jointUSR.revolute.e[3]} * ({jointRRR1.jointUSR.frame_ib.t[1] + jointRRR1.jointUSR.frame_im.t[1] + (jointRRR1.jointUSR.rRod2_ib[2] * jointRRR1.jointUSR.frame_im.f[3] - jointRRR1.jointUSR.rRod2_ib[3] * jointRRR1.jointUSR.frame_im.f[2]),jointRRR1.jointUSR.frame_ib.t[2] + jointRRR1.jointUSR.frame_im.t[2] + (jointRRR1.jointUSR.rRod2_ib[3] * jointRRR1.jointUSR.frame_im.f[1] - jointRRR1.jointUSR.rRod2_ib[1] * jointRRR1.jointUSR.frame_im.f[3]),jointRRR1.jointUSR.frame_ib.t[3] + jointRRR1.jointUSR.frame_im.t[3] + (jointRRR1.jointUSR.rRod2_ib[1] * jointRRR1.jointUSR.frame_im.f[2] - jointRRR1.jointUSR.rRod2_ib[2] * jointRRR1.jointUSR.frame_im.f[1])} - cross({jointRRR1.jointUSR.rRod2_ib[1],jointRRR1.jointUSR.rRod2_ib[2],jointRRR1.jointUSR.rRod2_ib[3]},Modelica.Mechanics.MultiBody.Frames.resolveRelative({jointRRR1.jointUSR.rod1.f_b_a1[1],jointRRR1.jointUSR.rod1.f_b_a1[2],jointRRR1.jointUSR.rod1.f_b_a1[3]},jointRRR1.jointUSR.rod1.frame_a.R,jointRRR1.jointUSR.rod1.frame_b.R)))) / (if noEvent(abs(jointRRR1.jointUSR.aux) < 1e-10) then 1e-10 else jointRRR1.jointUSR.aux);
//   jointRRR1.jointUSR.totalPower = {jointRRR1.jointUSR.frame_a.f[1],jointRRR1.jointUSR.frame_a.f[2],jointRRR1.jointUSR.frame_a.f[3]} * Modelica.Mechanics.MultiBody.Frames.resolve2(jointRRR1.jointUSR.frame_a.R,{der(jointRRR1.jointUSR.frame_a.r_0[1]),der(jointRRR1.jointUSR.frame_a.r_0[2]),der(jointRRR1.jointUSR.frame_a.r_0[3])}) + ({jointRRR1.jointUSR.frame_b.f[1],jointRRR1.jointUSR.frame_b.f[2],jointRRR1.jointUSR.frame_b.f[3]} * Modelica.Mechanics.MultiBody.Frames.resolve2(jointRRR1.jointUSR.frame_b.R,{der(jointRRR1.jointUSR.frame_b.r_0[1]),der(jointRRR1.jointUSR.frame_b.r_0[2]),der(jointRRR1.jointUSR.frame_b.r_0[3])}) + ({jointRRR1.jointUSR.frame_ia.f[1],jointRRR1.jointUSR.frame_ia.f[2],jointRRR1.jointUSR.frame_ia.f[3]} * Modelica.Mechanics.MultiBody.Frames.resolve2(jointRRR1.jointUSR.frame_ia.R,{der(jointRRR1.jointUSR.frame_ia.r_0[1]),der(jointRRR1.jointUSR.frame_ia.r_0[2]),der(jointRRR1.jointUSR.frame_ia.r_0[3])}) + ({jointRRR1.jointUSR.frame_ib.f[1],jointRRR1.jointUSR.frame_ib.f[2],jointRRR1.jointUSR.frame_ib.f[3]} * Modelica.Mechanics.MultiBody.Frames.resolve2(jointRRR1.jointUSR.frame_ib.R,{der(jointRRR1.jointUSR.frame_ib.r_0[1]),der(jointRRR1.jointUSR.frame_ib.r_0[2]),der(jointRRR1.jointUSR.frame_ib.r_0[3])}) + ({jointRRR1.jointUSR.frame_im.f[1],jointRRR1.jointUSR.frame_im.f[2],jointRRR1.jointUSR.frame_im.f[3]} * Modelica.Mechanics.MultiBody.Frames.resolve2(jointRRR1.jointUSR.frame_im.R,{der(jointRRR1.jointUSR.frame_im.r_0[1]),der(jointRRR1.jointUSR.frame_im.r_0[2]),der(jointRRR1.jointUSR.frame_im.r_0[3])}) + ({jointRRR1.jointUSR.frame_a.t[1],jointRRR1.jointUSR.frame_a.t[2],jointRRR1.jointUSR.frame_a.t[3]} * Modelica.Mechanics.MultiBody.Frames.angularVelocity2(jointRRR1.jointUSR.frame_a.R) + ({jointRRR1.jointUSR.frame_b.t[1],jointRRR1.jointUSR.frame_b.t[2],jointRRR1.jointUSR.frame_b.t[3]} * Modelica.Mechanics.MultiBody.Frames.angularVelocity2(jointRRR1.jointUSR.frame_b.R) + ({jointRRR1.jointUSR.frame_ia.t[1],jointRRR1.jointUSR.frame_ia.t[2],jointRRR1.jointUSR.frame_ia.t[3]} * Modelica.Mechanics.MultiBody.Frames.angularVelocity2(jointRRR1.jointUSR.frame_ia.R) + ({jointRRR1.jointUSR.frame_ib.t[1],jointRRR1.jointUSR.frame_ib.t[2],jointRRR1.jointUSR.frame_ib.t[3]} * Modelica.Mechanics.MultiBody.Frames.angularVelocity2(jointRRR1.jointUSR.frame_ib.R) + ({jointRRR1.jointUSR.frame_im.t[1],jointRRR1.jointUSR.frame_im.t[2],jointRRR1.jointUSR.frame_im.t[3]} * Modelica.Mechanics.MultiBody.Frames.angularVelocity2(jointRRR1.jointUSR.frame_im.R) + (jointRRR1.jointUSR.axis.tau * der(jointRRR1.jointUSR.axis.phi) + jointRRR1.jointUSR.bearing.tau * der(jointRRR1.jointUSR.bearing.phi)))))))))));
//   assert(true,\"Connector frame_a of component is not connected\");
//   assert(true,\"Connector frame_b of component is not connected\");
//   jointRRR1.shape_rev1.R.T[1,1] = jointRRR1.frame_a.R.T[1,1];
//   jointRRR1.shape_rev1.R.T[1,2] = jointRRR1.frame_a.R.T[1,2];
//   jointRRR1.shape_rev1.R.T[1,3] = jointRRR1.frame_a.R.T[1,3];
//   jointRRR1.shape_rev1.R.T[2,1] = jointRRR1.frame_a.R.T[2,1];
//   jointRRR1.shape_rev1.R.T[2,2] = jointRRR1.frame_a.R.T[2,2];
//   jointRRR1.shape_rev1.R.T[2,3] = jointRRR1.frame_a.R.T[2,3];
//   jointRRR1.shape_rev1.R.T[3,1] = jointRRR1.frame_a.R.T[3,1];
//   jointRRR1.shape_rev1.R.T[3,2] = jointRRR1.frame_a.R.T[3,2];
//   jointRRR1.shape_rev1.R.T[3,3] = jointRRR1.frame_a.R.T[3,3];
//   jointRRR1.shape_rev1.R.w[1] = jointRRR1.frame_a.R.w[1];
//   jointRRR1.shape_rev1.R.w[2] = jointRRR1.frame_a.R.w[2];
//   jointRRR1.shape_rev1.R.w[3] = jointRRR1.frame_a.R.w[3];
//   jointRRR1.shape_rev1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(jointRRR1.shape_rev1.shapeType);
//   jointRRR1.shape_rev1.rxvisobj[1] = jointRRR1.shape_rev1.R.T[1,1] * jointRRR1.shape_rev1.e_x[1] + (jointRRR1.shape_rev1.R.T[2,1] * jointRRR1.shape_rev1.e_x[2] + jointRRR1.shape_rev1.R.T[3,1] * jointRRR1.shape_rev1.e_x[3]);
//   jointRRR1.shape_rev1.rxvisobj[2] = jointRRR1.shape_rev1.R.T[1,2] * jointRRR1.shape_rev1.e_x[1] + (jointRRR1.shape_rev1.R.T[2,2] * jointRRR1.shape_rev1.e_x[2] + jointRRR1.shape_rev1.R.T[3,2] * jointRRR1.shape_rev1.e_x[3]);
//   jointRRR1.shape_rev1.rxvisobj[3] = jointRRR1.shape_rev1.R.T[1,3] * jointRRR1.shape_rev1.e_x[1] + (jointRRR1.shape_rev1.R.T[2,3] * jointRRR1.shape_rev1.e_x[2] + jointRRR1.shape_rev1.R.T[3,3] * jointRRR1.shape_rev1.e_x[3]);
//   jointRRR1.shape_rev1.ryvisobj[1] = jointRRR1.shape_rev1.R.T[1,1] * jointRRR1.shape_rev1.e_y[1] + (jointRRR1.shape_rev1.R.T[2,1] * jointRRR1.shape_rev1.e_y[2] + jointRRR1.shape_rev1.R.T[3,1] * jointRRR1.shape_rev1.e_y[3]);
//   jointRRR1.shape_rev1.ryvisobj[2] = jointRRR1.shape_rev1.R.T[1,2] * jointRRR1.shape_rev1.e_y[1] + (jointRRR1.shape_rev1.R.T[2,2] * jointRRR1.shape_rev1.e_y[2] + jointRRR1.shape_rev1.R.T[3,2] * jointRRR1.shape_rev1.e_y[3]);
//   jointRRR1.shape_rev1.ryvisobj[3] = jointRRR1.shape_rev1.R.T[1,3] * jointRRR1.shape_rev1.e_y[1] + (jointRRR1.shape_rev1.R.T[2,3] * jointRRR1.shape_rev1.e_y[2] + jointRRR1.shape_rev1.R.T[3,3] * jointRRR1.shape_rev1.e_y[3]);
//   jointRRR1.shape_rev1.rvisobj = jointRRR1.shape_rev1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{jointRRR1.shape_rev1.R.T[1,1],jointRRR1.shape_rev1.R.T[1,2],jointRRR1.shape_rev1.R.T[1,3]},{jointRRR1.shape_rev1.R.T[2,1],jointRRR1.shape_rev1.R.T[2,2],jointRRR1.shape_rev1.R.T[2,3]},{jointRRR1.shape_rev1.R.T[3,1],jointRRR1.shape_rev1.R.T[3,2],jointRRR1.shape_rev1.R.T[3,3]}},{jointRRR1.shape_rev1.r_shape[1],jointRRR1.shape_rev1.r_shape[2],jointRRR1.shape_rev1.r_shape[3]});
//   jointRRR1.shape_rev1.size[1] = jointRRR1.shape_rev1.length;
//   jointRRR1.shape_rev1.size[2] = jointRRR1.shape_rev1.width;
//   jointRRR1.shape_rev1.size[3] = jointRRR1.shape_rev1.height;
//   jointRRR1.shape_rev1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(jointRRR1.shape_rev1.color[1] / 255.0,jointRRR1.shape_rev1.color[2] / 255.0,jointRRR1.shape_rev1.color[3] / 255.0,jointRRR1.shape_rev1.specularCoefficient);
//   jointRRR1.shape_rev1.Extra = jointRRR1.shape_rev1.extra;
//   jointRRR1.shape_rev2.R.T[1,1] = jointRRR1.frame_im.R.T[1,1];
//   jointRRR1.shape_rev2.R.T[1,2] = jointRRR1.frame_im.R.T[1,2];
//   jointRRR1.shape_rev2.R.T[1,3] = jointRRR1.frame_im.R.T[1,3];
//   jointRRR1.shape_rev2.R.T[2,1] = jointRRR1.frame_im.R.T[2,1];
//   jointRRR1.shape_rev2.R.T[2,2] = jointRRR1.frame_im.R.T[2,2];
//   jointRRR1.shape_rev2.R.T[2,3] = jointRRR1.frame_im.R.T[2,3];
//   jointRRR1.shape_rev2.R.T[3,1] = jointRRR1.frame_im.R.T[3,1];
//   jointRRR1.shape_rev2.R.T[3,2] = jointRRR1.frame_im.R.T[3,2];
//   jointRRR1.shape_rev2.R.T[3,3] = jointRRR1.frame_im.R.T[3,3];
//   jointRRR1.shape_rev2.R.w[1] = jointRRR1.frame_im.R.w[1];
//   jointRRR1.shape_rev2.R.w[2] = jointRRR1.frame_im.R.w[2];
//   jointRRR1.shape_rev2.R.w[3] = jointRRR1.frame_im.R.w[3];
//   jointRRR1.shape_rev2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(jointRRR1.shape_rev2.shapeType);
//   jointRRR1.shape_rev2.rxvisobj[1] = jointRRR1.shape_rev2.R.T[1,1] * jointRRR1.shape_rev2.e_x[1] + (jointRRR1.shape_rev2.R.T[2,1] * jointRRR1.shape_rev2.e_x[2] + jointRRR1.shape_rev2.R.T[3,1] * jointRRR1.shape_rev2.e_x[3]);
//   jointRRR1.shape_rev2.rxvisobj[2] = jointRRR1.shape_rev2.R.T[1,2] * jointRRR1.shape_rev2.e_x[1] + (jointRRR1.shape_rev2.R.T[2,2] * jointRRR1.shape_rev2.e_x[2] + jointRRR1.shape_rev2.R.T[3,2] * jointRRR1.shape_rev2.e_x[3]);
//   jointRRR1.shape_rev2.rxvisobj[3] = jointRRR1.shape_rev2.R.T[1,3] * jointRRR1.shape_rev2.e_x[1] + (jointRRR1.shape_rev2.R.T[2,3] * jointRRR1.shape_rev2.e_x[2] + jointRRR1.shape_rev2.R.T[3,3] * jointRRR1.shape_rev2.e_x[3]);
//   jointRRR1.shape_rev2.ryvisobj[1] = jointRRR1.shape_rev2.R.T[1,1] * jointRRR1.shape_rev2.e_y[1] + (jointRRR1.shape_rev2.R.T[2,1] * jointRRR1.shape_rev2.e_y[2] + jointRRR1.shape_rev2.R.T[3,1] * jointRRR1.shape_rev2.e_y[3]);
//   jointRRR1.shape_rev2.ryvisobj[2] = jointRRR1.shape_rev2.R.T[1,2] * jointRRR1.shape_rev2.e_y[1] + (jointRRR1.shape_rev2.R.T[2,2] * jointRRR1.shape_rev2.e_y[2] + jointRRR1.shape_rev2.R.T[3,2] * jointRRR1.shape_rev2.e_y[3]);
//   jointRRR1.shape_rev2.ryvisobj[3] = jointRRR1.shape_rev2.R.T[1,3] * jointRRR1.shape_rev2.e_y[1] + (jointRRR1.shape_rev2.R.T[2,3] * jointRRR1.shape_rev2.e_y[2] + jointRRR1.shape_rev2.R.T[3,3] * jointRRR1.shape_rev2.e_y[3]);
//   jointRRR1.shape_rev2.rvisobj = jointRRR1.shape_rev2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{jointRRR1.shape_rev2.R.T[1,1],jointRRR1.shape_rev2.R.T[1,2],jointRRR1.shape_rev2.R.T[1,3]},{jointRRR1.shape_rev2.R.T[2,1],jointRRR1.shape_rev2.R.T[2,2],jointRRR1.shape_rev2.R.T[2,3]},{jointRRR1.shape_rev2.R.T[3,1],jointRRR1.shape_rev2.R.T[3,2],jointRRR1.shape_rev2.R.T[3,3]}},{jointRRR1.shape_rev2.r_shape[1],jointRRR1.shape_rev2.r_shape[2],jointRRR1.shape_rev2.r_shape[3]});
//   jointRRR1.shape_rev2.size[1] = jointRRR1.shape_rev2.length;
//   jointRRR1.shape_rev2.size[2] = jointRRR1.shape_rev2.width;
//   jointRRR1.shape_rev2.size[3] = jointRRR1.shape_rev2.height;
//   jointRRR1.shape_rev2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(jointRRR1.shape_rev2.color[1] / 255.0,jointRRR1.shape_rev2.color[2] / 255.0,jointRRR1.shape_rev2.color[3] / 255.0,jointRRR1.shape_rev2.specularCoefficient);
//   jointRRR1.shape_rev2.Extra = jointRRR1.shape_rev2.extra;
//   jointRRR1.shape_rev3.R.T[1,1] = jointRRR1.frame_b.R.T[1,1];
//   jointRRR1.shape_rev3.R.T[1,2] = jointRRR1.frame_b.R.T[1,2];
//   jointRRR1.shape_rev3.R.T[1,3] = jointRRR1.frame_b.R.T[1,3];
//   jointRRR1.shape_rev3.R.T[2,1] = jointRRR1.frame_b.R.T[2,1];
//   jointRRR1.shape_rev3.R.T[2,2] = jointRRR1.frame_b.R.T[2,2];
//   jointRRR1.shape_rev3.R.T[2,3] = jointRRR1.frame_b.R.T[2,3];
//   jointRRR1.shape_rev3.R.T[3,1] = jointRRR1.frame_b.R.T[3,1];
//   jointRRR1.shape_rev3.R.T[3,2] = jointRRR1.frame_b.R.T[3,2];
//   jointRRR1.shape_rev3.R.T[3,3] = jointRRR1.frame_b.R.T[3,3];
//   jointRRR1.shape_rev3.R.w[1] = jointRRR1.frame_b.R.w[1];
//   jointRRR1.shape_rev3.R.w[2] = jointRRR1.frame_b.R.w[2];
//   jointRRR1.shape_rev3.R.w[3] = jointRRR1.frame_b.R.w[3];
//   jointRRR1.shape_rev3.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(jointRRR1.shape_rev3.shapeType);
//   jointRRR1.shape_rev3.rxvisobj[1] = jointRRR1.shape_rev3.R.T[1,1] * jointRRR1.shape_rev3.e_x[1] + (jointRRR1.shape_rev3.R.T[2,1] * jointRRR1.shape_rev3.e_x[2] + jointRRR1.shape_rev3.R.T[3,1] * jointRRR1.shape_rev3.e_x[3]);
//   jointRRR1.shape_rev3.rxvisobj[2] = jointRRR1.shape_rev3.R.T[1,2] * jointRRR1.shape_rev3.e_x[1] + (jointRRR1.shape_rev3.R.T[2,2] * jointRRR1.shape_rev3.e_x[2] + jointRRR1.shape_rev3.R.T[3,2] * jointRRR1.shape_rev3.e_x[3]);
//   jointRRR1.shape_rev3.rxvisobj[3] = jointRRR1.shape_rev3.R.T[1,3] * jointRRR1.shape_rev3.e_x[1] + (jointRRR1.shape_rev3.R.T[2,3] * jointRRR1.shape_rev3.e_x[2] + jointRRR1.shape_rev3.R.T[3,3] * jointRRR1.shape_rev3.e_x[3]);
//   jointRRR1.shape_rev3.ryvisobj[1] = jointRRR1.shape_rev3.R.T[1,1] * jointRRR1.shape_rev3.e_y[1] + (jointRRR1.shape_rev3.R.T[2,1] * jointRRR1.shape_rev3.e_y[2] + jointRRR1.shape_rev3.R.T[3,1] * jointRRR1.shape_rev3.e_y[3]);
//   jointRRR1.shape_rev3.ryvisobj[2] = jointRRR1.shape_rev3.R.T[1,2] * jointRRR1.shape_rev3.e_y[1] + (jointRRR1.shape_rev3.R.T[2,2] * jointRRR1.shape_rev3.e_y[2] + jointRRR1.shape_rev3.R.T[3,2] * jointRRR1.shape_rev3.e_y[3]);
//   jointRRR1.shape_rev3.ryvisobj[3] = jointRRR1.shape_rev3.R.T[1,3] * jointRRR1.shape_rev3.e_y[1] + (jointRRR1.shape_rev3.R.T[2,3] * jointRRR1.shape_rev3.e_y[2] + jointRRR1.shape_rev3.R.T[3,3] * jointRRR1.shape_rev3.e_y[3]);
//   jointRRR1.shape_rev3.rvisobj = jointRRR1.shape_rev3.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{jointRRR1.shape_rev3.R.T[1,1],jointRRR1.shape_rev3.R.T[1,2],jointRRR1.shape_rev3.R.T[1,3]},{jointRRR1.shape_rev3.R.T[2,1],jointRRR1.shape_rev3.R.T[2,2],jointRRR1.shape_rev3.R.T[2,3]},{jointRRR1.shape_rev3.R.T[3,1],jointRRR1.shape_rev3.R.T[3,2],jointRRR1.shape_rev3.R.T[3,3]}},{jointRRR1.shape_rev3.r_shape[1],jointRRR1.shape_rev3.r_shape[2],jointRRR1.shape_rev3.r_shape[3]});
//   jointRRR1.shape_rev3.size[1] = jointRRR1.shape_rev3.length;
//   jointRRR1.shape_rev3.size[2] = jointRRR1.shape_rev3.width;
//   jointRRR1.shape_rev3.size[3] = jointRRR1.shape_rev3.height;
//   jointRRR1.shape_rev3.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(jointRRR1.shape_rev3.color[1] / 255.0,jointRRR1.shape_rev3.color[2] / 255.0,jointRRR1.shape_rev3.color[3] / 255.0,jointRRR1.shape_rev3.specularCoefficient);
//   jointRRR1.shape_rev3.Extra = jointRRR1.shape_rev3.extra;
//   jointRRR1.shape_rod1.R.T[1,1] = jointRRR1.frame_ia.R.T[1,1];
//   jointRRR1.shape_rod1.R.T[1,2] = jointRRR1.frame_ia.R.T[1,2];
//   jointRRR1.shape_rod1.R.T[1,3] = jointRRR1.frame_ia.R.T[1,3];
//   jointRRR1.shape_rod1.R.T[2,1] = jointRRR1.frame_ia.R.T[2,1];
//   jointRRR1.shape_rod1.R.T[2,2] = jointRRR1.frame_ia.R.T[2,2];
//   jointRRR1.shape_rod1.R.T[2,3] = jointRRR1.frame_ia.R.T[2,3];
//   jointRRR1.shape_rod1.R.T[3,1] = jointRRR1.frame_ia.R.T[3,1];
//   jointRRR1.shape_rod1.R.T[3,2] = jointRRR1.frame_ia.R.T[3,2];
//   jointRRR1.shape_rod1.R.T[3,3] = jointRRR1.frame_ia.R.T[3,3];
//   jointRRR1.shape_rod1.R.w[1] = jointRRR1.frame_ia.R.w[1];
//   jointRRR1.shape_rod1.R.w[2] = jointRRR1.frame_ia.R.w[2];
//   jointRRR1.shape_rod1.R.w[3] = jointRRR1.frame_ia.R.w[3];
//   jointRRR1.shape_rod1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(jointRRR1.shape_rod1.shapeType);
//   jointRRR1.shape_rod1.rxvisobj[1] = jointRRR1.shape_rod1.R.T[1,1] * jointRRR1.shape_rod1.e_x[1] + (jointRRR1.shape_rod1.R.T[2,1] * jointRRR1.shape_rod1.e_x[2] + jointRRR1.shape_rod1.R.T[3,1] * jointRRR1.shape_rod1.e_x[3]);
//   jointRRR1.shape_rod1.rxvisobj[2] = jointRRR1.shape_rod1.R.T[1,2] * jointRRR1.shape_rod1.e_x[1] + (jointRRR1.shape_rod1.R.T[2,2] * jointRRR1.shape_rod1.e_x[2] + jointRRR1.shape_rod1.R.T[3,2] * jointRRR1.shape_rod1.e_x[3]);
//   jointRRR1.shape_rod1.rxvisobj[3] = jointRRR1.shape_rod1.R.T[1,3] * jointRRR1.shape_rod1.e_x[1] + (jointRRR1.shape_rod1.R.T[2,3] * jointRRR1.shape_rod1.e_x[2] + jointRRR1.shape_rod1.R.T[3,3] * jointRRR1.shape_rod1.e_x[3]);
//   jointRRR1.shape_rod1.ryvisobj[1] = jointRRR1.shape_rod1.R.T[1,1] * jointRRR1.shape_rod1.e_y[1] + (jointRRR1.shape_rod1.R.T[2,1] * jointRRR1.shape_rod1.e_y[2] + jointRRR1.shape_rod1.R.T[3,1] * jointRRR1.shape_rod1.e_y[3]);
//   jointRRR1.shape_rod1.ryvisobj[2] = jointRRR1.shape_rod1.R.T[1,2] * jointRRR1.shape_rod1.e_y[1] + (jointRRR1.shape_rod1.R.T[2,2] * jointRRR1.shape_rod1.e_y[2] + jointRRR1.shape_rod1.R.T[3,2] * jointRRR1.shape_rod1.e_y[3]);
//   jointRRR1.shape_rod1.ryvisobj[3] = jointRRR1.shape_rod1.R.T[1,3] * jointRRR1.shape_rod1.e_y[1] + (jointRRR1.shape_rod1.R.T[2,3] * jointRRR1.shape_rod1.e_y[2] + jointRRR1.shape_rod1.R.T[3,3] * jointRRR1.shape_rod1.e_y[3]);
//   jointRRR1.shape_rod1.rvisobj = jointRRR1.shape_rod1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{jointRRR1.shape_rod1.R.T[1,1],jointRRR1.shape_rod1.R.T[1,2],jointRRR1.shape_rod1.R.T[1,3]},{jointRRR1.shape_rod1.R.T[2,1],jointRRR1.shape_rod1.R.T[2,2],jointRRR1.shape_rod1.R.T[2,3]},{jointRRR1.shape_rod1.R.T[3,1],jointRRR1.shape_rod1.R.T[3,2],jointRRR1.shape_rod1.R.T[3,3]}},{jointRRR1.shape_rod1.r_shape[1],jointRRR1.shape_rod1.r_shape[2],jointRRR1.shape_rod1.r_shape[3]});
//   jointRRR1.shape_rod1.size[1] = jointRRR1.shape_rod1.length;
//   jointRRR1.shape_rod1.size[2] = jointRRR1.shape_rod1.width;
//   jointRRR1.shape_rod1.size[3] = jointRRR1.shape_rod1.height;
//   jointRRR1.shape_rod1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(jointRRR1.shape_rod1.color[1] / 255.0,jointRRR1.shape_rod1.color[2] / 255.0,jointRRR1.shape_rod1.color[3] / 255.0,jointRRR1.shape_rod1.specularCoefficient);
//   jointRRR1.shape_rod1.Extra = jointRRR1.shape_rod1.extra;
//   jointRRR1.shape_rod2.R.T[1,1] = jointRRR1.frame_ib.R.T[1,1];
//   jointRRR1.shape_rod2.R.T[1,2] = jointRRR1.frame_ib.R.T[1,2];
//   jointRRR1.shape_rod2.R.T[1,3] = jointRRR1.frame_ib.R.T[1,3];
//   jointRRR1.shape_rod2.R.T[2,1] = jointRRR1.frame_ib.R.T[2,1];
//   jointRRR1.shape_rod2.R.T[2,2] = jointRRR1.frame_ib.R.T[2,2];
//   jointRRR1.shape_rod2.R.T[2,3] = jointRRR1.frame_ib.R.T[2,3];
//   jointRRR1.shape_rod2.R.T[3,1] = jointRRR1.frame_ib.R.T[3,1];
//   jointRRR1.shape_rod2.R.T[3,2] = jointRRR1.frame_ib.R.T[3,2];
//   jointRRR1.shape_rod2.R.T[3,3] = jointRRR1.frame_ib.R.T[3,3];
//   jointRRR1.shape_rod2.R.w[1] = jointRRR1.frame_ib.R.w[1];
//   jointRRR1.shape_rod2.R.w[2] = jointRRR1.frame_ib.R.w[2];
//   jointRRR1.shape_rod2.R.w[3] = jointRRR1.frame_ib.R.w[3];
//   jointRRR1.shape_rod2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(jointRRR1.shape_rod2.shapeType);
//   jointRRR1.shape_rod2.rxvisobj[1] = jointRRR1.shape_rod2.R.T[1,1] * jointRRR1.shape_rod2.e_x[1] + (jointRRR1.shape_rod2.R.T[2,1] * jointRRR1.shape_rod2.e_x[2] + jointRRR1.shape_rod2.R.T[3,1] * jointRRR1.shape_rod2.e_x[3]);
//   jointRRR1.shape_rod2.rxvisobj[2] = jointRRR1.shape_rod2.R.T[1,2] * jointRRR1.shape_rod2.e_x[1] + (jointRRR1.shape_rod2.R.T[2,2] * jointRRR1.shape_rod2.e_x[2] + jointRRR1.shape_rod2.R.T[3,2] * jointRRR1.shape_rod2.e_x[3]);
//   jointRRR1.shape_rod2.rxvisobj[3] = jointRRR1.shape_rod2.R.T[1,3] * jointRRR1.shape_rod2.e_x[1] + (jointRRR1.shape_rod2.R.T[2,3] * jointRRR1.shape_rod2.e_x[2] + jointRRR1.shape_rod2.R.T[3,3] * jointRRR1.shape_rod2.e_x[3]);
//   jointRRR1.shape_rod2.ryvisobj[1] = jointRRR1.shape_rod2.R.T[1,1] * jointRRR1.shape_rod2.e_y[1] + (jointRRR1.shape_rod2.R.T[2,1] * jointRRR1.shape_rod2.e_y[2] + jointRRR1.shape_rod2.R.T[3,1] * jointRRR1.shape_rod2.e_y[3]);
//   jointRRR1.shape_rod2.ryvisobj[2] = jointRRR1.shape_rod2.R.T[1,2] * jointRRR1.shape_rod2.e_y[1] + (jointRRR1.shape_rod2.R.T[2,2] * jointRRR1.shape_rod2.e_y[2] + jointRRR1.shape_rod2.R.T[3,2] * jointRRR1.shape_rod2.e_y[3]);
//   jointRRR1.shape_rod2.ryvisobj[3] = jointRRR1.shape_rod2.R.T[1,3] * jointRRR1.shape_rod2.e_y[1] + (jointRRR1.shape_rod2.R.T[2,3] * jointRRR1.shape_rod2.e_y[2] + jointRRR1.shape_rod2.R.T[3,3] * jointRRR1.shape_rod2.e_y[3]);
//   jointRRR1.shape_rod2.rvisobj = jointRRR1.shape_rod2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{jointRRR1.shape_rod2.R.T[1,1],jointRRR1.shape_rod2.R.T[1,2],jointRRR1.shape_rod2.R.T[1,3]},{jointRRR1.shape_rod2.R.T[2,1],jointRRR1.shape_rod2.R.T[2,2],jointRRR1.shape_rod2.R.T[2,3]},{jointRRR1.shape_rod2.R.T[3,1],jointRRR1.shape_rod2.R.T[3,2],jointRRR1.shape_rod2.R.T[3,3]}},{jointRRR1.shape_rod2.r_shape[1],jointRRR1.shape_rod2.r_shape[2],jointRRR1.shape_rod2.r_shape[3]});
//   jointRRR1.shape_rod2.size[1] = jointRRR1.shape_rod2.length;
//   jointRRR1.shape_rod2.size[2] = jointRRR1.shape_rod2.width;
//   jointRRR1.shape_rod2.size[3] = jointRRR1.shape_rod2.height;
//   jointRRR1.shape_rod2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(jointRRR1.shape_rod2.color[1] / 255.0,jointRRR1.shape_rod2.color[2] / 255.0,jointRRR1.shape_rod2.color[3] / 255.0,jointRRR1.shape_rod2.specularCoefficient);
//   jointRRR1.shape_rod2.Extra = jointRRR1.shape_rod2.extra;
//   assert(true,\"Connector frame_a of component is not connected\");
//   assert(true,\"Connector frame_b of component is not connected\");
//   rev.fixed.flange.phi = rev.fixed.phi0;
//   rev.internalAxis.flange.tau = rev.internalAxis.tau;
//   rev.internalAxis.flange.phi = rev.internalAxis.phi;
//   rev.cylinder.R.T[1,1] = rev.frame_a.R.T[1,1];
//   rev.cylinder.R.T[1,2] = rev.frame_a.R.T[1,2];
//   rev.cylinder.R.T[1,3] = rev.frame_a.R.T[1,3];
//   rev.cylinder.R.T[2,1] = rev.frame_a.R.T[2,1];
//   rev.cylinder.R.T[2,2] = rev.frame_a.R.T[2,2];
//   rev.cylinder.R.T[2,3] = rev.frame_a.R.T[2,3];
//   rev.cylinder.R.T[3,1] = rev.frame_a.R.T[3,1];
//   rev.cylinder.R.T[3,2] = rev.frame_a.R.T[3,2];
//   rev.cylinder.R.T[3,3] = rev.frame_a.R.T[3,3];
//   rev.cylinder.R.w[1] = rev.frame_a.R.w[1];
//   rev.cylinder.R.w[2] = rev.frame_a.R.w[2];
//   rev.cylinder.R.w[3] = rev.frame_a.R.w[3];
//   rev.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(rev.cylinder.shapeType);
//   rev.cylinder.rxvisobj[1] = rev.cylinder.R.T[1,1] * rev.cylinder.e_x[1] + (rev.cylinder.R.T[2,1] * rev.cylinder.e_x[2] + rev.cylinder.R.T[3,1] * rev.cylinder.e_x[3]);
//   rev.cylinder.rxvisobj[2] = rev.cylinder.R.T[1,2] * rev.cylinder.e_x[1] + (rev.cylinder.R.T[2,2] * rev.cylinder.e_x[2] + rev.cylinder.R.T[3,2] * rev.cylinder.e_x[3]);
//   rev.cylinder.rxvisobj[3] = rev.cylinder.R.T[1,3] * rev.cylinder.e_x[1] + (rev.cylinder.R.T[2,3] * rev.cylinder.e_x[2] + rev.cylinder.R.T[3,3] * rev.cylinder.e_x[3]);
//   rev.cylinder.ryvisobj[1] = rev.cylinder.R.T[1,1] * rev.cylinder.e_y[1] + (rev.cylinder.R.T[2,1] * rev.cylinder.e_y[2] + rev.cylinder.R.T[3,1] * rev.cylinder.e_y[3]);
//   rev.cylinder.ryvisobj[2] = rev.cylinder.R.T[1,2] * rev.cylinder.e_y[1] + (rev.cylinder.R.T[2,2] * rev.cylinder.e_y[2] + rev.cylinder.R.T[3,2] * rev.cylinder.e_y[3]);
//   rev.cylinder.ryvisobj[3] = rev.cylinder.R.T[1,3] * rev.cylinder.e_y[1] + (rev.cylinder.R.T[2,3] * rev.cylinder.e_y[2] + rev.cylinder.R.T[3,3] * rev.cylinder.e_y[3]);
//   rev.cylinder.rvisobj = rev.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{rev.cylinder.R.T[1,1],rev.cylinder.R.T[1,2],rev.cylinder.R.T[1,3]},{rev.cylinder.R.T[2,1],rev.cylinder.R.T[2,2],rev.cylinder.R.T[2,3]},{rev.cylinder.R.T[3,1],rev.cylinder.R.T[3,2],rev.cylinder.R.T[3,3]}},{rev.cylinder.r_shape[1],rev.cylinder.r_shape[2],rev.cylinder.r_shape[3]});
//   rev.cylinder.size[1] = rev.cylinder.length;
//   rev.cylinder.size[2] = rev.cylinder.width;
//   rev.cylinder.size[3] = rev.cylinder.height;
//   rev.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(rev.cylinder.color[1] / 255.0,rev.cylinder.color[2] / 255.0,rev.cylinder.color[3] / 255.0,rev.cylinder.specularCoefficient);
//   rev.cylinder.Extra = rev.cylinder.extra;
//   assert(true,\"Connector frame_a of revolute joint is not connected\");
//   assert(true,\"Connector frame_b of revolute joint is not connected\");
//   rev.angle = rev.phi;
//   rev.w = der(rev.phi);
//   rev.a = der(rev.w);
//   rev.frame_b.r_0[1] = rev.frame_a.r_0[1];
//   rev.frame_b.r_0[2] = rev.frame_a.r_0[2];
//   rev.frame_b.r_0[3] = rev.frame_a.r_0[3];
//   rev.R_rel = Modelica.Mechanics.MultiBody.Frames.planarRotation({rev.e[1],rev.e[2],rev.e[3]},rev.phi,rev.w);
//   rev.frame_b.R = Modelica.Mechanics.MultiBody.Frames.absoluteRotation(rev.frame_a.R,rev.R_rel);
//   rev.frame_a.f = -Modelica.Mechanics.MultiBody.Frames.resolve1(rev.R_rel,{rev.frame_b.f[1],rev.frame_b.f[2],rev.frame_b.f[3]});
//   rev.frame_a.t = -Modelica.Mechanics.MultiBody.Frames.resolve1(rev.R_rel,{rev.frame_b.t[1],rev.frame_b.t[2],rev.frame_b.t[3]});
//   rev.tau = (-rev.frame_b.t[1]) * rev.e[1] + ((-rev.frame_b.t[2]) * rev.e[2] + (-rev.frame_b.t[3]) * rev.e[3]);
//   rev.phi = rev.internalAxis.phi;
//   rod1.shape.R.T[1,1] = rod1.frame_a.R.T[1,1];
//   rod1.shape.R.T[1,2] = rod1.frame_a.R.T[1,2];
//   rod1.shape.R.T[1,3] = rod1.frame_a.R.T[1,3];
//   rod1.shape.R.T[2,1] = rod1.frame_a.R.T[2,1];
//   rod1.shape.R.T[2,2] = rod1.frame_a.R.T[2,2];
//   rod1.shape.R.T[2,3] = rod1.frame_a.R.T[2,3];
//   rod1.shape.R.T[3,1] = rod1.frame_a.R.T[3,1];
//   rod1.shape.R.T[3,2] = rod1.frame_a.R.T[3,2];
//   rod1.shape.R.T[3,3] = rod1.frame_a.R.T[3,3];
//   rod1.shape.R.w[1] = rod1.frame_a.R.w[1];
//   rod1.shape.R.w[2] = rod1.frame_a.R.w[2];
//   rod1.shape.R.w[3] = rod1.frame_a.R.w[3];
//   rod1.shape.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(rod1.shape.shapeType);
//   rod1.shape.rxvisobj[1] = rod1.shape.R.T[1,1] * rod1.shape.e_x[1] + (rod1.shape.R.T[2,1] * rod1.shape.e_x[2] + rod1.shape.R.T[3,1] * rod1.shape.e_x[3]);
//   rod1.shape.rxvisobj[2] = rod1.shape.R.T[1,2] * rod1.shape.e_x[1] + (rod1.shape.R.T[2,2] * rod1.shape.e_x[2] + rod1.shape.R.T[3,2] * rod1.shape.e_x[3]);
//   rod1.shape.rxvisobj[3] = rod1.shape.R.T[1,3] * rod1.shape.e_x[1] + (rod1.shape.R.T[2,3] * rod1.shape.e_x[2] + rod1.shape.R.T[3,3] * rod1.shape.e_x[3]);
//   rod1.shape.ryvisobj[1] = rod1.shape.R.T[1,1] * rod1.shape.e_y[1] + (rod1.shape.R.T[2,1] * rod1.shape.e_y[2] + rod1.shape.R.T[3,1] * rod1.shape.e_y[3]);
//   rod1.shape.ryvisobj[2] = rod1.shape.R.T[1,2] * rod1.shape.e_y[1] + (rod1.shape.R.T[2,2] * rod1.shape.e_y[2] + rod1.shape.R.T[3,2] * rod1.shape.e_y[3]);
//   rod1.shape.ryvisobj[3] = rod1.shape.R.T[1,3] * rod1.shape.e_y[1] + (rod1.shape.R.T[2,3] * rod1.shape.e_y[2] + rod1.shape.R.T[3,3] * rod1.shape.e_y[3]);
//   rod1.shape.rvisobj = rod1.shape.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{rod1.shape.R.T[1,1],rod1.shape.R.T[1,2],rod1.shape.R.T[1,3]},{rod1.shape.R.T[2,1],rod1.shape.R.T[2,2],rod1.shape.R.T[2,3]},{rod1.shape.R.T[3,1],rod1.shape.R.T[3,2],rod1.shape.R.T[3,3]}},{rod1.shape.r_shape[1],rod1.shape.r_shape[2],rod1.shape.r_shape[3]});
//   rod1.shape.size[1] = rod1.shape.length;
//   rod1.shape.size[2] = rod1.shape.width;
//   rod1.shape.size[3] = rod1.shape.height;
//   rod1.shape.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(rod1.shape.color[1] / 255.0,rod1.shape.color[2] / 255.0,rod1.shape.color[3] / 255.0,rod1.shape.specularCoefficient);
//   rod1.shape.Extra = rod1.shape.extra;
//   assert(true,\"Neither connector frame_a nor frame_b of FixedTranslation object is connected\");
//   rod1.frame_b.r_0 = rod1.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(rod1.frame_a.R,{rod1.r[1],rod1.r[2],rod1.r[3]});
//   rod1.frame_b.R.T[1,1] = rod1.frame_a.R.T[1,1];
//   rod1.frame_b.R.T[1,2] = rod1.frame_a.R.T[1,2];
//   rod1.frame_b.R.T[1,3] = rod1.frame_a.R.T[1,3];
//   rod1.frame_b.R.T[2,1] = rod1.frame_a.R.T[2,1];
//   rod1.frame_b.R.T[2,2] = rod1.frame_a.R.T[2,2];
//   rod1.frame_b.R.T[2,3] = rod1.frame_a.R.T[2,3];
//   rod1.frame_b.R.T[3,1] = rod1.frame_a.R.T[3,1];
//   rod1.frame_b.R.T[3,2] = rod1.frame_a.R.T[3,2];
//   rod1.frame_b.R.T[3,3] = rod1.frame_a.R.T[3,3];
//   rod1.frame_b.R.w[1] = rod1.frame_a.R.w[1];
//   rod1.frame_b.R.w[2] = rod1.frame_a.R.w[2];
//   rod1.frame_b.R.w[3] = rod1.frame_a.R.w[3];
//   0.0 = rod1.frame_a.f[1] + rod1.frame_b.f[1];
//   0.0 = rod1.frame_a.f[2] + rod1.frame_b.f[2];
//   0.0 = rod1.frame_a.f[3] + rod1.frame_b.f[3];
//   0.0 = rod1.frame_a.t[1] + (rod1.frame_b.t[1] + (rod1.r[2] * rod1.frame_b.f[3] + (-rod1.r[3] * rod1.frame_b.f[2])));
//   0.0 = rod1.frame_a.t[2] + (rod1.frame_b.t[2] + (rod1.r[3] * rod1.frame_b.f[1] + (-rod1.r[1] * rod1.frame_b.f[3])));
//   0.0 = rod1.frame_a.t[3] + (rod1.frame_b.t[3] + (rod1.r[1] * rod1.frame_b.f[2] + (-rod1.r[2] * rod1.frame_b.f[1])));
//   rod2.shape.R.T[1,1] = rod2.frame_a.R.T[1,1];
//   rod2.shape.R.T[1,2] = rod2.frame_a.R.T[1,2];
//   rod2.shape.R.T[1,3] = rod2.frame_a.R.T[1,3];
//   rod2.shape.R.T[2,1] = rod2.frame_a.R.T[2,1];
//   rod2.shape.R.T[2,2] = rod2.frame_a.R.T[2,2];
//   rod2.shape.R.T[2,3] = rod2.frame_a.R.T[2,3];
//   rod2.shape.R.T[3,1] = rod2.frame_a.R.T[3,1];
//   rod2.shape.R.T[3,2] = rod2.frame_a.R.T[3,2];
//   rod2.shape.R.T[3,3] = rod2.frame_a.R.T[3,3];
//   rod2.shape.R.w[1] = rod2.frame_a.R.w[1];
//   rod2.shape.R.w[2] = rod2.frame_a.R.w[2];
//   rod2.shape.R.w[3] = rod2.frame_a.R.w[3];
//   rod2.shape.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(rod2.shape.shapeType);
//   rod2.shape.rxvisobj[1] = rod2.shape.R.T[1,1] * rod2.shape.e_x[1] + (rod2.shape.R.T[2,1] * rod2.shape.e_x[2] + rod2.shape.R.T[3,1] * rod2.shape.e_x[3]);
//   rod2.shape.rxvisobj[2] = rod2.shape.R.T[1,2] * rod2.shape.e_x[1] + (rod2.shape.R.T[2,2] * rod2.shape.e_x[2] + rod2.shape.R.T[3,2] * rod2.shape.e_x[3]);
//   rod2.shape.rxvisobj[3] = rod2.shape.R.T[1,3] * rod2.shape.e_x[1] + (rod2.shape.R.T[2,3] * rod2.shape.e_x[2] + rod2.shape.R.T[3,3] * rod2.shape.e_x[3]);
//   rod2.shape.ryvisobj[1] = rod2.shape.R.T[1,1] * rod2.shape.e_y[1] + (rod2.shape.R.T[2,1] * rod2.shape.e_y[2] + rod2.shape.R.T[3,1] * rod2.shape.e_y[3]);
//   rod2.shape.ryvisobj[2] = rod2.shape.R.T[1,2] * rod2.shape.e_y[1] + (rod2.shape.R.T[2,2] * rod2.shape.e_y[2] + rod2.shape.R.T[3,2] * rod2.shape.e_y[3]);
//   rod2.shape.ryvisobj[3] = rod2.shape.R.T[1,3] * rod2.shape.e_y[1] + (rod2.shape.R.T[2,3] * rod2.shape.e_y[2] + rod2.shape.R.T[3,3] * rod2.shape.e_y[3]);
//   rod2.shape.rvisobj = rod2.shape.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{rod2.shape.R.T[1,1],rod2.shape.R.T[1,2],rod2.shape.R.T[1,3]},{rod2.shape.R.T[2,1],rod2.shape.R.T[2,2],rod2.shape.R.T[2,3]},{rod2.shape.R.T[3,1],rod2.shape.R.T[3,2],rod2.shape.R.T[3,3]}},{rod2.shape.r_shape[1],rod2.shape.r_shape[2],rod2.shape.r_shape[3]});
//   rod2.shape.size[1] = rod2.shape.length;
//   rod2.shape.size[2] = rod2.shape.width;
//   rod2.shape.size[3] = rod2.shape.height;
//   rod2.shape.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(rod2.shape.color[1] / 255.0,rod2.shape.color[2] / 255.0,rod2.shape.color[3] / 255.0,rod2.shape.specularCoefficient);
//   rod2.shape.Extra = rod2.shape.extra;
//   assert(true,\"Neither connector frame_a nor frame_b of FixedTranslation object is connected\");
//   rod2.frame_b.r_0 = rod2.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(rod2.frame_a.R,{rod2.r[1],rod2.r[2],rod2.r[3]});
//   rod2.frame_b.R.T[1,1] = rod2.frame_a.R.T[1,1];
//   rod2.frame_b.R.T[1,2] = rod2.frame_a.R.T[1,2];
//   rod2.frame_b.R.T[1,3] = rod2.frame_a.R.T[1,3];
//   rod2.frame_b.R.T[2,1] = rod2.frame_a.R.T[2,1];
//   rod2.frame_b.R.T[2,2] = rod2.frame_a.R.T[2,2];
//   rod2.frame_b.R.T[2,3] = rod2.frame_a.R.T[2,3];
//   rod2.frame_b.R.T[3,1] = rod2.frame_a.R.T[3,1];
//   rod2.frame_b.R.T[3,2] = rod2.frame_a.R.T[3,2];
//   rod2.frame_b.R.T[3,3] = rod2.frame_a.R.T[3,3];
//   rod2.frame_b.R.w[1] = rod2.frame_a.R.w[1];
//   rod2.frame_b.R.w[2] = rod2.frame_a.R.w[2];
//   rod2.frame_b.R.w[3] = rod2.frame_a.R.w[3];
//   0.0 = rod2.frame_a.f[1] + rod2.frame_b.f[1];
//   0.0 = rod2.frame_a.f[2] + rod2.frame_b.f[2];
//   0.0 = rod2.frame_a.f[3] + rod2.frame_b.f[3];
//   0.0 = rod2.frame_a.t[1] + (rod2.frame_b.t[1] + (rod2.r[2] * rod2.frame_b.f[3] + (-rod2.r[3] * rod2.frame_b.f[2])));
//   0.0 = rod2.frame_a.t[2] + (rod2.frame_b.t[2] + (rod2.r[3] * rod2.frame_b.f[1] + (-rod2.r[1] * rod2.frame_b.f[3])));
//   0.0 = rod2.frame_a.t[3] + (rod2.frame_b.t[3] + (rod2.r[1] * rod2.frame_b.f[2] + (-rod2.r[2] * rod2.frame_b.f[1])));
//   body1.cylinder.R.T[1,1] = body1.frame_a.R.T[1,1];
//   body1.cylinder.R.T[1,2] = body1.frame_a.R.T[1,2];
//   body1.cylinder.R.T[1,3] = body1.frame_a.R.T[1,3];
//   body1.cylinder.R.T[2,1] = body1.frame_a.R.T[2,1];
//   body1.cylinder.R.T[2,2] = body1.frame_a.R.T[2,2];
//   body1.cylinder.R.T[2,3] = body1.frame_a.R.T[2,3];
//   body1.cylinder.R.T[3,1] = body1.frame_a.R.T[3,1];
//   body1.cylinder.R.T[3,2] = body1.frame_a.R.T[3,2];
//   body1.cylinder.R.T[3,3] = body1.frame_a.R.T[3,3];
//   body1.cylinder.R.w[1] = body1.frame_a.R.w[1];
//   body1.cylinder.R.w[2] = body1.frame_a.R.w[2];
//   body1.cylinder.R.w[3] = body1.frame_a.R.w[3];
//   body1.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body1.cylinder.shapeType);
//   body1.cylinder.rxvisobj[1] = body1.cylinder.R.T[1,1] * body1.cylinder.e_x[1] + (body1.cylinder.R.T[2,1] * body1.cylinder.e_x[2] + body1.cylinder.R.T[3,1] * body1.cylinder.e_x[3]);
//   body1.cylinder.rxvisobj[2] = body1.cylinder.R.T[1,2] * body1.cylinder.e_x[1] + (body1.cylinder.R.T[2,2] * body1.cylinder.e_x[2] + body1.cylinder.R.T[3,2] * body1.cylinder.e_x[3]);
//   body1.cylinder.rxvisobj[3] = body1.cylinder.R.T[1,3] * body1.cylinder.e_x[1] + (body1.cylinder.R.T[2,3] * body1.cylinder.e_x[2] + body1.cylinder.R.T[3,3] * body1.cylinder.e_x[3]);
//   body1.cylinder.ryvisobj[1] = body1.cylinder.R.T[1,1] * body1.cylinder.e_y[1] + (body1.cylinder.R.T[2,1] * body1.cylinder.e_y[2] + body1.cylinder.R.T[3,1] * body1.cylinder.e_y[3]);
//   body1.cylinder.ryvisobj[2] = body1.cylinder.R.T[1,2] * body1.cylinder.e_y[1] + (body1.cylinder.R.T[2,2] * body1.cylinder.e_y[2] + body1.cylinder.R.T[3,2] * body1.cylinder.e_y[3]);
//   body1.cylinder.ryvisobj[3] = body1.cylinder.R.T[1,3] * body1.cylinder.e_y[1] + (body1.cylinder.R.T[2,3] * body1.cylinder.e_y[2] + body1.cylinder.R.T[3,3] * body1.cylinder.e_y[3]);
//   body1.cylinder.rvisobj = body1.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body1.cylinder.R.T[1,1],body1.cylinder.R.T[1,2],body1.cylinder.R.T[1,3]},{body1.cylinder.R.T[2,1],body1.cylinder.R.T[2,2],body1.cylinder.R.T[2,3]},{body1.cylinder.R.T[3,1],body1.cylinder.R.T[3,2],body1.cylinder.R.T[3,3]}},{body1.cylinder.r_shape[1],body1.cylinder.r_shape[2],body1.cylinder.r_shape[3]});
//   body1.cylinder.size[1] = body1.cylinder.length;
//   body1.cylinder.size[2] = body1.cylinder.width;
//   body1.cylinder.size[3] = body1.cylinder.height;
//   body1.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body1.cylinder.color[1] / 255.0,body1.cylinder.color[2] / 255.0,body1.cylinder.color[3] / 255.0,body1.cylinder.specularCoefficient);
//   body1.cylinder.Extra = body1.cylinder.extra;
//   body1.sphere.R.T[1,1] = body1.frame_a.R.T[1,1];
//   body1.sphere.R.T[1,2] = body1.frame_a.R.T[1,2];
//   body1.sphere.R.T[1,3] = body1.frame_a.R.T[1,3];
//   body1.sphere.R.T[2,1] = body1.frame_a.R.T[2,1];
//   body1.sphere.R.T[2,2] = body1.frame_a.R.T[2,2];
//   body1.sphere.R.T[2,3] = body1.frame_a.R.T[2,3];
//   body1.sphere.R.T[3,1] = body1.frame_a.R.T[3,1];
//   body1.sphere.R.T[3,2] = body1.frame_a.R.T[3,2];
//   body1.sphere.R.T[3,3] = body1.frame_a.R.T[3,3];
//   body1.sphere.R.w[1] = body1.frame_a.R.w[1];
//   body1.sphere.R.w[2] = body1.frame_a.R.w[2];
//   body1.sphere.R.w[3] = body1.frame_a.R.w[3];
//   body1.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body1.sphere.shapeType);
//   body1.sphere.rxvisobj[1] = body1.sphere.R.T[1,1] * body1.sphere.e_x[1] + (body1.sphere.R.T[2,1] * body1.sphere.e_x[2] + body1.sphere.R.T[3,1] * body1.sphere.e_x[3]);
//   body1.sphere.rxvisobj[2] = body1.sphere.R.T[1,2] * body1.sphere.e_x[1] + (body1.sphere.R.T[2,2] * body1.sphere.e_x[2] + body1.sphere.R.T[3,2] * body1.sphere.e_x[3]);
//   body1.sphere.rxvisobj[3] = body1.sphere.R.T[1,3] * body1.sphere.e_x[1] + (body1.sphere.R.T[2,3] * body1.sphere.e_x[2] + body1.sphere.R.T[3,3] * body1.sphere.e_x[3]);
//   body1.sphere.ryvisobj[1] = body1.sphere.R.T[1,1] * body1.sphere.e_y[1] + (body1.sphere.R.T[2,1] * body1.sphere.e_y[2] + body1.sphere.R.T[3,1] * body1.sphere.e_y[3]);
//   body1.sphere.ryvisobj[2] = body1.sphere.R.T[1,2] * body1.sphere.e_y[1] + (body1.sphere.R.T[2,2] * body1.sphere.e_y[2] + body1.sphere.R.T[3,2] * body1.sphere.e_y[3]);
//   body1.sphere.ryvisobj[3] = body1.sphere.R.T[1,3] * body1.sphere.e_y[1] + (body1.sphere.R.T[2,3] * body1.sphere.e_y[2] + body1.sphere.R.T[3,3] * body1.sphere.e_y[3]);
//   body1.sphere.rvisobj = body1.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body1.sphere.R.T[1,1],body1.sphere.R.T[1,2],body1.sphere.R.T[1,3]},{body1.sphere.R.T[2,1],body1.sphere.R.T[2,2],body1.sphere.R.T[2,3]},{body1.sphere.R.T[3,1],body1.sphere.R.T[3,2],body1.sphere.R.T[3,3]}},{body1.sphere.r_shape[1],body1.sphere.r_shape[2],body1.sphere.r_shape[3]});
//   body1.sphere.size[1] = body1.sphere.length;
//   body1.sphere.size[2] = body1.sphere.width;
//   body1.sphere.size[3] = body1.sphere.height;
//   body1.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body1.sphere.color[1] / 255.0,body1.sphere.color[2] / 255.0,body1.sphere.color[3] / 255.0,body1.sphere.specularCoefficient);
//   body1.sphere.Extra = body1.sphere.extra;
//   body1.r_0[1] = body1.frame_a.r_0[1];
//   body1.r_0[2] = body1.frame_a.r_0[2];
//   body1.r_0[3] = body1.frame_a.r_0[3];
//   if true then
//   body1.Q[1] = 0.0;
//   body1.Q[2] = 0.0;
//   body1.Q[3] = 0.0;
//   body1.Q[4] = 1.0;
//   body1.phi[1] = 0.0;
//   body1.phi[2] = 0.0;
//   body1.phi[3] = 0.0;
//   body1.phi_d[1] = 0.0;
//   body1.phi_d[2] = 0.0;
//   body1.phi_d[3] = 0.0;
//   body1.phi_dd[1] = 0.0;
//   body1.phi_dd[2] = 0.0;
//   body1.phi_dd[3] = 0.0;
//   elseif body1.useQuaternions then
//   body1.frame_a.R = Modelica.Mechanics.MultiBody.Frames.from_Q({body1.Q[1],body1.Q[2],body1.Q[3],body1.Q[4]},Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2({body1.Q[1],body1.Q[2],body1.Q[3],body1.Q[4]},{der(body1.Q[1]),der(body1.Q[2]),der(body1.Q[3]),der(body1.Q[4])}));
//   {0.0} = Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint({body1.Q[1],body1.Q[2],body1.Q[3],body1.Q[4]});
//   body1.phi[1] = 0.0;
//   body1.phi[2] = 0.0;
//   body1.phi[3] = 0.0;
//   body1.phi_d[1] = 0.0;
//   body1.phi_d[2] = 0.0;
//   body1.phi_d[3] = 0.0;
//   body1.phi_dd[1] = 0.0;
//   body1.phi_dd[2] = 0.0;
//   body1.phi_dd[3] = 0.0;
//   else
//   body1.phi_d[1] = der(body1.phi[1]);
//   body1.phi_d[2] = der(body1.phi[2]);
//   body1.phi_d[3] = der(body1.phi[3]);
//   body1.phi_dd[1] = der(body1.phi_d[1]);
//   body1.phi_dd[2] = der(body1.phi_d[2]);
//   body1.phi_dd[3] = der(body1.phi_d[3]);
//   body1.frame_a.R = Modelica.Mechanics.MultiBody.Frames.axesRotations({body1.sequence_angleStates[1],body1.sequence_angleStates[2],body1.sequence_angleStates[3]},{body1.phi[1],body1.phi[2],body1.phi[3]},{body1.phi_d[1],body1.phi_d[2],body1.phi_d[3]});
//   body1.Q[1] = 0.0;
//   body1.Q[2] = 0.0;
//   body1.Q[3] = 0.0;
//   body1.Q[4] = 1.0;
//   end if;
//   body1.g_0 = Modelica.Mechanics.MultiBody.Parts.Body.world__gravityAcceleration({body1.frame_a.r_0[1],body1.frame_a.r_0[2],body1.frame_a.r_0[3]} + Modelica.Mechanics.MultiBody.Frames.resolve1(body1.frame_a.R,{body1.r_CM[1],body1.r_CM[2],body1.r_CM[3]}),world.gravityType,world.g * Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13),world.mue);
//   body1.v_0[1] = der(body1.frame_a.r_0[1]);
//   body1.v_0[2] = der(body1.frame_a.r_0[2]);
//   body1.v_0[3] = der(body1.frame_a.r_0[3]);
//   body1.a_0[1] = der(body1.v_0[1]);
//   body1.a_0[2] = der(body1.v_0[2]);
//   body1.a_0[3] = der(body1.v_0[3]);
//   body1.w_a = Modelica.Mechanics.MultiBody.Frames.angularVelocity2(body1.frame_a.R);
//   body1.z_a[1] = der(body1.w_a[1]);
//   body1.z_a[2] = der(body1.w_a[2]);
//   body1.z_a[3] = der(body1.w_a[3]);
//   body1.frame_a.f = body1.m * (Modelica.Mechanics.MultiBody.Frames.resolve2(body1.frame_a.R,{body1.a_0[1] - body1.g_0[1],body1.a_0[2] - body1.g_0[2],body1.a_0[3] - body1.g_0[3]}) + {body1.z_a[2] * body1.r_CM[3] - body1.z_a[3] * body1.r_CM[2],body1.z_a[3] * body1.r_CM[1] - body1.z_a[1] * body1.r_CM[3],body1.z_a[1] * body1.r_CM[2] - body1.z_a[2] * body1.r_CM[1]} + {body1.w_a[2] * (body1.w_a[1] * body1.r_CM[2] - body1.w_a[2] * body1.r_CM[1]) - body1.w_a[3] * (body1.w_a[3] * body1.r_CM[1] - body1.w_a[1] * body1.r_CM[3]),body1.w_a[3] * (body1.w_a[2] * body1.r_CM[3] - body1.w_a[3] * body1.r_CM[2]) - body1.w_a[1] * (body1.w_a[1] * body1.r_CM[2] - body1.w_a[2] * body1.r_CM[1]),body1.w_a[1] * (body1.w_a[3] * body1.r_CM[1] - body1.w_a[1] * body1.r_CM[3]) - body1.w_a[2] * (body1.w_a[2] * body1.r_CM[3] - body1.w_a[3] * body1.r_CM[2])});
//   body1.frame_a.t[1] = body1.I[1,1] * body1.z_a[1] + (body1.I[1,2] * body1.z_a[2] + (body1.I[1,3] * body1.z_a[3] + (body1.w_a[2] * (body1.I[3,1] * body1.w_a[1] + (body1.I[3,2] * body1.w_a[2] + body1.I[3,3] * body1.w_a[3])) + ((-body1.w_a[3] * (body1.I[2,1] * body1.w_a[1] + (body1.I[2,2] * body1.w_a[2] + body1.I[2,3] * body1.w_a[3]))) + (body1.r_CM[2] * body1.frame_a.f[3] + (-body1.r_CM[3] * body1.frame_a.f[2]))))));
//   body1.frame_a.t[2] = body1.I[2,1] * body1.z_a[1] + (body1.I[2,2] * body1.z_a[2] + (body1.I[2,3] * body1.z_a[3] + (body1.w_a[3] * (body1.I[1,1] * body1.w_a[1] + (body1.I[1,2] * body1.w_a[2] + body1.I[1,3] * body1.w_a[3])) + ((-body1.w_a[1] * (body1.I[3,1] * body1.w_a[1] + (body1.I[3,2] * body1.w_a[2] + body1.I[3,3] * body1.w_a[3]))) + (body1.r_CM[3] * body1.frame_a.f[1] + (-body1.r_CM[1] * body1.frame_a.f[3]))))));
//   body1.frame_a.t[3] = body1.I[3,1] * body1.z_a[1] + (body1.I[3,2] * body1.z_a[2] + (body1.I[3,3] * body1.z_a[3] + (body1.w_a[1] * (body1.I[2,1] * body1.w_a[1] + (body1.I[2,2] * body1.w_a[2] + body1.I[2,3] * body1.w_a[3])) + ((-body1.w_a[2] * (body1.I[1,1] * body1.w_a[1] + (body1.I[1,2] * body1.w_a[2] + body1.I[1,3] * body1.w_a[3]))) + (body1.r_CM[1] * body1.frame_a.f[2] + (-body1.r_CM[2] * body1.frame_a.f[1]))))));
//   position.phi = position.flange.phi - position.phi_support;
//   position.w = der(position.phi);
//   position.a = der(position.w);
//   position.a = ((position.phi_ref - position.phi) * position.w_crit - 1.3617 * position.w) * position.w_crit / 0.618;
//   sine.y = sine.offset + (if time < sine.startTime then 0.0 else sine.amplitude * sin(6.28318530717959 * (sine.freqHz * (time - sine.startTime)) + sine.phase));
//   jointRRR2.jointUSR.revolute.axis.tau = jointRRR2.jointUSR.revolute.tau;
//   jointRRR2.jointUSR.revolute.axis.phi = jointRRR2.jointUSR.revolute.phi;
//   jointRRR2.jointUSR.revolute.bearing.phi = 0.0;
//   jointRRR2.jointUSR.revolute.angle = Modelica.SIunits.Conversions.from_deg(jointRRR2.jointUSR.revolute.phi_offset) + jointRRR2.jointUSR.revolute.phi;
//   jointRRR2.jointUSR.revolute.frame_b.r_0[1] = jointRRR2.jointUSR.revolute.frame_a.r_0[1];
//   jointRRR2.jointUSR.revolute.frame_b.r_0[2] = jointRRR2.jointUSR.revolute.frame_a.r_0[2];
//   jointRRR2.jointUSR.revolute.frame_b.r_0[3] = jointRRR2.jointUSR.revolute.frame_a.r_0[3];
//   jointRRR2.jointUSR.revolute.R_rel = Modelica.Mechanics.MultiBody.Frames.planarRotation({jointRRR2.jointUSR.revolute.e[1],jointRRR2.jointUSR.revolute.e[2],jointRRR2.jointUSR.revolute.e[3]},jointRRR2.jointUSR.revolute.angle,der(jointRRR2.jointUSR.revolute.angle));
//   jointRRR2.jointUSR.revolute.frame_b.R = Modelica.Mechanics.MultiBody.Frames.absoluteRotation(jointRRR2.jointUSR.revolute.frame_a.R,jointRRR2.jointUSR.revolute.R_rel);
//   {0.0,0.0,0.0} = jointRRR2.jointUSR.revolute.frame_a.f + Modelica.Mechanics.MultiBody.Frames.resolve1(jointRRR2.jointUSR.revolute.R_rel,{jointRRR2.jointUSR.revolute.frame_b.f[1],jointRRR2.jointUSR.revolute.frame_b.f[2],jointRRR2.jointUSR.revolute.frame_b.f[3]});
//   {0.0,0.0,0.0} = jointRRR2.jointUSR.revolute.frame_a.t + Modelica.Mechanics.MultiBody.Frames.resolve1(jointRRR2.jointUSR.revolute.R_rel,{jointRRR2.jointUSR.revolute.frame_b.t[1],jointRRR2.jointUSR.revolute.frame_b.t[2],jointRRR2.jointUSR.revolute.frame_b.t[3]});
//   jointRRR2.jointUSR.revolute.e_r_a = jointRRR2.jointUSR.revolute.e[1] * jointRRR2.jointUSR.revolute.r_a[1] + (jointRRR2.jointUSR.revolute.e[2] * jointRRR2.jointUSR.revolute.r_a[2] + jointRRR2.jointUSR.revolute.e[3] * jointRRR2.jointUSR.revolute.r_a[3]);
//   jointRRR2.jointUSR.revolute.e_r_b = jointRRR2.jointUSR.revolute.e[1] * jointRRR2.jointUSR.revolute.r_b[1] + (jointRRR2.jointUSR.revolute.e[2] * jointRRR2.jointUSR.revolute.r_b[2] + jointRRR2.jointUSR.revolute.e[3] * jointRRR2.jointUSR.revolute.r_b[3]);
//   jointRRR2.jointUSR.revolute.A = -2.0 * (jointRRR2.jointUSR.revolute.r_b[1] * jointRRR2.jointUSR.revolute.r_a[1] + (jointRRR2.jointUSR.revolute.r_b[2] * jointRRR2.jointUSR.revolute.r_a[2] + jointRRR2.jointUSR.revolute.r_b[3] * jointRRR2.jointUSR.revolute.r_a[3]) - jointRRR2.jointUSR.revolute.e_r_b * jointRRR2.jointUSR.revolute.e_r_a);
//   jointRRR2.jointUSR.revolute.B = 2.0 * (jointRRR2.jointUSR.revolute.r_b[1] * (jointRRR2.jointUSR.revolute.e[2] * jointRRR2.jointUSR.revolute.r_a[3] - jointRRR2.jointUSR.revolute.e[3] * jointRRR2.jointUSR.revolute.r_a[2])) + (2.0 * (jointRRR2.jointUSR.revolute.r_b[2] * (jointRRR2.jointUSR.revolute.e[3] * jointRRR2.jointUSR.revolute.r_a[1] - jointRRR2.jointUSR.revolute.e[1] * jointRRR2.jointUSR.revolute.r_a[3])) + 2.0 * (jointRRR2.jointUSR.revolute.r_b[3] * (jointRRR2.jointUSR.revolute.e[1] * jointRRR2.jointUSR.revolute.r_a[2] - jointRRR2.jointUSR.revolute.e[2] * jointRRR2.jointUSR.revolute.r_a[1])));
//   jointRRR2.jointUSR.revolute.C = jointRRR2.jointUSR.revolute.r_a[1] ^ 2.0 + (jointRRR2.jointUSR.revolute.r_a[2] ^ 2.0 + (jointRRR2.jointUSR.revolute.r_a[3] ^ 2.0 + (jointRRR2.jointUSR.revolute.r_b[1] ^ 2.0 + (jointRRR2.jointUSR.revolute.r_b[2] ^ 2.0 + jointRRR2.jointUSR.revolute.r_b[3] ^ 2.0)))) - jointRRR2.jointUSR.revolute.lengthConstraint ^ 2.0 - 2.0 * (jointRRR2.jointUSR.revolute.e_r_b * jointRRR2.jointUSR.revolute.e_r_a);
//   jointRRR2.jointUSR.revolute.k1 = jointRRR2.jointUSR.revolute.A ^ 2.0 + jointRRR2.jointUSR.revolute.B ^ 2.0;
//   jointRRR2.jointUSR.revolute.k1a = jointRRR2.jointUSR.revolute.k1 - jointRRR2.jointUSR.revolute.C ^ 2.0;
//   assert(jointRRR2.jointUSR.revolute.k1a > 1e-10,\"
// Singular position of loop (either no or two analytic solutions;
// the mechanism has lost one-degree-of freedom in this position).
// Try first to use another Modelica.Mechanics.MultiBody.Joints.Assemblies.JointXXX component.
// In most cases it is best that the joints outside of the JointXXX
// component are revolute and NOT prismatic joints. If this also
// lead to singular positions, it could be that this kinematic loop
// cannot be solved analytically. In this case you have to build
// up the loop with basic joints (NO aggregation JointXXX components)
// and rely on dynamic state selection, i.e., during simulation
// the states will be dynamically selected in such a way that in no
// position a degree of freedom is lost.
// \");
//   jointRRR2.jointUSR.revolute.k1b = Modelica.Mechanics.MultiBody.Frames.Internal.maxWithoutEvent(jointRRR2.jointUSR.revolute.k1a,1e-12);
//   jointRRR2.jointUSR.revolute.k2 = sqrt(jointRRR2.jointUSR.revolute.k1b);
//   jointRRR2.jointUSR.revolute.kcos_angle = (-jointRRR2.jointUSR.revolute.A) * jointRRR2.jointUSR.revolute.C + (if jointRRR2.jointUSR.revolute.positiveBranch then jointRRR2.jointUSR.revolute.B else -jointRRR2.jointUSR.revolute.B) * jointRRR2.jointUSR.revolute.k2;
//   jointRRR2.jointUSR.revolute.ksin_angle = (-jointRRR2.jointUSR.revolute.B) * jointRRR2.jointUSR.revolute.C + (if jointRRR2.jointUSR.revolute.positiveBranch then -jointRRR2.jointUSR.revolute.A else jointRRR2.jointUSR.revolute.A) * jointRRR2.jointUSR.revolute.k2;
//   jointRRR2.jointUSR.revolute.angle = atan2(jointRRR2.jointUSR.revolute.ksin_angle,jointRRR2.jointUSR.revolute.kcos_angle);
//   assert(true,\"Connector frame_a of component is not connected\");
//   assert(true,\"Connector frame_b of component is not connected\");
//   jointRRR2.jointUSR.rod1.rRod_0[1] = jointRRR2.jointUSR.rod1.frame_b.r_0[1] - jointRRR2.jointUSR.rod1.frame_a.r_0[1];
//   jointRRR2.jointUSR.rod1.rRod_0[2] = jointRRR2.jointUSR.rod1.frame_b.r_0[2] - jointRRR2.jointUSR.rod1.frame_a.r_0[2];
//   jointRRR2.jointUSR.rod1.rRod_0[3] = jointRRR2.jointUSR.rod1.frame_b.r_0[3] - jointRRR2.jointUSR.rod1.frame_a.r_0[3];
//   jointRRR2.jointUSR.rod1.rRod_a = Modelica.Mechanics.MultiBody.Frames.resolve2(jointRRR2.jointUSR.rod1.frame_a.R,{jointRRR2.jointUSR.rod1.rRod_0[1],jointRRR2.jointUSR.rod1.rRod_0[2],jointRRR2.jointUSR.rod1.rRod_0[3]});
//   jointRRR2.jointUSR.rod1.constraintResidue = 0.0;
//   jointRRR2.jointUSR.rod1.eRod_a[1] = jointRRR2.jointUSR.rod1.rRod_a[1] / jointRRR2.jointUSR.rod1.rodLength;
//   jointRRR2.jointUSR.rod1.eRod_a[2] = jointRRR2.jointUSR.rod1.rRod_a[2] / jointRRR2.jointUSR.rod1.rodLength;
//   jointRRR2.jointUSR.rod1.eRod_a[3] = jointRRR2.jointUSR.rod1.rRod_a[3] / jointRRR2.jointUSR.rod1.rodLength;
//   jointRRR2.jointUSR.rod1.n2_a[1] = jointRRR2.jointUSR.rod1.n1_a[2] * jointRRR2.jointUSR.rod1.eRod_a[3] - jointRRR2.jointUSR.rod1.n1_a[3] * jointRRR2.jointUSR.rod1.eRod_a[2];
//   jointRRR2.jointUSR.rod1.n2_a[2] = jointRRR2.jointUSR.rod1.n1_a[3] * jointRRR2.jointUSR.rod1.eRod_a[1] - jointRRR2.jointUSR.rod1.n1_a[1] * jointRRR2.jointUSR.rod1.eRod_a[3];
//   jointRRR2.jointUSR.rod1.n2_a[3] = jointRRR2.jointUSR.rod1.n1_a[1] * jointRRR2.jointUSR.rod1.eRod_a[2] - jointRRR2.jointUSR.rod1.n1_a[2] * jointRRR2.jointUSR.rod1.eRod_a[1];
//   jointRRR2.jointUSR.rod1.length2_n2_a = jointRRR2.jointUSR.rod1.n2_a[1] ^ 2.0 + (jointRRR2.jointUSR.rod1.n2_a[2] ^ 2.0 + jointRRR2.jointUSR.rod1.n2_a[3] ^ 2.0);
//   assert(jointRRR2.jointUSR.rod1.length2_n2_a > 1e-10,\"
// A Modelica.Mechanics.MultiBody.Joints.UniversalSpherical joint (consisting of
// a universal joint and a spherical joint connected together
// by a rigid rod) is in the singular configuration of the
// universal joint. This means that axis 1 of the universal
// joint defined via parameter \\\"n1_a\\\" is parallel to vector
// \\\"rRod_ia\\\" that is directed from the origin of frame_a to the
// origin of frame_b.
//    You may try to use another \\\"n1_a\\\" vector. If this fails,
// use instead Modelica.Mechanics.MultiBody.Joints.SphericalSpherical, if this is
// possible, because this joint aggregation does not have a
// singular configuration.
// \");
//   jointRRR2.jointUSR.rod1.length_n2_a = sqrt(jointRRR2.jointUSR.rod1.length2_n2_a);
//   jointRRR2.jointUSR.rod1.e2_a[1] = jointRRR2.jointUSR.rod1.n2_a[1] / jointRRR2.jointUSR.rod1.length_n2_a;
//   jointRRR2.jointUSR.rod1.e2_a[2] = jointRRR2.jointUSR.rod1.n2_a[2] / jointRRR2.jointUSR.rod1.length_n2_a;
//   jointRRR2.jointUSR.rod1.e2_a[3] = jointRRR2.jointUSR.rod1.n2_a[3] / jointRRR2.jointUSR.rod1.length_n2_a;
//   jointRRR2.jointUSR.rod1.e3_a[1] = jointRRR2.jointUSR.rod1.eRod_a[2] * jointRRR2.jointUSR.rod1.e2_a[3] - jointRRR2.jointUSR.rod1.eRod_a[3] * jointRRR2.jointUSR.rod1.e2_a[2];
//   jointRRR2.jointUSR.rod1.e3_a[2] = jointRRR2.jointUSR.rod1.eRod_a[3] * jointRRR2.jointUSR.rod1.e2_a[1] - jointRRR2.jointUSR.rod1.eRod_a[1] * jointRRR2.jointUSR.rod1.e2_a[3];
//   jointRRR2.jointUSR.rod1.e3_a[3] = jointRRR2.jointUSR.rod1.eRod_a[1] * jointRRR2.jointUSR.rod1.e2_a[2] - jointRRR2.jointUSR.rod1.eRod_a[2] * jointRRR2.jointUSR.rod1.e2_a[1];
//   jointRRR2.jointUSR.rod1.der_rRod_a_L = (Modelica.Mechanics.MultiBody.Frames.resolve2(jointRRR2.jointUSR.rod1.frame_a.R,{der(jointRRR2.jointUSR.rod1.rRod_0[1]),der(jointRRR2.jointUSR.rod1.rRod_0[2]),der(jointRRR2.jointUSR.rod1.rRod_0[3])}) - {jointRRR2.jointUSR.rod1.frame_a.R.w[2] * jointRRR2.jointUSR.rod1.rRod_a[3] - jointRRR2.jointUSR.rod1.frame_a.R.w[3] * jointRRR2.jointUSR.rod1.rRod_a[2],jointRRR2.jointUSR.rod1.frame_a.R.w[3] * jointRRR2.jointUSR.rod1.rRod_a[1] - jointRRR2.jointUSR.rod1.frame_a.R.w[1] * jointRRR2.jointUSR.rod1.rRod_a[3],jointRRR2.jointUSR.rod1.frame_a.R.w[1] * jointRRR2.jointUSR.rod1.rRod_a[2] - jointRRR2.jointUSR.rod1.frame_a.R.w[2] * jointRRR2.jointUSR.rod1.rRod_a[1]}) / jointRRR2.jointUSR.rod1.rodLength;
//   jointRRR2.jointUSR.rod1.w_rel_ia1[1] = (jointRRR2.jointUSR.rod1.e3_a[1] * (jointRRR2.jointUSR.rod1.n1_a[2] * jointRRR2.jointUSR.rod1.der_rRod_a_L[3] - jointRRR2.jointUSR.rod1.n1_a[3] * jointRRR2.jointUSR.rod1.der_rRod_a_L[2]) + (jointRRR2.jointUSR.rod1.e3_a[2] * (jointRRR2.jointUSR.rod1.n1_a[3] * jointRRR2.jointUSR.rod1.der_rRod_a_L[1] - jointRRR2.jointUSR.rod1.n1_a[1] * jointRRR2.jointUSR.rod1.der_rRod_a_L[3]) + jointRRR2.jointUSR.rod1.e3_a[3] * (jointRRR2.jointUSR.rod1.n1_a[1] * jointRRR2.jointUSR.rod1.der_rRod_a_L[2] - jointRRR2.jointUSR.rod1.n1_a[2] * jointRRR2.jointUSR.rod1.der_rRod_a_L[1]))) / jointRRR2.jointUSR.rod1.length_n2_a;
//   jointRRR2.jointUSR.rod1.w_rel_ia1[2] = (-jointRRR2.jointUSR.rod1.e3_a[1]) * jointRRR2.jointUSR.rod1.der_rRod_a_L[1] + ((-jointRRR2.jointUSR.rod1.e3_a[2]) * jointRRR2.jointUSR.rod1.der_rRod_a_L[2] + (-jointRRR2.jointUSR.rod1.e3_a[3]) * jointRRR2.jointUSR.rod1.der_rRod_a_L[3]);
//   jointRRR2.jointUSR.rod1.w_rel_ia1[3] = jointRRR2.jointUSR.rod1.e2_a[1] * jointRRR2.jointUSR.rod1.der_rRod_a_L[1] + (jointRRR2.jointUSR.rod1.e2_a[2] * jointRRR2.jointUSR.rod1.der_rRod_a_L[2] + jointRRR2.jointUSR.rod1.e2_a[3] * jointRRR2.jointUSR.rod1.der_rRod_a_L[3]);
//   jointRRR2.jointUSR.rod1.R_rel_ia1 = Modelica.Mechanics.MultiBody.Frames.from_T({{jointRRR2.jointUSR.rod1.eRod_a[1],jointRRR2.jointUSR.rod1.eRod_a[2],jointRRR2.jointUSR.rod1.eRod_a[3]},{jointRRR2.jointUSR.rod1.e2_a[1],jointRRR2.jointUSR.rod1.e2_a[2],jointRRR2.jointUSR.rod1.e2_a[3]},{jointRRR2.jointUSR.rod1.e3_a[1],jointRRR2.jointUSR.rod1.e3_a[2],jointRRR2.jointUSR.rod1.e3_a[3]}},{jointRRR2.jointUSR.rod1.w_rel_ia1[1],jointRRR2.jointUSR.rod1.w_rel_ia1[2],jointRRR2.jointUSR.rod1.w_rel_ia1[3]});
//   jointRRR2.jointUSR.rod1.R_rel_ia2 = Modelica.Mechanics.MultiBody.Frames.from_T({{jointRRR2.jointUSR.rod1.eRod_ia[1],jointRRR2.jointUSR.rod1.e2_ia[1],jointRRR2.jointUSR.rod1.e3_ia[1]},{jointRRR2.jointUSR.rod1.eRod_ia[2],jointRRR2.jointUSR.rod1.e2_ia[2],jointRRR2.jointUSR.rod1.e3_ia[2]},{jointRRR2.jointUSR.rod1.eRod_ia[3],jointRRR2.jointUSR.rod1.e2_ia[3],jointRRR2.jointUSR.rod1.e3_ia[3]}},{0.0,0.0,0.0});
//   jointRRR2.jointUSR.rod1.R_rel_ia = Modelica.Mechanics.MultiBody.Frames.absoluteRotation(jointRRR2.jointUSR.rod1.R_rel_ia1,jointRRR2.jointUSR.rod1.R_rel_ia2);
//   jointRRR2.jointUSR.rod1.frame_ia.r_0[1] = jointRRR2.jointUSR.rod1.frame_a.r_0[1];
//   jointRRR2.jointUSR.rod1.frame_ia.r_0[2] = jointRRR2.jointUSR.rod1.frame_a.r_0[2];
//   jointRRR2.jointUSR.rod1.frame_ia.r_0[3] = jointRRR2.jointUSR.rod1.frame_a.r_0[3];
//   jointRRR2.jointUSR.rod1.frame_ia.R = Modelica.Mechanics.MultiBody.Frames.absoluteRotation(jointRRR2.jointUSR.rod1.frame_a.R,jointRRR2.jointUSR.rod1.R_rel_ia);
//   jointRRR2.jointUSR.rod1.f_ia_a = Modelica.Mechanics.MultiBody.Frames.resolve1(jointRRR2.jointUSR.rod1.R_rel_ia,{jointRRR2.jointUSR.rod1.frame_ia.f[1],jointRRR2.jointUSR.rod1.frame_ia.f[2],jointRRR2.jointUSR.rod1.frame_ia.f[3]});
//   jointRRR2.jointUSR.rod1.t_ia_a = Modelica.Mechanics.MultiBody.Frames.resolve1(jointRRR2.jointUSR.rod1.R_rel_ia,{jointRRR2.jointUSR.rod1.frame_ia.t[1],jointRRR2.jointUSR.rod1.frame_ia.t[2],jointRRR2.jointUSR.rod1.frame_ia.t[3]});
//   jointRRR2.jointUSR.rod1.f_b_a1[1] = ((-jointRRR2.jointUSR.rod1.n1_a[1]) * jointRRR2.jointUSR.rod1.t_ia_a[1] + ((-jointRRR2.jointUSR.rod1.n1_a[2]) * jointRRR2.jointUSR.rod1.t_ia_a[2] + (-jointRRR2.jointUSR.rod1.n1_a[3]) * jointRRR2.jointUSR.rod1.t_ia_a[3])) * (jointRRR2.jointUSR.rod1.e2_a[1] * 1.0 / (jointRRR2.jointUSR.rod1.n1_a[1] * jointRRR2.jointUSR.rod1.e3_a[1] + (jointRRR2.jointUSR.rod1.n1_a[2] * jointRRR2.jointUSR.rod1.e3_a[2] + jointRRR2.jointUSR.rod1.n1_a[3] * jointRRR2.jointUSR.rod1.e3_a[3])) / jointRRR2.jointUSR.rod1.rodLength) + (jointRRR2.jointUSR.rod1.e2_a[1] * jointRRR2.jointUSR.rod1.t_ia_a[1] + (jointRRR2.jointUSR.rod1.e2_a[2] * jointRRR2.jointUSR.rod1.t_ia_a[2] + jointRRR2.jointUSR.rod1.e2_a[3] * jointRRR2.jointUSR.rod1.t_ia_a[3])) * jointRRR2.jointUSR.rod1.e3_a[1] / jointRRR2.jointUSR.rod1.rodLength;
//   jointRRR2.jointUSR.rod1.f_b_a1[2] = ((-jointRRR2.jointUSR.rod1.n1_a[1]) * jointRRR2.jointUSR.rod1.t_ia_a[1] + ((-jointRRR2.jointUSR.rod1.n1_a[2]) * jointRRR2.jointUSR.rod1.t_ia_a[2] + (-jointRRR2.jointUSR.rod1.n1_a[3]) * jointRRR2.jointUSR.rod1.t_ia_a[3])) * (jointRRR2.jointUSR.rod1.e2_a[2] * 1.0 / (jointRRR2.jointUSR.rod1.n1_a[1] * jointRRR2.jointUSR.rod1.e3_a[1] + (jointRRR2.jointUSR.rod1.n1_a[2] * jointRRR2.jointUSR.rod1.e3_a[2] + jointRRR2.jointUSR.rod1.n1_a[3] * jointRRR2.jointUSR.rod1.e3_a[3])) / jointRRR2.jointUSR.rod1.rodLength) + (jointRRR2.jointUSR.rod1.e2_a[1] * jointRRR2.jointUSR.rod1.t_ia_a[1] + (jointRRR2.jointUSR.rod1.e2_a[2] * jointRRR2.jointUSR.rod1.t_ia_a[2] + jointRRR2.jointUSR.rod1.e2_a[3] * jointRRR2.jointUSR.rod1.t_ia_a[3])) * jointRRR2.jointUSR.rod1.e3_a[2] / jointRRR2.jointUSR.rod1.rodLength;
//   jointRRR2.jointUSR.rod1.f_b_a1[3] = ((-jointRRR2.jointUSR.rod1.n1_a[1]) * jointRRR2.jointUSR.rod1.t_ia_a[1] + ((-jointRRR2.jointUSR.rod1.n1_a[2]) * jointRRR2.jointUSR.rod1.t_ia_a[2] + (-jointRRR2.jointUSR.rod1.n1_a[3]) * jointRRR2.jointUSR.rod1.t_ia_a[3])) * (jointRRR2.jointUSR.rod1.e2_a[3] * 1.0 / (jointRRR2.jointUSR.rod1.n1_a[1] * jointRRR2.jointUSR.rod1.e3_a[1] + (jointRRR2.jointUSR.rod1.n1_a[2] * jointRRR2.jointUSR.rod1.e3_a[2] + jointRRR2.jointUSR.rod1.n1_a[3] * jointRRR2.jointUSR.rod1.e3_a[3])) / jointRRR2.jointUSR.rod1.rodLength) + (jointRRR2.jointUSR.rod1.e2_a[1] * jointRRR2.jointUSR.rod1.t_ia_a[1] + (jointRRR2.jointUSR.rod1.e2_a[2] * jointRRR2.jointUSR.rod1.t_ia_a[2] + jointRRR2.jointUSR.rod1.e2_a[3] * jointRRR2.jointUSR.rod1.t_ia_a[3])) * jointRRR2.jointUSR.rod1.e3_a[3] / jointRRR2.jointUSR.rod1.rodLength;
//   jointRRR2.jointUSR.rod1.f_b_a[1] = (-jointRRR2.jointUSR.rod1.f_rod) * jointRRR2.jointUSR.rod1.eRod_a[1] + jointRRR2.jointUSR.rod1.f_b_a1[1];
//   jointRRR2.jointUSR.rod1.f_b_a[2] = (-jointRRR2.jointUSR.rod1.f_rod) * jointRRR2.jointUSR.rod1.eRod_a[2] + jointRRR2.jointUSR.rod1.f_b_a1[2];
//   jointRRR2.jointUSR.rod1.f_b_a[3] = (-jointRRR2.jointUSR.rod1.f_rod) * jointRRR2.jointUSR.rod1.eRod_a[3] + jointRRR2.jointUSR.rod1.f_b_a1[3];
//   jointRRR2.jointUSR.rod1.frame_b.f = Modelica.Mechanics.MultiBody.Frames.resolveRelative({jointRRR2.jointUSR.rod1.f_b_a[1],jointRRR2.jointUSR.rod1.f_b_a[2],jointRRR2.jointUSR.rod1.f_b_a[3]},jointRRR2.jointUSR.rod1.frame_a.R,jointRRR2.jointUSR.rod1.frame_b.R);
//   jointRRR2.jointUSR.rod1.frame_b.t[1] = 0.0;
//   jointRRR2.jointUSR.rod1.frame_b.t[2] = 0.0;
//   jointRRR2.jointUSR.rod1.frame_b.t[3] = 0.0;
//   0.0 = jointRRR2.jointUSR.rod1.frame_a.f[1] + (jointRRR2.jointUSR.rod1.f_b_a[1] + jointRRR2.jointUSR.rod1.f_ia_a[1]);
//   0.0 = jointRRR2.jointUSR.rod1.frame_a.f[2] + (jointRRR2.jointUSR.rod1.f_b_a[2] + jointRRR2.jointUSR.rod1.f_ia_a[2]);
//   0.0 = jointRRR2.jointUSR.rod1.frame_a.f[3] + (jointRRR2.jointUSR.rod1.f_b_a[3] + jointRRR2.jointUSR.rod1.f_ia_a[3]);
//   0.0 = jointRRR2.jointUSR.rod1.frame_a.t[1] + (jointRRR2.jointUSR.rod1.t_ia_a[1] + (jointRRR2.jointUSR.rod1.rRod_a[2] * jointRRR2.jointUSR.rod1.f_b_a[3] + (-jointRRR2.jointUSR.rod1.rRod_a[3] * jointRRR2.jointUSR.rod1.f_b_a[2])));
//   0.0 = jointRRR2.jointUSR.rod1.frame_a.t[2] + (jointRRR2.jointUSR.rod1.t_ia_a[2] + (jointRRR2.jointUSR.rod1.rRod_a[3] * jointRRR2.jointUSR.rod1.f_b_a[1] + (-jointRRR2.jointUSR.rod1.rRod_a[1] * jointRRR2.jointUSR.rod1.f_b_a[3])));
//   0.0 = jointRRR2.jointUSR.rod1.frame_a.t[3] + (jointRRR2.jointUSR.rod1.t_ia_a[3] + (jointRRR2.jointUSR.rod1.rRod_a[1] * jointRRR2.jointUSR.rod1.f_b_a[2] + (-jointRRR2.jointUSR.rod1.rRod_a[2] * jointRRR2.jointUSR.rod1.f_b_a[1])));
//   jointRRR2.jointUSR.rod1.totalPower = 0.0;
//   assert(true,\"Connector frame_a of component is not connected\");
//   assert(true,\"Connector frame_b of component is not connected\");
//   assert(true,\"Neither connector frame_a nor frame_b of FixedTranslation object is connected\");
//   jointRRR2.jointUSR.rod2.frame_b.r_0 = jointRRR2.jointUSR.rod2.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(jointRRR2.jointUSR.rod2.frame_a.R,{jointRRR2.jointUSR.rod2.r[1],jointRRR2.jointUSR.rod2.r[2],jointRRR2.jointUSR.rod2.r[3]});
//   jointRRR2.jointUSR.rod2.frame_b.R.T[1,1] = jointRRR2.jointUSR.rod2.frame_a.R.T[1,1];
//   jointRRR2.jointUSR.rod2.frame_b.R.T[1,2] = jointRRR2.jointUSR.rod2.frame_a.R.T[1,2];
//   jointRRR2.jointUSR.rod2.frame_b.R.T[1,3] = jointRRR2.jointUSR.rod2.frame_a.R.T[1,3];
//   jointRRR2.jointUSR.rod2.frame_b.R.T[2,1] = jointRRR2.jointUSR.rod2.frame_a.R.T[2,1];
//   jointRRR2.jointUSR.rod2.frame_b.R.T[2,2] = jointRRR2.jointUSR.rod2.frame_a.R.T[2,2];
//   jointRRR2.jointUSR.rod2.frame_b.R.T[2,3] = jointRRR2.jointUSR.rod2.frame_a.R.T[2,3];
//   jointRRR2.jointUSR.rod2.frame_b.R.T[3,1] = jointRRR2.jointUSR.rod2.frame_a.R.T[3,1];
//   jointRRR2.jointUSR.rod2.frame_b.R.T[3,2] = jointRRR2.jointUSR.rod2.frame_a.R.T[3,2];
//   jointRRR2.jointUSR.rod2.frame_b.R.T[3,3] = jointRRR2.jointUSR.rod2.frame_a.R.T[3,3];
//   jointRRR2.jointUSR.rod2.frame_b.R.w[1] = jointRRR2.jointUSR.rod2.frame_a.R.w[1];
//   jointRRR2.jointUSR.rod2.frame_b.R.w[2] = jointRRR2.jointUSR.rod2.frame_a.R.w[2];
//   jointRRR2.jointUSR.rod2.frame_b.R.w[3] = jointRRR2.jointUSR.rod2.frame_a.R.w[3];
//   0.0 = jointRRR2.jointUSR.rod2.frame_a.f[1] + jointRRR2.jointUSR.rod2.frame_b.f[1];
//   0.0 = jointRRR2.jointUSR.rod2.frame_a.f[2] + jointRRR2.jointUSR.rod2.frame_b.f[2];
//   0.0 = jointRRR2.jointUSR.rod2.frame_a.f[3] + jointRRR2.jointUSR.rod2.frame_b.f[3];
//   0.0 = jointRRR2.jointUSR.rod2.frame_a.t[1] + (jointRRR2.jointUSR.rod2.frame_b.t[1] + (jointRRR2.jointUSR.rod2.r[2] * jointRRR2.jointUSR.rod2.frame_b.f[3] + (-jointRRR2.jointUSR.rod2.r[3] * jointRRR2.jointUSR.rod2.frame_b.f[2])));
//   0.0 = jointRRR2.jointUSR.rod2.frame_a.t[2] + (jointRRR2.jointUSR.rod2.frame_b.t[2] + (jointRRR2.jointUSR.rod2.r[3] * jointRRR2.jointUSR.rod2.frame_b.f[1] + (-jointRRR2.jointUSR.rod2.r[1] * jointRRR2.jointUSR.rod2.frame_b.f[3])));
//   0.0 = jointRRR2.jointUSR.rod2.frame_a.t[3] + (jointRRR2.jointUSR.rod2.frame_b.t[3] + (jointRRR2.jointUSR.rod2.r[1] * jointRRR2.jointUSR.rod2.frame_b.f[2] + (-jointRRR2.jointUSR.rod2.r[2] * jointRRR2.jointUSR.rod2.frame_b.f[1])));
//   jointRRR2.jointUSR.relativePosition.relativePosition.r_rel = Modelica.Mechanics.MultiBody.Frames.resolve2(jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.R,{jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.r_0[1] - jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.r_0[1],jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.r_0[2] - jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.r_0[2],jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.r_0[3] - jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.r_0[3]});
//   assert(true,\"Connector frame_a must be connected at least once\");
//   assert(true,\"Connector frame_b must be connected at least once\");
//   assert(true,\"Connector frame_resolve must be connected exactly once\");
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.f[1] = 0.0;
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.f[2] = 0.0;
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.f[3] = 0.0;
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.t[1] = 0.0;
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.t[2] = 0.0;
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.t[3] = 0.0;
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.f[1] = 0.0;
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.f[2] = 0.0;
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.f[3] = 0.0;
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.t[1] = 0.0;
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.t[2] = 0.0;
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.t[3] = 0.0;
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.f[1] = 0.0;
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.f[2] = 0.0;
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.f[3] = 0.0;
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.t[1] = 0.0;
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.t[2] = 0.0;
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.t[3] = 0.0;
//   jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.w[3] = 0.0;
//   jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.w[2] = 0.0;
//   jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.w[1] = 0.0;
//   jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[3,3] = 1.0;
//   jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[3,2] = 0.0;
//   jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[3,1] = 0.0;
//   jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[2,3] = 0.0;
//   jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[2,2] = 1.0;
//   jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[2,1] = 0.0;
//   jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[1,3] = 0.0;
//   jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[1,2] = 0.0;
//   jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[1,1] = 1.0;
//   jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.r_0[1] = 0.0;
//   jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.r_0[2] = 0.0;
//   jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.r_0[3] = 0.0;
//   assert(true,\"Connector frame_a must be connected at least once\");
//   assert(true,\"Connector frame_b must be connected at least once\");
//   jointRRR2.jointUSR.position_b[1].y = jointRRR2.jointUSR.position_b[1].k;
//   jointRRR2.jointUSR.position_b[2].y = jointRRR2.jointUSR.position_b[2].k;
//   jointRRR2.jointUSR.position_b[3].y = jointRRR2.jointUSR.position_b[3].k;
//   jointRRR2.jointUSR.aux = {jointRRR2.jointUSR.revolute.e[2] * jointRRR2.jointUSR.rRod2_ib[3] - jointRRR2.jointUSR.revolute.e[3] * jointRRR2.jointUSR.rRod2_ib[2],jointRRR2.jointUSR.revolute.e[3] * jointRRR2.jointUSR.rRod2_ib[1] - jointRRR2.jointUSR.revolute.e[1] * jointRRR2.jointUSR.rRod2_ib[3],jointRRR2.jointUSR.revolute.e[1] * jointRRR2.jointUSR.rRod2_ib[2] - jointRRR2.jointUSR.revolute.e[2] * jointRRR2.jointUSR.rRod2_ib[1]} * Modelica.Mechanics.MultiBody.Frames.resolveRelative({jointRRR2.jointUSR.rod1.eRod_a[1],jointRRR2.jointUSR.rod1.eRod_a[2],jointRRR2.jointUSR.rod1.eRod_a[3]},jointRRR2.jointUSR.rod1.frame_a.R,jointRRR2.jointUSR.rod1.frame_b.R);
//   jointRRR2.jointUSR.f_rod = ((-jointRRR2.jointUSR.revolute.tau) - {jointRRR2.jointUSR.revolute.e[1],jointRRR2.jointUSR.revolute.e[2],jointRRR2.jointUSR.revolute.e[3]} * ({jointRRR2.jointUSR.frame_ib.t[1] + jointRRR2.jointUSR.frame_im.t[1] + (jointRRR2.jointUSR.rRod2_ib[2] * jointRRR2.jointUSR.frame_im.f[3] - jointRRR2.jointUSR.rRod2_ib[3] * jointRRR2.jointUSR.frame_im.f[2]),jointRRR2.jointUSR.frame_ib.t[2] + jointRRR2.jointUSR.frame_im.t[2] + (jointRRR2.jointUSR.rRod2_ib[3] * jointRRR2.jointUSR.frame_im.f[1] - jointRRR2.jointUSR.rRod2_ib[1] * jointRRR2.jointUSR.frame_im.f[3]),jointRRR2.jointUSR.frame_ib.t[3] + jointRRR2.jointUSR.frame_im.t[3] + (jointRRR2.jointUSR.rRod2_ib[1] * jointRRR2.jointUSR.frame_im.f[2] - jointRRR2.jointUSR.rRod2_ib[2] * jointRRR2.jointUSR.frame_im.f[1])} - cross({jointRRR2.jointUSR.rRod2_ib[1],jointRRR2.jointUSR.rRod2_ib[2],jointRRR2.jointUSR.rRod2_ib[3]},Modelica.Mechanics.MultiBody.Frames.resolveRelative({jointRRR2.jointUSR.rod1.f_b_a1[1],jointRRR2.jointUSR.rod1.f_b_a1[2],jointRRR2.jointUSR.rod1.f_b_a1[3]},jointRRR2.jointUSR.rod1.frame_a.R,jointRRR2.jointUSR.rod1.frame_b.R)))) / (if noEvent(abs(jointRRR2.jointUSR.aux) < 1e-10) then 1e-10 else jointRRR2.jointUSR.aux);
//   jointRRR2.jointUSR.totalPower = {jointRRR2.jointUSR.frame_a.f[1],jointRRR2.jointUSR.frame_a.f[2],jointRRR2.jointUSR.frame_a.f[3]} * Modelica.Mechanics.MultiBody.Frames.resolve2(jointRRR2.jointUSR.frame_a.R,{der(jointRRR2.jointUSR.frame_a.r_0[1]),der(jointRRR2.jointUSR.frame_a.r_0[2]),der(jointRRR2.jointUSR.frame_a.r_0[3])}) + ({jointRRR2.jointUSR.frame_b.f[1],jointRRR2.jointUSR.frame_b.f[2],jointRRR2.jointUSR.frame_b.f[3]} * Modelica.Mechanics.MultiBody.Frames.resolve2(jointRRR2.jointUSR.frame_b.R,{der(jointRRR2.jointUSR.frame_b.r_0[1]),der(jointRRR2.jointUSR.frame_b.r_0[2]),der(jointRRR2.jointUSR.frame_b.r_0[3])}) + ({jointRRR2.jointUSR.frame_ia.f[1],jointRRR2.jointUSR.frame_ia.f[2],jointRRR2.jointUSR.frame_ia.f[3]} * Modelica.Mechanics.MultiBody.Frames.resolve2(jointRRR2.jointUSR.frame_ia.R,{der(jointRRR2.jointUSR.frame_ia.r_0[1]),der(jointRRR2.jointUSR.frame_ia.r_0[2]),der(jointRRR2.jointUSR.frame_ia.r_0[3])}) + ({jointRRR2.jointUSR.frame_ib.f[1],jointRRR2.jointUSR.frame_ib.f[2],jointRRR2.jointUSR.frame_ib.f[3]} * Modelica.Mechanics.MultiBody.Frames.resolve2(jointRRR2.jointUSR.frame_ib.R,{der(jointRRR2.jointUSR.frame_ib.r_0[1]),der(jointRRR2.jointUSR.frame_ib.r_0[2]),der(jointRRR2.jointUSR.frame_ib.r_0[3])}) + ({jointRRR2.jointUSR.frame_im.f[1],jointRRR2.jointUSR.frame_im.f[2],jointRRR2.jointUSR.frame_im.f[3]} * Modelica.Mechanics.MultiBody.Frames.resolve2(jointRRR2.jointUSR.frame_im.R,{der(jointRRR2.jointUSR.frame_im.r_0[1]),der(jointRRR2.jointUSR.frame_im.r_0[2]),der(jointRRR2.jointUSR.frame_im.r_0[3])}) + ({jointRRR2.jointUSR.frame_a.t[1],jointRRR2.jointUSR.frame_a.t[2],jointRRR2.jointUSR.frame_a.t[3]} * Modelica.Mechanics.MultiBody.Frames.angularVelocity2(jointRRR2.jointUSR.frame_a.R) + ({jointRRR2.jointUSR.frame_b.t[1],jointRRR2.jointUSR.frame_b.t[2],jointRRR2.jointUSR.frame_b.t[3]} * Modelica.Mechanics.MultiBody.Frames.angularVelocity2(jointRRR2.jointUSR.frame_b.R) + ({jointRRR2.jointUSR.frame_ia.t[1],jointRRR2.jointUSR.frame_ia.t[2],jointRRR2.jointUSR.frame_ia.t[3]} * Modelica.Mechanics.MultiBody.Frames.angularVelocity2(jointRRR2.jointUSR.frame_ia.R) + ({jointRRR2.jointUSR.frame_ib.t[1],jointRRR2.jointUSR.frame_ib.t[2],jointRRR2.jointUSR.frame_ib.t[3]} * Modelica.Mechanics.MultiBody.Frames.angularVelocity2(jointRRR2.jointUSR.frame_ib.R) + ({jointRRR2.jointUSR.frame_im.t[1],jointRRR2.jointUSR.frame_im.t[2],jointRRR2.jointUSR.frame_im.t[3]} * Modelica.Mechanics.MultiBody.Frames.angularVelocity2(jointRRR2.jointUSR.frame_im.R) + (jointRRR2.jointUSR.axis.tau * der(jointRRR2.jointUSR.axis.phi) + jointRRR2.jointUSR.bearing.tau * der(jointRRR2.jointUSR.bearing.phi)))))))))));
//   assert(true,\"Connector frame_a of component is not connected\");
//   assert(true,\"Connector frame_b of component is not connected\");
//   jointRRR2.shape_rev1.R.T[1,1] = jointRRR2.frame_a.R.T[1,1];
//   jointRRR2.shape_rev1.R.T[1,2] = jointRRR2.frame_a.R.T[1,2];
//   jointRRR2.shape_rev1.R.T[1,3] = jointRRR2.frame_a.R.T[1,3];
//   jointRRR2.shape_rev1.R.T[2,1] = jointRRR2.frame_a.R.T[2,1];
//   jointRRR2.shape_rev1.R.T[2,2] = jointRRR2.frame_a.R.T[2,2];
//   jointRRR2.shape_rev1.R.T[2,3] = jointRRR2.frame_a.R.T[2,3];
//   jointRRR2.shape_rev1.R.T[3,1] = jointRRR2.frame_a.R.T[3,1];
//   jointRRR2.shape_rev1.R.T[3,2] = jointRRR2.frame_a.R.T[3,2];
//   jointRRR2.shape_rev1.R.T[3,3] = jointRRR2.frame_a.R.T[3,3];
//   jointRRR2.shape_rev1.R.w[1] = jointRRR2.frame_a.R.w[1];
//   jointRRR2.shape_rev1.R.w[2] = jointRRR2.frame_a.R.w[2];
//   jointRRR2.shape_rev1.R.w[3] = jointRRR2.frame_a.R.w[3];
//   jointRRR2.shape_rev1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(jointRRR2.shape_rev1.shapeType);
//   jointRRR2.shape_rev1.rxvisobj[1] = jointRRR2.shape_rev1.R.T[1,1] * jointRRR2.shape_rev1.e_x[1] + (jointRRR2.shape_rev1.R.T[2,1] * jointRRR2.shape_rev1.e_x[2] + jointRRR2.shape_rev1.R.T[3,1] * jointRRR2.shape_rev1.e_x[3]);
//   jointRRR2.shape_rev1.rxvisobj[2] = jointRRR2.shape_rev1.R.T[1,2] * jointRRR2.shape_rev1.e_x[1] + (jointRRR2.shape_rev1.R.T[2,2] * jointRRR2.shape_rev1.e_x[2] + jointRRR2.shape_rev1.R.T[3,2] * jointRRR2.shape_rev1.e_x[3]);
//   jointRRR2.shape_rev1.rxvisobj[3] = jointRRR2.shape_rev1.R.T[1,3] * jointRRR2.shape_rev1.e_x[1] + (jointRRR2.shape_rev1.R.T[2,3] * jointRRR2.shape_rev1.e_x[2] + jointRRR2.shape_rev1.R.T[3,3] * jointRRR2.shape_rev1.e_x[3]);
//   jointRRR2.shape_rev1.ryvisobj[1] = jointRRR2.shape_rev1.R.T[1,1] * jointRRR2.shape_rev1.e_y[1] + (jointRRR2.shape_rev1.R.T[2,1] * jointRRR2.shape_rev1.e_y[2] + jointRRR2.shape_rev1.R.T[3,1] * jointRRR2.shape_rev1.e_y[3]);
//   jointRRR2.shape_rev1.ryvisobj[2] = jointRRR2.shape_rev1.R.T[1,2] * jointRRR2.shape_rev1.e_y[1] + (jointRRR2.shape_rev1.R.T[2,2] * jointRRR2.shape_rev1.e_y[2] + jointRRR2.shape_rev1.R.T[3,2] * jointRRR2.shape_rev1.e_y[3]);
//   jointRRR2.shape_rev1.ryvisobj[3] = jointRRR2.shape_rev1.R.T[1,3] * jointRRR2.shape_rev1.e_y[1] + (jointRRR2.shape_rev1.R.T[2,3] * jointRRR2.shape_rev1.e_y[2] + jointRRR2.shape_rev1.R.T[3,3] * jointRRR2.shape_rev1.e_y[3]);
//   jointRRR2.shape_rev1.rvisobj = jointRRR2.shape_rev1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{jointRRR2.shape_rev1.R.T[1,1],jointRRR2.shape_rev1.R.T[1,2],jointRRR2.shape_rev1.R.T[1,3]},{jointRRR2.shape_rev1.R.T[2,1],jointRRR2.shape_rev1.R.T[2,2],jointRRR2.shape_rev1.R.T[2,3]},{jointRRR2.shape_rev1.R.T[3,1],jointRRR2.shape_rev1.R.T[3,2],jointRRR2.shape_rev1.R.T[3,3]}},{jointRRR2.shape_rev1.r_shape[1],jointRRR2.shape_rev1.r_shape[2],jointRRR2.shape_rev1.r_shape[3]});
//   jointRRR2.shape_rev1.size[1] = jointRRR2.shape_rev1.length;
//   jointRRR2.shape_rev1.size[2] = jointRRR2.shape_rev1.width;
//   jointRRR2.shape_rev1.size[3] = jointRRR2.shape_rev1.height;
//   jointRRR2.shape_rev1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(jointRRR2.shape_rev1.color[1] / 255.0,jointRRR2.shape_rev1.color[2] / 255.0,jointRRR2.shape_rev1.color[3] / 255.0,jointRRR2.shape_rev1.specularCoefficient);
//   jointRRR2.shape_rev1.Extra = jointRRR2.shape_rev1.extra;
//   jointRRR2.shape_rev2.R.T[1,1] = jointRRR2.frame_im.R.T[1,1];
//   jointRRR2.shape_rev2.R.T[1,2] = jointRRR2.frame_im.R.T[1,2];
//   jointRRR2.shape_rev2.R.T[1,3] = jointRRR2.frame_im.R.T[1,3];
//   jointRRR2.shape_rev2.R.T[2,1] = jointRRR2.frame_im.R.T[2,1];
//   jointRRR2.shape_rev2.R.T[2,2] = jointRRR2.frame_im.R.T[2,2];
//   jointRRR2.shape_rev2.R.T[2,3] = jointRRR2.frame_im.R.T[2,3];
//   jointRRR2.shape_rev2.R.T[3,1] = jointRRR2.frame_im.R.T[3,1];
//   jointRRR2.shape_rev2.R.T[3,2] = jointRRR2.frame_im.R.T[3,2];
//   jointRRR2.shape_rev2.R.T[3,3] = jointRRR2.frame_im.R.T[3,3];
//   jointRRR2.shape_rev2.R.w[1] = jointRRR2.frame_im.R.w[1];
//   jointRRR2.shape_rev2.R.w[2] = jointRRR2.frame_im.R.w[2];
//   jointRRR2.shape_rev2.R.w[3] = jointRRR2.frame_im.R.w[3];
//   jointRRR2.shape_rev2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(jointRRR2.shape_rev2.shapeType);
//   jointRRR2.shape_rev2.rxvisobj[1] = jointRRR2.shape_rev2.R.T[1,1] * jointRRR2.shape_rev2.e_x[1] + (jointRRR2.shape_rev2.R.T[2,1] * jointRRR2.shape_rev2.e_x[2] + jointRRR2.shape_rev2.R.T[3,1] * jointRRR2.shape_rev2.e_x[3]);
//   jointRRR2.shape_rev2.rxvisobj[2] = jointRRR2.shape_rev2.R.T[1,2] * jointRRR2.shape_rev2.e_x[1] + (jointRRR2.shape_rev2.R.T[2,2] * jointRRR2.shape_rev2.e_x[2] + jointRRR2.shape_rev2.R.T[3,2] * jointRRR2.shape_rev2.e_x[3]);
//   jointRRR2.shape_rev2.rxvisobj[3] = jointRRR2.shape_rev2.R.T[1,3] * jointRRR2.shape_rev2.e_x[1] + (jointRRR2.shape_rev2.R.T[2,3] * jointRRR2.shape_rev2.e_x[2] + jointRRR2.shape_rev2.R.T[3,3] * jointRRR2.shape_rev2.e_x[3]);
//   jointRRR2.shape_rev2.ryvisobj[1] = jointRRR2.shape_rev2.R.T[1,1] * jointRRR2.shape_rev2.e_y[1] + (jointRRR2.shape_rev2.R.T[2,1] * jointRRR2.shape_rev2.e_y[2] + jointRRR2.shape_rev2.R.T[3,1] * jointRRR2.shape_rev2.e_y[3]);
//   jointRRR2.shape_rev2.ryvisobj[2] = jointRRR2.shape_rev2.R.T[1,2] * jointRRR2.shape_rev2.e_y[1] + (jointRRR2.shape_rev2.R.T[2,2] * jointRRR2.shape_rev2.e_y[2] + jointRRR2.shape_rev2.R.T[3,2] * jointRRR2.shape_rev2.e_y[3]);
//   jointRRR2.shape_rev2.ryvisobj[3] = jointRRR2.shape_rev2.R.T[1,3] * jointRRR2.shape_rev2.e_y[1] + (jointRRR2.shape_rev2.R.T[2,3] * jointRRR2.shape_rev2.e_y[2] + jointRRR2.shape_rev2.R.T[3,3] * jointRRR2.shape_rev2.e_y[3]);
//   jointRRR2.shape_rev2.rvisobj = jointRRR2.shape_rev2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{jointRRR2.shape_rev2.R.T[1,1],jointRRR2.shape_rev2.R.T[1,2],jointRRR2.shape_rev2.R.T[1,3]},{jointRRR2.shape_rev2.R.T[2,1],jointRRR2.shape_rev2.R.T[2,2],jointRRR2.shape_rev2.R.T[2,3]},{jointRRR2.shape_rev2.R.T[3,1],jointRRR2.shape_rev2.R.T[3,2],jointRRR2.shape_rev2.R.T[3,3]}},{jointRRR2.shape_rev2.r_shape[1],jointRRR2.shape_rev2.r_shape[2],jointRRR2.shape_rev2.r_shape[3]});
//   jointRRR2.shape_rev2.size[1] = jointRRR2.shape_rev2.length;
//   jointRRR2.shape_rev2.size[2] = jointRRR2.shape_rev2.width;
//   jointRRR2.shape_rev2.size[3] = jointRRR2.shape_rev2.height;
//   jointRRR2.shape_rev2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(jointRRR2.shape_rev2.color[1] / 255.0,jointRRR2.shape_rev2.color[2] / 255.0,jointRRR2.shape_rev2.color[3] / 255.0,jointRRR2.shape_rev2.specularCoefficient);
//   jointRRR2.shape_rev2.Extra = jointRRR2.shape_rev2.extra;
//   jointRRR2.shape_rev3.R.T[1,1] = jointRRR2.frame_b.R.T[1,1];
//   jointRRR2.shape_rev3.R.T[1,2] = jointRRR2.frame_b.R.T[1,2];
//   jointRRR2.shape_rev3.R.T[1,3] = jointRRR2.frame_b.R.T[1,3];
//   jointRRR2.shape_rev3.R.T[2,1] = jointRRR2.frame_b.R.T[2,1];
//   jointRRR2.shape_rev3.R.T[2,2] = jointRRR2.frame_b.R.T[2,2];
//   jointRRR2.shape_rev3.R.T[2,3] = jointRRR2.frame_b.R.T[2,3];
//   jointRRR2.shape_rev3.R.T[3,1] = jointRRR2.frame_b.R.T[3,1];
//   jointRRR2.shape_rev3.R.T[3,2] = jointRRR2.frame_b.R.T[3,2];
//   jointRRR2.shape_rev3.R.T[3,3] = jointRRR2.frame_b.R.T[3,3];
//   jointRRR2.shape_rev3.R.w[1] = jointRRR2.frame_b.R.w[1];
//   jointRRR2.shape_rev3.R.w[2] = jointRRR2.frame_b.R.w[2];
//   jointRRR2.shape_rev3.R.w[3] = jointRRR2.frame_b.R.w[3];
//   jointRRR2.shape_rev3.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(jointRRR2.shape_rev3.shapeType);
//   jointRRR2.shape_rev3.rxvisobj[1] = jointRRR2.shape_rev3.R.T[1,1] * jointRRR2.shape_rev3.e_x[1] + (jointRRR2.shape_rev3.R.T[2,1] * jointRRR2.shape_rev3.e_x[2] + jointRRR2.shape_rev3.R.T[3,1] * jointRRR2.shape_rev3.e_x[3]);
//   jointRRR2.shape_rev3.rxvisobj[2] = jointRRR2.shape_rev3.R.T[1,2] * jointRRR2.shape_rev3.e_x[1] + (jointRRR2.shape_rev3.R.T[2,2] * jointRRR2.shape_rev3.e_x[2] + jointRRR2.shape_rev3.R.T[3,2] * jointRRR2.shape_rev3.e_x[3]);
//   jointRRR2.shape_rev3.rxvisobj[3] = jointRRR2.shape_rev3.R.T[1,3] * jointRRR2.shape_rev3.e_x[1] + (jointRRR2.shape_rev3.R.T[2,3] * jointRRR2.shape_rev3.e_x[2] + jointRRR2.shape_rev3.R.T[3,3] * jointRRR2.shape_rev3.e_x[3]);
//   jointRRR2.shape_rev3.ryvisobj[1] = jointRRR2.shape_rev3.R.T[1,1] * jointRRR2.shape_rev3.e_y[1] + (jointRRR2.shape_rev3.R.T[2,1] * jointRRR2.shape_rev3.e_y[2] + jointRRR2.shape_rev3.R.T[3,1] * jointRRR2.shape_rev3.e_y[3]);
//   jointRRR2.shape_rev3.ryvisobj[2] = jointRRR2.shape_rev3.R.T[1,2] * jointRRR2.shape_rev3.e_y[1] + (jointRRR2.shape_rev3.R.T[2,2] * jointRRR2.shape_rev3.e_y[2] + jointRRR2.shape_rev3.R.T[3,2] * jointRRR2.shape_rev3.e_y[3]);
//   jointRRR2.shape_rev3.ryvisobj[3] = jointRRR2.shape_rev3.R.T[1,3] * jointRRR2.shape_rev3.e_y[1] + (jointRRR2.shape_rev3.R.T[2,3] * jointRRR2.shape_rev3.e_y[2] + jointRRR2.shape_rev3.R.T[3,3] * jointRRR2.shape_rev3.e_y[3]);
//   jointRRR2.shape_rev3.rvisobj = jointRRR2.shape_rev3.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{jointRRR2.shape_rev3.R.T[1,1],jointRRR2.shape_rev3.R.T[1,2],jointRRR2.shape_rev3.R.T[1,3]},{jointRRR2.shape_rev3.R.T[2,1],jointRRR2.shape_rev3.R.T[2,2],jointRRR2.shape_rev3.R.T[2,3]},{jointRRR2.shape_rev3.R.T[3,1],jointRRR2.shape_rev3.R.T[3,2],jointRRR2.shape_rev3.R.T[3,3]}},{jointRRR2.shape_rev3.r_shape[1],jointRRR2.shape_rev3.r_shape[2],jointRRR2.shape_rev3.r_shape[3]});
//   jointRRR2.shape_rev3.size[1] = jointRRR2.shape_rev3.length;
//   jointRRR2.shape_rev3.size[2] = jointRRR2.shape_rev3.width;
//   jointRRR2.shape_rev3.size[3] = jointRRR2.shape_rev3.height;
//   jointRRR2.shape_rev3.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(jointRRR2.shape_rev3.color[1] / 255.0,jointRRR2.shape_rev3.color[2] / 255.0,jointRRR2.shape_rev3.color[3] / 255.0,jointRRR2.shape_rev3.specularCoefficient);
//   jointRRR2.shape_rev3.Extra = jointRRR2.shape_rev3.extra;
//   jointRRR2.shape_rod1.R.T[1,1] = jointRRR2.frame_ia.R.T[1,1];
//   jointRRR2.shape_rod1.R.T[1,2] = jointRRR2.frame_ia.R.T[1,2];
//   jointRRR2.shape_rod1.R.T[1,3] = jointRRR2.frame_ia.R.T[1,3];
//   jointRRR2.shape_rod1.R.T[2,1] = jointRRR2.frame_ia.R.T[2,1];
//   jointRRR2.shape_rod1.R.T[2,2] = jointRRR2.frame_ia.R.T[2,2];
//   jointRRR2.shape_rod1.R.T[2,3] = jointRRR2.frame_ia.R.T[2,3];
//   jointRRR2.shape_rod1.R.T[3,1] = jointRRR2.frame_ia.R.T[3,1];
//   jointRRR2.shape_rod1.R.T[3,2] = jointRRR2.frame_ia.R.T[3,2];
//   jointRRR2.shape_rod1.R.T[3,3] = jointRRR2.frame_ia.R.T[3,3];
//   jointRRR2.shape_rod1.R.w[1] = jointRRR2.frame_ia.R.w[1];
//   jointRRR2.shape_rod1.R.w[2] = jointRRR2.frame_ia.R.w[2];
//   jointRRR2.shape_rod1.R.w[3] = jointRRR2.frame_ia.R.w[3];
//   jointRRR2.shape_rod1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(jointRRR2.shape_rod1.shapeType);
//   jointRRR2.shape_rod1.rxvisobj[1] = jointRRR2.shape_rod1.R.T[1,1] * jointRRR2.shape_rod1.e_x[1] + (jointRRR2.shape_rod1.R.T[2,1] * jointRRR2.shape_rod1.e_x[2] + jointRRR2.shape_rod1.R.T[3,1] * jointRRR2.shape_rod1.e_x[3]);
//   jointRRR2.shape_rod1.rxvisobj[2] = jointRRR2.shape_rod1.R.T[1,2] * jointRRR2.shape_rod1.e_x[1] + (jointRRR2.shape_rod1.R.T[2,2] * jointRRR2.shape_rod1.e_x[2] + jointRRR2.shape_rod1.R.T[3,2] * jointRRR2.shape_rod1.e_x[3]);
//   jointRRR2.shape_rod1.rxvisobj[3] = jointRRR2.shape_rod1.R.T[1,3] * jointRRR2.shape_rod1.e_x[1] + (jointRRR2.shape_rod1.R.T[2,3] * jointRRR2.shape_rod1.e_x[2] + jointRRR2.shape_rod1.R.T[3,3] * jointRRR2.shape_rod1.e_x[3]);
//   jointRRR2.shape_rod1.ryvisobj[1] = jointRRR2.shape_rod1.R.T[1,1] * jointRRR2.shape_rod1.e_y[1] + (jointRRR2.shape_rod1.R.T[2,1] * jointRRR2.shape_rod1.e_y[2] + jointRRR2.shape_rod1.R.T[3,1] * jointRRR2.shape_rod1.e_y[3]);
//   jointRRR2.shape_rod1.ryvisobj[2] = jointRRR2.shape_rod1.R.T[1,2] * jointRRR2.shape_rod1.e_y[1] + (jointRRR2.shape_rod1.R.T[2,2] * jointRRR2.shape_rod1.e_y[2] + jointRRR2.shape_rod1.R.T[3,2] * jointRRR2.shape_rod1.e_y[3]);
//   jointRRR2.shape_rod1.ryvisobj[3] = jointRRR2.shape_rod1.R.T[1,3] * jointRRR2.shape_rod1.e_y[1] + (jointRRR2.shape_rod1.R.T[2,3] * jointRRR2.shape_rod1.e_y[2] + jointRRR2.shape_rod1.R.T[3,3] * jointRRR2.shape_rod1.e_y[3]);
//   jointRRR2.shape_rod1.rvisobj = jointRRR2.shape_rod1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{jointRRR2.shape_rod1.R.T[1,1],jointRRR2.shape_rod1.R.T[1,2],jointRRR2.shape_rod1.R.T[1,3]},{jointRRR2.shape_rod1.R.T[2,1],jointRRR2.shape_rod1.R.T[2,2],jointRRR2.shape_rod1.R.T[2,3]},{jointRRR2.shape_rod1.R.T[3,1],jointRRR2.shape_rod1.R.T[3,2],jointRRR2.shape_rod1.R.T[3,3]}},{jointRRR2.shape_rod1.r_shape[1],jointRRR2.shape_rod1.r_shape[2],jointRRR2.shape_rod1.r_shape[3]});
//   jointRRR2.shape_rod1.size[1] = jointRRR2.shape_rod1.length;
//   jointRRR2.shape_rod1.size[2] = jointRRR2.shape_rod1.width;
//   jointRRR2.shape_rod1.size[3] = jointRRR2.shape_rod1.height;
//   jointRRR2.shape_rod1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(jointRRR2.shape_rod1.color[1] / 255.0,jointRRR2.shape_rod1.color[2] / 255.0,jointRRR2.shape_rod1.color[3] / 255.0,jointRRR2.shape_rod1.specularCoefficient);
//   jointRRR2.shape_rod1.Extra = jointRRR2.shape_rod1.extra;
//   jointRRR2.shape_rod2.R.T[1,1] = jointRRR2.frame_ib.R.T[1,1];
//   jointRRR2.shape_rod2.R.T[1,2] = jointRRR2.frame_ib.R.T[1,2];
//   jointRRR2.shape_rod2.R.T[1,3] = jointRRR2.frame_ib.R.T[1,3];
//   jointRRR2.shape_rod2.R.T[2,1] = jointRRR2.frame_ib.R.T[2,1];
//   jointRRR2.shape_rod2.R.T[2,2] = jointRRR2.frame_ib.R.T[2,2];
//   jointRRR2.shape_rod2.R.T[2,3] = jointRRR2.frame_ib.R.T[2,3];
//   jointRRR2.shape_rod2.R.T[3,1] = jointRRR2.frame_ib.R.T[3,1];
//   jointRRR2.shape_rod2.R.T[3,2] = jointRRR2.frame_ib.R.T[3,2];
//   jointRRR2.shape_rod2.R.T[3,3] = jointRRR2.frame_ib.R.T[3,3];
//   jointRRR2.shape_rod2.R.w[1] = jointRRR2.frame_ib.R.w[1];
//   jointRRR2.shape_rod2.R.w[2] = jointRRR2.frame_ib.R.w[2];
//   jointRRR2.shape_rod2.R.w[3] = jointRRR2.frame_ib.R.w[3];
//   jointRRR2.shape_rod2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(jointRRR2.shape_rod2.shapeType);
//   jointRRR2.shape_rod2.rxvisobj[1] = jointRRR2.shape_rod2.R.T[1,1] * jointRRR2.shape_rod2.e_x[1] + (jointRRR2.shape_rod2.R.T[2,1] * jointRRR2.shape_rod2.e_x[2] + jointRRR2.shape_rod2.R.T[3,1] * jointRRR2.shape_rod2.e_x[3]);
//   jointRRR2.shape_rod2.rxvisobj[2] = jointRRR2.shape_rod2.R.T[1,2] * jointRRR2.shape_rod2.e_x[1] + (jointRRR2.shape_rod2.R.T[2,2] * jointRRR2.shape_rod2.e_x[2] + jointRRR2.shape_rod2.R.T[3,2] * jointRRR2.shape_rod2.e_x[3]);
//   jointRRR2.shape_rod2.rxvisobj[3] = jointRRR2.shape_rod2.R.T[1,3] * jointRRR2.shape_rod2.e_x[1] + (jointRRR2.shape_rod2.R.T[2,3] * jointRRR2.shape_rod2.e_x[2] + jointRRR2.shape_rod2.R.T[3,3] * jointRRR2.shape_rod2.e_x[3]);
//   jointRRR2.shape_rod2.ryvisobj[1] = jointRRR2.shape_rod2.R.T[1,1] * jointRRR2.shape_rod2.e_y[1] + (jointRRR2.shape_rod2.R.T[2,1] * jointRRR2.shape_rod2.e_y[2] + jointRRR2.shape_rod2.R.T[3,1] * jointRRR2.shape_rod2.e_y[3]);
//   jointRRR2.shape_rod2.ryvisobj[2] = jointRRR2.shape_rod2.R.T[1,2] * jointRRR2.shape_rod2.e_y[1] + (jointRRR2.shape_rod2.R.T[2,2] * jointRRR2.shape_rod2.e_y[2] + jointRRR2.shape_rod2.R.T[3,2] * jointRRR2.shape_rod2.e_y[3]);
//   jointRRR2.shape_rod2.ryvisobj[3] = jointRRR2.shape_rod2.R.T[1,3] * jointRRR2.shape_rod2.e_y[1] + (jointRRR2.shape_rod2.R.T[2,3] * jointRRR2.shape_rod2.e_y[2] + jointRRR2.shape_rod2.R.T[3,3] * jointRRR2.shape_rod2.e_y[3]);
//   jointRRR2.shape_rod2.rvisobj = jointRRR2.shape_rod2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{jointRRR2.shape_rod2.R.T[1,1],jointRRR2.shape_rod2.R.T[1,2],jointRRR2.shape_rod2.R.T[1,3]},{jointRRR2.shape_rod2.R.T[2,1],jointRRR2.shape_rod2.R.T[2,2],jointRRR2.shape_rod2.R.T[2,3]},{jointRRR2.shape_rod2.R.T[3,1],jointRRR2.shape_rod2.R.T[3,2],jointRRR2.shape_rod2.R.T[3,3]}},{jointRRR2.shape_rod2.r_shape[1],jointRRR2.shape_rod2.r_shape[2],jointRRR2.shape_rod2.r_shape[3]});
//   jointRRR2.shape_rod2.size[1] = jointRRR2.shape_rod2.length;
//   jointRRR2.shape_rod2.size[2] = jointRRR2.shape_rod2.width;
//   jointRRR2.shape_rod2.size[3] = jointRRR2.shape_rod2.height;
//   jointRRR2.shape_rod2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(jointRRR2.shape_rod2.color[1] / 255.0,jointRRR2.shape_rod2.color[2] / 255.0,jointRRR2.shape_rod2.color[3] / 255.0,jointRRR2.shape_rod2.specularCoefficient);
//   jointRRR2.shape_rod2.Extra = jointRRR2.shape_rod2.extra;
//   assert(true,\"Connector frame_a of component is not connected\");
//   assert(true,\"Connector frame_b of component is not connected\");
//   rod3.shape.R.T[1,1] = rod3.frame_a.R.T[1,1];
//   rod3.shape.R.T[1,2] = rod3.frame_a.R.T[1,2];
//   rod3.shape.R.T[1,3] = rod3.frame_a.R.T[1,3];
//   rod3.shape.R.T[2,1] = rod3.frame_a.R.T[2,1];
//   rod3.shape.R.T[2,2] = rod3.frame_a.R.T[2,2];
//   rod3.shape.R.T[2,3] = rod3.frame_a.R.T[2,3];
//   rod3.shape.R.T[3,1] = rod3.frame_a.R.T[3,1];
//   rod3.shape.R.T[3,2] = rod3.frame_a.R.T[3,2];
//   rod3.shape.R.T[3,3] = rod3.frame_a.R.T[3,3];
//   rod3.shape.R.w[1] = rod3.frame_a.R.w[1];
//   rod3.shape.R.w[2] = rod3.frame_a.R.w[2];
//   rod3.shape.R.w[3] = rod3.frame_a.R.w[3];
//   rod3.shape.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(rod3.shape.shapeType);
//   rod3.shape.rxvisobj[1] = rod3.shape.R.T[1,1] * rod3.shape.e_x[1] + (rod3.shape.R.T[2,1] * rod3.shape.e_x[2] + rod3.shape.R.T[3,1] * rod3.shape.e_x[3]);
//   rod3.shape.rxvisobj[2] = rod3.shape.R.T[1,2] * rod3.shape.e_x[1] + (rod3.shape.R.T[2,2] * rod3.shape.e_x[2] + rod3.shape.R.T[3,2] * rod3.shape.e_x[3]);
//   rod3.shape.rxvisobj[3] = rod3.shape.R.T[1,3] * rod3.shape.e_x[1] + (rod3.shape.R.T[2,3] * rod3.shape.e_x[2] + rod3.shape.R.T[3,3] * rod3.shape.e_x[3]);
//   rod3.shape.ryvisobj[1] = rod3.shape.R.T[1,1] * rod3.shape.e_y[1] + (rod3.shape.R.T[2,1] * rod3.shape.e_y[2] + rod3.shape.R.T[3,1] * rod3.shape.e_y[3]);
//   rod3.shape.ryvisobj[2] = rod3.shape.R.T[1,2] * rod3.shape.e_y[1] + (rod3.shape.R.T[2,2] * rod3.shape.e_y[2] + rod3.shape.R.T[3,2] * rod3.shape.e_y[3]);
//   rod3.shape.ryvisobj[3] = rod3.shape.R.T[1,3] * rod3.shape.e_y[1] + (rod3.shape.R.T[2,3] * rod3.shape.e_y[2] + rod3.shape.R.T[3,3] * rod3.shape.e_y[3]);
//   rod3.shape.rvisobj = rod3.shape.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{rod3.shape.R.T[1,1],rod3.shape.R.T[1,2],rod3.shape.R.T[1,3]},{rod3.shape.R.T[2,1],rod3.shape.R.T[2,2],rod3.shape.R.T[2,3]},{rod3.shape.R.T[3,1],rod3.shape.R.T[3,2],rod3.shape.R.T[3,3]}},{rod3.shape.r_shape[1],rod3.shape.r_shape[2],rod3.shape.r_shape[3]});
//   rod3.shape.size[1] = rod3.shape.length;
//   rod3.shape.size[2] = rod3.shape.width;
//   rod3.shape.size[3] = rod3.shape.height;
//   rod3.shape.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(rod3.shape.color[1] / 255.0,rod3.shape.color[2] / 255.0,rod3.shape.color[3] / 255.0,rod3.shape.specularCoefficient);
//   rod3.shape.Extra = rod3.shape.extra;
//   assert(true,\"Neither connector frame_a nor frame_b of FixedTranslation object is connected\");
//   rod3.frame_b.r_0 = rod3.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(rod3.frame_a.R,{rod3.r[1],rod3.r[2],rod3.r[3]});
//   rod3.frame_b.R.T[1,1] = rod3.frame_a.R.T[1,1];
//   rod3.frame_b.R.T[1,2] = rod3.frame_a.R.T[1,2];
//   rod3.frame_b.R.T[1,3] = rod3.frame_a.R.T[1,3];
//   rod3.frame_b.R.T[2,1] = rod3.frame_a.R.T[2,1];
//   rod3.frame_b.R.T[2,2] = rod3.frame_a.R.T[2,2];
//   rod3.frame_b.R.T[2,3] = rod3.frame_a.R.T[2,3];
//   rod3.frame_b.R.T[3,1] = rod3.frame_a.R.T[3,1];
//   rod3.frame_b.R.T[3,2] = rod3.frame_a.R.T[3,2];
//   rod3.frame_b.R.T[3,3] = rod3.frame_a.R.T[3,3];
//   rod3.frame_b.R.w[1] = rod3.frame_a.R.w[1];
//   rod3.frame_b.R.w[2] = rod3.frame_a.R.w[2];
//   rod3.frame_b.R.w[3] = rod3.frame_a.R.w[3];
//   0.0 = rod3.frame_a.f[1] + rod3.frame_b.f[1];
//   0.0 = rod3.frame_a.f[2] + rod3.frame_b.f[2];
//   0.0 = rod3.frame_a.f[3] + rod3.frame_b.f[3];
//   0.0 = rod3.frame_a.t[1] + (rod3.frame_b.t[1] + (rod3.r[2] * rod3.frame_b.f[3] + (-rod3.r[3] * rod3.frame_b.f[2])));
//   0.0 = rod3.frame_a.t[2] + (rod3.frame_b.t[2] + (rod3.r[3] * rod3.frame_b.f[1] + (-rod3.r[1] * rod3.frame_b.f[3])));
//   0.0 = rod3.frame_a.t[3] + (rod3.frame_b.t[3] + (rod3.r[1] * rod3.frame_b.f[2] + (-rod3.r[2] * rod3.frame_b.f[1])));
//   body2.cylinder.R.T[1,1] = body2.frame_a.R.T[1,1];
//   body2.cylinder.R.T[1,2] = body2.frame_a.R.T[1,2];
//   body2.cylinder.R.T[1,3] = body2.frame_a.R.T[1,3];
//   body2.cylinder.R.T[2,1] = body2.frame_a.R.T[2,1];
//   body2.cylinder.R.T[2,2] = body2.frame_a.R.T[2,2];
//   body2.cylinder.R.T[2,3] = body2.frame_a.R.T[2,3];
//   body2.cylinder.R.T[3,1] = body2.frame_a.R.T[3,1];
//   body2.cylinder.R.T[3,2] = body2.frame_a.R.T[3,2];
//   body2.cylinder.R.T[3,3] = body2.frame_a.R.T[3,3];
//   body2.cylinder.R.w[1] = body2.frame_a.R.w[1];
//   body2.cylinder.R.w[2] = body2.frame_a.R.w[2];
//   body2.cylinder.R.w[3] = body2.frame_a.R.w[3];
//   body2.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body2.cylinder.shapeType);
//   body2.cylinder.rxvisobj[1] = body2.cylinder.R.T[1,1] * body2.cylinder.e_x[1] + (body2.cylinder.R.T[2,1] * body2.cylinder.e_x[2] + body2.cylinder.R.T[3,1] * body2.cylinder.e_x[3]);
//   body2.cylinder.rxvisobj[2] = body2.cylinder.R.T[1,2] * body2.cylinder.e_x[1] + (body2.cylinder.R.T[2,2] * body2.cylinder.e_x[2] + body2.cylinder.R.T[3,2] * body2.cylinder.e_x[3]);
//   body2.cylinder.rxvisobj[3] = body2.cylinder.R.T[1,3] * body2.cylinder.e_x[1] + (body2.cylinder.R.T[2,3] * body2.cylinder.e_x[2] + body2.cylinder.R.T[3,3] * body2.cylinder.e_x[3]);
//   body2.cylinder.ryvisobj[1] = body2.cylinder.R.T[1,1] * body2.cylinder.e_y[1] + (body2.cylinder.R.T[2,1] * body2.cylinder.e_y[2] + body2.cylinder.R.T[3,1] * body2.cylinder.e_y[3]);
//   body2.cylinder.ryvisobj[2] = body2.cylinder.R.T[1,2] * body2.cylinder.e_y[1] + (body2.cylinder.R.T[2,2] * body2.cylinder.e_y[2] + body2.cylinder.R.T[3,2] * body2.cylinder.e_y[3]);
//   body2.cylinder.ryvisobj[3] = body2.cylinder.R.T[1,3] * body2.cylinder.e_y[1] + (body2.cylinder.R.T[2,3] * body2.cylinder.e_y[2] + body2.cylinder.R.T[3,3] * body2.cylinder.e_y[3]);
//   body2.cylinder.rvisobj = body2.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body2.cylinder.R.T[1,1],body2.cylinder.R.T[1,2],body2.cylinder.R.T[1,3]},{body2.cylinder.R.T[2,1],body2.cylinder.R.T[2,2],body2.cylinder.R.T[2,3]},{body2.cylinder.R.T[3,1],body2.cylinder.R.T[3,2],body2.cylinder.R.T[3,3]}},{body2.cylinder.r_shape[1],body2.cylinder.r_shape[2],body2.cylinder.r_shape[3]});
//   body2.cylinder.size[1] = body2.cylinder.length;
//   body2.cylinder.size[2] = body2.cylinder.width;
//   body2.cylinder.size[3] = body2.cylinder.height;
//   body2.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body2.cylinder.color[1] / 255.0,body2.cylinder.color[2] / 255.0,body2.cylinder.color[3] / 255.0,body2.cylinder.specularCoefficient);
//   body2.cylinder.Extra = body2.cylinder.extra;
//   body2.sphere.R.T[1,1] = body2.frame_a.R.T[1,1];
//   body2.sphere.R.T[1,2] = body2.frame_a.R.T[1,2];
//   body2.sphere.R.T[1,3] = body2.frame_a.R.T[1,3];
//   body2.sphere.R.T[2,1] = body2.frame_a.R.T[2,1];
//   body2.sphere.R.T[2,2] = body2.frame_a.R.T[2,2];
//   body2.sphere.R.T[2,3] = body2.frame_a.R.T[2,3];
//   body2.sphere.R.T[3,1] = body2.frame_a.R.T[3,1];
//   body2.sphere.R.T[3,2] = body2.frame_a.R.T[3,2];
//   body2.sphere.R.T[3,3] = body2.frame_a.R.T[3,3];
//   body2.sphere.R.w[1] = body2.frame_a.R.w[1];
//   body2.sphere.R.w[2] = body2.frame_a.R.w[2];
//   body2.sphere.R.w[3] = body2.frame_a.R.w[3];
//   body2.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body2.sphere.shapeType);
//   body2.sphere.rxvisobj[1] = body2.sphere.R.T[1,1] * body2.sphere.e_x[1] + (body2.sphere.R.T[2,1] * body2.sphere.e_x[2] + body2.sphere.R.T[3,1] * body2.sphere.e_x[3]);
//   body2.sphere.rxvisobj[2] = body2.sphere.R.T[1,2] * body2.sphere.e_x[1] + (body2.sphere.R.T[2,2] * body2.sphere.e_x[2] + body2.sphere.R.T[3,2] * body2.sphere.e_x[3]);
//   body2.sphere.rxvisobj[3] = body2.sphere.R.T[1,3] * body2.sphere.e_x[1] + (body2.sphere.R.T[2,3] * body2.sphere.e_x[2] + body2.sphere.R.T[3,3] * body2.sphere.e_x[3]);
//   body2.sphere.ryvisobj[1] = body2.sphere.R.T[1,1] * body2.sphere.e_y[1] + (body2.sphere.R.T[2,1] * body2.sphere.e_y[2] + body2.sphere.R.T[3,1] * body2.sphere.e_y[3]);
//   body2.sphere.ryvisobj[2] = body2.sphere.R.T[1,2] * body2.sphere.e_y[1] + (body2.sphere.R.T[2,2] * body2.sphere.e_y[2] + body2.sphere.R.T[3,2] * body2.sphere.e_y[3]);
//   body2.sphere.ryvisobj[3] = body2.sphere.R.T[1,3] * body2.sphere.e_y[1] + (body2.sphere.R.T[2,3] * body2.sphere.e_y[2] + body2.sphere.R.T[3,3] * body2.sphere.e_y[3]);
//   body2.sphere.rvisobj = body2.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body2.sphere.R.T[1,1],body2.sphere.R.T[1,2],body2.sphere.R.T[1,3]},{body2.sphere.R.T[2,1],body2.sphere.R.T[2,2],body2.sphere.R.T[2,3]},{body2.sphere.R.T[3,1],body2.sphere.R.T[3,2],body2.sphere.R.T[3,3]}},{body2.sphere.r_shape[1],body2.sphere.r_shape[2],body2.sphere.r_shape[3]});
//   body2.sphere.size[1] = body2.sphere.length;
//   body2.sphere.size[2] = body2.sphere.width;
//   body2.sphere.size[3] = body2.sphere.height;
//   body2.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body2.sphere.color[1] / 255.0,body2.sphere.color[2] / 255.0,body2.sphere.color[3] / 255.0,body2.sphere.specularCoefficient);
//   body2.sphere.Extra = body2.sphere.extra;
//   body2.r_0[1] = body2.frame_a.r_0[1];
//   body2.r_0[2] = body2.frame_a.r_0[2];
//   body2.r_0[3] = body2.frame_a.r_0[3];
//   if true then
//   body2.Q[1] = 0.0;
//   body2.Q[2] = 0.0;
//   body2.Q[3] = 0.0;
//   body2.Q[4] = 1.0;
//   body2.phi[1] = 0.0;
//   body2.phi[2] = 0.0;
//   body2.phi[3] = 0.0;
//   body2.phi_d[1] = 0.0;
//   body2.phi_d[2] = 0.0;
//   body2.phi_d[3] = 0.0;
//   body2.phi_dd[1] = 0.0;
//   body2.phi_dd[2] = 0.0;
//   body2.phi_dd[3] = 0.0;
//   elseif body2.useQuaternions then
//   body2.frame_a.R = Modelica.Mechanics.MultiBody.Frames.from_Q({body2.Q[1],body2.Q[2],body2.Q[3],body2.Q[4]},Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2({body2.Q[1],body2.Q[2],body2.Q[3],body2.Q[4]},{der(body2.Q[1]),der(body2.Q[2]),der(body2.Q[3]),der(body2.Q[4])}));
//   {0.0} = Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint({body2.Q[1],body2.Q[2],body2.Q[3],body2.Q[4]});
//   body2.phi[1] = 0.0;
//   body2.phi[2] = 0.0;
//   body2.phi[3] = 0.0;
//   body2.phi_d[1] = 0.0;
//   body2.phi_d[2] = 0.0;
//   body2.phi_d[3] = 0.0;
//   body2.phi_dd[1] = 0.0;
//   body2.phi_dd[2] = 0.0;
//   body2.phi_dd[3] = 0.0;
//   else
//   body2.phi_d[1] = der(body2.phi[1]);
//   body2.phi_d[2] = der(body2.phi[2]);
//   body2.phi_d[3] = der(body2.phi[3]);
//   body2.phi_dd[1] = der(body2.phi_d[1]);
//   body2.phi_dd[2] = der(body2.phi_d[2]);
//   body2.phi_dd[3] = der(body2.phi_d[3]);
//   body2.frame_a.R = Modelica.Mechanics.MultiBody.Frames.axesRotations({body2.sequence_angleStates[1],body2.sequence_angleStates[2],body2.sequence_angleStates[3]},{body2.phi[1],body2.phi[2],body2.phi[3]},{body2.phi_d[1],body2.phi_d[2],body2.phi_d[3]});
//   body2.Q[1] = 0.0;
//   body2.Q[2] = 0.0;
//   body2.Q[3] = 0.0;
//   body2.Q[4] = 1.0;
//   end if;
//   body2.g_0 = Modelica.Mechanics.MultiBody.Parts.Body.world__gravityAcceleration({body2.frame_a.r_0[1],body2.frame_a.r_0[2],body2.frame_a.r_0[3]} + Modelica.Mechanics.MultiBody.Frames.resolve1(body2.frame_a.R,{body2.r_CM[1],body2.r_CM[2],body2.r_CM[3]}),world.gravityType,world.g * Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13),world.mue);
//   body2.v_0[1] = der(body2.frame_a.r_0[1]);
//   body2.v_0[2] = der(body2.frame_a.r_0[2]);
//   body2.v_0[3] = der(body2.frame_a.r_0[3]);
//   body2.a_0[1] = der(body2.v_0[1]);
//   body2.a_0[2] = der(body2.v_0[2]);
//   body2.a_0[3] = der(body2.v_0[3]);
//   body2.w_a = Modelica.Mechanics.MultiBody.Frames.angularVelocity2(body2.frame_a.R);
//   body2.z_a[1] = der(body2.w_a[1]);
//   body2.z_a[2] = der(body2.w_a[2]);
//   body2.z_a[3] = der(body2.w_a[3]);
//   body2.frame_a.f = body2.m * (Modelica.Mechanics.MultiBody.Frames.resolve2(body2.frame_a.R,{body2.a_0[1] - body2.g_0[1],body2.a_0[2] - body2.g_0[2],body2.a_0[3] - body2.g_0[3]}) + {body2.z_a[2] * body2.r_CM[3] - body2.z_a[3] * body2.r_CM[2],body2.z_a[3] * body2.r_CM[1] - body2.z_a[1] * body2.r_CM[3],body2.z_a[1] * body2.r_CM[2] - body2.z_a[2] * body2.r_CM[1]} + {body2.w_a[2] * (body2.w_a[1] * body2.r_CM[2] - body2.w_a[2] * body2.r_CM[1]) - body2.w_a[3] * (body2.w_a[3] * body2.r_CM[1] - body2.w_a[1] * body2.r_CM[3]),body2.w_a[3] * (body2.w_a[2] * body2.r_CM[3] - body2.w_a[3] * body2.r_CM[2]) - body2.w_a[1] * (body2.w_a[1] * body2.r_CM[2] - body2.w_a[2] * body2.r_CM[1]),body2.w_a[1] * (body2.w_a[3] * body2.r_CM[1] - body2.w_a[1] * body2.r_CM[3]) - body2.w_a[2] * (body2.w_a[2] * body2.r_CM[3] - body2.w_a[3] * body2.r_CM[2])});
//   body2.frame_a.t[1] = body2.I[1,1] * body2.z_a[1] + (body2.I[1,2] * body2.z_a[2] + (body2.I[1,3] * body2.z_a[3] + (body2.w_a[2] * (body2.I[3,1] * body2.w_a[1] + (body2.I[3,2] * body2.w_a[2] + body2.I[3,3] * body2.w_a[3])) + ((-body2.w_a[3] * (body2.I[2,1] * body2.w_a[1] + (body2.I[2,2] * body2.w_a[2] + body2.I[2,3] * body2.w_a[3]))) + (body2.r_CM[2] * body2.frame_a.f[3] + (-body2.r_CM[3] * body2.frame_a.f[2]))))));
//   body2.frame_a.t[2] = body2.I[2,1] * body2.z_a[1] + (body2.I[2,2] * body2.z_a[2] + (body2.I[2,3] * body2.z_a[3] + (body2.w_a[3] * (body2.I[1,1] * body2.w_a[1] + (body2.I[1,2] * body2.w_a[2] + body2.I[1,3] * body2.w_a[3])) + ((-body2.w_a[1] * (body2.I[3,1] * body2.w_a[1] + (body2.I[3,2] * body2.w_a[2] + body2.I[3,3] * body2.w_a[3]))) + (body2.r_CM[3] * body2.frame_a.f[1] + (-body2.r_CM[1] * body2.frame_a.f[3]))))));
//   body2.frame_a.t[3] = body2.I[3,1] * body2.z_a[1] + (body2.I[3,2] * body2.z_a[2] + (body2.I[3,3] * body2.z_a[3] + (body2.w_a[1] * (body2.I[2,1] * body2.w_a[1] + (body2.I[2,2] * body2.w_a[2] + body2.I[2,3] * body2.w_a[3])) + ((-body2.w_a[2] * (body2.I[1,1] * body2.w_a[1] + (body2.I[1,2] * body2.w_a[2] + body2.I[1,3] * body2.w_a[3]))) + (body2.r_CM[1] * body2.frame_a.f[2] + (-body2.r_CM[2] * body2.frame_a.f[1]))))));
//   jointRRR3.jointUSR.revolute.axis.tau = jointRRR3.jointUSR.revolute.tau;
//   jointRRR3.jointUSR.revolute.axis.phi = jointRRR3.jointUSR.revolute.phi;
//   jointRRR3.jointUSR.revolute.bearing.phi = 0.0;
//   jointRRR3.jointUSR.revolute.angle = Modelica.SIunits.Conversions.from_deg(jointRRR3.jointUSR.revolute.phi_offset) + jointRRR3.jointUSR.revolute.phi;
//   jointRRR3.jointUSR.revolute.frame_b.r_0[1] = jointRRR3.jointUSR.revolute.frame_a.r_0[1];
//   jointRRR3.jointUSR.revolute.frame_b.r_0[2] = jointRRR3.jointUSR.revolute.frame_a.r_0[2];
//   jointRRR3.jointUSR.revolute.frame_b.r_0[3] = jointRRR3.jointUSR.revolute.frame_a.r_0[3];
//   jointRRR3.jointUSR.revolute.R_rel = Modelica.Mechanics.MultiBody.Frames.planarRotation({jointRRR3.jointUSR.revolute.e[1],jointRRR3.jointUSR.revolute.e[2],jointRRR3.jointUSR.revolute.e[3]},jointRRR3.jointUSR.revolute.angle,der(jointRRR3.jointUSR.revolute.angle));
//   jointRRR3.jointUSR.revolute.frame_b.R = Modelica.Mechanics.MultiBody.Frames.absoluteRotation(jointRRR3.jointUSR.revolute.frame_a.R,jointRRR3.jointUSR.revolute.R_rel);
//   {0.0,0.0,0.0} = jointRRR3.jointUSR.revolute.frame_a.f + Modelica.Mechanics.MultiBody.Frames.resolve1(jointRRR3.jointUSR.revolute.R_rel,{jointRRR3.jointUSR.revolute.frame_b.f[1],jointRRR3.jointUSR.revolute.frame_b.f[2],jointRRR3.jointUSR.revolute.frame_b.f[3]});
//   {0.0,0.0,0.0} = jointRRR3.jointUSR.revolute.frame_a.t + Modelica.Mechanics.MultiBody.Frames.resolve1(jointRRR3.jointUSR.revolute.R_rel,{jointRRR3.jointUSR.revolute.frame_b.t[1],jointRRR3.jointUSR.revolute.frame_b.t[2],jointRRR3.jointUSR.revolute.frame_b.t[3]});
//   jointRRR3.jointUSR.revolute.e_r_a = jointRRR3.jointUSR.revolute.e[1] * jointRRR3.jointUSR.revolute.r_a[1] + (jointRRR3.jointUSR.revolute.e[2] * jointRRR3.jointUSR.revolute.r_a[2] + jointRRR3.jointUSR.revolute.e[3] * jointRRR3.jointUSR.revolute.r_a[3]);
//   jointRRR3.jointUSR.revolute.e_r_b = jointRRR3.jointUSR.revolute.e[1] * jointRRR3.jointUSR.revolute.r_b[1] + (jointRRR3.jointUSR.revolute.e[2] * jointRRR3.jointUSR.revolute.r_b[2] + jointRRR3.jointUSR.revolute.e[3] * jointRRR3.jointUSR.revolute.r_b[3]);
//   jointRRR3.jointUSR.revolute.A = -2.0 * (jointRRR3.jointUSR.revolute.r_b[1] * jointRRR3.jointUSR.revolute.r_a[1] + (jointRRR3.jointUSR.revolute.r_b[2] * jointRRR3.jointUSR.revolute.r_a[2] + jointRRR3.jointUSR.revolute.r_b[3] * jointRRR3.jointUSR.revolute.r_a[3]) - jointRRR3.jointUSR.revolute.e_r_b * jointRRR3.jointUSR.revolute.e_r_a);
//   jointRRR3.jointUSR.revolute.B = 2.0 * (jointRRR3.jointUSR.revolute.r_b[1] * (jointRRR3.jointUSR.revolute.e[2] * jointRRR3.jointUSR.revolute.r_a[3] - jointRRR3.jointUSR.revolute.e[3] * jointRRR3.jointUSR.revolute.r_a[2])) + (2.0 * (jointRRR3.jointUSR.revolute.r_b[2] * (jointRRR3.jointUSR.revolute.e[3] * jointRRR3.jointUSR.revolute.r_a[1] - jointRRR3.jointUSR.revolute.e[1] * jointRRR3.jointUSR.revolute.r_a[3])) + 2.0 * (jointRRR3.jointUSR.revolute.r_b[3] * (jointRRR3.jointUSR.revolute.e[1] * jointRRR3.jointUSR.revolute.r_a[2] - jointRRR3.jointUSR.revolute.e[2] * jointRRR3.jointUSR.revolute.r_a[1])));
//   jointRRR3.jointUSR.revolute.C = jointRRR3.jointUSR.revolute.r_a[1] ^ 2.0 + (jointRRR3.jointUSR.revolute.r_a[2] ^ 2.0 + (jointRRR3.jointUSR.revolute.r_a[3] ^ 2.0 + (jointRRR3.jointUSR.revolute.r_b[1] ^ 2.0 + (jointRRR3.jointUSR.revolute.r_b[2] ^ 2.0 + jointRRR3.jointUSR.revolute.r_b[3] ^ 2.0)))) - jointRRR3.jointUSR.revolute.lengthConstraint ^ 2.0 - 2.0 * (jointRRR3.jointUSR.revolute.e_r_b * jointRRR3.jointUSR.revolute.e_r_a);
//   jointRRR3.jointUSR.revolute.k1 = jointRRR3.jointUSR.revolute.A ^ 2.0 + jointRRR3.jointUSR.revolute.B ^ 2.0;
//   jointRRR3.jointUSR.revolute.k1a = jointRRR3.jointUSR.revolute.k1 - jointRRR3.jointUSR.revolute.C ^ 2.0;
//   assert(jointRRR3.jointUSR.revolute.k1a > 1e-10,\"
// Singular position of loop (either no or two analytic solutions;
// the mechanism has lost one-degree-of freedom in this position).
// Try first to use another Modelica.Mechanics.MultiBody.Joints.Assemblies.JointXXX component.
// In most cases it is best that the joints outside of the JointXXX
// component are revolute and NOT prismatic joints. If this also
// lead to singular positions, it could be that this kinematic loop
// cannot be solved analytically. In this case you have to build
// up the loop with basic joints (NO aggregation JointXXX components)
// and rely on dynamic state selection, i.e., during simulation
// the states will be dynamically selected in such a way that in no
// position a degree of freedom is lost.
// \");
//   jointRRR3.jointUSR.revolute.k1b = Modelica.Mechanics.MultiBody.Frames.Internal.maxWithoutEvent(jointRRR3.jointUSR.revolute.k1a,1e-12);
//   jointRRR3.jointUSR.revolute.k2 = sqrt(jointRRR3.jointUSR.revolute.k1b);
//   jointRRR3.jointUSR.revolute.kcos_angle = (-jointRRR3.jointUSR.revolute.A) * jointRRR3.jointUSR.revolute.C + (if jointRRR3.jointUSR.revolute.positiveBranch then jointRRR3.jointUSR.revolute.B else -jointRRR3.jointUSR.revolute.B) * jointRRR3.jointUSR.revolute.k2;
//   jointRRR3.jointUSR.revolute.ksin_angle = (-jointRRR3.jointUSR.revolute.B) * jointRRR3.jointUSR.revolute.C + (if jointRRR3.jointUSR.revolute.positiveBranch then -jointRRR3.jointUSR.revolute.A else jointRRR3.jointUSR.revolute.A) * jointRRR3.jointUSR.revolute.k2;
//   jointRRR3.jointUSR.revolute.angle = atan2(jointRRR3.jointUSR.revolute.ksin_angle,jointRRR3.jointUSR.revolute.kcos_angle);
//   assert(true,\"Connector frame_a of component is not connected\");
//   assert(true,\"Connector frame_b of component is not connected\");
//   jointRRR3.jointUSR.rod1.rRod_0[1] = jointRRR3.jointUSR.rod1.frame_b.r_0[1] - jointRRR3.jointUSR.rod1.frame_a.r_0[1];
//   jointRRR3.jointUSR.rod1.rRod_0[2] = jointRRR3.jointUSR.rod1.frame_b.r_0[2] - jointRRR3.jointUSR.rod1.frame_a.r_0[2];
//   jointRRR3.jointUSR.rod1.rRod_0[3] = jointRRR3.jointUSR.rod1.frame_b.r_0[3] - jointRRR3.jointUSR.rod1.frame_a.r_0[3];
//   jointRRR3.jointUSR.rod1.rRod_a = Modelica.Mechanics.MultiBody.Frames.resolve2(jointRRR3.jointUSR.rod1.frame_a.R,{jointRRR3.jointUSR.rod1.rRod_0[1],jointRRR3.jointUSR.rod1.rRod_0[2],jointRRR3.jointUSR.rod1.rRod_0[3]});
//   jointRRR3.jointUSR.rod1.constraintResidue = 0.0;
//   jointRRR3.jointUSR.rod1.eRod_a[1] = jointRRR3.jointUSR.rod1.rRod_a[1] / jointRRR3.jointUSR.rod1.rodLength;
//   jointRRR3.jointUSR.rod1.eRod_a[2] = jointRRR3.jointUSR.rod1.rRod_a[2] / jointRRR3.jointUSR.rod1.rodLength;
//   jointRRR3.jointUSR.rod1.eRod_a[3] = jointRRR3.jointUSR.rod1.rRod_a[3] / jointRRR3.jointUSR.rod1.rodLength;
//   jointRRR3.jointUSR.rod1.n2_a[1] = jointRRR3.jointUSR.rod1.n1_a[2] * jointRRR3.jointUSR.rod1.eRod_a[3] - jointRRR3.jointUSR.rod1.n1_a[3] * jointRRR3.jointUSR.rod1.eRod_a[2];
//   jointRRR3.jointUSR.rod1.n2_a[2] = jointRRR3.jointUSR.rod1.n1_a[3] * jointRRR3.jointUSR.rod1.eRod_a[1] - jointRRR3.jointUSR.rod1.n1_a[1] * jointRRR3.jointUSR.rod1.eRod_a[3];
//   jointRRR3.jointUSR.rod1.n2_a[3] = jointRRR3.jointUSR.rod1.n1_a[1] * jointRRR3.jointUSR.rod1.eRod_a[2] - jointRRR3.jointUSR.rod1.n1_a[2] * jointRRR3.jointUSR.rod1.eRod_a[1];
//   jointRRR3.jointUSR.rod1.length2_n2_a = jointRRR3.jointUSR.rod1.n2_a[1] ^ 2.0 + (jointRRR3.jointUSR.rod1.n2_a[2] ^ 2.0 + jointRRR3.jointUSR.rod1.n2_a[3] ^ 2.0);
//   assert(jointRRR3.jointUSR.rod1.length2_n2_a > 1e-10,\"
// A Modelica.Mechanics.MultiBody.Joints.UniversalSpherical joint (consisting of
// a universal joint and a spherical joint connected together
// by a rigid rod) is in the singular configuration of the
// universal joint. This means that axis 1 of the universal
// joint defined via parameter \\\"n1_a\\\" is parallel to vector
// \\\"rRod_ia\\\" that is directed from the origin of frame_a to the
// origin of frame_b.
//    You may try to use another \\\"n1_a\\\" vector. If this fails,
// use instead Modelica.Mechanics.MultiBody.Joints.SphericalSpherical, if this is
// possible, because this joint aggregation does not have a
// singular configuration.
// \");
//   jointRRR3.jointUSR.rod1.length_n2_a = sqrt(jointRRR3.jointUSR.rod1.length2_n2_a);
//   jointRRR3.jointUSR.rod1.e2_a[1] = jointRRR3.jointUSR.rod1.n2_a[1] / jointRRR3.jointUSR.rod1.length_n2_a;
//   jointRRR3.jointUSR.rod1.e2_a[2] = jointRRR3.jointUSR.rod1.n2_a[2] / jointRRR3.jointUSR.rod1.length_n2_a;
//   jointRRR3.jointUSR.rod1.e2_a[3] = jointRRR3.jointUSR.rod1.n2_a[3] / jointRRR3.jointUSR.rod1.length_n2_a;
//   jointRRR3.jointUSR.rod1.e3_a[1] = jointRRR3.jointUSR.rod1.eRod_a[2] * jointRRR3.jointUSR.rod1.e2_a[3] - jointRRR3.jointUSR.rod1.eRod_a[3] * jointRRR3.jointUSR.rod1.e2_a[2];
//   jointRRR3.jointUSR.rod1.e3_a[2] = jointRRR3.jointUSR.rod1.eRod_a[3] * jointRRR3.jointUSR.rod1.e2_a[1] - jointRRR3.jointUSR.rod1.eRod_a[1] * jointRRR3.jointUSR.rod1.e2_a[3];
//   jointRRR3.jointUSR.rod1.e3_a[3] = jointRRR3.jointUSR.rod1.eRod_a[1] * jointRRR3.jointUSR.rod1.e2_a[2] - jointRRR3.jointUSR.rod1.eRod_a[2] * jointRRR3.jointUSR.rod1.e2_a[1];
//   jointRRR3.jointUSR.rod1.der_rRod_a_L = (Modelica.Mechanics.MultiBody.Frames.resolve2(jointRRR3.jointUSR.rod1.frame_a.R,{der(jointRRR3.jointUSR.rod1.rRod_0[1]),der(jointRRR3.jointUSR.rod1.rRod_0[2]),der(jointRRR3.jointUSR.rod1.rRod_0[3])}) - {jointRRR3.jointUSR.rod1.frame_a.R.w[2] * jointRRR3.jointUSR.rod1.rRod_a[3] - jointRRR3.jointUSR.rod1.frame_a.R.w[3] * jointRRR3.jointUSR.rod1.rRod_a[2],jointRRR3.jointUSR.rod1.frame_a.R.w[3] * jointRRR3.jointUSR.rod1.rRod_a[1] - jointRRR3.jointUSR.rod1.frame_a.R.w[1] * jointRRR3.jointUSR.rod1.rRod_a[3],jointRRR3.jointUSR.rod1.frame_a.R.w[1] * jointRRR3.jointUSR.rod1.rRod_a[2] - jointRRR3.jointUSR.rod1.frame_a.R.w[2] * jointRRR3.jointUSR.rod1.rRod_a[1]}) / jointRRR3.jointUSR.rod1.rodLength;
//   jointRRR3.jointUSR.rod1.w_rel_ia1[1] = (jointRRR3.jointUSR.rod1.e3_a[1] * (jointRRR3.jointUSR.rod1.n1_a[2] * jointRRR3.jointUSR.rod1.der_rRod_a_L[3] - jointRRR3.jointUSR.rod1.n1_a[3] * jointRRR3.jointUSR.rod1.der_rRod_a_L[2]) + (jointRRR3.jointUSR.rod1.e3_a[2] * (jointRRR3.jointUSR.rod1.n1_a[3] * jointRRR3.jointUSR.rod1.der_rRod_a_L[1] - jointRRR3.jointUSR.rod1.n1_a[1] * jointRRR3.jointUSR.rod1.der_rRod_a_L[3]) + jointRRR3.jointUSR.rod1.e3_a[3] * (jointRRR3.jointUSR.rod1.n1_a[1] * jointRRR3.jointUSR.rod1.der_rRod_a_L[2] - jointRRR3.jointUSR.rod1.n1_a[2] * jointRRR3.jointUSR.rod1.der_rRod_a_L[1]))) / jointRRR3.jointUSR.rod1.length_n2_a;
//   jointRRR3.jointUSR.rod1.w_rel_ia1[2] = (-jointRRR3.jointUSR.rod1.e3_a[1]) * jointRRR3.jointUSR.rod1.der_rRod_a_L[1] + ((-jointRRR3.jointUSR.rod1.e3_a[2]) * jointRRR3.jointUSR.rod1.der_rRod_a_L[2] + (-jointRRR3.jointUSR.rod1.e3_a[3]) * jointRRR3.jointUSR.rod1.der_rRod_a_L[3]);
//   jointRRR3.jointUSR.rod1.w_rel_ia1[3] = jointRRR3.jointUSR.rod1.e2_a[1] * jointRRR3.jointUSR.rod1.der_rRod_a_L[1] + (jointRRR3.jointUSR.rod1.e2_a[2] * jointRRR3.jointUSR.rod1.der_rRod_a_L[2] + jointRRR3.jointUSR.rod1.e2_a[3] * jointRRR3.jointUSR.rod1.der_rRod_a_L[3]);
//   jointRRR3.jointUSR.rod1.R_rel_ia1 = Modelica.Mechanics.MultiBody.Frames.from_T({{jointRRR3.jointUSR.rod1.eRod_a[1],jointRRR3.jointUSR.rod1.eRod_a[2],jointRRR3.jointUSR.rod1.eRod_a[3]},{jointRRR3.jointUSR.rod1.e2_a[1],jointRRR3.jointUSR.rod1.e2_a[2],jointRRR3.jointUSR.rod1.e2_a[3]},{jointRRR3.jointUSR.rod1.e3_a[1],jointRRR3.jointUSR.rod1.e3_a[2],jointRRR3.jointUSR.rod1.e3_a[3]}},{jointRRR3.jointUSR.rod1.w_rel_ia1[1],jointRRR3.jointUSR.rod1.w_rel_ia1[2],jointRRR3.jointUSR.rod1.w_rel_ia1[3]});
//   jointRRR3.jointUSR.rod1.R_rel_ia2 = Modelica.Mechanics.MultiBody.Frames.from_T({{jointRRR3.jointUSR.rod1.eRod_ia[1],jointRRR3.jointUSR.rod1.e2_ia[1],jointRRR3.jointUSR.rod1.e3_ia[1]},{jointRRR3.jointUSR.rod1.eRod_ia[2],jointRRR3.jointUSR.rod1.e2_ia[2],jointRRR3.jointUSR.rod1.e3_ia[2]},{jointRRR3.jointUSR.rod1.eRod_ia[3],jointRRR3.jointUSR.rod1.e2_ia[3],jointRRR3.jointUSR.rod1.e3_ia[3]}},{0.0,0.0,0.0});
//   jointRRR3.jointUSR.rod1.R_rel_ia = Modelica.Mechanics.MultiBody.Frames.absoluteRotation(jointRRR3.jointUSR.rod1.R_rel_ia1,jointRRR3.jointUSR.rod1.R_rel_ia2);
//   jointRRR3.jointUSR.rod1.frame_ia.r_0[1] = jointRRR3.jointUSR.rod1.frame_a.r_0[1];
//   jointRRR3.jointUSR.rod1.frame_ia.r_0[2] = jointRRR3.jointUSR.rod1.frame_a.r_0[2];
//   jointRRR3.jointUSR.rod1.frame_ia.r_0[3] = jointRRR3.jointUSR.rod1.frame_a.r_0[3];
//   jointRRR3.jointUSR.rod1.frame_ia.R = Modelica.Mechanics.MultiBody.Frames.absoluteRotation(jointRRR3.jointUSR.rod1.frame_a.R,jointRRR3.jointUSR.rod1.R_rel_ia);
//   jointRRR3.jointUSR.rod1.f_ia_a = Modelica.Mechanics.MultiBody.Frames.resolve1(jointRRR3.jointUSR.rod1.R_rel_ia,{jointRRR3.jointUSR.rod1.frame_ia.f[1],jointRRR3.jointUSR.rod1.frame_ia.f[2],jointRRR3.jointUSR.rod1.frame_ia.f[3]});
//   jointRRR3.jointUSR.rod1.t_ia_a = Modelica.Mechanics.MultiBody.Frames.resolve1(jointRRR3.jointUSR.rod1.R_rel_ia,{jointRRR3.jointUSR.rod1.frame_ia.t[1],jointRRR3.jointUSR.rod1.frame_ia.t[2],jointRRR3.jointUSR.rod1.frame_ia.t[3]});
//   jointRRR3.jointUSR.rod1.f_b_a1[1] = ((-jointRRR3.jointUSR.rod1.n1_a[1]) * jointRRR3.jointUSR.rod1.t_ia_a[1] + ((-jointRRR3.jointUSR.rod1.n1_a[2]) * jointRRR3.jointUSR.rod1.t_ia_a[2] + (-jointRRR3.jointUSR.rod1.n1_a[3]) * jointRRR3.jointUSR.rod1.t_ia_a[3])) * (jointRRR3.jointUSR.rod1.e2_a[1] * 1.0 / (jointRRR3.jointUSR.rod1.n1_a[1] * jointRRR3.jointUSR.rod1.e3_a[1] + (jointRRR3.jointUSR.rod1.n1_a[2] * jointRRR3.jointUSR.rod1.e3_a[2] + jointRRR3.jointUSR.rod1.n1_a[3] * jointRRR3.jointUSR.rod1.e3_a[3])) / jointRRR3.jointUSR.rod1.rodLength) + (jointRRR3.jointUSR.rod1.e2_a[1] * jointRRR3.jointUSR.rod1.t_ia_a[1] + (jointRRR3.jointUSR.rod1.e2_a[2] * jointRRR3.jointUSR.rod1.t_ia_a[2] + jointRRR3.jointUSR.rod1.e2_a[3] * jointRRR3.jointUSR.rod1.t_ia_a[3])) * jointRRR3.jointUSR.rod1.e3_a[1] / jointRRR3.jointUSR.rod1.rodLength;
//   jointRRR3.jointUSR.rod1.f_b_a1[2] = ((-jointRRR3.jointUSR.rod1.n1_a[1]) * jointRRR3.jointUSR.rod1.t_ia_a[1] + ((-jointRRR3.jointUSR.rod1.n1_a[2]) * jointRRR3.jointUSR.rod1.t_ia_a[2] + (-jointRRR3.jointUSR.rod1.n1_a[3]) * jointRRR3.jointUSR.rod1.t_ia_a[3])) * (jointRRR3.jointUSR.rod1.e2_a[2] * 1.0 / (jointRRR3.jointUSR.rod1.n1_a[1] * jointRRR3.jointUSR.rod1.e3_a[1] + (jointRRR3.jointUSR.rod1.n1_a[2] * jointRRR3.jointUSR.rod1.e3_a[2] + jointRRR3.jointUSR.rod1.n1_a[3] * jointRRR3.jointUSR.rod1.e3_a[3])) / jointRRR3.jointUSR.rod1.rodLength) + (jointRRR3.jointUSR.rod1.e2_a[1] * jointRRR3.jointUSR.rod1.t_ia_a[1] + (jointRRR3.jointUSR.rod1.e2_a[2] * jointRRR3.jointUSR.rod1.t_ia_a[2] + jointRRR3.jointUSR.rod1.e2_a[3] * jointRRR3.jointUSR.rod1.t_ia_a[3])) * jointRRR3.jointUSR.rod1.e3_a[2] / jointRRR3.jointUSR.rod1.rodLength;
//   jointRRR3.jointUSR.rod1.f_b_a1[3] = ((-jointRRR3.jointUSR.rod1.n1_a[1]) * jointRRR3.jointUSR.rod1.t_ia_a[1] + ((-jointRRR3.jointUSR.rod1.n1_a[2]) * jointRRR3.jointUSR.rod1.t_ia_a[2] + (-jointRRR3.jointUSR.rod1.n1_a[3]) * jointRRR3.jointUSR.rod1.t_ia_a[3])) * (jointRRR3.jointUSR.rod1.e2_a[3] * 1.0 / (jointRRR3.jointUSR.rod1.n1_a[1] * jointRRR3.jointUSR.rod1.e3_a[1] + (jointRRR3.jointUSR.rod1.n1_a[2] * jointRRR3.jointUSR.rod1.e3_a[2] + jointRRR3.jointUSR.rod1.n1_a[3] * jointRRR3.jointUSR.rod1.e3_a[3])) / jointRRR3.jointUSR.rod1.rodLength) + (jointRRR3.jointUSR.rod1.e2_a[1] * jointRRR3.jointUSR.rod1.t_ia_a[1] + (jointRRR3.jointUSR.rod1.e2_a[2] * jointRRR3.jointUSR.rod1.t_ia_a[2] + jointRRR3.jointUSR.rod1.e2_a[3] * jointRRR3.jointUSR.rod1.t_ia_a[3])) * jointRRR3.jointUSR.rod1.e3_a[3] / jointRRR3.jointUSR.rod1.rodLength;
//   jointRRR3.jointUSR.rod1.f_b_a[1] = (-jointRRR3.jointUSR.rod1.f_rod) * jointRRR3.jointUSR.rod1.eRod_a[1] + jointRRR3.jointUSR.rod1.f_b_a1[1];
//   jointRRR3.jointUSR.rod1.f_b_a[2] = (-jointRRR3.jointUSR.rod1.f_rod) * jointRRR3.jointUSR.rod1.eRod_a[2] + jointRRR3.jointUSR.rod1.f_b_a1[2];
//   jointRRR3.jointUSR.rod1.f_b_a[3] = (-jointRRR3.jointUSR.rod1.f_rod) * jointRRR3.jointUSR.rod1.eRod_a[3] + jointRRR3.jointUSR.rod1.f_b_a1[3];
//   jointRRR3.jointUSR.rod1.frame_b.f = Modelica.Mechanics.MultiBody.Frames.resolveRelative({jointRRR3.jointUSR.rod1.f_b_a[1],jointRRR3.jointUSR.rod1.f_b_a[2],jointRRR3.jointUSR.rod1.f_b_a[3]},jointRRR3.jointUSR.rod1.frame_a.R,jointRRR3.jointUSR.rod1.frame_b.R);
//   jointRRR3.jointUSR.rod1.frame_b.t[1] = 0.0;
//   jointRRR3.jointUSR.rod1.frame_b.t[2] = 0.0;
//   jointRRR3.jointUSR.rod1.frame_b.t[3] = 0.0;
//   0.0 = jointRRR3.jointUSR.rod1.frame_a.f[1] + (jointRRR3.jointUSR.rod1.f_b_a[1] + jointRRR3.jointUSR.rod1.f_ia_a[1]);
//   0.0 = jointRRR3.jointUSR.rod1.frame_a.f[2] + (jointRRR3.jointUSR.rod1.f_b_a[2] + jointRRR3.jointUSR.rod1.f_ia_a[2]);
//   0.0 = jointRRR3.jointUSR.rod1.frame_a.f[3] + (jointRRR3.jointUSR.rod1.f_b_a[3] + jointRRR3.jointUSR.rod1.f_ia_a[3]);
//   0.0 = jointRRR3.jointUSR.rod1.frame_a.t[1] + (jointRRR3.jointUSR.rod1.t_ia_a[1] + (jointRRR3.jointUSR.rod1.rRod_a[2] * jointRRR3.jointUSR.rod1.f_b_a[3] + (-jointRRR3.jointUSR.rod1.rRod_a[3] * jointRRR3.jointUSR.rod1.f_b_a[2])));
//   0.0 = jointRRR3.jointUSR.rod1.frame_a.t[2] + (jointRRR3.jointUSR.rod1.t_ia_a[2] + (jointRRR3.jointUSR.rod1.rRod_a[3] * jointRRR3.jointUSR.rod1.f_b_a[1] + (-jointRRR3.jointUSR.rod1.rRod_a[1] * jointRRR3.jointUSR.rod1.f_b_a[3])));
//   0.0 = jointRRR3.jointUSR.rod1.frame_a.t[3] + (jointRRR3.jointUSR.rod1.t_ia_a[3] + (jointRRR3.jointUSR.rod1.rRod_a[1] * jointRRR3.jointUSR.rod1.f_b_a[2] + (-jointRRR3.jointUSR.rod1.rRod_a[2] * jointRRR3.jointUSR.rod1.f_b_a[1])));
//   jointRRR3.jointUSR.rod1.totalPower = 0.0;
//   assert(true,\"Connector frame_a of component is not connected\");
//   assert(true,\"Connector frame_b of component is not connected\");
//   assert(true,\"Neither connector frame_a nor frame_b of FixedTranslation object is connected\");
//   jointRRR3.jointUSR.rod2.frame_b.r_0 = jointRRR3.jointUSR.rod2.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(jointRRR3.jointUSR.rod2.frame_a.R,{jointRRR3.jointUSR.rod2.r[1],jointRRR3.jointUSR.rod2.r[2],jointRRR3.jointUSR.rod2.r[3]});
//   jointRRR3.jointUSR.rod2.frame_b.R.T[1,1] = jointRRR3.jointUSR.rod2.frame_a.R.T[1,1];
//   jointRRR3.jointUSR.rod2.frame_b.R.T[1,2] = jointRRR3.jointUSR.rod2.frame_a.R.T[1,2];
//   jointRRR3.jointUSR.rod2.frame_b.R.T[1,3] = jointRRR3.jointUSR.rod2.frame_a.R.T[1,3];
//   jointRRR3.jointUSR.rod2.frame_b.R.T[2,1] = jointRRR3.jointUSR.rod2.frame_a.R.T[2,1];
//   jointRRR3.jointUSR.rod2.frame_b.R.T[2,2] = jointRRR3.jointUSR.rod2.frame_a.R.T[2,2];
//   jointRRR3.jointUSR.rod2.frame_b.R.T[2,3] = jointRRR3.jointUSR.rod2.frame_a.R.T[2,3];
//   jointRRR3.jointUSR.rod2.frame_b.R.T[3,1] = jointRRR3.jointUSR.rod2.frame_a.R.T[3,1];
//   jointRRR3.jointUSR.rod2.frame_b.R.T[3,2] = jointRRR3.jointUSR.rod2.frame_a.R.T[3,2];
//   jointRRR3.jointUSR.rod2.frame_b.R.T[3,3] = jointRRR3.jointUSR.rod2.frame_a.R.T[3,3];
//   jointRRR3.jointUSR.rod2.frame_b.R.w[1] = jointRRR3.jointUSR.rod2.frame_a.R.w[1];
//   jointRRR3.jointUSR.rod2.frame_b.R.w[2] = jointRRR3.jointUSR.rod2.frame_a.R.w[2];
//   jointRRR3.jointUSR.rod2.frame_b.R.w[3] = jointRRR3.jointUSR.rod2.frame_a.R.w[3];
//   0.0 = jointRRR3.jointUSR.rod2.frame_a.f[1] + jointRRR3.jointUSR.rod2.frame_b.f[1];
//   0.0 = jointRRR3.jointUSR.rod2.frame_a.f[2] + jointRRR3.jointUSR.rod2.frame_b.f[2];
//   0.0 = jointRRR3.jointUSR.rod2.frame_a.f[3] + jointRRR3.jointUSR.rod2.frame_b.f[3];
//   0.0 = jointRRR3.jointUSR.rod2.frame_a.t[1] + (jointRRR3.jointUSR.rod2.frame_b.t[1] + (jointRRR3.jointUSR.rod2.r[2] * jointRRR3.jointUSR.rod2.frame_b.f[3] + (-jointRRR3.jointUSR.rod2.r[3] * jointRRR3.jointUSR.rod2.frame_b.f[2])));
//   0.0 = jointRRR3.jointUSR.rod2.frame_a.t[2] + (jointRRR3.jointUSR.rod2.frame_b.t[2] + (jointRRR3.jointUSR.rod2.r[3] * jointRRR3.jointUSR.rod2.frame_b.f[1] + (-jointRRR3.jointUSR.rod2.r[1] * jointRRR3.jointUSR.rod2.frame_b.f[3])));
//   0.0 = jointRRR3.jointUSR.rod2.frame_a.t[3] + (jointRRR3.jointUSR.rod2.frame_b.t[3] + (jointRRR3.jointUSR.rod2.r[1] * jointRRR3.jointUSR.rod2.frame_b.f[2] + (-jointRRR3.jointUSR.rod2.r[2] * jointRRR3.jointUSR.rod2.frame_b.f[1])));
//   jointRRR3.jointUSR.relativePosition.relativePosition.r_rel = Modelica.Mechanics.MultiBody.Frames.resolve2(jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.R,{jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.r_0[1] - jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.r_0[1],jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.r_0[2] - jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.r_0[2],jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.r_0[3] - jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.r_0[3]});
//   assert(true,\"Connector frame_a must be connected at least once\");
//   assert(true,\"Connector frame_b must be connected at least once\");
//   assert(true,\"Connector frame_resolve must be connected exactly once\");
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.f[1] = 0.0;
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.f[2] = 0.0;
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.f[3] = 0.0;
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.t[1] = 0.0;
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.t[2] = 0.0;
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.t[3] = 0.0;
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.f[1] = 0.0;
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.f[2] = 0.0;
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.f[3] = 0.0;
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.t[1] = 0.0;
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.t[2] = 0.0;
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.t[3] = 0.0;
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.f[1] = 0.0;
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.f[2] = 0.0;
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.f[3] = 0.0;
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.t[1] = 0.0;
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.t[2] = 0.0;
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.t[3] = 0.0;
//   jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.w[3] = 0.0;
//   jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.w[2] = 0.0;
//   jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.w[1] = 0.0;
//   jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[3,3] = 1.0;
//   jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[3,2] = 0.0;
//   jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[3,1] = 0.0;
//   jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[2,3] = 0.0;
//   jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[2,2] = 1.0;
//   jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[2,1] = 0.0;
//   jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[1,3] = 0.0;
//   jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[1,2] = 0.0;
//   jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[1,1] = 1.0;
//   jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.r_0[1] = 0.0;
//   jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.r_0[2] = 0.0;
//   jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.r_0[3] = 0.0;
//   assert(true,\"Connector frame_a must be connected at least once\");
//   assert(true,\"Connector frame_b must be connected at least once\");
//   jointRRR3.jointUSR.position_b[1].y = jointRRR3.jointUSR.position_b[1].k;
//   jointRRR3.jointUSR.position_b[2].y = jointRRR3.jointUSR.position_b[2].k;
//   jointRRR3.jointUSR.position_b[3].y = jointRRR3.jointUSR.position_b[3].k;
//   jointRRR3.jointUSR.aux = {jointRRR3.jointUSR.revolute.e[2] * jointRRR3.jointUSR.rRod2_ib[3] - jointRRR3.jointUSR.revolute.e[3] * jointRRR3.jointUSR.rRod2_ib[2],jointRRR3.jointUSR.revolute.e[3] * jointRRR3.jointUSR.rRod2_ib[1] - jointRRR3.jointUSR.revolute.e[1] * jointRRR3.jointUSR.rRod2_ib[3],jointRRR3.jointUSR.revolute.e[1] * jointRRR3.jointUSR.rRod2_ib[2] - jointRRR3.jointUSR.revolute.e[2] * jointRRR3.jointUSR.rRod2_ib[1]} * Modelica.Mechanics.MultiBody.Frames.resolveRelative({jointRRR3.jointUSR.rod1.eRod_a[1],jointRRR3.jointUSR.rod1.eRod_a[2],jointRRR3.jointUSR.rod1.eRod_a[3]},jointRRR3.jointUSR.rod1.frame_a.R,jointRRR3.jointUSR.rod1.frame_b.R);
//   jointRRR3.jointUSR.f_rod = ((-jointRRR3.jointUSR.revolute.tau) - {jointRRR3.jointUSR.revolute.e[1],jointRRR3.jointUSR.revolute.e[2],jointRRR3.jointUSR.revolute.e[3]} * ({jointRRR3.jointUSR.frame_ib.t[1] + jointRRR3.jointUSR.frame_im.t[1] + (jointRRR3.jointUSR.rRod2_ib[2] * jointRRR3.jointUSR.frame_im.f[3] - jointRRR3.jointUSR.rRod2_ib[3] * jointRRR3.jointUSR.frame_im.f[2]),jointRRR3.jointUSR.frame_ib.t[2] + jointRRR3.jointUSR.frame_im.t[2] + (jointRRR3.jointUSR.rRod2_ib[3] * jointRRR3.jointUSR.frame_im.f[1] - jointRRR3.jointUSR.rRod2_ib[1] * jointRRR3.jointUSR.frame_im.f[3]),jointRRR3.jointUSR.frame_ib.t[3] + jointRRR3.jointUSR.frame_im.t[3] + (jointRRR3.jointUSR.rRod2_ib[1] * jointRRR3.jointUSR.frame_im.f[2] - jointRRR3.jointUSR.rRod2_ib[2] * jointRRR3.jointUSR.frame_im.f[1])} - cross({jointRRR3.jointUSR.rRod2_ib[1],jointRRR3.jointUSR.rRod2_ib[2],jointRRR3.jointUSR.rRod2_ib[3]},Modelica.Mechanics.MultiBody.Frames.resolveRelative({jointRRR3.jointUSR.rod1.f_b_a1[1],jointRRR3.jointUSR.rod1.f_b_a1[2],jointRRR3.jointUSR.rod1.f_b_a1[3]},jointRRR3.jointUSR.rod1.frame_a.R,jointRRR3.jointUSR.rod1.frame_b.R)))) / (if noEvent(abs(jointRRR3.jointUSR.aux) < 1e-10) then 1e-10 else jointRRR3.jointUSR.aux);
//   jointRRR3.jointUSR.totalPower = {jointRRR3.jointUSR.frame_a.f[1],jointRRR3.jointUSR.frame_a.f[2],jointRRR3.jointUSR.frame_a.f[3]} * Modelica.Mechanics.MultiBody.Frames.resolve2(jointRRR3.jointUSR.frame_a.R,{der(jointRRR3.jointUSR.frame_a.r_0[1]),der(jointRRR3.jointUSR.frame_a.r_0[2]),der(jointRRR3.jointUSR.frame_a.r_0[3])}) + ({jointRRR3.jointUSR.frame_b.f[1],jointRRR3.jointUSR.frame_b.f[2],jointRRR3.jointUSR.frame_b.f[3]} * Modelica.Mechanics.MultiBody.Frames.resolve2(jointRRR3.jointUSR.frame_b.R,{der(jointRRR3.jointUSR.frame_b.r_0[1]),der(jointRRR3.jointUSR.frame_b.r_0[2]),der(jointRRR3.jointUSR.frame_b.r_0[3])}) + ({jointRRR3.jointUSR.frame_ia.f[1],jointRRR3.jointUSR.frame_ia.f[2],jointRRR3.jointUSR.frame_ia.f[3]} * Modelica.Mechanics.MultiBody.Frames.resolve2(jointRRR3.jointUSR.frame_ia.R,{der(jointRRR3.jointUSR.frame_ia.r_0[1]),der(jointRRR3.jointUSR.frame_ia.r_0[2]),der(jointRRR3.jointUSR.frame_ia.r_0[3])}) + ({jointRRR3.jointUSR.frame_ib.f[1],jointRRR3.jointUSR.frame_ib.f[2],jointRRR3.jointUSR.frame_ib.f[3]} * Modelica.Mechanics.MultiBody.Frames.resolve2(jointRRR3.jointUSR.frame_ib.R,{der(jointRRR3.jointUSR.frame_ib.r_0[1]),der(jointRRR3.jointUSR.frame_ib.r_0[2]),der(jointRRR3.jointUSR.frame_ib.r_0[3])}) + ({jointRRR3.jointUSR.frame_im.f[1],jointRRR3.jointUSR.frame_im.f[2],jointRRR3.jointUSR.frame_im.f[3]} * Modelica.Mechanics.MultiBody.Frames.resolve2(jointRRR3.jointUSR.frame_im.R,{der(jointRRR3.jointUSR.frame_im.r_0[1]),der(jointRRR3.jointUSR.frame_im.r_0[2]),der(jointRRR3.jointUSR.frame_im.r_0[3])}) + ({jointRRR3.jointUSR.frame_a.t[1],jointRRR3.jointUSR.frame_a.t[2],jointRRR3.jointUSR.frame_a.t[3]} * Modelica.Mechanics.MultiBody.Frames.angularVelocity2(jointRRR3.jointUSR.frame_a.R) + ({jointRRR3.jointUSR.frame_b.t[1],jointRRR3.jointUSR.frame_b.t[2],jointRRR3.jointUSR.frame_b.t[3]} * Modelica.Mechanics.MultiBody.Frames.angularVelocity2(jointRRR3.jointUSR.frame_b.R) + ({jointRRR3.jointUSR.frame_ia.t[1],jointRRR3.jointUSR.frame_ia.t[2],jointRRR3.jointUSR.frame_ia.t[3]} * Modelica.Mechanics.MultiBody.Frames.angularVelocity2(jointRRR3.jointUSR.frame_ia.R) + ({jointRRR3.jointUSR.frame_ib.t[1],jointRRR3.jointUSR.frame_ib.t[2],jointRRR3.jointUSR.frame_ib.t[3]} * Modelica.Mechanics.MultiBody.Frames.angularVelocity2(jointRRR3.jointUSR.frame_ib.R) + ({jointRRR3.jointUSR.frame_im.t[1],jointRRR3.jointUSR.frame_im.t[2],jointRRR3.jointUSR.frame_im.t[3]} * Modelica.Mechanics.MultiBody.Frames.angularVelocity2(jointRRR3.jointUSR.frame_im.R) + (jointRRR3.jointUSR.axis.tau * der(jointRRR3.jointUSR.axis.phi) + jointRRR3.jointUSR.bearing.tau * der(jointRRR3.jointUSR.bearing.phi)))))))))));
//   assert(true,\"Connector frame_a of component is not connected\");
//   assert(true,\"Connector frame_b of component is not connected\");
//   jointRRR3.shape_rev1.R.T[1,1] = jointRRR3.frame_a.R.T[1,1];
//   jointRRR3.shape_rev1.R.T[1,2] = jointRRR3.frame_a.R.T[1,2];
//   jointRRR3.shape_rev1.R.T[1,3] = jointRRR3.frame_a.R.T[1,3];
//   jointRRR3.shape_rev1.R.T[2,1] = jointRRR3.frame_a.R.T[2,1];
//   jointRRR3.shape_rev1.R.T[2,2] = jointRRR3.frame_a.R.T[2,2];
//   jointRRR3.shape_rev1.R.T[2,3] = jointRRR3.frame_a.R.T[2,3];
//   jointRRR3.shape_rev1.R.T[3,1] = jointRRR3.frame_a.R.T[3,1];
//   jointRRR3.shape_rev1.R.T[3,2] = jointRRR3.frame_a.R.T[3,2];
//   jointRRR3.shape_rev1.R.T[3,3] = jointRRR3.frame_a.R.T[3,3];
//   jointRRR3.shape_rev1.R.w[1] = jointRRR3.frame_a.R.w[1];
//   jointRRR3.shape_rev1.R.w[2] = jointRRR3.frame_a.R.w[2];
//   jointRRR3.shape_rev1.R.w[3] = jointRRR3.frame_a.R.w[3];
//   jointRRR3.shape_rev1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(jointRRR3.shape_rev1.shapeType);
//   jointRRR3.shape_rev1.rxvisobj[1] = jointRRR3.shape_rev1.R.T[1,1] * jointRRR3.shape_rev1.e_x[1] + (jointRRR3.shape_rev1.R.T[2,1] * jointRRR3.shape_rev1.e_x[2] + jointRRR3.shape_rev1.R.T[3,1] * jointRRR3.shape_rev1.e_x[3]);
//   jointRRR3.shape_rev1.rxvisobj[2] = jointRRR3.shape_rev1.R.T[1,2] * jointRRR3.shape_rev1.e_x[1] + (jointRRR3.shape_rev1.R.T[2,2] * jointRRR3.shape_rev1.e_x[2] + jointRRR3.shape_rev1.R.T[3,2] * jointRRR3.shape_rev1.e_x[3]);
//   jointRRR3.shape_rev1.rxvisobj[3] = jointRRR3.shape_rev1.R.T[1,3] * jointRRR3.shape_rev1.e_x[1] + (jointRRR3.shape_rev1.R.T[2,3] * jointRRR3.shape_rev1.e_x[2] + jointRRR3.shape_rev1.R.T[3,3] * jointRRR3.shape_rev1.e_x[3]);
//   jointRRR3.shape_rev1.ryvisobj[1] = jointRRR3.shape_rev1.R.T[1,1] * jointRRR3.shape_rev1.e_y[1] + (jointRRR3.shape_rev1.R.T[2,1] * jointRRR3.shape_rev1.e_y[2] + jointRRR3.shape_rev1.R.T[3,1] * jointRRR3.shape_rev1.e_y[3]);
//   jointRRR3.shape_rev1.ryvisobj[2] = jointRRR3.shape_rev1.R.T[1,2] * jointRRR3.shape_rev1.e_y[1] + (jointRRR3.shape_rev1.R.T[2,2] * jointRRR3.shape_rev1.e_y[2] + jointRRR3.shape_rev1.R.T[3,2] * jointRRR3.shape_rev1.e_y[3]);
//   jointRRR3.shape_rev1.ryvisobj[3] = jointRRR3.shape_rev1.R.T[1,3] * jointRRR3.shape_rev1.e_y[1] + (jointRRR3.shape_rev1.R.T[2,3] * jointRRR3.shape_rev1.e_y[2] + jointRRR3.shape_rev1.R.T[3,3] * jointRRR3.shape_rev1.e_y[3]);
//   jointRRR3.shape_rev1.rvisobj = jointRRR3.shape_rev1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{jointRRR3.shape_rev1.R.T[1,1],jointRRR3.shape_rev1.R.T[1,2],jointRRR3.shape_rev1.R.T[1,3]},{jointRRR3.shape_rev1.R.T[2,1],jointRRR3.shape_rev1.R.T[2,2],jointRRR3.shape_rev1.R.T[2,3]},{jointRRR3.shape_rev1.R.T[3,1],jointRRR3.shape_rev1.R.T[3,2],jointRRR3.shape_rev1.R.T[3,3]}},{jointRRR3.shape_rev1.r_shape[1],jointRRR3.shape_rev1.r_shape[2],jointRRR3.shape_rev1.r_shape[3]});
//   jointRRR3.shape_rev1.size[1] = jointRRR3.shape_rev1.length;
//   jointRRR3.shape_rev1.size[2] = jointRRR3.shape_rev1.width;
//   jointRRR3.shape_rev1.size[3] = jointRRR3.shape_rev1.height;
//   jointRRR3.shape_rev1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(jointRRR3.shape_rev1.color[1] / 255.0,jointRRR3.shape_rev1.color[2] / 255.0,jointRRR3.shape_rev1.color[3] / 255.0,jointRRR3.shape_rev1.specularCoefficient);
//   jointRRR3.shape_rev1.Extra = jointRRR3.shape_rev1.extra;
//   jointRRR3.shape_rev2.R.T[1,1] = jointRRR3.frame_im.R.T[1,1];
//   jointRRR3.shape_rev2.R.T[1,2] = jointRRR3.frame_im.R.T[1,2];
//   jointRRR3.shape_rev2.R.T[1,3] = jointRRR3.frame_im.R.T[1,3];
//   jointRRR3.shape_rev2.R.T[2,1] = jointRRR3.frame_im.R.T[2,1];
//   jointRRR3.shape_rev2.R.T[2,2] = jointRRR3.frame_im.R.T[2,2];
//   jointRRR3.shape_rev2.R.T[2,3] = jointRRR3.frame_im.R.T[2,3];
//   jointRRR3.shape_rev2.R.T[3,1] = jointRRR3.frame_im.R.T[3,1];
//   jointRRR3.shape_rev2.R.T[3,2] = jointRRR3.frame_im.R.T[3,2];
//   jointRRR3.shape_rev2.R.T[3,3] = jointRRR3.frame_im.R.T[3,3];
//   jointRRR3.shape_rev2.R.w[1] = jointRRR3.frame_im.R.w[1];
//   jointRRR3.shape_rev2.R.w[2] = jointRRR3.frame_im.R.w[2];
//   jointRRR3.shape_rev2.R.w[3] = jointRRR3.frame_im.R.w[3];
//   jointRRR3.shape_rev2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(jointRRR3.shape_rev2.shapeType);
//   jointRRR3.shape_rev2.rxvisobj[1] = jointRRR3.shape_rev2.R.T[1,1] * jointRRR3.shape_rev2.e_x[1] + (jointRRR3.shape_rev2.R.T[2,1] * jointRRR3.shape_rev2.e_x[2] + jointRRR3.shape_rev2.R.T[3,1] * jointRRR3.shape_rev2.e_x[3]);
//   jointRRR3.shape_rev2.rxvisobj[2] = jointRRR3.shape_rev2.R.T[1,2] * jointRRR3.shape_rev2.e_x[1] + (jointRRR3.shape_rev2.R.T[2,2] * jointRRR3.shape_rev2.e_x[2] + jointRRR3.shape_rev2.R.T[3,2] * jointRRR3.shape_rev2.e_x[3]);
//   jointRRR3.shape_rev2.rxvisobj[3] = jointRRR3.shape_rev2.R.T[1,3] * jointRRR3.shape_rev2.e_x[1] + (jointRRR3.shape_rev2.R.T[2,3] * jointRRR3.shape_rev2.e_x[2] + jointRRR3.shape_rev2.R.T[3,3] * jointRRR3.shape_rev2.e_x[3]);
//   jointRRR3.shape_rev2.ryvisobj[1] = jointRRR3.shape_rev2.R.T[1,1] * jointRRR3.shape_rev2.e_y[1] + (jointRRR3.shape_rev2.R.T[2,1] * jointRRR3.shape_rev2.e_y[2] + jointRRR3.shape_rev2.R.T[3,1] * jointRRR3.shape_rev2.e_y[3]);
//   jointRRR3.shape_rev2.ryvisobj[2] = jointRRR3.shape_rev2.R.T[1,2] * jointRRR3.shape_rev2.e_y[1] + (jointRRR3.shape_rev2.R.T[2,2] * jointRRR3.shape_rev2.e_y[2] + jointRRR3.shape_rev2.R.T[3,2] * jointRRR3.shape_rev2.e_y[3]);
//   jointRRR3.shape_rev2.ryvisobj[3] = jointRRR3.shape_rev2.R.T[1,3] * jointRRR3.shape_rev2.e_y[1] + (jointRRR3.shape_rev2.R.T[2,3] * jointRRR3.shape_rev2.e_y[2] + jointRRR3.shape_rev2.R.T[3,3] * jointRRR3.shape_rev2.e_y[3]);
//   jointRRR3.shape_rev2.rvisobj = jointRRR3.shape_rev2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{jointRRR3.shape_rev2.R.T[1,1],jointRRR3.shape_rev2.R.T[1,2],jointRRR3.shape_rev2.R.T[1,3]},{jointRRR3.shape_rev2.R.T[2,1],jointRRR3.shape_rev2.R.T[2,2],jointRRR3.shape_rev2.R.T[2,3]},{jointRRR3.shape_rev2.R.T[3,1],jointRRR3.shape_rev2.R.T[3,2],jointRRR3.shape_rev2.R.T[3,3]}},{jointRRR3.shape_rev2.r_shape[1],jointRRR3.shape_rev2.r_shape[2],jointRRR3.shape_rev2.r_shape[3]});
//   jointRRR3.shape_rev2.size[1] = jointRRR3.shape_rev2.length;
//   jointRRR3.shape_rev2.size[2] = jointRRR3.shape_rev2.width;
//   jointRRR3.shape_rev2.size[3] = jointRRR3.shape_rev2.height;
//   jointRRR3.shape_rev2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(jointRRR3.shape_rev2.color[1] / 255.0,jointRRR3.shape_rev2.color[2] / 255.0,jointRRR3.shape_rev2.color[3] / 255.0,jointRRR3.shape_rev2.specularCoefficient);
//   jointRRR3.shape_rev2.Extra = jointRRR3.shape_rev2.extra;
//   jointRRR3.shape_rev3.R.T[1,1] = jointRRR3.frame_b.R.T[1,1];
//   jointRRR3.shape_rev3.R.T[1,2] = jointRRR3.frame_b.R.T[1,2];
//   jointRRR3.shape_rev3.R.T[1,3] = jointRRR3.frame_b.R.T[1,3];
//   jointRRR3.shape_rev3.R.T[2,1] = jointRRR3.frame_b.R.T[2,1];
//   jointRRR3.shape_rev3.R.T[2,2] = jointRRR3.frame_b.R.T[2,2];
//   jointRRR3.shape_rev3.R.T[2,3] = jointRRR3.frame_b.R.T[2,3];
//   jointRRR3.shape_rev3.R.T[3,1] = jointRRR3.frame_b.R.T[3,1];
//   jointRRR3.shape_rev3.R.T[3,2] = jointRRR3.frame_b.R.T[3,2];
//   jointRRR3.shape_rev3.R.T[3,3] = jointRRR3.frame_b.R.T[3,3];
//   jointRRR3.shape_rev3.R.w[1] = jointRRR3.frame_b.R.w[1];
//   jointRRR3.shape_rev3.R.w[2] = jointRRR3.frame_b.R.w[2];
//   jointRRR3.shape_rev3.R.w[3] = jointRRR3.frame_b.R.w[3];
//   jointRRR3.shape_rev3.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(jointRRR3.shape_rev3.shapeType);
//   jointRRR3.shape_rev3.rxvisobj[1] = jointRRR3.shape_rev3.R.T[1,1] * jointRRR3.shape_rev3.e_x[1] + (jointRRR3.shape_rev3.R.T[2,1] * jointRRR3.shape_rev3.e_x[2] + jointRRR3.shape_rev3.R.T[3,1] * jointRRR3.shape_rev3.e_x[3]);
//   jointRRR3.shape_rev3.rxvisobj[2] = jointRRR3.shape_rev3.R.T[1,2] * jointRRR3.shape_rev3.e_x[1] + (jointRRR3.shape_rev3.R.T[2,2] * jointRRR3.shape_rev3.e_x[2] + jointRRR3.shape_rev3.R.T[3,2] * jointRRR3.shape_rev3.e_x[3]);
//   jointRRR3.shape_rev3.rxvisobj[3] = jointRRR3.shape_rev3.R.T[1,3] * jointRRR3.shape_rev3.e_x[1] + (jointRRR3.shape_rev3.R.T[2,3] * jointRRR3.shape_rev3.e_x[2] + jointRRR3.shape_rev3.R.T[3,3] * jointRRR3.shape_rev3.e_x[3]);
//   jointRRR3.shape_rev3.ryvisobj[1] = jointRRR3.shape_rev3.R.T[1,1] * jointRRR3.shape_rev3.e_y[1] + (jointRRR3.shape_rev3.R.T[2,1] * jointRRR3.shape_rev3.e_y[2] + jointRRR3.shape_rev3.R.T[3,1] * jointRRR3.shape_rev3.e_y[3]);
//   jointRRR3.shape_rev3.ryvisobj[2] = jointRRR3.shape_rev3.R.T[1,2] * jointRRR3.shape_rev3.e_y[1] + (jointRRR3.shape_rev3.R.T[2,2] * jointRRR3.shape_rev3.e_y[2] + jointRRR3.shape_rev3.R.T[3,2] * jointRRR3.shape_rev3.e_y[3]);
//   jointRRR3.shape_rev3.ryvisobj[3] = jointRRR3.shape_rev3.R.T[1,3] * jointRRR3.shape_rev3.e_y[1] + (jointRRR3.shape_rev3.R.T[2,3] * jointRRR3.shape_rev3.e_y[2] + jointRRR3.shape_rev3.R.T[3,3] * jointRRR3.shape_rev3.e_y[3]);
//   jointRRR3.shape_rev3.rvisobj = jointRRR3.shape_rev3.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{jointRRR3.shape_rev3.R.T[1,1],jointRRR3.shape_rev3.R.T[1,2],jointRRR3.shape_rev3.R.T[1,3]},{jointRRR3.shape_rev3.R.T[2,1],jointRRR3.shape_rev3.R.T[2,2],jointRRR3.shape_rev3.R.T[2,3]},{jointRRR3.shape_rev3.R.T[3,1],jointRRR3.shape_rev3.R.T[3,2],jointRRR3.shape_rev3.R.T[3,3]}},{jointRRR3.shape_rev3.r_shape[1],jointRRR3.shape_rev3.r_shape[2],jointRRR3.shape_rev3.r_shape[3]});
//   jointRRR3.shape_rev3.size[1] = jointRRR3.shape_rev3.length;
//   jointRRR3.shape_rev3.size[2] = jointRRR3.shape_rev3.width;
//   jointRRR3.shape_rev3.size[3] = jointRRR3.shape_rev3.height;
//   jointRRR3.shape_rev3.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(jointRRR3.shape_rev3.color[1] / 255.0,jointRRR3.shape_rev3.color[2] / 255.0,jointRRR3.shape_rev3.color[3] / 255.0,jointRRR3.shape_rev3.specularCoefficient);
//   jointRRR3.shape_rev3.Extra = jointRRR3.shape_rev3.extra;
//   jointRRR3.shape_rod1.R.T[1,1] = jointRRR3.frame_ia.R.T[1,1];
//   jointRRR3.shape_rod1.R.T[1,2] = jointRRR3.frame_ia.R.T[1,2];
//   jointRRR3.shape_rod1.R.T[1,3] = jointRRR3.frame_ia.R.T[1,3];
//   jointRRR3.shape_rod1.R.T[2,1] = jointRRR3.frame_ia.R.T[2,1];
//   jointRRR3.shape_rod1.R.T[2,2] = jointRRR3.frame_ia.R.T[2,2];
//   jointRRR3.shape_rod1.R.T[2,3] = jointRRR3.frame_ia.R.T[2,3];
//   jointRRR3.shape_rod1.R.T[3,1] = jointRRR3.frame_ia.R.T[3,1];
//   jointRRR3.shape_rod1.R.T[3,2] = jointRRR3.frame_ia.R.T[3,2];
//   jointRRR3.shape_rod1.R.T[3,3] = jointRRR3.frame_ia.R.T[3,3];
//   jointRRR3.shape_rod1.R.w[1] = jointRRR3.frame_ia.R.w[1];
//   jointRRR3.shape_rod1.R.w[2] = jointRRR3.frame_ia.R.w[2];
//   jointRRR3.shape_rod1.R.w[3] = jointRRR3.frame_ia.R.w[3];
//   jointRRR3.shape_rod1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(jointRRR3.shape_rod1.shapeType);
//   jointRRR3.shape_rod1.rxvisobj[1] = jointRRR3.shape_rod1.R.T[1,1] * jointRRR3.shape_rod1.e_x[1] + (jointRRR3.shape_rod1.R.T[2,1] * jointRRR3.shape_rod1.e_x[2] + jointRRR3.shape_rod1.R.T[3,1] * jointRRR3.shape_rod1.e_x[3]);
//   jointRRR3.shape_rod1.rxvisobj[2] = jointRRR3.shape_rod1.R.T[1,2] * jointRRR3.shape_rod1.e_x[1] + (jointRRR3.shape_rod1.R.T[2,2] * jointRRR3.shape_rod1.e_x[2] + jointRRR3.shape_rod1.R.T[3,2] * jointRRR3.shape_rod1.e_x[3]);
//   jointRRR3.shape_rod1.rxvisobj[3] = jointRRR3.shape_rod1.R.T[1,3] * jointRRR3.shape_rod1.e_x[1] + (jointRRR3.shape_rod1.R.T[2,3] * jointRRR3.shape_rod1.e_x[2] + jointRRR3.shape_rod1.R.T[3,3] * jointRRR3.shape_rod1.e_x[3]);
//   jointRRR3.shape_rod1.ryvisobj[1] = jointRRR3.shape_rod1.R.T[1,1] * jointRRR3.shape_rod1.e_y[1] + (jointRRR3.shape_rod1.R.T[2,1] * jointRRR3.shape_rod1.e_y[2] + jointRRR3.shape_rod1.R.T[3,1] * jointRRR3.shape_rod1.e_y[3]);
//   jointRRR3.shape_rod1.ryvisobj[2] = jointRRR3.shape_rod1.R.T[1,2] * jointRRR3.shape_rod1.e_y[1] + (jointRRR3.shape_rod1.R.T[2,2] * jointRRR3.shape_rod1.e_y[2] + jointRRR3.shape_rod1.R.T[3,2] * jointRRR3.shape_rod1.e_y[3]);
//   jointRRR3.shape_rod1.ryvisobj[3] = jointRRR3.shape_rod1.R.T[1,3] * jointRRR3.shape_rod1.e_y[1] + (jointRRR3.shape_rod1.R.T[2,3] * jointRRR3.shape_rod1.e_y[2] + jointRRR3.shape_rod1.R.T[3,3] * jointRRR3.shape_rod1.e_y[3]);
//   jointRRR3.shape_rod1.rvisobj = jointRRR3.shape_rod1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{jointRRR3.shape_rod1.R.T[1,1],jointRRR3.shape_rod1.R.T[1,2],jointRRR3.shape_rod1.R.T[1,3]},{jointRRR3.shape_rod1.R.T[2,1],jointRRR3.shape_rod1.R.T[2,2],jointRRR3.shape_rod1.R.T[2,3]},{jointRRR3.shape_rod1.R.T[3,1],jointRRR3.shape_rod1.R.T[3,2],jointRRR3.shape_rod1.R.T[3,3]}},{jointRRR3.shape_rod1.r_shape[1],jointRRR3.shape_rod1.r_shape[2],jointRRR3.shape_rod1.r_shape[3]});
//   jointRRR3.shape_rod1.size[1] = jointRRR3.shape_rod1.length;
//   jointRRR3.shape_rod1.size[2] = jointRRR3.shape_rod1.width;
//   jointRRR3.shape_rod1.size[3] = jointRRR3.shape_rod1.height;
//   jointRRR3.shape_rod1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(jointRRR3.shape_rod1.color[1] / 255.0,jointRRR3.shape_rod1.color[2] / 255.0,jointRRR3.shape_rod1.color[3] / 255.0,jointRRR3.shape_rod1.specularCoefficient);
//   jointRRR3.shape_rod1.Extra = jointRRR3.shape_rod1.extra;
//   jointRRR3.shape_rod2.R.T[1,1] = jointRRR3.frame_ib.R.T[1,1];
//   jointRRR3.shape_rod2.R.T[1,2] = jointRRR3.frame_ib.R.T[1,2];
//   jointRRR3.shape_rod2.R.T[1,3] = jointRRR3.frame_ib.R.T[1,3];
//   jointRRR3.shape_rod2.R.T[2,1] = jointRRR3.frame_ib.R.T[2,1];
//   jointRRR3.shape_rod2.R.T[2,2] = jointRRR3.frame_ib.R.T[2,2];
//   jointRRR3.shape_rod2.R.T[2,3] = jointRRR3.frame_ib.R.T[2,3];
//   jointRRR3.shape_rod2.R.T[3,1] = jointRRR3.frame_ib.R.T[3,1];
//   jointRRR3.shape_rod2.R.T[3,2] = jointRRR3.frame_ib.R.T[3,2];
//   jointRRR3.shape_rod2.R.T[3,3] = jointRRR3.frame_ib.R.T[3,3];
//   jointRRR3.shape_rod2.R.w[1] = jointRRR3.frame_ib.R.w[1];
//   jointRRR3.shape_rod2.R.w[2] = jointRRR3.frame_ib.R.w[2];
//   jointRRR3.shape_rod2.R.w[3] = jointRRR3.frame_ib.R.w[3];
//   jointRRR3.shape_rod2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(jointRRR3.shape_rod2.shapeType);
//   jointRRR3.shape_rod2.rxvisobj[1] = jointRRR3.shape_rod2.R.T[1,1] * jointRRR3.shape_rod2.e_x[1] + (jointRRR3.shape_rod2.R.T[2,1] * jointRRR3.shape_rod2.e_x[2] + jointRRR3.shape_rod2.R.T[3,1] * jointRRR3.shape_rod2.e_x[3]);
//   jointRRR3.shape_rod2.rxvisobj[2] = jointRRR3.shape_rod2.R.T[1,2] * jointRRR3.shape_rod2.e_x[1] + (jointRRR3.shape_rod2.R.T[2,2] * jointRRR3.shape_rod2.e_x[2] + jointRRR3.shape_rod2.R.T[3,2] * jointRRR3.shape_rod2.e_x[3]);
//   jointRRR3.shape_rod2.rxvisobj[3] = jointRRR3.shape_rod2.R.T[1,3] * jointRRR3.shape_rod2.e_x[1] + (jointRRR3.shape_rod2.R.T[2,3] * jointRRR3.shape_rod2.e_x[2] + jointRRR3.shape_rod2.R.T[3,3] * jointRRR3.shape_rod2.e_x[3]);
//   jointRRR3.shape_rod2.ryvisobj[1] = jointRRR3.shape_rod2.R.T[1,1] * jointRRR3.shape_rod2.e_y[1] + (jointRRR3.shape_rod2.R.T[2,1] * jointRRR3.shape_rod2.e_y[2] + jointRRR3.shape_rod2.R.T[3,1] * jointRRR3.shape_rod2.e_y[3]);
//   jointRRR3.shape_rod2.ryvisobj[2] = jointRRR3.shape_rod2.R.T[1,2] * jointRRR3.shape_rod2.e_y[1] + (jointRRR3.shape_rod2.R.T[2,2] * jointRRR3.shape_rod2.e_y[2] + jointRRR3.shape_rod2.R.T[3,2] * jointRRR3.shape_rod2.e_y[3]);
//   jointRRR3.shape_rod2.ryvisobj[3] = jointRRR3.shape_rod2.R.T[1,3] * jointRRR3.shape_rod2.e_y[1] + (jointRRR3.shape_rod2.R.T[2,3] * jointRRR3.shape_rod2.e_y[2] + jointRRR3.shape_rod2.R.T[3,3] * jointRRR3.shape_rod2.e_y[3]);
//   jointRRR3.shape_rod2.rvisobj = jointRRR3.shape_rod2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{jointRRR3.shape_rod2.R.T[1,1],jointRRR3.shape_rod2.R.T[1,2],jointRRR3.shape_rod2.R.T[1,3]},{jointRRR3.shape_rod2.R.T[2,1],jointRRR3.shape_rod2.R.T[2,2],jointRRR3.shape_rod2.R.T[2,3]},{jointRRR3.shape_rod2.R.T[3,1],jointRRR3.shape_rod2.R.T[3,2],jointRRR3.shape_rod2.R.T[3,3]}},{jointRRR3.shape_rod2.r_shape[1],jointRRR3.shape_rod2.r_shape[2],jointRRR3.shape_rod2.r_shape[3]});
//   jointRRR3.shape_rod2.size[1] = jointRRR3.shape_rod2.length;
//   jointRRR3.shape_rod2.size[2] = jointRRR3.shape_rod2.width;
//   jointRRR3.shape_rod2.size[3] = jointRRR3.shape_rod2.height;
//   jointRRR3.shape_rod2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(jointRRR3.shape_rod2.color[1] / 255.0,jointRRR3.shape_rod2.color[2] / 255.0,jointRRR3.shape_rod2.color[3] / 255.0,jointRRR3.shape_rod2.specularCoefficient);
//   jointRRR3.shape_rod2.Extra = jointRRR3.shape_rod2.extra;
//   assert(true,\"Connector frame_a of component is not connected\");
//   assert(true,\"Connector frame_b of component is not connected\");
//   rod4.shape.R.T[1,1] = rod4.frame_a.R.T[1,1];
//   rod4.shape.R.T[1,2] = rod4.frame_a.R.T[1,2];
//   rod4.shape.R.T[1,3] = rod4.frame_a.R.T[1,3];
//   rod4.shape.R.T[2,1] = rod4.frame_a.R.T[2,1];
//   rod4.shape.R.T[2,2] = rod4.frame_a.R.T[2,2];
//   rod4.shape.R.T[2,3] = rod4.frame_a.R.T[2,3];
//   rod4.shape.R.T[3,1] = rod4.frame_a.R.T[3,1];
//   rod4.shape.R.T[3,2] = rod4.frame_a.R.T[3,2];
//   rod4.shape.R.T[3,3] = rod4.frame_a.R.T[3,3];
//   rod4.shape.R.w[1] = rod4.frame_a.R.w[1];
//   rod4.shape.R.w[2] = rod4.frame_a.R.w[2];
//   rod4.shape.R.w[3] = rod4.frame_a.R.w[3];
//   rod4.shape.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(rod4.shape.shapeType);
//   rod4.shape.rxvisobj[1] = rod4.shape.R.T[1,1] * rod4.shape.e_x[1] + (rod4.shape.R.T[2,1] * rod4.shape.e_x[2] + rod4.shape.R.T[3,1] * rod4.shape.e_x[3]);
//   rod4.shape.rxvisobj[2] = rod4.shape.R.T[1,2] * rod4.shape.e_x[1] + (rod4.shape.R.T[2,2] * rod4.shape.e_x[2] + rod4.shape.R.T[3,2] * rod4.shape.e_x[3]);
//   rod4.shape.rxvisobj[3] = rod4.shape.R.T[1,3] * rod4.shape.e_x[1] + (rod4.shape.R.T[2,3] * rod4.shape.e_x[2] + rod4.shape.R.T[3,3] * rod4.shape.e_x[3]);
//   rod4.shape.ryvisobj[1] = rod4.shape.R.T[1,1] * rod4.shape.e_y[1] + (rod4.shape.R.T[2,1] * rod4.shape.e_y[2] + rod4.shape.R.T[3,1] * rod4.shape.e_y[3]);
//   rod4.shape.ryvisobj[2] = rod4.shape.R.T[1,2] * rod4.shape.e_y[1] + (rod4.shape.R.T[2,2] * rod4.shape.e_y[2] + rod4.shape.R.T[3,2] * rod4.shape.e_y[3]);
//   rod4.shape.ryvisobj[3] = rod4.shape.R.T[1,3] * rod4.shape.e_y[1] + (rod4.shape.R.T[2,3] * rod4.shape.e_y[2] + rod4.shape.R.T[3,3] * rod4.shape.e_y[3]);
//   rod4.shape.rvisobj = rod4.shape.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{rod4.shape.R.T[1,1],rod4.shape.R.T[1,2],rod4.shape.R.T[1,3]},{rod4.shape.R.T[2,1],rod4.shape.R.T[2,2],rod4.shape.R.T[2,3]},{rod4.shape.R.T[3,1],rod4.shape.R.T[3,2],rod4.shape.R.T[3,3]}},{rod4.shape.r_shape[1],rod4.shape.r_shape[2],rod4.shape.r_shape[3]});
//   rod4.shape.size[1] = rod4.shape.length;
//   rod4.shape.size[2] = rod4.shape.width;
//   rod4.shape.size[3] = rod4.shape.height;
//   rod4.shape.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(rod4.shape.color[1] / 255.0,rod4.shape.color[2] / 255.0,rod4.shape.color[3] / 255.0,rod4.shape.specularCoefficient);
//   rod4.shape.Extra = rod4.shape.extra;
//   assert(true,\"Neither connector frame_a nor frame_b of FixedTranslation object is connected\");
//   rod4.frame_b.r_0 = rod4.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(rod4.frame_a.R,{rod4.r[1],rod4.r[2],rod4.r[3]});
//   rod4.frame_b.R.T[1,1] = rod4.frame_a.R.T[1,1];
//   rod4.frame_b.R.T[1,2] = rod4.frame_a.R.T[1,2];
//   rod4.frame_b.R.T[1,3] = rod4.frame_a.R.T[1,3];
//   rod4.frame_b.R.T[2,1] = rod4.frame_a.R.T[2,1];
//   rod4.frame_b.R.T[2,2] = rod4.frame_a.R.T[2,2];
//   rod4.frame_b.R.T[2,3] = rod4.frame_a.R.T[2,3];
//   rod4.frame_b.R.T[3,1] = rod4.frame_a.R.T[3,1];
//   rod4.frame_b.R.T[3,2] = rod4.frame_a.R.T[3,2];
//   rod4.frame_b.R.T[3,3] = rod4.frame_a.R.T[3,3];
//   rod4.frame_b.R.w[1] = rod4.frame_a.R.w[1];
//   rod4.frame_b.R.w[2] = rod4.frame_a.R.w[2];
//   rod4.frame_b.R.w[3] = rod4.frame_a.R.w[3];
//   0.0 = rod4.frame_a.f[1] + rod4.frame_b.f[1];
//   0.0 = rod4.frame_a.f[2] + rod4.frame_b.f[2];
//   0.0 = rod4.frame_a.f[3] + rod4.frame_b.f[3];
//   0.0 = rod4.frame_a.t[1] + (rod4.frame_b.t[1] + (rod4.r[2] * rod4.frame_b.f[3] + (-rod4.r[3] * rod4.frame_b.f[2])));
//   0.0 = rod4.frame_a.t[2] + (rod4.frame_b.t[2] + (rod4.r[3] * rod4.frame_b.f[1] + (-rod4.r[1] * rod4.frame_b.f[3])));
//   0.0 = rod4.frame_a.t[3] + (rod4.frame_b.t[3] + (rod4.r[1] * rod4.frame_b.f[2] + (-rod4.r[2] * rod4.frame_b.f[1])));
//   body3.cylinder.R.T[1,1] = body3.frame_a.R.T[1,1];
//   body3.cylinder.R.T[1,2] = body3.frame_a.R.T[1,2];
//   body3.cylinder.R.T[1,3] = body3.frame_a.R.T[1,3];
//   body3.cylinder.R.T[2,1] = body3.frame_a.R.T[2,1];
//   body3.cylinder.R.T[2,2] = body3.frame_a.R.T[2,2];
//   body3.cylinder.R.T[2,3] = body3.frame_a.R.T[2,3];
//   body3.cylinder.R.T[3,1] = body3.frame_a.R.T[3,1];
//   body3.cylinder.R.T[3,2] = body3.frame_a.R.T[3,2];
//   body3.cylinder.R.T[3,3] = body3.frame_a.R.T[3,3];
//   body3.cylinder.R.w[1] = body3.frame_a.R.w[1];
//   body3.cylinder.R.w[2] = body3.frame_a.R.w[2];
//   body3.cylinder.R.w[3] = body3.frame_a.R.w[3];
//   body3.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body3.cylinder.shapeType);
//   body3.cylinder.rxvisobj[1] = body3.cylinder.R.T[1,1] * body3.cylinder.e_x[1] + (body3.cylinder.R.T[2,1] * body3.cylinder.e_x[2] + body3.cylinder.R.T[3,1] * body3.cylinder.e_x[3]);
//   body3.cylinder.rxvisobj[2] = body3.cylinder.R.T[1,2] * body3.cylinder.e_x[1] + (body3.cylinder.R.T[2,2] * body3.cylinder.e_x[2] + body3.cylinder.R.T[3,2] * body3.cylinder.e_x[3]);
//   body3.cylinder.rxvisobj[3] = body3.cylinder.R.T[1,3] * body3.cylinder.e_x[1] + (body3.cylinder.R.T[2,3] * body3.cylinder.e_x[2] + body3.cylinder.R.T[3,3] * body3.cylinder.e_x[3]);
//   body3.cylinder.ryvisobj[1] = body3.cylinder.R.T[1,1] * body3.cylinder.e_y[1] + (body3.cylinder.R.T[2,1] * body3.cylinder.e_y[2] + body3.cylinder.R.T[3,1] * body3.cylinder.e_y[3]);
//   body3.cylinder.ryvisobj[2] = body3.cylinder.R.T[1,2] * body3.cylinder.e_y[1] + (body3.cylinder.R.T[2,2] * body3.cylinder.e_y[2] + body3.cylinder.R.T[3,2] * body3.cylinder.e_y[3]);
//   body3.cylinder.ryvisobj[3] = body3.cylinder.R.T[1,3] * body3.cylinder.e_y[1] + (body3.cylinder.R.T[2,3] * body3.cylinder.e_y[2] + body3.cylinder.R.T[3,3] * body3.cylinder.e_y[3]);
//   body3.cylinder.rvisobj = body3.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body3.cylinder.R.T[1,1],body3.cylinder.R.T[1,2],body3.cylinder.R.T[1,3]},{body3.cylinder.R.T[2,1],body3.cylinder.R.T[2,2],body3.cylinder.R.T[2,3]},{body3.cylinder.R.T[3,1],body3.cylinder.R.T[3,2],body3.cylinder.R.T[3,3]}},{body3.cylinder.r_shape[1],body3.cylinder.r_shape[2],body3.cylinder.r_shape[3]});
//   body3.cylinder.size[1] = body3.cylinder.length;
//   body3.cylinder.size[2] = body3.cylinder.width;
//   body3.cylinder.size[3] = body3.cylinder.height;
//   body3.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body3.cylinder.color[1] / 255.0,body3.cylinder.color[2] / 255.0,body3.cylinder.color[3] / 255.0,body3.cylinder.specularCoefficient);
//   body3.cylinder.Extra = body3.cylinder.extra;
//   body3.sphere.R.T[1,1] = body3.frame_a.R.T[1,1];
//   body3.sphere.R.T[1,2] = body3.frame_a.R.T[1,2];
//   body3.sphere.R.T[1,3] = body3.frame_a.R.T[1,3];
//   body3.sphere.R.T[2,1] = body3.frame_a.R.T[2,1];
//   body3.sphere.R.T[2,2] = body3.frame_a.R.T[2,2];
//   body3.sphere.R.T[2,3] = body3.frame_a.R.T[2,3];
//   body3.sphere.R.T[3,1] = body3.frame_a.R.T[3,1];
//   body3.sphere.R.T[3,2] = body3.frame_a.R.T[3,2];
//   body3.sphere.R.T[3,3] = body3.frame_a.R.T[3,3];
//   body3.sphere.R.w[1] = body3.frame_a.R.w[1];
//   body3.sphere.R.w[2] = body3.frame_a.R.w[2];
//   body3.sphere.R.w[3] = body3.frame_a.R.w[3];
//   body3.sphere.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(body3.sphere.shapeType);
//   body3.sphere.rxvisobj[1] = body3.sphere.R.T[1,1] * body3.sphere.e_x[1] + (body3.sphere.R.T[2,1] * body3.sphere.e_x[2] + body3.sphere.R.T[3,1] * body3.sphere.e_x[3]);
//   body3.sphere.rxvisobj[2] = body3.sphere.R.T[1,2] * body3.sphere.e_x[1] + (body3.sphere.R.T[2,2] * body3.sphere.e_x[2] + body3.sphere.R.T[3,2] * body3.sphere.e_x[3]);
//   body3.sphere.rxvisobj[3] = body3.sphere.R.T[1,3] * body3.sphere.e_x[1] + (body3.sphere.R.T[2,3] * body3.sphere.e_x[2] + body3.sphere.R.T[3,3] * body3.sphere.e_x[3]);
//   body3.sphere.ryvisobj[1] = body3.sphere.R.T[1,1] * body3.sphere.e_y[1] + (body3.sphere.R.T[2,1] * body3.sphere.e_y[2] + body3.sphere.R.T[3,1] * body3.sphere.e_y[3]);
//   body3.sphere.ryvisobj[2] = body3.sphere.R.T[1,2] * body3.sphere.e_y[1] + (body3.sphere.R.T[2,2] * body3.sphere.e_y[2] + body3.sphere.R.T[3,2] * body3.sphere.e_y[3]);
//   body3.sphere.ryvisobj[3] = body3.sphere.R.T[1,3] * body3.sphere.e_y[1] + (body3.sphere.R.T[2,3] * body3.sphere.e_y[2] + body3.sphere.R.T[3,3] * body3.sphere.e_y[3]);
//   body3.sphere.rvisobj = body3.sphere.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{body3.sphere.R.T[1,1],body3.sphere.R.T[1,2],body3.sphere.R.T[1,3]},{body3.sphere.R.T[2,1],body3.sphere.R.T[2,2],body3.sphere.R.T[2,3]},{body3.sphere.R.T[3,1],body3.sphere.R.T[3,2],body3.sphere.R.T[3,3]}},{body3.sphere.r_shape[1],body3.sphere.r_shape[2],body3.sphere.r_shape[3]});
//   body3.sphere.size[1] = body3.sphere.length;
//   body3.sphere.size[2] = body3.sphere.width;
//   body3.sphere.size[3] = body3.sphere.height;
//   body3.sphere.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(body3.sphere.color[1] / 255.0,body3.sphere.color[2] / 255.0,body3.sphere.color[3] / 255.0,body3.sphere.specularCoefficient);
//   body3.sphere.Extra = body3.sphere.extra;
//   body3.r_0[1] = body3.frame_a.r_0[1];
//   body3.r_0[2] = body3.frame_a.r_0[2];
//   body3.r_0[3] = body3.frame_a.r_0[3];
//   if true then
//   body3.Q[1] = 0.0;
//   body3.Q[2] = 0.0;
//   body3.Q[3] = 0.0;
//   body3.Q[4] = 1.0;
//   body3.phi[1] = 0.0;
//   body3.phi[2] = 0.0;
//   body3.phi[3] = 0.0;
//   body3.phi_d[1] = 0.0;
//   body3.phi_d[2] = 0.0;
//   body3.phi_d[3] = 0.0;
//   body3.phi_dd[1] = 0.0;
//   body3.phi_dd[2] = 0.0;
//   body3.phi_dd[3] = 0.0;
//   elseif body3.useQuaternions then
//   body3.frame_a.R = Modelica.Mechanics.MultiBody.Frames.from_Q({body3.Q[1],body3.Q[2],body3.Q[3],body3.Q[4]},Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2({body3.Q[1],body3.Q[2],body3.Q[3],body3.Q[4]},{der(body3.Q[1]),der(body3.Q[2]),der(body3.Q[3]),der(body3.Q[4])}));
//   {0.0} = Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint({body3.Q[1],body3.Q[2],body3.Q[3],body3.Q[4]});
//   body3.phi[1] = 0.0;
//   body3.phi[2] = 0.0;
//   body3.phi[3] = 0.0;
//   body3.phi_d[1] = 0.0;
//   body3.phi_d[2] = 0.0;
//   body3.phi_d[3] = 0.0;
//   body3.phi_dd[1] = 0.0;
//   body3.phi_dd[2] = 0.0;
//   body3.phi_dd[3] = 0.0;
//   else
//   body3.phi_d[1] = der(body3.phi[1]);
//   body3.phi_d[2] = der(body3.phi[2]);
//   body3.phi_d[3] = der(body3.phi[3]);
//   body3.phi_dd[1] = der(body3.phi_d[1]);
//   body3.phi_dd[2] = der(body3.phi_d[2]);
//   body3.phi_dd[3] = der(body3.phi_d[3]);
//   body3.frame_a.R = Modelica.Mechanics.MultiBody.Frames.axesRotations({body3.sequence_angleStates[1],body3.sequence_angleStates[2],body3.sequence_angleStates[3]},{body3.phi[1],body3.phi[2],body3.phi[3]},{body3.phi_d[1],body3.phi_d[2],body3.phi_d[3]});
//   body3.Q[1] = 0.0;
//   body3.Q[2] = 0.0;
//   body3.Q[3] = 0.0;
//   body3.Q[4] = 1.0;
//   end if;
//   body3.g_0 = Modelica.Mechanics.MultiBody.Parts.Body.world__gravityAcceleration({body3.frame_a.r_0[1],body3.frame_a.r_0[2],body3.frame_a.r_0[3]} + Modelica.Mechanics.MultiBody.Frames.resolve1(body3.frame_a.R,{body3.r_CM[1],body3.r_CM[2],body3.r_CM[3]}),world.gravityType,world.g * Modelica.Math.Vectors.normalize({world.n[1],world.n[2],world.n[3]},1e-13),world.mue);
//   body3.v_0[1] = der(body3.frame_a.r_0[1]);
//   body3.v_0[2] = der(body3.frame_a.r_0[2]);
//   body3.v_0[3] = der(body3.frame_a.r_0[3]);
//   body3.a_0[1] = der(body3.v_0[1]);
//   body3.a_0[2] = der(body3.v_0[2]);
//   body3.a_0[3] = der(body3.v_0[3]);
//   body3.w_a = Modelica.Mechanics.MultiBody.Frames.angularVelocity2(body3.frame_a.R);
//   body3.z_a[1] = der(body3.w_a[1]);
//   body3.z_a[2] = der(body3.w_a[2]);
//   body3.z_a[3] = der(body3.w_a[3]);
//   body3.frame_a.f = body3.m * (Modelica.Mechanics.MultiBody.Frames.resolve2(body3.frame_a.R,{body3.a_0[1] - body3.g_0[1],body3.a_0[2] - body3.g_0[2],body3.a_0[3] - body3.g_0[3]}) + {body3.z_a[2] * body3.r_CM[3] - body3.z_a[3] * body3.r_CM[2],body3.z_a[3] * body3.r_CM[1] - body3.z_a[1] * body3.r_CM[3],body3.z_a[1] * body3.r_CM[2] - body3.z_a[2] * body3.r_CM[1]} + {body3.w_a[2] * (body3.w_a[1] * body3.r_CM[2] - body3.w_a[2] * body3.r_CM[1]) - body3.w_a[3] * (body3.w_a[3] * body3.r_CM[1] - body3.w_a[1] * body3.r_CM[3]),body3.w_a[3] * (body3.w_a[2] * body3.r_CM[3] - body3.w_a[3] * body3.r_CM[2]) - body3.w_a[1] * (body3.w_a[1] * body3.r_CM[2] - body3.w_a[2] * body3.r_CM[1]),body3.w_a[1] * (body3.w_a[3] * body3.r_CM[1] - body3.w_a[1] * body3.r_CM[3]) - body3.w_a[2] * (body3.w_a[2] * body3.r_CM[3] - body3.w_a[3] * body3.r_CM[2])});
//   body3.frame_a.t[1] = body3.I[1,1] * body3.z_a[1] + (body3.I[1,2] * body3.z_a[2] + (body3.I[1,3] * body3.z_a[3] + (body3.w_a[2] * (body3.I[3,1] * body3.w_a[1] + (body3.I[3,2] * body3.w_a[2] + body3.I[3,3] * body3.w_a[3])) + ((-body3.w_a[3] * (body3.I[2,1] * body3.w_a[1] + (body3.I[2,2] * body3.w_a[2] + body3.I[2,3] * body3.w_a[3]))) + (body3.r_CM[2] * body3.frame_a.f[3] + (-body3.r_CM[3] * body3.frame_a.f[2]))))));
//   body3.frame_a.t[2] = body3.I[2,1] * body3.z_a[1] + (body3.I[2,2] * body3.z_a[2] + (body3.I[2,3] * body3.z_a[3] + (body3.w_a[3] * (body3.I[1,1] * body3.w_a[1] + (body3.I[1,2] * body3.w_a[2] + body3.I[1,3] * body3.w_a[3])) + ((-body3.w_a[1] * (body3.I[3,1] * body3.w_a[1] + (body3.I[3,2] * body3.w_a[2] + body3.I[3,3] * body3.w_a[3]))) + (body3.r_CM[3] * body3.frame_a.f[1] + (-body3.r_CM[1] * body3.frame_a.f[3]))))));
//   body3.frame_a.t[3] = body3.I[3,1] * body3.z_a[1] + (body3.I[3,2] * body3.z_a[2] + (body3.I[3,3] * body3.z_a[3] + (body3.w_a[1] * (body3.I[2,1] * body3.w_a[1] + (body3.I[2,2] * body3.w_a[2] + body3.I[2,3] * body3.w_a[3])) + ((-body3.w_a[2] * (body3.I[1,1] * body3.w_a[1] + (body3.I[1,2] * body3.w_a[2] + body3.I[1,3] * body3.w_a[3]))) + (body3.r_CM[1] * body3.frame_a.f[2] + (-body3.r_CM[2] * body3.frame_a.f[1]))))));
//   mounting1D.housing.frame_a.f[1] = 0.0;
//   mounting1D.housing.frame_a.f[2] = 0.0;
//   mounting1D.housing.frame_a.f[3] = 0.0;
//   mounting1D.housing.frame_a.t[1] = mounting1D.housing.t[1];
//   mounting1D.housing.frame_a.t[2] = mounting1D.housing.t[2];
//   mounting1D.housing.frame_a.t[3] = mounting1D.housing.t[3];
//   mounting1D.flange_b.phi = mounting1D.phi0;
//   position.flange.tau + rev.axis.tau = 0.0;
//   position.flange.phi = rev.axis.phi;
//   mounting1D.frame_a.t[1] + (rod2.frame_a.t[1] + (world.frame_b.t[1] + rev.frame_a.t[1])) = 0.0;
//   mounting1D.frame_a.t[2] + (rod2.frame_a.t[2] + (world.frame_b.t[2] + rev.frame_a.t[2])) = 0.0;
//   mounting1D.frame_a.t[3] + (rod2.frame_a.t[3] + (world.frame_b.t[3] + rev.frame_a.t[3])) = 0.0;
//   mounting1D.frame_a.f[1] + (rod2.frame_a.f[1] + (world.frame_b.f[1] + rev.frame_a.f[1])) = 0.0;
//   mounting1D.frame_a.f[2] + (rod2.frame_a.f[2] + (world.frame_b.f[2] + rev.frame_a.f[2])) = 0.0;
//   mounting1D.frame_a.f[3] + (rod2.frame_a.f[3] + (world.frame_b.f[3] + rev.frame_a.f[3])) = 0.0;
//   mounting1D.frame_a.R.w[1] = rev.frame_a.R.w[1];
//   mounting1D.frame_a.R.w[1] = rod2.frame_a.R.w[1];
//   mounting1D.frame_a.R.w[1] = world.frame_b.R.w[1];
//   mounting1D.frame_a.R.w[2] = rev.frame_a.R.w[2];
//   mounting1D.frame_a.R.w[2] = rod2.frame_a.R.w[2];
//   mounting1D.frame_a.R.w[2] = world.frame_b.R.w[2];
//   mounting1D.frame_a.R.w[3] = rev.frame_a.R.w[3];
//   mounting1D.frame_a.R.w[3] = rod2.frame_a.R.w[3];
//   mounting1D.frame_a.R.w[3] = world.frame_b.R.w[3];
//   mounting1D.frame_a.R.T[1,1] = rev.frame_a.R.T[1,1];
//   mounting1D.frame_a.R.T[1,1] = rod2.frame_a.R.T[1,1];
//   mounting1D.frame_a.R.T[1,1] = world.frame_b.R.T[1,1];
//   mounting1D.frame_a.R.T[1,2] = rev.frame_a.R.T[1,2];
//   mounting1D.frame_a.R.T[1,2] = rod2.frame_a.R.T[1,2];
//   mounting1D.frame_a.R.T[1,2] = world.frame_b.R.T[1,2];
//   mounting1D.frame_a.R.T[1,3] = rev.frame_a.R.T[1,3];
//   mounting1D.frame_a.R.T[1,3] = rod2.frame_a.R.T[1,3];
//   mounting1D.frame_a.R.T[1,3] = world.frame_b.R.T[1,3];
//   mounting1D.frame_a.R.T[2,1] = rev.frame_a.R.T[2,1];
//   mounting1D.frame_a.R.T[2,1] = rod2.frame_a.R.T[2,1];
//   mounting1D.frame_a.R.T[2,1] = world.frame_b.R.T[2,1];
//   mounting1D.frame_a.R.T[2,2] = rev.frame_a.R.T[2,2];
//   mounting1D.frame_a.R.T[2,2] = rod2.frame_a.R.T[2,2];
//   mounting1D.frame_a.R.T[2,2] = world.frame_b.R.T[2,2];
//   mounting1D.frame_a.R.T[2,3] = rev.frame_a.R.T[2,3];
//   mounting1D.frame_a.R.T[2,3] = rod2.frame_a.R.T[2,3];
//   mounting1D.frame_a.R.T[2,3] = world.frame_b.R.T[2,3];
//   mounting1D.frame_a.R.T[3,1] = rev.frame_a.R.T[3,1];
//   mounting1D.frame_a.R.T[3,1] = rod2.frame_a.R.T[3,1];
//   mounting1D.frame_a.R.T[3,1] = world.frame_b.R.T[3,1];
//   mounting1D.frame_a.R.T[3,2] = rev.frame_a.R.T[3,2];
//   mounting1D.frame_a.R.T[3,2] = rod2.frame_a.R.T[3,2];
//   mounting1D.frame_a.R.T[3,2] = world.frame_b.R.T[3,2];
//   mounting1D.frame_a.R.T[3,3] = rev.frame_a.R.T[3,3];
//   mounting1D.frame_a.R.T[3,3] = rod2.frame_a.R.T[3,3];
//   mounting1D.frame_a.R.T[3,3] = world.frame_b.R.T[3,3];
//   mounting1D.frame_a.r_0[1] = rev.frame_a.r_0[1];
//   mounting1D.frame_a.r_0[1] = rod2.frame_a.r_0[1];
//   mounting1D.frame_a.r_0[1] = world.frame_b.r_0[1];
//   mounting1D.frame_a.r_0[2] = rev.frame_a.r_0[2];
//   mounting1D.frame_a.r_0[2] = rod2.frame_a.r_0[2];
//   mounting1D.frame_a.r_0[2] = world.frame_b.r_0[2];
//   mounting1D.frame_a.r_0[3] = rev.frame_a.r_0[3];
//   mounting1D.frame_a.r_0[3] = rod2.frame_a.r_0[3];
//   mounting1D.frame_a.r_0[3] = world.frame_b.r_0[3];
//   mounting1D.flange_b.tau + position.support.tau = 0.0;
//   mounting1D.flange_b.phi = position.support.phi;
//   position.phi_ref = sine.y;
//   jointRRR3.frame_ia.t[1] + body3.frame_a.t[1] = 0.0;
//   jointRRR3.frame_ia.t[2] + body3.frame_a.t[2] = 0.0;
//   jointRRR3.frame_ia.t[3] + body3.frame_a.t[3] = 0.0;
//   jointRRR3.frame_ia.f[1] + body3.frame_a.f[1] = 0.0;
//   jointRRR3.frame_ia.f[2] + body3.frame_a.f[2] = 0.0;
//   jointRRR3.frame_ia.f[3] + body3.frame_a.f[3] = 0.0;
//   body3.frame_a.R.w[1] = jointRRR3.frame_ia.R.w[1];
//   body3.frame_a.R.w[2] = jointRRR3.frame_ia.R.w[2];
//   body3.frame_a.R.w[3] = jointRRR3.frame_ia.R.w[3];
//   body3.frame_a.R.T[1,1] = jointRRR3.frame_ia.R.T[1,1];
//   body3.frame_a.R.T[1,2] = jointRRR3.frame_ia.R.T[1,2];
//   body3.frame_a.R.T[1,3] = jointRRR3.frame_ia.R.T[1,3];
//   body3.frame_a.R.T[2,1] = jointRRR3.frame_ia.R.T[2,1];
//   body3.frame_a.R.T[2,2] = jointRRR3.frame_ia.R.T[2,2];
//   body3.frame_a.R.T[2,3] = jointRRR3.frame_ia.R.T[2,3];
//   body3.frame_a.R.T[3,1] = jointRRR3.frame_ia.R.T[3,1];
//   body3.frame_a.R.T[3,2] = jointRRR3.frame_ia.R.T[3,2];
//   body3.frame_a.R.T[3,3] = jointRRR3.frame_ia.R.T[3,3];
//   body3.frame_a.r_0[1] = jointRRR3.frame_ia.r_0[1];
//   body3.frame_a.r_0[2] = jointRRR3.frame_ia.r_0[2];
//   body3.frame_a.r_0[3] = jointRRR3.frame_ia.r_0[3];
//   jointRRR2.frame_im.t[1] + jointRRR3.frame_a.t[1] = 0.0;
//   jointRRR2.frame_im.t[2] + jointRRR3.frame_a.t[2] = 0.0;
//   jointRRR2.frame_im.t[3] + jointRRR3.frame_a.t[3] = 0.0;
//   jointRRR2.frame_im.f[1] + jointRRR3.frame_a.f[1] = 0.0;
//   jointRRR2.frame_im.f[2] + jointRRR3.frame_a.f[2] = 0.0;
//   jointRRR2.frame_im.f[3] + jointRRR3.frame_a.f[3] = 0.0;
//   jointRRR2.frame_im.R.w[1] = jointRRR3.frame_a.R.w[1];
//   jointRRR2.frame_im.R.w[2] = jointRRR3.frame_a.R.w[2];
//   jointRRR2.frame_im.R.w[3] = jointRRR3.frame_a.R.w[3];
//   jointRRR2.frame_im.R.T[1,1] = jointRRR3.frame_a.R.T[1,1];
//   jointRRR2.frame_im.R.T[1,2] = jointRRR3.frame_a.R.T[1,2];
//   jointRRR2.frame_im.R.T[1,3] = jointRRR3.frame_a.R.T[1,3];
//   jointRRR2.frame_im.R.T[2,1] = jointRRR3.frame_a.R.T[2,1];
//   jointRRR2.frame_im.R.T[2,2] = jointRRR3.frame_a.R.T[2,2];
//   jointRRR2.frame_im.R.T[2,3] = jointRRR3.frame_a.R.T[2,3];
//   jointRRR2.frame_im.R.T[3,1] = jointRRR3.frame_a.R.T[3,1];
//   jointRRR2.frame_im.R.T[3,2] = jointRRR3.frame_a.R.T[3,2];
//   jointRRR2.frame_im.R.T[3,3] = jointRRR3.frame_a.R.T[3,3];
//   jointRRR2.frame_im.r_0[1] = jointRRR3.frame_a.r_0[1];
//   jointRRR2.frame_im.r_0[2] = jointRRR3.frame_a.r_0[2];
//   jointRRR2.frame_im.r_0[3] = jointRRR3.frame_a.r_0[3];
//   rod4.frame_b.t[1] + jointRRR3.frame_b.t[1] = 0.0;
//   rod4.frame_b.t[2] + jointRRR3.frame_b.t[2] = 0.0;
//   rod4.frame_b.t[3] + jointRRR3.frame_b.t[3] = 0.0;
//   rod4.frame_b.f[1] + jointRRR3.frame_b.f[1] = 0.0;
//   rod4.frame_b.f[2] + jointRRR3.frame_b.f[2] = 0.0;
//   rod4.frame_b.f[3] + jointRRR3.frame_b.f[3] = 0.0;
//   jointRRR3.frame_b.R.w[1] = rod4.frame_b.R.w[1];
//   jointRRR3.frame_b.R.w[2] = rod4.frame_b.R.w[2];
//   jointRRR3.frame_b.R.w[3] = rod4.frame_b.R.w[3];
//   jointRRR3.frame_b.R.T[1,1] = rod4.frame_b.R.T[1,1];
//   jointRRR3.frame_b.R.T[1,2] = rod4.frame_b.R.T[1,2];
//   jointRRR3.frame_b.R.T[1,3] = rod4.frame_b.R.T[1,3];
//   jointRRR3.frame_b.R.T[2,1] = rod4.frame_b.R.T[2,1];
//   jointRRR3.frame_b.R.T[2,2] = rod4.frame_b.R.T[2,2];
//   jointRRR3.frame_b.R.T[2,3] = rod4.frame_b.R.T[2,3];
//   jointRRR3.frame_b.R.T[3,1] = rod4.frame_b.R.T[3,1];
//   jointRRR3.frame_b.R.T[3,2] = rod4.frame_b.R.T[3,2];
//   jointRRR3.frame_b.R.T[3,3] = rod4.frame_b.R.T[3,3];
//   jointRRR3.frame_b.r_0[1] = rod4.frame_b.r_0[1];
//   jointRRR3.frame_b.r_0[2] = rod4.frame_b.r_0[2];
//   jointRRR3.frame_b.r_0[3] = rod4.frame_b.r_0[3];
//   rod3.frame_b.t[1] + (jointRRR2.frame_b.t[1] + rod4.frame_a.t[1]) = 0.0;
//   rod3.frame_b.t[2] + (jointRRR2.frame_b.t[2] + rod4.frame_a.t[2]) = 0.0;
//   rod3.frame_b.t[3] + (jointRRR2.frame_b.t[3] + rod4.frame_a.t[3]) = 0.0;
//   rod3.frame_b.f[1] + (jointRRR2.frame_b.f[1] + rod4.frame_a.f[1]) = 0.0;
//   rod3.frame_b.f[2] + (jointRRR2.frame_b.f[2] + rod4.frame_a.f[2]) = 0.0;
//   rod3.frame_b.f[3] + (jointRRR2.frame_b.f[3] + rod4.frame_a.f[3]) = 0.0;
//   jointRRR2.frame_b.R.w[1] = rod3.frame_b.R.w[1];
//   jointRRR2.frame_b.R.w[1] = rod4.frame_a.R.w[1];
//   jointRRR2.frame_b.R.w[2] = rod3.frame_b.R.w[2];
//   jointRRR2.frame_b.R.w[2] = rod4.frame_a.R.w[2];
//   jointRRR2.frame_b.R.w[3] = rod3.frame_b.R.w[3];
//   jointRRR2.frame_b.R.w[3] = rod4.frame_a.R.w[3];
//   jointRRR2.frame_b.R.T[1,1] = rod3.frame_b.R.T[1,1];
//   jointRRR2.frame_b.R.T[1,1] = rod4.frame_a.R.T[1,1];
//   jointRRR2.frame_b.R.T[1,2] = rod3.frame_b.R.T[1,2];
//   jointRRR2.frame_b.R.T[1,2] = rod4.frame_a.R.T[1,2];
//   jointRRR2.frame_b.R.T[1,3] = rod3.frame_b.R.T[1,3];
//   jointRRR2.frame_b.R.T[1,3] = rod4.frame_a.R.T[1,3];
//   jointRRR2.frame_b.R.T[2,1] = rod3.frame_b.R.T[2,1];
//   jointRRR2.frame_b.R.T[2,1] = rod4.frame_a.R.T[2,1];
//   jointRRR2.frame_b.R.T[2,2] = rod3.frame_b.R.T[2,2];
//   jointRRR2.frame_b.R.T[2,2] = rod4.frame_a.R.T[2,2];
//   jointRRR2.frame_b.R.T[2,3] = rod3.frame_b.R.T[2,3];
//   jointRRR2.frame_b.R.T[2,3] = rod4.frame_a.R.T[2,3];
//   jointRRR2.frame_b.R.T[3,1] = rod3.frame_b.R.T[3,1];
//   jointRRR2.frame_b.R.T[3,1] = rod4.frame_a.R.T[3,1];
//   jointRRR2.frame_b.R.T[3,2] = rod3.frame_b.R.T[3,2];
//   jointRRR2.frame_b.R.T[3,2] = rod4.frame_a.R.T[3,2];
//   jointRRR2.frame_b.R.T[3,3] = rod3.frame_b.R.T[3,3];
//   jointRRR2.frame_b.R.T[3,3] = rod4.frame_a.R.T[3,3];
//   jointRRR2.frame_b.r_0[1] = rod3.frame_b.r_0[1];
//   jointRRR2.frame_b.r_0[1] = rod4.frame_a.r_0[1];
//   jointRRR2.frame_b.r_0[2] = rod3.frame_b.r_0[2];
//   jointRRR2.frame_b.r_0[2] = rod4.frame_a.r_0[2];
//   jointRRR2.frame_b.r_0[3] = rod3.frame_b.r_0[3];
//   jointRRR2.frame_b.r_0[3] = rod4.frame_a.r_0[3];
//   jointRRR1.frame_im.t[1] + jointRRR2.frame_a.t[1] = 0.0;
//   jointRRR1.frame_im.t[2] + jointRRR2.frame_a.t[2] = 0.0;
//   jointRRR1.frame_im.t[3] + jointRRR2.frame_a.t[3] = 0.0;
//   jointRRR1.frame_im.f[1] + jointRRR2.frame_a.f[1] = 0.0;
//   jointRRR1.frame_im.f[2] + jointRRR2.frame_a.f[2] = 0.0;
//   jointRRR1.frame_im.f[3] + jointRRR2.frame_a.f[3] = 0.0;
//   jointRRR1.frame_im.R.w[1] = jointRRR2.frame_a.R.w[1];
//   jointRRR1.frame_im.R.w[2] = jointRRR2.frame_a.R.w[2];
//   jointRRR1.frame_im.R.w[3] = jointRRR2.frame_a.R.w[3];
//   jointRRR1.frame_im.R.T[1,1] = jointRRR2.frame_a.R.T[1,1];
//   jointRRR1.frame_im.R.T[1,2] = jointRRR2.frame_a.R.T[1,2];
//   jointRRR1.frame_im.R.T[1,3] = jointRRR2.frame_a.R.T[1,3];
//   jointRRR1.frame_im.R.T[2,1] = jointRRR2.frame_a.R.T[2,1];
//   jointRRR1.frame_im.R.T[2,2] = jointRRR2.frame_a.R.T[2,2];
//   jointRRR1.frame_im.R.T[2,3] = jointRRR2.frame_a.R.T[2,3];
//   jointRRR1.frame_im.R.T[3,1] = jointRRR2.frame_a.R.T[3,1];
//   jointRRR1.frame_im.R.T[3,2] = jointRRR2.frame_a.R.T[3,2];
//   jointRRR1.frame_im.R.T[3,3] = jointRRR2.frame_a.R.T[3,3];
//   jointRRR1.frame_im.r_0[1] = jointRRR2.frame_a.r_0[1];
//   jointRRR1.frame_im.r_0[2] = jointRRR2.frame_a.r_0[2];
//   jointRRR1.frame_im.r_0[3] = jointRRR2.frame_a.r_0[3];
//   jointRRR2.frame_ia.t[1] + body2.frame_a.t[1] = 0.0;
//   jointRRR2.frame_ia.t[2] + body2.frame_a.t[2] = 0.0;
//   jointRRR2.frame_ia.t[3] + body2.frame_a.t[3] = 0.0;
//   jointRRR2.frame_ia.f[1] + body2.frame_a.f[1] = 0.0;
//   jointRRR2.frame_ia.f[2] + body2.frame_a.f[2] = 0.0;
//   jointRRR2.frame_ia.f[3] + body2.frame_a.f[3] = 0.0;
//   body2.frame_a.R.w[1] = jointRRR2.frame_ia.R.w[1];
//   body2.frame_a.R.w[2] = jointRRR2.frame_ia.R.w[2];
//   body2.frame_a.R.w[3] = jointRRR2.frame_ia.R.w[3];
//   body2.frame_a.R.T[1,1] = jointRRR2.frame_ia.R.T[1,1];
//   body2.frame_a.R.T[1,2] = jointRRR2.frame_ia.R.T[1,2];
//   body2.frame_a.R.T[1,3] = jointRRR2.frame_ia.R.T[1,3];
//   body2.frame_a.R.T[2,1] = jointRRR2.frame_ia.R.T[2,1];
//   body2.frame_a.R.T[2,2] = jointRRR2.frame_ia.R.T[2,2];
//   body2.frame_a.R.T[2,3] = jointRRR2.frame_ia.R.T[2,3];
//   body2.frame_a.R.T[3,1] = jointRRR2.frame_ia.R.T[3,1];
//   body2.frame_a.R.T[3,2] = jointRRR2.frame_ia.R.T[3,2];
//   body2.frame_a.R.T[3,3] = jointRRR2.frame_ia.R.T[3,3];
//   body2.frame_a.r_0[1] = jointRRR2.frame_ia.r_0[1];
//   body2.frame_a.r_0[2] = jointRRR2.frame_ia.r_0[2];
//   body2.frame_a.r_0[3] = jointRRR2.frame_ia.r_0[3];
//   rod3.frame_a.t[1] + (rod2.frame_b.t[1] + jointRRR1.frame_b.t[1]) = 0.0;
//   rod3.frame_a.t[2] + (rod2.frame_b.t[2] + jointRRR1.frame_b.t[2]) = 0.0;
//   rod3.frame_a.t[3] + (rod2.frame_b.t[3] + jointRRR1.frame_b.t[3]) = 0.0;
//   rod3.frame_a.f[1] + (rod2.frame_b.f[1] + jointRRR1.frame_b.f[1]) = 0.0;
//   rod3.frame_a.f[2] + (rod2.frame_b.f[2] + jointRRR1.frame_b.f[2]) = 0.0;
//   rod3.frame_a.f[3] + (rod2.frame_b.f[3] + jointRRR1.frame_b.f[3]) = 0.0;
//   jointRRR1.frame_b.R.w[1] = rod2.frame_b.R.w[1];
//   jointRRR1.frame_b.R.w[1] = rod3.frame_a.R.w[1];
//   jointRRR1.frame_b.R.w[2] = rod2.frame_b.R.w[2];
//   jointRRR1.frame_b.R.w[2] = rod3.frame_a.R.w[2];
//   jointRRR1.frame_b.R.w[3] = rod2.frame_b.R.w[3];
//   jointRRR1.frame_b.R.w[3] = rod3.frame_a.R.w[3];
//   jointRRR1.frame_b.R.T[1,1] = rod2.frame_b.R.T[1,1];
//   jointRRR1.frame_b.R.T[1,1] = rod3.frame_a.R.T[1,1];
//   jointRRR1.frame_b.R.T[1,2] = rod2.frame_b.R.T[1,2];
//   jointRRR1.frame_b.R.T[1,2] = rod3.frame_a.R.T[1,2];
//   jointRRR1.frame_b.R.T[1,3] = rod2.frame_b.R.T[1,3];
//   jointRRR1.frame_b.R.T[1,3] = rod3.frame_a.R.T[1,3];
//   jointRRR1.frame_b.R.T[2,1] = rod2.frame_b.R.T[2,1];
//   jointRRR1.frame_b.R.T[2,1] = rod3.frame_a.R.T[2,1];
//   jointRRR1.frame_b.R.T[2,2] = rod2.frame_b.R.T[2,2];
//   jointRRR1.frame_b.R.T[2,2] = rod3.frame_a.R.T[2,2];
//   jointRRR1.frame_b.R.T[2,3] = rod2.frame_b.R.T[2,3];
//   jointRRR1.frame_b.R.T[2,3] = rod3.frame_a.R.T[2,3];
//   jointRRR1.frame_b.R.T[3,1] = rod2.frame_b.R.T[3,1];
//   jointRRR1.frame_b.R.T[3,1] = rod3.frame_a.R.T[3,1];
//   jointRRR1.frame_b.R.T[3,2] = rod2.frame_b.R.T[3,2];
//   jointRRR1.frame_b.R.T[3,2] = rod3.frame_a.R.T[3,2];
//   jointRRR1.frame_b.R.T[3,3] = rod2.frame_b.R.T[3,3];
//   jointRRR1.frame_b.R.T[3,3] = rod3.frame_a.R.T[3,3];
//   jointRRR1.frame_b.r_0[1] = rod2.frame_b.r_0[1];
//   jointRRR1.frame_b.r_0[1] = rod3.frame_a.r_0[1];
//   jointRRR1.frame_b.r_0[2] = rod2.frame_b.r_0[2];
//   jointRRR1.frame_b.r_0[2] = rod3.frame_a.r_0[2];
//   jointRRR1.frame_b.r_0[3] = rod2.frame_b.r_0[3];
//   jointRRR1.frame_b.r_0[3] = rod3.frame_a.r_0[3];
//   jointRRR1.frame_ia.t[1] + body1.frame_a.t[1] = 0.0;
//   jointRRR1.frame_ia.t[2] + body1.frame_a.t[2] = 0.0;
//   jointRRR1.frame_ia.t[3] + body1.frame_a.t[3] = 0.0;
//   jointRRR1.frame_ia.f[1] + body1.frame_a.f[1] = 0.0;
//   jointRRR1.frame_ia.f[2] + body1.frame_a.f[2] = 0.0;
//   jointRRR1.frame_ia.f[3] + body1.frame_a.f[3] = 0.0;
//   body1.frame_a.R.w[1] = jointRRR1.frame_ia.R.w[1];
//   body1.frame_a.R.w[2] = jointRRR1.frame_ia.R.w[2];
//   body1.frame_a.R.w[3] = jointRRR1.frame_ia.R.w[3];
//   body1.frame_a.R.T[1,1] = jointRRR1.frame_ia.R.T[1,1];
//   body1.frame_a.R.T[1,2] = jointRRR1.frame_ia.R.T[1,2];
//   body1.frame_a.R.T[1,3] = jointRRR1.frame_ia.R.T[1,3];
//   body1.frame_a.R.T[2,1] = jointRRR1.frame_ia.R.T[2,1];
//   body1.frame_a.R.T[2,2] = jointRRR1.frame_ia.R.T[2,2];
//   body1.frame_a.R.T[2,3] = jointRRR1.frame_ia.R.T[2,3];
//   body1.frame_a.R.T[3,1] = jointRRR1.frame_ia.R.T[3,1];
//   body1.frame_a.R.T[3,2] = jointRRR1.frame_ia.R.T[3,2];
//   body1.frame_a.R.T[3,3] = jointRRR1.frame_ia.R.T[3,3];
//   body1.frame_a.r_0[1] = jointRRR1.frame_ia.r_0[1];
//   body1.frame_a.r_0[2] = jointRRR1.frame_ia.r_0[2];
//   body1.frame_a.r_0[3] = jointRRR1.frame_ia.r_0[3];
//   rod1.frame_b.t[1] + jointRRR1.frame_a.t[1] = 0.0;
//   rod1.frame_b.t[2] + jointRRR1.frame_a.t[2] = 0.0;
//   rod1.frame_b.t[3] + jointRRR1.frame_a.t[3] = 0.0;
//   rod1.frame_b.f[1] + jointRRR1.frame_a.f[1] = 0.0;
//   rod1.frame_b.f[2] + jointRRR1.frame_a.f[2] = 0.0;
//   rod1.frame_b.f[3] + jointRRR1.frame_a.f[3] = 0.0;
//   jointRRR1.frame_a.R.w[1] = rod1.frame_b.R.w[1];
//   jointRRR1.frame_a.R.w[2] = rod1.frame_b.R.w[2];
//   jointRRR1.frame_a.R.w[3] = rod1.frame_b.R.w[3];
//   jointRRR1.frame_a.R.T[1,1] = rod1.frame_b.R.T[1,1];
//   jointRRR1.frame_a.R.T[1,2] = rod1.frame_b.R.T[1,2];
//   jointRRR1.frame_a.R.T[1,3] = rod1.frame_b.R.T[1,3];
//   jointRRR1.frame_a.R.T[2,1] = rod1.frame_b.R.T[2,1];
//   jointRRR1.frame_a.R.T[2,2] = rod1.frame_b.R.T[2,2];
//   jointRRR1.frame_a.R.T[2,3] = rod1.frame_b.R.T[2,3];
//   jointRRR1.frame_a.R.T[3,1] = rod1.frame_b.R.T[3,1];
//   jointRRR1.frame_a.R.T[3,2] = rod1.frame_b.R.T[3,2];
//   jointRRR1.frame_a.R.T[3,3] = rod1.frame_b.R.T[3,3];
//   jointRRR1.frame_a.r_0[1] = rod1.frame_b.r_0[1];
//   jointRRR1.frame_a.r_0[2] = rod1.frame_b.r_0[2];
//   jointRRR1.frame_a.r_0[3] = rod1.frame_b.r_0[3];
//   rod1.frame_a.t[1] + rev.frame_b.t[1] = 0.0;
//   rod1.frame_a.t[2] + rev.frame_b.t[2] = 0.0;
//   rod1.frame_a.t[3] + rev.frame_b.t[3] = 0.0;
//   rod1.frame_a.f[1] + rev.frame_b.f[1] = 0.0;
//   rod1.frame_a.f[2] + rev.frame_b.f[2] = 0.0;
//   rod1.frame_a.f[3] + rev.frame_b.f[3] = 0.0;
//   rev.frame_b.R.w[1] = rod1.frame_a.R.w[1];
//   rev.frame_b.R.w[2] = rod1.frame_a.R.w[2];
//   rev.frame_b.R.w[3] = rod1.frame_a.R.w[3];
//   rev.frame_b.R.T[1,1] = rod1.frame_a.R.T[1,1];
//   rev.frame_b.R.T[1,2] = rod1.frame_a.R.T[1,2];
//   rev.frame_b.R.T[1,3] = rod1.frame_a.R.T[1,3];
//   rev.frame_b.R.T[2,1] = rod1.frame_a.R.T[2,1];
//   rev.frame_b.R.T[2,2] = rod1.frame_a.R.T[2,2];
//   rev.frame_b.R.T[2,3] = rod1.frame_a.R.T[2,3];
//   rev.frame_b.R.T[3,1] = rod1.frame_a.R.T[3,1];
//   rev.frame_b.R.T[3,2] = rod1.frame_a.R.T[3,2];
//   rev.frame_b.R.T[3,3] = rod1.frame_a.R.T[3,3];
//   rev.frame_b.r_0[1] = rod1.frame_a.r_0[1];
//   rev.frame_b.r_0[2] = rod1.frame_a.r_0[2];
//   rev.frame_b.r_0[3] = rod1.frame_a.r_0[3];
//   mounting1D.housing.frame_a.t[1] + (-mounting1D.frame_a.t[1]) = 0.0;
//   mounting1D.housing.frame_a.t[2] + (-mounting1D.frame_a.t[2]) = 0.0;
//   mounting1D.housing.frame_a.t[3] + (-mounting1D.frame_a.t[3]) = 0.0;
//   mounting1D.housing.frame_a.f[1] + (-mounting1D.frame_a.f[1]) = 0.0;
//   mounting1D.housing.frame_a.f[2] + (-mounting1D.frame_a.f[2]) = 0.0;
//   mounting1D.housing.frame_a.f[3] + (-mounting1D.frame_a.f[3]) = 0.0;
//   mounting1D.frame_a.R.w[1] = mounting1D.housing.frame_a.R.w[1];
//   mounting1D.frame_a.R.w[2] = mounting1D.housing.frame_a.R.w[2];
//   mounting1D.frame_a.R.w[3] = mounting1D.housing.frame_a.R.w[3];
//   mounting1D.frame_a.R.T[1,1] = mounting1D.housing.frame_a.R.T[1,1];
//   mounting1D.frame_a.R.T[1,2] = mounting1D.housing.frame_a.R.T[1,2];
//   mounting1D.frame_a.R.T[1,3] = mounting1D.housing.frame_a.R.T[1,3];
//   mounting1D.frame_a.R.T[2,1] = mounting1D.housing.frame_a.R.T[2,1];
//   mounting1D.frame_a.R.T[2,2] = mounting1D.housing.frame_a.R.T[2,2];
//   mounting1D.frame_a.R.T[2,3] = mounting1D.housing.frame_a.R.T[2,3];
//   mounting1D.frame_a.R.T[3,1] = mounting1D.housing.frame_a.R.T[3,1];
//   mounting1D.frame_a.R.T[3,2] = mounting1D.housing.frame_a.R.T[3,2];
//   mounting1D.frame_a.R.T[3,3] = mounting1D.housing.frame_a.R.T[3,3];
//   mounting1D.frame_a.r_0[1] = mounting1D.housing.frame_a.r_0[1];
//   mounting1D.frame_a.r_0[2] = mounting1D.housing.frame_a.r_0[2];
//   mounting1D.frame_a.r_0[3] = mounting1D.housing.frame_a.r_0[3];
//   jointRRR3.jointUSR.bearing.tau + (-jointRRR3.bearing.tau) = 0.0;
//   jointRRR3.bearing.phi = jointRRR3.jointUSR.bearing.phi;
//   jointRRR3.jointUSR.axis.tau + (-jointRRR3.axis.tau) = 0.0;
//   jointRRR3.axis.phi = jointRRR3.jointUSR.axis.phi;
//   jointRRR3.jointUSR.frame_ib.t[1] + (-jointRRR3.frame_ib.t[1]) = 0.0;
//   jointRRR3.jointUSR.frame_ib.t[2] + (-jointRRR3.frame_ib.t[2]) = 0.0;
//   jointRRR3.jointUSR.frame_ib.t[3] + (-jointRRR3.frame_ib.t[3]) = 0.0;
//   jointRRR3.jointUSR.frame_ib.f[1] + (-jointRRR3.frame_ib.f[1]) = 0.0;
//   jointRRR3.jointUSR.frame_ib.f[2] + (-jointRRR3.frame_ib.f[2]) = 0.0;
//   jointRRR3.jointUSR.frame_ib.f[3] + (-jointRRR3.frame_ib.f[3]) = 0.0;
//   jointRRR3.frame_ib.R.w[1] = jointRRR3.jointUSR.frame_ib.R.w[1];
//   jointRRR3.frame_ib.R.w[2] = jointRRR3.jointUSR.frame_ib.R.w[2];
//   jointRRR3.frame_ib.R.w[3] = jointRRR3.jointUSR.frame_ib.R.w[3];
//   jointRRR3.frame_ib.R.T[1,1] = jointRRR3.jointUSR.frame_ib.R.T[1,1];
//   jointRRR3.frame_ib.R.T[1,2] = jointRRR3.jointUSR.frame_ib.R.T[1,2];
//   jointRRR3.frame_ib.R.T[1,3] = jointRRR3.jointUSR.frame_ib.R.T[1,3];
//   jointRRR3.frame_ib.R.T[2,1] = jointRRR3.jointUSR.frame_ib.R.T[2,1];
//   jointRRR3.frame_ib.R.T[2,2] = jointRRR3.jointUSR.frame_ib.R.T[2,2];
//   jointRRR3.frame_ib.R.T[2,3] = jointRRR3.jointUSR.frame_ib.R.T[2,3];
//   jointRRR3.frame_ib.R.T[3,1] = jointRRR3.jointUSR.frame_ib.R.T[3,1];
//   jointRRR3.frame_ib.R.T[3,2] = jointRRR3.jointUSR.frame_ib.R.T[3,2];
//   jointRRR3.frame_ib.R.T[3,3] = jointRRR3.jointUSR.frame_ib.R.T[3,3];
//   jointRRR3.frame_ib.r_0[1] = jointRRR3.jointUSR.frame_ib.r_0[1];
//   jointRRR3.frame_ib.r_0[2] = jointRRR3.jointUSR.frame_ib.r_0[2];
//   jointRRR3.frame_ib.r_0[3] = jointRRR3.jointUSR.frame_ib.r_0[3];
//   jointRRR3.jointUSR.frame_im.t[1] + (-jointRRR3.frame_im.t[1]) = 0.0;
//   jointRRR3.jointUSR.frame_im.t[2] + (-jointRRR3.frame_im.t[2]) = 0.0;
//   jointRRR3.jointUSR.frame_im.t[3] + (-jointRRR3.frame_im.t[3]) = 0.0;
//   jointRRR3.jointUSR.frame_im.f[1] + (-jointRRR3.frame_im.f[1]) = 0.0;
//   jointRRR3.jointUSR.frame_im.f[2] + (-jointRRR3.frame_im.f[2]) = 0.0;
//   jointRRR3.jointUSR.frame_im.f[3] + (-jointRRR3.frame_im.f[3]) = 0.0;
//   jointRRR3.frame_im.R.w[1] = jointRRR3.jointUSR.frame_im.R.w[1];
//   jointRRR3.frame_im.R.w[2] = jointRRR3.jointUSR.frame_im.R.w[2];
//   jointRRR3.frame_im.R.w[3] = jointRRR3.jointUSR.frame_im.R.w[3];
//   jointRRR3.frame_im.R.T[1,1] = jointRRR3.jointUSR.frame_im.R.T[1,1];
//   jointRRR3.frame_im.R.T[1,2] = jointRRR3.jointUSR.frame_im.R.T[1,2];
//   jointRRR3.frame_im.R.T[1,3] = jointRRR3.jointUSR.frame_im.R.T[1,3];
//   jointRRR3.frame_im.R.T[2,1] = jointRRR3.jointUSR.frame_im.R.T[2,1];
//   jointRRR3.frame_im.R.T[2,2] = jointRRR3.jointUSR.frame_im.R.T[2,2];
//   jointRRR3.frame_im.R.T[2,3] = jointRRR3.jointUSR.frame_im.R.T[2,3];
//   jointRRR3.frame_im.R.T[3,1] = jointRRR3.jointUSR.frame_im.R.T[3,1];
//   jointRRR3.frame_im.R.T[3,2] = jointRRR3.jointUSR.frame_im.R.T[3,2];
//   jointRRR3.frame_im.R.T[3,3] = jointRRR3.jointUSR.frame_im.R.T[3,3];
//   jointRRR3.frame_im.r_0[1] = jointRRR3.jointUSR.frame_im.r_0[1];
//   jointRRR3.frame_im.r_0[2] = jointRRR3.jointUSR.frame_im.r_0[2];
//   jointRRR3.frame_im.r_0[3] = jointRRR3.jointUSR.frame_im.r_0[3];
//   jointRRR3.jointUSR.frame_ia.t[1] + (-jointRRR3.frame_ia.t[1]) = 0.0;
//   jointRRR3.jointUSR.frame_ia.t[2] + (-jointRRR3.frame_ia.t[2]) = 0.0;
//   jointRRR3.jointUSR.frame_ia.t[3] + (-jointRRR3.frame_ia.t[3]) = 0.0;
//   jointRRR3.jointUSR.frame_ia.f[1] + (-jointRRR3.frame_ia.f[1]) = 0.0;
//   jointRRR3.jointUSR.frame_ia.f[2] + (-jointRRR3.frame_ia.f[2]) = 0.0;
//   jointRRR3.jointUSR.frame_ia.f[3] + (-jointRRR3.frame_ia.f[3]) = 0.0;
//   jointRRR3.frame_ia.R.w[1] = jointRRR3.jointUSR.frame_ia.R.w[1];
//   jointRRR3.frame_ia.R.w[2] = jointRRR3.jointUSR.frame_ia.R.w[2];
//   jointRRR3.frame_ia.R.w[3] = jointRRR3.jointUSR.frame_ia.R.w[3];
//   jointRRR3.frame_ia.R.T[1,1] = jointRRR3.jointUSR.frame_ia.R.T[1,1];
//   jointRRR3.frame_ia.R.T[1,2] = jointRRR3.jointUSR.frame_ia.R.T[1,2];
//   jointRRR3.frame_ia.R.T[1,3] = jointRRR3.jointUSR.frame_ia.R.T[1,3];
//   jointRRR3.frame_ia.R.T[2,1] = jointRRR3.jointUSR.frame_ia.R.T[2,1];
//   jointRRR3.frame_ia.R.T[2,2] = jointRRR3.jointUSR.frame_ia.R.T[2,2];
//   jointRRR3.frame_ia.R.T[2,3] = jointRRR3.jointUSR.frame_ia.R.T[2,3];
//   jointRRR3.frame_ia.R.T[3,1] = jointRRR3.jointUSR.frame_ia.R.T[3,1];
//   jointRRR3.frame_ia.R.T[3,2] = jointRRR3.jointUSR.frame_ia.R.T[3,2];
//   jointRRR3.frame_ia.R.T[3,3] = jointRRR3.jointUSR.frame_ia.R.T[3,3];
//   jointRRR3.frame_ia.r_0[1] = jointRRR3.jointUSR.frame_ia.r_0[1];
//   jointRRR3.frame_ia.r_0[2] = jointRRR3.jointUSR.frame_ia.r_0[2];
//   jointRRR3.frame_ia.r_0[3] = jointRRR3.jointUSR.frame_ia.r_0[3];
//   jointRRR3.jointUSR.frame_b.t[1] + (-jointRRR3.frame_b.t[1]) = 0.0;
//   jointRRR3.jointUSR.frame_b.t[2] + (-jointRRR3.frame_b.t[2]) = 0.0;
//   jointRRR3.jointUSR.frame_b.t[3] + (-jointRRR3.frame_b.t[3]) = 0.0;
//   jointRRR3.jointUSR.frame_b.f[1] + (-jointRRR3.frame_b.f[1]) = 0.0;
//   jointRRR3.jointUSR.frame_b.f[2] + (-jointRRR3.frame_b.f[2]) = 0.0;
//   jointRRR3.jointUSR.frame_b.f[3] + (-jointRRR3.frame_b.f[3]) = 0.0;
//   jointRRR3.frame_b.R.w[1] = jointRRR3.jointUSR.frame_b.R.w[1];
//   jointRRR3.frame_b.R.w[2] = jointRRR3.jointUSR.frame_b.R.w[2];
//   jointRRR3.frame_b.R.w[3] = jointRRR3.jointUSR.frame_b.R.w[3];
//   jointRRR3.frame_b.R.T[1,1] = jointRRR3.jointUSR.frame_b.R.T[1,1];
//   jointRRR3.frame_b.R.T[1,2] = jointRRR3.jointUSR.frame_b.R.T[1,2];
//   jointRRR3.frame_b.R.T[1,3] = jointRRR3.jointUSR.frame_b.R.T[1,3];
//   jointRRR3.frame_b.R.T[2,1] = jointRRR3.jointUSR.frame_b.R.T[2,1];
//   jointRRR3.frame_b.R.T[2,2] = jointRRR3.jointUSR.frame_b.R.T[2,2];
//   jointRRR3.frame_b.R.T[2,3] = jointRRR3.jointUSR.frame_b.R.T[2,3];
//   jointRRR3.frame_b.R.T[3,1] = jointRRR3.jointUSR.frame_b.R.T[3,1];
//   jointRRR3.frame_b.R.T[3,2] = jointRRR3.jointUSR.frame_b.R.T[3,2];
//   jointRRR3.frame_b.R.T[3,3] = jointRRR3.jointUSR.frame_b.R.T[3,3];
//   jointRRR3.frame_b.r_0[1] = jointRRR3.jointUSR.frame_b.r_0[1];
//   jointRRR3.frame_b.r_0[2] = jointRRR3.jointUSR.frame_b.r_0[2];
//   jointRRR3.frame_b.r_0[3] = jointRRR3.jointUSR.frame_b.r_0[3];
//   jointRRR3.jointUSR.frame_a.t[1] + (-jointRRR3.frame_a.t[1]) = 0.0;
//   jointRRR3.jointUSR.frame_a.t[2] + (-jointRRR3.frame_a.t[2]) = 0.0;
//   jointRRR3.jointUSR.frame_a.t[3] + (-jointRRR3.frame_a.t[3]) = 0.0;
//   jointRRR3.jointUSR.frame_a.f[1] + (-jointRRR3.frame_a.f[1]) = 0.0;
//   jointRRR3.jointUSR.frame_a.f[2] + (-jointRRR3.frame_a.f[2]) = 0.0;
//   jointRRR3.jointUSR.frame_a.f[3] + (-jointRRR3.frame_a.f[3]) = 0.0;
//   jointRRR3.frame_a.R.w[1] = jointRRR3.jointUSR.frame_a.R.w[1];
//   jointRRR3.frame_a.R.w[2] = jointRRR3.jointUSR.frame_a.R.w[2];
//   jointRRR3.frame_a.R.w[3] = jointRRR3.jointUSR.frame_a.R.w[3];
//   jointRRR3.frame_a.R.T[1,1] = jointRRR3.jointUSR.frame_a.R.T[1,1];
//   jointRRR3.frame_a.R.T[1,2] = jointRRR3.jointUSR.frame_a.R.T[1,2];
//   jointRRR3.frame_a.R.T[1,3] = jointRRR3.jointUSR.frame_a.R.T[1,3];
//   jointRRR3.frame_a.R.T[2,1] = jointRRR3.jointUSR.frame_a.R.T[2,1];
//   jointRRR3.frame_a.R.T[2,2] = jointRRR3.jointUSR.frame_a.R.T[2,2];
//   jointRRR3.frame_a.R.T[2,3] = jointRRR3.jointUSR.frame_a.R.T[2,3];
//   jointRRR3.frame_a.R.T[3,1] = jointRRR3.jointUSR.frame_a.R.T[3,1];
//   jointRRR3.frame_a.R.T[3,2] = jointRRR3.jointUSR.frame_a.R.T[3,2];
//   jointRRR3.frame_a.R.T[3,3] = jointRRR3.jointUSR.frame_a.R.T[3,3];
//   jointRRR3.frame_a.r_0[1] = jointRRR3.jointUSR.frame_a.r_0[1];
//   jointRRR3.frame_a.r_0[2] = jointRRR3.jointUSR.frame_a.r_0[2];
//   jointRRR3.frame_a.r_0[3] = jointRRR3.jointUSR.frame_a.r_0[3];
//   jointRRR3.jointUSR.revolute.bearing.tau + (-jointRRR3.jointUSR.bearing.tau) = 0.0;
//   jointRRR3.jointUSR.bearing.phi = jointRRR3.jointUSR.revolute.bearing.phi;
//   jointRRR3.jointUSR.relativePosition.r_rel[1] = jointRRR3.jointUSR.revolute.position_a[1];
//   jointRRR3.jointUSR.relativePosition.r_rel[2] = jointRRR3.jointUSR.revolute.position_a[2];
//   jointRRR3.jointUSR.relativePosition.r_rel[3] = jointRRR3.jointUSR.revolute.position_a[3];
//   jointRRR3.jointUSR.revolute.axis.tau + (-jointRRR3.jointUSR.axis.tau) = 0.0;
//   jointRRR3.jointUSR.axis.phi = jointRRR3.jointUSR.revolute.axis.phi;
//   jointRRR3.jointUSR.rod1.frame_ia.t[1] + (-jointRRR3.jointUSR.frame_ia.t[1]) = 0.0;
//   jointRRR3.jointUSR.rod1.frame_ia.t[2] + (-jointRRR3.jointUSR.frame_ia.t[2]) = 0.0;
//   jointRRR3.jointUSR.rod1.frame_ia.t[3] + (-jointRRR3.jointUSR.frame_ia.t[3]) = 0.0;
//   jointRRR3.jointUSR.rod1.frame_ia.f[1] + (-jointRRR3.jointUSR.frame_ia.f[1]) = 0.0;
//   jointRRR3.jointUSR.rod1.frame_ia.f[2] + (-jointRRR3.jointUSR.frame_ia.f[2]) = 0.0;
//   jointRRR3.jointUSR.rod1.frame_ia.f[3] + (-jointRRR3.jointUSR.frame_ia.f[3]) = 0.0;
//   jointRRR3.jointUSR.frame_ia.R.w[1] = jointRRR3.jointUSR.rod1.frame_ia.R.w[1];
//   jointRRR3.jointUSR.frame_ia.R.w[2] = jointRRR3.jointUSR.rod1.frame_ia.R.w[2];
//   jointRRR3.jointUSR.frame_ia.R.w[3] = jointRRR3.jointUSR.rod1.frame_ia.R.w[3];
//   jointRRR3.jointUSR.frame_ia.R.T[1,1] = jointRRR3.jointUSR.rod1.frame_ia.R.T[1,1];
//   jointRRR3.jointUSR.frame_ia.R.T[1,2] = jointRRR3.jointUSR.rod1.frame_ia.R.T[1,2];
//   jointRRR3.jointUSR.frame_ia.R.T[1,3] = jointRRR3.jointUSR.rod1.frame_ia.R.T[1,3];
//   jointRRR3.jointUSR.frame_ia.R.T[2,1] = jointRRR3.jointUSR.rod1.frame_ia.R.T[2,1];
//   jointRRR3.jointUSR.frame_ia.R.T[2,2] = jointRRR3.jointUSR.rod1.frame_ia.R.T[2,2];
//   jointRRR3.jointUSR.frame_ia.R.T[2,3] = jointRRR3.jointUSR.rod1.frame_ia.R.T[2,3];
//   jointRRR3.jointUSR.frame_ia.R.T[3,1] = jointRRR3.jointUSR.rod1.frame_ia.R.T[3,1];
//   jointRRR3.jointUSR.frame_ia.R.T[3,2] = jointRRR3.jointUSR.rod1.frame_ia.R.T[3,2];
//   jointRRR3.jointUSR.frame_ia.R.T[3,3] = jointRRR3.jointUSR.rod1.frame_ia.R.T[3,3];
//   jointRRR3.jointUSR.frame_ia.r_0[1] = jointRRR3.jointUSR.rod1.frame_ia.r_0[1];
//   jointRRR3.jointUSR.frame_ia.r_0[2] = jointRRR3.jointUSR.rod1.frame_ia.r_0[2];
//   jointRRR3.jointUSR.frame_ia.r_0[3] = jointRRR3.jointUSR.rod1.frame_ia.r_0[3];
//   jointRRR3.jointUSR.rod2.frame_b.t[1] + (jointRRR3.jointUSR.rod1.frame_b.t[1] + (-jointRRR3.jointUSR.frame_im.t[1])) = 0.0;
//   jointRRR3.jointUSR.rod2.frame_b.t[2] + (jointRRR3.jointUSR.rod1.frame_b.t[2] + (-jointRRR3.jointUSR.frame_im.t[2])) = 0.0;
//   jointRRR3.jointUSR.rod2.frame_b.t[3] + (jointRRR3.jointUSR.rod1.frame_b.t[3] + (-jointRRR3.jointUSR.frame_im.t[3])) = 0.0;
//   jointRRR3.jointUSR.rod2.frame_b.f[1] + (jointRRR3.jointUSR.rod1.frame_b.f[1] + (-jointRRR3.jointUSR.frame_im.f[1])) = 0.0;
//   jointRRR3.jointUSR.rod2.frame_b.f[2] + (jointRRR3.jointUSR.rod1.frame_b.f[2] + (-jointRRR3.jointUSR.frame_im.f[2])) = 0.0;
//   jointRRR3.jointUSR.rod2.frame_b.f[3] + (jointRRR3.jointUSR.rod1.frame_b.f[3] + (-jointRRR3.jointUSR.frame_im.f[3])) = 0.0;
//   jointRRR3.jointUSR.frame_im.R.w[1] = jointRRR3.jointUSR.rod1.frame_b.R.w[1];
//   jointRRR3.jointUSR.frame_im.R.w[1] = jointRRR3.jointUSR.rod2.frame_b.R.w[1];
//   jointRRR3.jointUSR.frame_im.R.w[2] = jointRRR3.jointUSR.rod1.frame_b.R.w[2];
//   jointRRR3.jointUSR.frame_im.R.w[2] = jointRRR3.jointUSR.rod2.frame_b.R.w[2];
//   jointRRR3.jointUSR.frame_im.R.w[3] = jointRRR3.jointUSR.rod1.frame_b.R.w[3];
//   jointRRR3.jointUSR.frame_im.R.w[3] = jointRRR3.jointUSR.rod2.frame_b.R.w[3];
//   jointRRR3.jointUSR.frame_im.R.T[1,1] = jointRRR3.jointUSR.rod1.frame_b.R.T[1,1];
//   jointRRR3.jointUSR.frame_im.R.T[1,1] = jointRRR3.jointUSR.rod2.frame_b.R.T[1,1];
//   jointRRR3.jointUSR.frame_im.R.T[1,2] = jointRRR3.jointUSR.rod1.frame_b.R.T[1,2];
//   jointRRR3.jointUSR.frame_im.R.T[1,2] = jointRRR3.jointUSR.rod2.frame_b.R.T[1,2];
//   jointRRR3.jointUSR.frame_im.R.T[1,3] = jointRRR3.jointUSR.rod1.frame_b.R.T[1,3];
//   jointRRR3.jointUSR.frame_im.R.T[1,3] = jointRRR3.jointUSR.rod2.frame_b.R.T[1,3];
//   jointRRR3.jointUSR.frame_im.R.T[2,1] = jointRRR3.jointUSR.rod1.frame_b.R.T[2,1];
//   jointRRR3.jointUSR.frame_im.R.T[2,1] = jointRRR3.jointUSR.rod2.frame_b.R.T[2,1];
//   jointRRR3.jointUSR.frame_im.R.T[2,2] = jointRRR3.jointUSR.rod1.frame_b.R.T[2,2];
//   jointRRR3.jointUSR.frame_im.R.T[2,2] = jointRRR3.jointUSR.rod2.frame_b.R.T[2,2];
//   jointRRR3.jointUSR.frame_im.R.T[2,3] = jointRRR3.jointUSR.rod1.frame_b.R.T[2,3];
//   jointRRR3.jointUSR.frame_im.R.T[2,3] = jointRRR3.jointUSR.rod2.frame_b.R.T[2,3];
//   jointRRR3.jointUSR.frame_im.R.T[3,1] = jointRRR3.jointUSR.rod1.frame_b.R.T[3,1];
//   jointRRR3.jointUSR.frame_im.R.T[3,1] = jointRRR3.jointUSR.rod2.frame_b.R.T[3,1];
//   jointRRR3.jointUSR.frame_im.R.T[3,2] = jointRRR3.jointUSR.rod1.frame_b.R.T[3,2];
//   jointRRR3.jointUSR.frame_im.R.T[3,2] = jointRRR3.jointUSR.rod2.frame_b.R.T[3,2];
//   jointRRR3.jointUSR.frame_im.R.T[3,3] = jointRRR3.jointUSR.rod1.frame_b.R.T[3,3];
//   jointRRR3.jointUSR.frame_im.R.T[3,3] = jointRRR3.jointUSR.rod2.frame_b.R.T[3,3];
//   jointRRR3.jointUSR.frame_im.r_0[1] = jointRRR3.jointUSR.rod1.frame_b.r_0[1];
//   jointRRR3.jointUSR.frame_im.r_0[1] = jointRRR3.jointUSR.rod2.frame_b.r_0[1];
//   jointRRR3.jointUSR.frame_im.r_0[2] = jointRRR3.jointUSR.rod1.frame_b.r_0[2];
//   jointRRR3.jointUSR.frame_im.r_0[2] = jointRRR3.jointUSR.rod2.frame_b.r_0[2];
//   jointRRR3.jointUSR.frame_im.r_0[3] = jointRRR3.jointUSR.rod1.frame_b.r_0[3];
//   jointRRR3.jointUSR.frame_im.r_0[3] = jointRRR3.jointUSR.rod2.frame_b.r_0[3];
//   jointRRR3.jointUSR.position_b[1].y = jointRRR3.jointUSR.revolute.position_b[1];
//   jointRRR3.jointUSR.position_b[2].y = jointRRR3.jointUSR.revolute.position_b[2];
//   jointRRR3.jointUSR.position_b[3].y = jointRRR3.jointUSR.revolute.position_b[3];
//   jointRRR3.jointUSR.relativePosition.frame_a.t[1] + (jointRRR3.jointUSR.revolute.frame_a.t[1] + (-jointRRR3.jointUSR.frame_b.t[1])) = 0.0;
//   jointRRR3.jointUSR.relativePosition.frame_a.t[2] + (jointRRR3.jointUSR.revolute.frame_a.t[2] + (-jointRRR3.jointUSR.frame_b.t[2])) = 0.0;
//   jointRRR3.jointUSR.relativePosition.frame_a.t[3] + (jointRRR3.jointUSR.revolute.frame_a.t[3] + (-jointRRR3.jointUSR.frame_b.t[3])) = 0.0;
//   jointRRR3.jointUSR.relativePosition.frame_a.f[1] + (jointRRR3.jointUSR.revolute.frame_a.f[1] + (-jointRRR3.jointUSR.frame_b.f[1])) = 0.0;
//   jointRRR3.jointUSR.relativePosition.frame_a.f[2] + (jointRRR3.jointUSR.revolute.frame_a.f[2] + (-jointRRR3.jointUSR.frame_b.f[2])) = 0.0;
//   jointRRR3.jointUSR.relativePosition.frame_a.f[3] + (jointRRR3.jointUSR.revolute.frame_a.f[3] + (-jointRRR3.jointUSR.frame_b.f[3])) = 0.0;
//   jointRRR3.jointUSR.frame_b.R.w[1] = jointRRR3.jointUSR.relativePosition.frame_a.R.w[1];
//   jointRRR3.jointUSR.frame_b.R.w[1] = jointRRR3.jointUSR.revolute.frame_a.R.w[1];
//   jointRRR3.jointUSR.frame_b.R.w[2] = jointRRR3.jointUSR.relativePosition.frame_a.R.w[2];
//   jointRRR3.jointUSR.frame_b.R.w[2] = jointRRR3.jointUSR.revolute.frame_a.R.w[2];
//   jointRRR3.jointUSR.frame_b.R.w[3] = jointRRR3.jointUSR.relativePosition.frame_a.R.w[3];
//   jointRRR3.jointUSR.frame_b.R.w[3] = jointRRR3.jointUSR.revolute.frame_a.R.w[3];
//   jointRRR3.jointUSR.frame_b.R.T[1,1] = jointRRR3.jointUSR.relativePosition.frame_a.R.T[1,1];
//   jointRRR3.jointUSR.frame_b.R.T[1,1] = jointRRR3.jointUSR.revolute.frame_a.R.T[1,1];
//   jointRRR3.jointUSR.frame_b.R.T[1,2] = jointRRR3.jointUSR.relativePosition.frame_a.R.T[1,2];
//   jointRRR3.jointUSR.frame_b.R.T[1,2] = jointRRR3.jointUSR.revolute.frame_a.R.T[1,2];
//   jointRRR3.jointUSR.frame_b.R.T[1,3] = jointRRR3.jointUSR.relativePosition.frame_a.R.T[1,3];
//   jointRRR3.jointUSR.frame_b.R.T[1,3] = jointRRR3.jointUSR.revolute.frame_a.R.T[1,3];
//   jointRRR3.jointUSR.frame_b.R.T[2,1] = jointRRR3.jointUSR.relativePosition.frame_a.R.T[2,1];
//   jointRRR3.jointUSR.frame_b.R.T[2,1] = jointRRR3.jointUSR.revolute.frame_a.R.T[2,1];
//   jointRRR3.jointUSR.frame_b.R.T[2,2] = jointRRR3.jointUSR.relativePosition.frame_a.R.T[2,2];
//   jointRRR3.jointUSR.frame_b.R.T[2,2] = jointRRR3.jointUSR.revolute.frame_a.R.T[2,2];
//   jointRRR3.jointUSR.frame_b.R.T[2,3] = jointRRR3.jointUSR.relativePosition.frame_a.R.T[2,3];
//   jointRRR3.jointUSR.frame_b.R.T[2,3] = jointRRR3.jointUSR.revolute.frame_a.R.T[2,3];
//   jointRRR3.jointUSR.frame_b.R.T[3,1] = jointRRR3.jointUSR.relativePosition.frame_a.R.T[3,1];
//   jointRRR3.jointUSR.frame_b.R.T[3,1] = jointRRR3.jointUSR.revolute.frame_a.R.T[3,1];
//   jointRRR3.jointUSR.frame_b.R.T[3,2] = jointRRR3.jointUSR.relativePosition.frame_a.R.T[3,2];
//   jointRRR3.jointUSR.frame_b.R.T[3,2] = jointRRR3.jointUSR.revolute.frame_a.R.T[3,2];
//   jointRRR3.jointUSR.frame_b.R.T[3,3] = jointRRR3.jointUSR.relativePosition.frame_a.R.T[3,3];
//   jointRRR3.jointUSR.frame_b.R.T[3,3] = jointRRR3.jointUSR.revolute.frame_a.R.T[3,3];
//   jointRRR3.jointUSR.frame_b.r_0[1] = jointRRR3.jointUSR.relativePosition.frame_a.r_0[1];
//   jointRRR3.jointUSR.frame_b.r_0[1] = jointRRR3.jointUSR.revolute.frame_a.r_0[1];
//   jointRRR3.jointUSR.frame_b.r_0[2] = jointRRR3.jointUSR.relativePosition.frame_a.r_0[2];
//   jointRRR3.jointUSR.frame_b.r_0[2] = jointRRR3.jointUSR.revolute.frame_a.r_0[2];
//   jointRRR3.jointUSR.frame_b.r_0[3] = jointRRR3.jointUSR.relativePosition.frame_a.r_0[3];
//   jointRRR3.jointUSR.frame_b.r_0[3] = jointRRR3.jointUSR.revolute.frame_a.r_0[3];
//   jointRRR3.jointUSR.relativePosition.frame_b.t[1] + (jointRRR3.jointUSR.rod1.frame_a.t[1] + (-jointRRR3.jointUSR.frame_a.t[1])) = 0.0;
//   jointRRR3.jointUSR.relativePosition.frame_b.t[2] + (jointRRR3.jointUSR.rod1.frame_a.t[2] + (-jointRRR3.jointUSR.frame_a.t[2])) = 0.0;
//   jointRRR3.jointUSR.relativePosition.frame_b.t[3] + (jointRRR3.jointUSR.rod1.frame_a.t[3] + (-jointRRR3.jointUSR.frame_a.t[3])) = 0.0;
//   jointRRR3.jointUSR.relativePosition.frame_b.f[1] + (jointRRR3.jointUSR.rod1.frame_a.f[1] + (-jointRRR3.jointUSR.frame_a.f[1])) = 0.0;
//   jointRRR3.jointUSR.relativePosition.frame_b.f[2] + (jointRRR3.jointUSR.rod1.frame_a.f[2] + (-jointRRR3.jointUSR.frame_a.f[2])) = 0.0;
//   jointRRR3.jointUSR.relativePosition.frame_b.f[3] + (jointRRR3.jointUSR.rod1.frame_a.f[3] + (-jointRRR3.jointUSR.frame_a.f[3])) = 0.0;
//   jointRRR3.jointUSR.frame_a.R.w[1] = jointRRR3.jointUSR.relativePosition.frame_b.R.w[1];
//   jointRRR3.jointUSR.frame_a.R.w[1] = jointRRR3.jointUSR.rod1.frame_a.R.w[1];
//   jointRRR3.jointUSR.frame_a.R.w[2] = jointRRR3.jointUSR.relativePosition.frame_b.R.w[2];
//   jointRRR3.jointUSR.frame_a.R.w[2] = jointRRR3.jointUSR.rod1.frame_a.R.w[2];
//   jointRRR3.jointUSR.frame_a.R.w[3] = jointRRR3.jointUSR.relativePosition.frame_b.R.w[3];
//   jointRRR3.jointUSR.frame_a.R.w[3] = jointRRR3.jointUSR.rod1.frame_a.R.w[3];
//   jointRRR3.jointUSR.frame_a.R.T[1,1] = jointRRR3.jointUSR.relativePosition.frame_b.R.T[1,1];
//   jointRRR3.jointUSR.frame_a.R.T[1,1] = jointRRR3.jointUSR.rod1.frame_a.R.T[1,1];
//   jointRRR3.jointUSR.frame_a.R.T[1,2] = jointRRR3.jointUSR.relativePosition.frame_b.R.T[1,2];
//   jointRRR3.jointUSR.frame_a.R.T[1,2] = jointRRR3.jointUSR.rod1.frame_a.R.T[1,2];
//   jointRRR3.jointUSR.frame_a.R.T[1,3] = jointRRR3.jointUSR.relativePosition.frame_b.R.T[1,3];
//   jointRRR3.jointUSR.frame_a.R.T[1,3] = jointRRR3.jointUSR.rod1.frame_a.R.T[1,3];
//   jointRRR3.jointUSR.frame_a.R.T[2,1] = jointRRR3.jointUSR.relativePosition.frame_b.R.T[2,1];
//   jointRRR3.jointUSR.frame_a.R.T[2,1] = jointRRR3.jointUSR.rod1.frame_a.R.T[2,1];
//   jointRRR3.jointUSR.frame_a.R.T[2,2] = jointRRR3.jointUSR.relativePosition.frame_b.R.T[2,2];
//   jointRRR3.jointUSR.frame_a.R.T[2,2] = jointRRR3.jointUSR.rod1.frame_a.R.T[2,2];
//   jointRRR3.jointUSR.frame_a.R.T[2,3] = jointRRR3.jointUSR.relativePosition.frame_b.R.T[2,3];
//   jointRRR3.jointUSR.frame_a.R.T[2,3] = jointRRR3.jointUSR.rod1.frame_a.R.T[2,3];
//   jointRRR3.jointUSR.frame_a.R.T[3,1] = jointRRR3.jointUSR.relativePosition.frame_b.R.T[3,1];
//   jointRRR3.jointUSR.frame_a.R.T[3,1] = jointRRR3.jointUSR.rod1.frame_a.R.T[3,1];
//   jointRRR3.jointUSR.frame_a.R.T[3,2] = jointRRR3.jointUSR.relativePosition.frame_b.R.T[3,2];
//   jointRRR3.jointUSR.frame_a.R.T[3,2] = jointRRR3.jointUSR.rod1.frame_a.R.T[3,2];
//   jointRRR3.jointUSR.frame_a.R.T[3,3] = jointRRR3.jointUSR.relativePosition.frame_b.R.T[3,3];
//   jointRRR3.jointUSR.frame_a.R.T[3,3] = jointRRR3.jointUSR.rod1.frame_a.R.T[3,3];
//   jointRRR3.jointUSR.frame_a.r_0[1] = jointRRR3.jointUSR.relativePosition.frame_b.r_0[1];
//   jointRRR3.jointUSR.frame_a.r_0[1] = jointRRR3.jointUSR.rod1.frame_a.r_0[1];
//   jointRRR3.jointUSR.frame_a.r_0[2] = jointRRR3.jointUSR.relativePosition.frame_b.r_0[2];
//   jointRRR3.jointUSR.frame_a.r_0[2] = jointRRR3.jointUSR.rod1.frame_a.r_0[2];
//   jointRRR3.jointUSR.frame_a.r_0[3] = jointRRR3.jointUSR.relativePosition.frame_b.r_0[3];
//   jointRRR3.jointUSR.frame_a.r_0[3] = jointRRR3.jointUSR.rod1.frame_a.r_0[3];
//   jointRRR3.jointUSR.revolute.frame_b.t[1] + (jointRRR3.jointUSR.rod2.frame_a.t[1] + (-jointRRR3.jointUSR.frame_ib.t[1])) = 0.0;
//   jointRRR3.jointUSR.revolute.frame_b.t[2] + (jointRRR3.jointUSR.rod2.frame_a.t[2] + (-jointRRR3.jointUSR.frame_ib.t[2])) = 0.0;
//   jointRRR3.jointUSR.revolute.frame_b.t[3] + (jointRRR3.jointUSR.rod2.frame_a.t[3] + (-jointRRR3.jointUSR.frame_ib.t[3])) = 0.0;
//   jointRRR3.jointUSR.revolute.frame_b.f[1] + (jointRRR3.jointUSR.rod2.frame_a.f[1] + (-jointRRR3.jointUSR.frame_ib.f[1])) = 0.0;
//   jointRRR3.jointUSR.revolute.frame_b.f[2] + (jointRRR3.jointUSR.rod2.frame_a.f[2] + (-jointRRR3.jointUSR.frame_ib.f[2])) = 0.0;
//   jointRRR3.jointUSR.revolute.frame_b.f[3] + (jointRRR3.jointUSR.rod2.frame_a.f[3] + (-jointRRR3.jointUSR.frame_ib.f[3])) = 0.0;
//   jointRRR3.jointUSR.frame_ib.R.w[1] = jointRRR3.jointUSR.revolute.frame_b.R.w[1];
//   jointRRR3.jointUSR.frame_ib.R.w[1] = jointRRR3.jointUSR.rod2.frame_a.R.w[1];
//   jointRRR3.jointUSR.frame_ib.R.w[2] = jointRRR3.jointUSR.revolute.frame_b.R.w[2];
//   jointRRR3.jointUSR.frame_ib.R.w[2] = jointRRR3.jointUSR.rod2.frame_a.R.w[2];
//   jointRRR3.jointUSR.frame_ib.R.w[3] = jointRRR3.jointUSR.revolute.frame_b.R.w[3];
//   jointRRR3.jointUSR.frame_ib.R.w[3] = jointRRR3.jointUSR.rod2.frame_a.R.w[3];
//   jointRRR3.jointUSR.frame_ib.R.T[1,1] = jointRRR3.jointUSR.revolute.frame_b.R.T[1,1];
//   jointRRR3.jointUSR.frame_ib.R.T[1,1] = jointRRR3.jointUSR.rod2.frame_a.R.T[1,1];
//   jointRRR3.jointUSR.frame_ib.R.T[1,2] = jointRRR3.jointUSR.revolute.frame_b.R.T[1,2];
//   jointRRR3.jointUSR.frame_ib.R.T[1,2] = jointRRR3.jointUSR.rod2.frame_a.R.T[1,2];
//   jointRRR3.jointUSR.frame_ib.R.T[1,3] = jointRRR3.jointUSR.revolute.frame_b.R.T[1,3];
//   jointRRR3.jointUSR.frame_ib.R.T[1,3] = jointRRR3.jointUSR.rod2.frame_a.R.T[1,3];
//   jointRRR3.jointUSR.frame_ib.R.T[2,1] = jointRRR3.jointUSR.revolute.frame_b.R.T[2,1];
//   jointRRR3.jointUSR.frame_ib.R.T[2,1] = jointRRR3.jointUSR.rod2.frame_a.R.T[2,1];
//   jointRRR3.jointUSR.frame_ib.R.T[2,2] = jointRRR3.jointUSR.revolute.frame_b.R.T[2,2];
//   jointRRR3.jointUSR.frame_ib.R.T[2,2] = jointRRR3.jointUSR.rod2.frame_a.R.T[2,2];
//   jointRRR3.jointUSR.frame_ib.R.T[2,3] = jointRRR3.jointUSR.revolute.frame_b.R.T[2,3];
//   jointRRR3.jointUSR.frame_ib.R.T[2,3] = jointRRR3.jointUSR.rod2.frame_a.R.T[2,3];
//   jointRRR3.jointUSR.frame_ib.R.T[3,1] = jointRRR3.jointUSR.revolute.frame_b.R.T[3,1];
//   jointRRR3.jointUSR.frame_ib.R.T[3,1] = jointRRR3.jointUSR.rod2.frame_a.R.T[3,1];
//   jointRRR3.jointUSR.frame_ib.R.T[3,2] = jointRRR3.jointUSR.revolute.frame_b.R.T[3,2];
//   jointRRR3.jointUSR.frame_ib.R.T[3,2] = jointRRR3.jointUSR.rod2.frame_a.R.T[3,2];
//   jointRRR3.jointUSR.frame_ib.R.T[3,3] = jointRRR3.jointUSR.revolute.frame_b.R.T[3,3];
//   jointRRR3.jointUSR.frame_ib.R.T[3,3] = jointRRR3.jointUSR.rod2.frame_a.R.T[3,3];
//   jointRRR3.jointUSR.frame_ib.r_0[1] = jointRRR3.jointUSR.revolute.frame_b.r_0[1];
//   jointRRR3.jointUSR.frame_ib.r_0[1] = jointRRR3.jointUSR.rod2.frame_a.r_0[1];
//   jointRRR3.jointUSR.frame_ib.r_0[2] = jointRRR3.jointUSR.revolute.frame_b.r_0[2];
//   jointRRR3.jointUSR.frame_ib.r_0[2] = jointRRR3.jointUSR.rod2.frame_a.r_0[2];
//   jointRRR3.jointUSR.frame_ib.r_0[3] = jointRRR3.jointUSR.revolute.frame_b.r_0[3];
//   jointRRR3.jointUSR.frame_ib.r_0[3] = jointRRR3.jointUSR.rod2.frame_a.r_0[3];
//   jointRRR3.jointUSR.relativePosition.r_rel[1] = jointRRR3.jointUSR.relativePosition.relativePosition.r_rel[1];
//   jointRRR3.jointUSR.relativePosition.r_rel[2] = jointRRR3.jointUSR.relativePosition.relativePosition.r_rel[2];
//   jointRRR3.jointUSR.relativePosition.r_rel[3] = jointRRR3.jointUSR.relativePosition.relativePosition.r_rel[3];
//   jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.t[1] + jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.t[1] = 0.0;
//   jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.t[2] + jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.t[2] = 0.0;
//   jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.t[3] + jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.t[3] = 0.0;
//   jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.f[1] + jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.f[1] = 0.0;
//   jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.f[2] + jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.f[2] = 0.0;
//   jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.f[3] + jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.f[3] = 0.0;
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.R.w[1] = jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.w[1];
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.R.w[2] = jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.w[2];
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.R.w[3] = jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.w[3];
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[1,1] = jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[1,1];
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[1,2] = jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[1,2];
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[1,3] = jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[1,3];
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[2,1] = jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[2,1];
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[2,2] = jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[2,2];
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[2,3] = jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[2,3];
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[3,1] = jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[3,1];
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[3,2] = jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[3,2];
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[3,3] = jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[3,3];
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.r_0[1] = jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.r_0[1];
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.r_0[2] = jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.r_0[2];
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_resolve.r_0[3] = jointRRR3.jointUSR.relativePosition.zeroPosition.frame_resolve.r_0[3];
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.t[1] + (-jointRRR3.jointUSR.relativePosition.frame_b.t[1]) = 0.0;
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.t[2] + (-jointRRR3.jointUSR.relativePosition.frame_b.t[2]) = 0.0;
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.t[3] + (-jointRRR3.jointUSR.relativePosition.frame_b.t[3]) = 0.0;
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.f[1] + (-jointRRR3.jointUSR.relativePosition.frame_b.f[1]) = 0.0;
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.f[2] + (-jointRRR3.jointUSR.relativePosition.frame_b.f[2]) = 0.0;
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.f[3] + (-jointRRR3.jointUSR.relativePosition.frame_b.f[3]) = 0.0;
//   jointRRR3.jointUSR.relativePosition.frame_b.R.w[1] = jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.R.w[1];
//   jointRRR3.jointUSR.relativePosition.frame_b.R.w[2] = jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.R.w[2];
//   jointRRR3.jointUSR.relativePosition.frame_b.R.w[3] = jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.R.w[3];
//   jointRRR3.jointUSR.relativePosition.frame_b.R.T[1,1] = jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.R.T[1,1];
//   jointRRR3.jointUSR.relativePosition.frame_b.R.T[1,2] = jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.R.T[1,2];
//   jointRRR3.jointUSR.relativePosition.frame_b.R.T[1,3] = jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.R.T[1,3];
//   jointRRR3.jointUSR.relativePosition.frame_b.R.T[2,1] = jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.R.T[2,1];
//   jointRRR3.jointUSR.relativePosition.frame_b.R.T[2,2] = jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.R.T[2,2];
//   jointRRR3.jointUSR.relativePosition.frame_b.R.T[2,3] = jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.R.T[2,3];
//   jointRRR3.jointUSR.relativePosition.frame_b.R.T[3,1] = jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.R.T[3,1];
//   jointRRR3.jointUSR.relativePosition.frame_b.R.T[3,2] = jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.R.T[3,2];
//   jointRRR3.jointUSR.relativePosition.frame_b.R.T[3,3] = jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.R.T[3,3];
//   jointRRR3.jointUSR.relativePosition.frame_b.r_0[1] = jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.r_0[1];
//   jointRRR3.jointUSR.relativePosition.frame_b.r_0[2] = jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.r_0[2];
//   jointRRR3.jointUSR.relativePosition.frame_b.r_0[3] = jointRRR3.jointUSR.relativePosition.relativePosition.frame_b.r_0[3];
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.t[1] + (-jointRRR3.jointUSR.relativePosition.frame_a.t[1]) = 0.0;
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.t[2] + (-jointRRR3.jointUSR.relativePosition.frame_a.t[2]) = 0.0;
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.t[3] + (-jointRRR3.jointUSR.relativePosition.frame_a.t[3]) = 0.0;
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.f[1] + (-jointRRR3.jointUSR.relativePosition.frame_a.f[1]) = 0.0;
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.f[2] + (-jointRRR3.jointUSR.relativePosition.frame_a.f[2]) = 0.0;
//   jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.f[3] + (-jointRRR3.jointUSR.relativePosition.frame_a.f[3]) = 0.0;
//   jointRRR3.jointUSR.relativePosition.frame_a.R.w[1] = jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.R.w[1];
//   jointRRR3.jointUSR.relativePosition.frame_a.R.w[2] = jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.R.w[2];
//   jointRRR3.jointUSR.relativePosition.frame_a.R.w[3] = jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.R.w[3];
//   jointRRR3.jointUSR.relativePosition.frame_a.R.T[1,1] = jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.R.T[1,1];
//   jointRRR3.jointUSR.relativePosition.frame_a.R.T[1,2] = jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.R.T[1,2];
//   jointRRR3.jointUSR.relativePosition.frame_a.R.T[1,3] = jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.R.T[1,3];
//   jointRRR3.jointUSR.relativePosition.frame_a.R.T[2,1] = jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.R.T[2,1];
//   jointRRR3.jointUSR.relativePosition.frame_a.R.T[2,2] = jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.R.T[2,2];
//   jointRRR3.jointUSR.relativePosition.frame_a.R.T[2,3] = jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.R.T[2,3];
//   jointRRR3.jointUSR.relativePosition.frame_a.R.T[3,1] = jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.R.T[3,1];
//   jointRRR3.jointUSR.relativePosition.frame_a.R.T[3,2] = jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.R.T[3,2];
//   jointRRR3.jointUSR.relativePosition.frame_a.R.T[3,3] = jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.R.T[3,3];
//   jointRRR3.jointUSR.relativePosition.frame_a.r_0[1] = jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.r_0[1];
//   jointRRR3.jointUSR.relativePosition.frame_a.r_0[2] = jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.r_0[2];
//   jointRRR3.jointUSR.relativePosition.frame_a.r_0[3] = jointRRR3.jointUSR.relativePosition.relativePosition.frame_a.r_0[3];
//   jointRRR3.bearing.tau = 0.0;
//   jointRRR3.axis.tau = 0.0;
//   jointRRR3.frame_im.t[3] = 0.0;
//   jointRRR3.frame_im.t[2] = 0.0;
//   jointRRR3.frame_im.t[1] = 0.0;
//   jointRRR3.frame_im.f[3] = 0.0;
//   jointRRR3.frame_im.f[2] = 0.0;
//   jointRRR3.frame_im.f[1] = 0.0;
//   jointRRR3.frame_ib.t[3] = 0.0;
//   jointRRR3.frame_ib.t[2] = 0.0;
//   jointRRR3.frame_ib.t[1] = 0.0;
//   jointRRR3.frame_ib.f[3] = 0.0;
//   jointRRR3.frame_ib.f[2] = 0.0;
//   jointRRR3.frame_ib.f[1] = 0.0;
//   jointRRR2.jointUSR.bearing.tau + (-jointRRR2.bearing.tau) = 0.0;
//   jointRRR2.bearing.phi = jointRRR2.jointUSR.bearing.phi;
//   jointRRR2.jointUSR.axis.tau + (-jointRRR2.axis.tau) = 0.0;
//   jointRRR2.axis.phi = jointRRR2.jointUSR.axis.phi;
//   jointRRR2.jointUSR.frame_ib.t[1] + (-jointRRR2.frame_ib.t[1]) = 0.0;
//   jointRRR2.jointUSR.frame_ib.t[2] + (-jointRRR2.frame_ib.t[2]) = 0.0;
//   jointRRR2.jointUSR.frame_ib.t[3] + (-jointRRR2.frame_ib.t[3]) = 0.0;
//   jointRRR2.jointUSR.frame_ib.f[1] + (-jointRRR2.frame_ib.f[1]) = 0.0;
//   jointRRR2.jointUSR.frame_ib.f[2] + (-jointRRR2.frame_ib.f[2]) = 0.0;
//   jointRRR2.jointUSR.frame_ib.f[3] + (-jointRRR2.frame_ib.f[3]) = 0.0;
//   jointRRR2.frame_ib.R.w[1] = jointRRR2.jointUSR.frame_ib.R.w[1];
//   jointRRR2.frame_ib.R.w[2] = jointRRR2.jointUSR.frame_ib.R.w[2];
//   jointRRR2.frame_ib.R.w[3] = jointRRR2.jointUSR.frame_ib.R.w[3];
//   jointRRR2.frame_ib.R.T[1,1] = jointRRR2.jointUSR.frame_ib.R.T[1,1];
//   jointRRR2.frame_ib.R.T[1,2] = jointRRR2.jointUSR.frame_ib.R.T[1,2];
//   jointRRR2.frame_ib.R.T[1,3] = jointRRR2.jointUSR.frame_ib.R.T[1,3];
//   jointRRR2.frame_ib.R.T[2,1] = jointRRR2.jointUSR.frame_ib.R.T[2,1];
//   jointRRR2.frame_ib.R.T[2,2] = jointRRR2.jointUSR.frame_ib.R.T[2,2];
//   jointRRR2.frame_ib.R.T[2,3] = jointRRR2.jointUSR.frame_ib.R.T[2,3];
//   jointRRR2.frame_ib.R.T[3,1] = jointRRR2.jointUSR.frame_ib.R.T[3,1];
//   jointRRR2.frame_ib.R.T[3,2] = jointRRR2.jointUSR.frame_ib.R.T[3,2];
//   jointRRR2.frame_ib.R.T[3,3] = jointRRR2.jointUSR.frame_ib.R.T[3,3];
//   jointRRR2.frame_ib.r_0[1] = jointRRR2.jointUSR.frame_ib.r_0[1];
//   jointRRR2.frame_ib.r_0[2] = jointRRR2.jointUSR.frame_ib.r_0[2];
//   jointRRR2.frame_ib.r_0[3] = jointRRR2.jointUSR.frame_ib.r_0[3];
//   jointRRR2.jointUSR.frame_im.t[1] + (-jointRRR2.frame_im.t[1]) = 0.0;
//   jointRRR2.jointUSR.frame_im.t[2] + (-jointRRR2.frame_im.t[2]) = 0.0;
//   jointRRR2.jointUSR.frame_im.t[3] + (-jointRRR2.frame_im.t[3]) = 0.0;
//   jointRRR2.jointUSR.frame_im.f[1] + (-jointRRR2.frame_im.f[1]) = 0.0;
//   jointRRR2.jointUSR.frame_im.f[2] + (-jointRRR2.frame_im.f[2]) = 0.0;
//   jointRRR2.jointUSR.frame_im.f[3] + (-jointRRR2.frame_im.f[3]) = 0.0;
//   jointRRR2.frame_im.R.w[1] = jointRRR2.jointUSR.frame_im.R.w[1];
//   jointRRR2.frame_im.R.w[2] = jointRRR2.jointUSR.frame_im.R.w[2];
//   jointRRR2.frame_im.R.w[3] = jointRRR2.jointUSR.frame_im.R.w[3];
//   jointRRR2.frame_im.R.T[1,1] = jointRRR2.jointUSR.frame_im.R.T[1,1];
//   jointRRR2.frame_im.R.T[1,2] = jointRRR2.jointUSR.frame_im.R.T[1,2];
//   jointRRR2.frame_im.R.T[1,3] = jointRRR2.jointUSR.frame_im.R.T[1,3];
//   jointRRR2.frame_im.R.T[2,1] = jointRRR2.jointUSR.frame_im.R.T[2,1];
//   jointRRR2.frame_im.R.T[2,2] = jointRRR2.jointUSR.frame_im.R.T[2,2];
//   jointRRR2.frame_im.R.T[2,3] = jointRRR2.jointUSR.frame_im.R.T[2,3];
//   jointRRR2.frame_im.R.T[3,1] = jointRRR2.jointUSR.frame_im.R.T[3,1];
//   jointRRR2.frame_im.R.T[3,2] = jointRRR2.jointUSR.frame_im.R.T[3,2];
//   jointRRR2.frame_im.R.T[3,3] = jointRRR2.jointUSR.frame_im.R.T[3,3];
//   jointRRR2.frame_im.r_0[1] = jointRRR2.jointUSR.frame_im.r_0[1];
//   jointRRR2.frame_im.r_0[2] = jointRRR2.jointUSR.frame_im.r_0[2];
//   jointRRR2.frame_im.r_0[3] = jointRRR2.jointUSR.frame_im.r_0[3];
//   jointRRR2.jointUSR.frame_ia.t[1] + (-jointRRR2.frame_ia.t[1]) = 0.0;
//   jointRRR2.jointUSR.frame_ia.t[2] + (-jointRRR2.frame_ia.t[2]) = 0.0;
//   jointRRR2.jointUSR.frame_ia.t[3] + (-jointRRR2.frame_ia.t[3]) = 0.0;
//   jointRRR2.jointUSR.frame_ia.f[1] + (-jointRRR2.frame_ia.f[1]) = 0.0;
//   jointRRR2.jointUSR.frame_ia.f[2] + (-jointRRR2.frame_ia.f[2]) = 0.0;
//   jointRRR2.jointUSR.frame_ia.f[3] + (-jointRRR2.frame_ia.f[3]) = 0.0;
//   jointRRR2.frame_ia.R.w[1] = jointRRR2.jointUSR.frame_ia.R.w[1];
//   jointRRR2.frame_ia.R.w[2] = jointRRR2.jointUSR.frame_ia.R.w[2];
//   jointRRR2.frame_ia.R.w[3] = jointRRR2.jointUSR.frame_ia.R.w[3];
//   jointRRR2.frame_ia.R.T[1,1] = jointRRR2.jointUSR.frame_ia.R.T[1,1];
//   jointRRR2.frame_ia.R.T[1,2] = jointRRR2.jointUSR.frame_ia.R.T[1,2];
//   jointRRR2.frame_ia.R.T[1,3] = jointRRR2.jointUSR.frame_ia.R.T[1,3];
//   jointRRR2.frame_ia.R.T[2,1] = jointRRR2.jointUSR.frame_ia.R.T[2,1];
//   jointRRR2.frame_ia.R.T[2,2] = jointRRR2.jointUSR.frame_ia.R.T[2,2];
//   jointRRR2.frame_ia.R.T[2,3] = jointRRR2.jointUSR.frame_ia.R.T[2,3];
//   jointRRR2.frame_ia.R.T[3,1] = jointRRR2.jointUSR.frame_ia.R.T[3,1];
//   jointRRR2.frame_ia.R.T[3,2] = jointRRR2.jointUSR.frame_ia.R.T[3,2];
//   jointRRR2.frame_ia.R.T[3,3] = jointRRR2.jointUSR.frame_ia.R.T[3,3];
//   jointRRR2.frame_ia.r_0[1] = jointRRR2.jointUSR.frame_ia.r_0[1];
//   jointRRR2.frame_ia.r_0[2] = jointRRR2.jointUSR.frame_ia.r_0[2];
//   jointRRR2.frame_ia.r_0[3] = jointRRR2.jointUSR.frame_ia.r_0[3];
//   jointRRR2.jointUSR.frame_b.t[1] + (-jointRRR2.frame_b.t[1]) = 0.0;
//   jointRRR2.jointUSR.frame_b.t[2] + (-jointRRR2.frame_b.t[2]) = 0.0;
//   jointRRR2.jointUSR.frame_b.t[3] + (-jointRRR2.frame_b.t[3]) = 0.0;
//   jointRRR2.jointUSR.frame_b.f[1] + (-jointRRR2.frame_b.f[1]) = 0.0;
//   jointRRR2.jointUSR.frame_b.f[2] + (-jointRRR2.frame_b.f[2]) = 0.0;
//   jointRRR2.jointUSR.frame_b.f[3] + (-jointRRR2.frame_b.f[3]) = 0.0;
//   jointRRR2.frame_b.R.w[1] = jointRRR2.jointUSR.frame_b.R.w[1];
//   jointRRR2.frame_b.R.w[2] = jointRRR2.jointUSR.frame_b.R.w[2];
//   jointRRR2.frame_b.R.w[3] = jointRRR2.jointUSR.frame_b.R.w[3];
//   jointRRR2.frame_b.R.T[1,1] = jointRRR2.jointUSR.frame_b.R.T[1,1];
//   jointRRR2.frame_b.R.T[1,2] = jointRRR2.jointUSR.frame_b.R.T[1,2];
//   jointRRR2.frame_b.R.T[1,3] = jointRRR2.jointUSR.frame_b.R.T[1,3];
//   jointRRR2.frame_b.R.T[2,1] = jointRRR2.jointUSR.frame_b.R.T[2,1];
//   jointRRR2.frame_b.R.T[2,2] = jointRRR2.jointUSR.frame_b.R.T[2,2];
//   jointRRR2.frame_b.R.T[2,3] = jointRRR2.jointUSR.frame_b.R.T[2,3];
//   jointRRR2.frame_b.R.T[3,1] = jointRRR2.jointUSR.frame_b.R.T[3,1];
//   jointRRR2.frame_b.R.T[3,2] = jointRRR2.jointUSR.frame_b.R.T[3,2];
//   jointRRR2.frame_b.R.T[3,3] = jointRRR2.jointUSR.frame_b.R.T[3,3];
//   jointRRR2.frame_b.r_0[1] = jointRRR2.jointUSR.frame_b.r_0[1];
//   jointRRR2.frame_b.r_0[2] = jointRRR2.jointUSR.frame_b.r_0[2];
//   jointRRR2.frame_b.r_0[3] = jointRRR2.jointUSR.frame_b.r_0[3];
//   jointRRR2.jointUSR.frame_a.t[1] + (-jointRRR2.frame_a.t[1]) = 0.0;
//   jointRRR2.jointUSR.frame_a.t[2] + (-jointRRR2.frame_a.t[2]) = 0.0;
//   jointRRR2.jointUSR.frame_a.t[3] + (-jointRRR2.frame_a.t[3]) = 0.0;
//   jointRRR2.jointUSR.frame_a.f[1] + (-jointRRR2.frame_a.f[1]) = 0.0;
//   jointRRR2.jointUSR.frame_a.f[2] + (-jointRRR2.frame_a.f[2]) = 0.0;
//   jointRRR2.jointUSR.frame_a.f[3] + (-jointRRR2.frame_a.f[3]) = 0.0;
//   jointRRR2.frame_a.R.w[1] = jointRRR2.jointUSR.frame_a.R.w[1];
//   jointRRR2.frame_a.R.w[2] = jointRRR2.jointUSR.frame_a.R.w[2];
//   jointRRR2.frame_a.R.w[3] = jointRRR2.jointUSR.frame_a.R.w[3];
//   jointRRR2.frame_a.R.T[1,1] = jointRRR2.jointUSR.frame_a.R.T[1,1];
//   jointRRR2.frame_a.R.T[1,2] = jointRRR2.jointUSR.frame_a.R.T[1,2];
//   jointRRR2.frame_a.R.T[1,3] = jointRRR2.jointUSR.frame_a.R.T[1,3];
//   jointRRR2.frame_a.R.T[2,1] = jointRRR2.jointUSR.frame_a.R.T[2,1];
//   jointRRR2.frame_a.R.T[2,2] = jointRRR2.jointUSR.frame_a.R.T[2,2];
//   jointRRR2.frame_a.R.T[2,3] = jointRRR2.jointUSR.frame_a.R.T[2,3];
//   jointRRR2.frame_a.R.T[3,1] = jointRRR2.jointUSR.frame_a.R.T[3,1];
//   jointRRR2.frame_a.R.T[3,2] = jointRRR2.jointUSR.frame_a.R.T[3,2];
//   jointRRR2.frame_a.R.T[3,3] = jointRRR2.jointUSR.frame_a.R.T[3,3];
//   jointRRR2.frame_a.r_0[1] = jointRRR2.jointUSR.frame_a.r_0[1];
//   jointRRR2.frame_a.r_0[2] = jointRRR2.jointUSR.frame_a.r_0[2];
//   jointRRR2.frame_a.r_0[3] = jointRRR2.jointUSR.frame_a.r_0[3];
//   jointRRR2.jointUSR.revolute.bearing.tau + (-jointRRR2.jointUSR.bearing.tau) = 0.0;
//   jointRRR2.jointUSR.bearing.phi = jointRRR2.jointUSR.revolute.bearing.phi;
//   jointRRR2.jointUSR.relativePosition.r_rel[1] = jointRRR2.jointUSR.revolute.position_a[1];
//   jointRRR2.jointUSR.relativePosition.r_rel[2] = jointRRR2.jointUSR.revolute.position_a[2];
//   jointRRR2.jointUSR.relativePosition.r_rel[3] = jointRRR2.jointUSR.revolute.position_a[3];
//   jointRRR2.jointUSR.revolute.axis.tau + (-jointRRR2.jointUSR.axis.tau) = 0.0;
//   jointRRR2.jointUSR.axis.phi = jointRRR2.jointUSR.revolute.axis.phi;
//   jointRRR2.jointUSR.rod1.frame_ia.t[1] + (-jointRRR2.jointUSR.frame_ia.t[1]) = 0.0;
//   jointRRR2.jointUSR.rod1.frame_ia.t[2] + (-jointRRR2.jointUSR.frame_ia.t[2]) = 0.0;
//   jointRRR2.jointUSR.rod1.frame_ia.t[3] + (-jointRRR2.jointUSR.frame_ia.t[3]) = 0.0;
//   jointRRR2.jointUSR.rod1.frame_ia.f[1] + (-jointRRR2.jointUSR.frame_ia.f[1]) = 0.0;
//   jointRRR2.jointUSR.rod1.frame_ia.f[2] + (-jointRRR2.jointUSR.frame_ia.f[2]) = 0.0;
//   jointRRR2.jointUSR.rod1.frame_ia.f[3] + (-jointRRR2.jointUSR.frame_ia.f[3]) = 0.0;
//   jointRRR2.jointUSR.frame_ia.R.w[1] = jointRRR2.jointUSR.rod1.frame_ia.R.w[1];
//   jointRRR2.jointUSR.frame_ia.R.w[2] = jointRRR2.jointUSR.rod1.frame_ia.R.w[2];
//   jointRRR2.jointUSR.frame_ia.R.w[3] = jointRRR2.jointUSR.rod1.frame_ia.R.w[3];
//   jointRRR2.jointUSR.frame_ia.R.T[1,1] = jointRRR2.jointUSR.rod1.frame_ia.R.T[1,1];
//   jointRRR2.jointUSR.frame_ia.R.T[1,2] = jointRRR2.jointUSR.rod1.frame_ia.R.T[1,2];
//   jointRRR2.jointUSR.frame_ia.R.T[1,3] = jointRRR2.jointUSR.rod1.frame_ia.R.T[1,3];
//   jointRRR2.jointUSR.frame_ia.R.T[2,1] = jointRRR2.jointUSR.rod1.frame_ia.R.T[2,1];
//   jointRRR2.jointUSR.frame_ia.R.T[2,2] = jointRRR2.jointUSR.rod1.frame_ia.R.T[2,2];
//   jointRRR2.jointUSR.frame_ia.R.T[2,3] = jointRRR2.jointUSR.rod1.frame_ia.R.T[2,3];
//   jointRRR2.jointUSR.frame_ia.R.T[3,1] = jointRRR2.jointUSR.rod1.frame_ia.R.T[3,1];
//   jointRRR2.jointUSR.frame_ia.R.T[3,2] = jointRRR2.jointUSR.rod1.frame_ia.R.T[3,2];
//   jointRRR2.jointUSR.frame_ia.R.T[3,3] = jointRRR2.jointUSR.rod1.frame_ia.R.T[3,3];
//   jointRRR2.jointUSR.frame_ia.r_0[1] = jointRRR2.jointUSR.rod1.frame_ia.r_0[1];
//   jointRRR2.jointUSR.frame_ia.r_0[2] = jointRRR2.jointUSR.rod1.frame_ia.r_0[2];
//   jointRRR2.jointUSR.frame_ia.r_0[3] = jointRRR2.jointUSR.rod1.frame_ia.r_0[3];
//   jointRRR2.jointUSR.rod2.frame_b.t[1] + (jointRRR2.jointUSR.rod1.frame_b.t[1] + (-jointRRR2.jointUSR.frame_im.t[1])) = 0.0;
//   jointRRR2.jointUSR.rod2.frame_b.t[2] + (jointRRR2.jointUSR.rod1.frame_b.t[2] + (-jointRRR2.jointUSR.frame_im.t[2])) = 0.0;
//   jointRRR2.jointUSR.rod2.frame_b.t[3] + (jointRRR2.jointUSR.rod1.frame_b.t[3] + (-jointRRR2.jointUSR.frame_im.t[3])) = 0.0;
//   jointRRR2.jointUSR.rod2.frame_b.f[1] + (jointRRR2.jointUSR.rod1.frame_b.f[1] + (-jointRRR2.jointUSR.frame_im.f[1])) = 0.0;
//   jointRRR2.jointUSR.rod2.frame_b.f[2] + (jointRRR2.jointUSR.rod1.frame_b.f[2] + (-jointRRR2.jointUSR.frame_im.f[2])) = 0.0;
//   jointRRR2.jointUSR.rod2.frame_b.f[3] + (jointRRR2.jointUSR.rod1.frame_b.f[3] + (-jointRRR2.jointUSR.frame_im.f[3])) = 0.0;
//   jointRRR2.jointUSR.frame_im.R.w[1] = jointRRR2.jointUSR.rod1.frame_b.R.w[1];
//   jointRRR2.jointUSR.frame_im.R.w[1] = jointRRR2.jointUSR.rod2.frame_b.R.w[1];
//   jointRRR2.jointUSR.frame_im.R.w[2] = jointRRR2.jointUSR.rod1.frame_b.R.w[2];
//   jointRRR2.jointUSR.frame_im.R.w[2] = jointRRR2.jointUSR.rod2.frame_b.R.w[2];
//   jointRRR2.jointUSR.frame_im.R.w[3] = jointRRR2.jointUSR.rod1.frame_b.R.w[3];
//   jointRRR2.jointUSR.frame_im.R.w[3] = jointRRR2.jointUSR.rod2.frame_b.R.w[3];
//   jointRRR2.jointUSR.frame_im.R.T[1,1] = jointRRR2.jointUSR.rod1.frame_b.R.T[1,1];
//   jointRRR2.jointUSR.frame_im.R.T[1,1] = jointRRR2.jointUSR.rod2.frame_b.R.T[1,1];
//   jointRRR2.jointUSR.frame_im.R.T[1,2] = jointRRR2.jointUSR.rod1.frame_b.R.T[1,2];
//   jointRRR2.jointUSR.frame_im.R.T[1,2] = jointRRR2.jointUSR.rod2.frame_b.R.T[1,2];
//   jointRRR2.jointUSR.frame_im.R.T[1,3] = jointRRR2.jointUSR.rod1.frame_b.R.T[1,3];
//   jointRRR2.jointUSR.frame_im.R.T[1,3] = jointRRR2.jointUSR.rod2.frame_b.R.T[1,3];
//   jointRRR2.jointUSR.frame_im.R.T[2,1] = jointRRR2.jointUSR.rod1.frame_b.R.T[2,1];
//   jointRRR2.jointUSR.frame_im.R.T[2,1] = jointRRR2.jointUSR.rod2.frame_b.R.T[2,1];
//   jointRRR2.jointUSR.frame_im.R.T[2,2] = jointRRR2.jointUSR.rod1.frame_b.R.T[2,2];
//   jointRRR2.jointUSR.frame_im.R.T[2,2] = jointRRR2.jointUSR.rod2.frame_b.R.T[2,2];
//   jointRRR2.jointUSR.frame_im.R.T[2,3] = jointRRR2.jointUSR.rod1.frame_b.R.T[2,3];
//   jointRRR2.jointUSR.frame_im.R.T[2,3] = jointRRR2.jointUSR.rod2.frame_b.R.T[2,3];
//   jointRRR2.jointUSR.frame_im.R.T[3,1] = jointRRR2.jointUSR.rod1.frame_b.R.T[3,1];
//   jointRRR2.jointUSR.frame_im.R.T[3,1] = jointRRR2.jointUSR.rod2.frame_b.R.T[3,1];
//   jointRRR2.jointUSR.frame_im.R.T[3,2] = jointRRR2.jointUSR.rod1.frame_b.R.T[3,2];
//   jointRRR2.jointUSR.frame_im.R.T[3,2] = jointRRR2.jointUSR.rod2.frame_b.R.T[3,2];
//   jointRRR2.jointUSR.frame_im.R.T[3,3] = jointRRR2.jointUSR.rod1.frame_b.R.T[3,3];
//   jointRRR2.jointUSR.frame_im.R.T[3,3] = jointRRR2.jointUSR.rod2.frame_b.R.T[3,3];
//   jointRRR2.jointUSR.frame_im.r_0[1] = jointRRR2.jointUSR.rod1.frame_b.r_0[1];
//   jointRRR2.jointUSR.frame_im.r_0[1] = jointRRR2.jointUSR.rod2.frame_b.r_0[1];
//   jointRRR2.jointUSR.frame_im.r_0[2] = jointRRR2.jointUSR.rod1.frame_b.r_0[2];
//   jointRRR2.jointUSR.frame_im.r_0[2] = jointRRR2.jointUSR.rod2.frame_b.r_0[2];
//   jointRRR2.jointUSR.frame_im.r_0[3] = jointRRR2.jointUSR.rod1.frame_b.r_0[3];
//   jointRRR2.jointUSR.frame_im.r_0[3] = jointRRR2.jointUSR.rod2.frame_b.r_0[3];
//   jointRRR2.jointUSR.position_b[1].y = jointRRR2.jointUSR.revolute.position_b[1];
//   jointRRR2.jointUSR.position_b[2].y = jointRRR2.jointUSR.revolute.position_b[2];
//   jointRRR2.jointUSR.position_b[3].y = jointRRR2.jointUSR.revolute.position_b[3];
//   jointRRR2.jointUSR.relativePosition.frame_a.t[1] + (jointRRR2.jointUSR.revolute.frame_a.t[1] + (-jointRRR2.jointUSR.frame_b.t[1])) = 0.0;
//   jointRRR2.jointUSR.relativePosition.frame_a.t[2] + (jointRRR2.jointUSR.revolute.frame_a.t[2] + (-jointRRR2.jointUSR.frame_b.t[2])) = 0.0;
//   jointRRR2.jointUSR.relativePosition.frame_a.t[3] + (jointRRR2.jointUSR.revolute.frame_a.t[3] + (-jointRRR2.jointUSR.frame_b.t[3])) = 0.0;
//   jointRRR2.jointUSR.relativePosition.frame_a.f[1] + (jointRRR2.jointUSR.revolute.frame_a.f[1] + (-jointRRR2.jointUSR.frame_b.f[1])) = 0.0;
//   jointRRR2.jointUSR.relativePosition.frame_a.f[2] + (jointRRR2.jointUSR.revolute.frame_a.f[2] + (-jointRRR2.jointUSR.frame_b.f[2])) = 0.0;
//   jointRRR2.jointUSR.relativePosition.frame_a.f[3] + (jointRRR2.jointUSR.revolute.frame_a.f[3] + (-jointRRR2.jointUSR.frame_b.f[3])) = 0.0;
//   jointRRR2.jointUSR.frame_b.R.w[1] = jointRRR2.jointUSR.relativePosition.frame_a.R.w[1];
//   jointRRR2.jointUSR.frame_b.R.w[1] = jointRRR2.jointUSR.revolute.frame_a.R.w[1];
//   jointRRR2.jointUSR.frame_b.R.w[2] = jointRRR2.jointUSR.relativePosition.frame_a.R.w[2];
//   jointRRR2.jointUSR.frame_b.R.w[2] = jointRRR2.jointUSR.revolute.frame_a.R.w[2];
//   jointRRR2.jointUSR.frame_b.R.w[3] = jointRRR2.jointUSR.relativePosition.frame_a.R.w[3];
//   jointRRR2.jointUSR.frame_b.R.w[3] = jointRRR2.jointUSR.revolute.frame_a.R.w[3];
//   jointRRR2.jointUSR.frame_b.R.T[1,1] = jointRRR2.jointUSR.relativePosition.frame_a.R.T[1,1];
//   jointRRR2.jointUSR.frame_b.R.T[1,1] = jointRRR2.jointUSR.revolute.frame_a.R.T[1,1];
//   jointRRR2.jointUSR.frame_b.R.T[1,2] = jointRRR2.jointUSR.relativePosition.frame_a.R.T[1,2];
//   jointRRR2.jointUSR.frame_b.R.T[1,2] = jointRRR2.jointUSR.revolute.frame_a.R.T[1,2];
//   jointRRR2.jointUSR.frame_b.R.T[1,3] = jointRRR2.jointUSR.relativePosition.frame_a.R.T[1,3];
//   jointRRR2.jointUSR.frame_b.R.T[1,3] = jointRRR2.jointUSR.revolute.frame_a.R.T[1,3];
//   jointRRR2.jointUSR.frame_b.R.T[2,1] = jointRRR2.jointUSR.relativePosition.frame_a.R.T[2,1];
//   jointRRR2.jointUSR.frame_b.R.T[2,1] = jointRRR2.jointUSR.revolute.frame_a.R.T[2,1];
//   jointRRR2.jointUSR.frame_b.R.T[2,2] = jointRRR2.jointUSR.relativePosition.frame_a.R.T[2,2];
//   jointRRR2.jointUSR.frame_b.R.T[2,2] = jointRRR2.jointUSR.revolute.frame_a.R.T[2,2];
//   jointRRR2.jointUSR.frame_b.R.T[2,3] = jointRRR2.jointUSR.relativePosition.frame_a.R.T[2,3];
//   jointRRR2.jointUSR.frame_b.R.T[2,3] = jointRRR2.jointUSR.revolute.frame_a.R.T[2,3];
//   jointRRR2.jointUSR.frame_b.R.T[3,1] = jointRRR2.jointUSR.relativePosition.frame_a.R.T[3,1];
//   jointRRR2.jointUSR.frame_b.R.T[3,1] = jointRRR2.jointUSR.revolute.frame_a.R.T[3,1];
//   jointRRR2.jointUSR.frame_b.R.T[3,2] = jointRRR2.jointUSR.relativePosition.frame_a.R.T[3,2];
//   jointRRR2.jointUSR.frame_b.R.T[3,2] = jointRRR2.jointUSR.revolute.frame_a.R.T[3,2];
//   jointRRR2.jointUSR.frame_b.R.T[3,3] = jointRRR2.jointUSR.relativePosition.frame_a.R.T[3,3];
//   jointRRR2.jointUSR.frame_b.R.T[3,3] = jointRRR2.jointUSR.revolute.frame_a.R.T[3,3];
//   jointRRR2.jointUSR.frame_b.r_0[1] = jointRRR2.jointUSR.relativePosition.frame_a.r_0[1];
//   jointRRR2.jointUSR.frame_b.r_0[1] = jointRRR2.jointUSR.revolute.frame_a.r_0[1];
//   jointRRR2.jointUSR.frame_b.r_0[2] = jointRRR2.jointUSR.relativePosition.frame_a.r_0[2];
//   jointRRR2.jointUSR.frame_b.r_0[2] = jointRRR2.jointUSR.revolute.frame_a.r_0[2];
//   jointRRR2.jointUSR.frame_b.r_0[3] = jointRRR2.jointUSR.relativePosition.frame_a.r_0[3];
//   jointRRR2.jointUSR.frame_b.r_0[3] = jointRRR2.jointUSR.revolute.frame_a.r_0[3];
//   jointRRR2.jointUSR.relativePosition.frame_b.t[1] + (jointRRR2.jointUSR.rod1.frame_a.t[1] + (-jointRRR2.jointUSR.frame_a.t[1])) = 0.0;
//   jointRRR2.jointUSR.relativePosition.frame_b.t[2] + (jointRRR2.jointUSR.rod1.frame_a.t[2] + (-jointRRR2.jointUSR.frame_a.t[2])) = 0.0;
//   jointRRR2.jointUSR.relativePosition.frame_b.t[3] + (jointRRR2.jointUSR.rod1.frame_a.t[3] + (-jointRRR2.jointUSR.frame_a.t[3])) = 0.0;
//   jointRRR2.jointUSR.relativePosition.frame_b.f[1] + (jointRRR2.jointUSR.rod1.frame_a.f[1] + (-jointRRR2.jointUSR.frame_a.f[1])) = 0.0;
//   jointRRR2.jointUSR.relativePosition.frame_b.f[2] + (jointRRR2.jointUSR.rod1.frame_a.f[2] + (-jointRRR2.jointUSR.frame_a.f[2])) = 0.0;
//   jointRRR2.jointUSR.relativePosition.frame_b.f[3] + (jointRRR2.jointUSR.rod1.frame_a.f[3] + (-jointRRR2.jointUSR.frame_a.f[3])) = 0.0;
//   jointRRR2.jointUSR.frame_a.R.w[1] = jointRRR2.jointUSR.relativePosition.frame_b.R.w[1];
//   jointRRR2.jointUSR.frame_a.R.w[1] = jointRRR2.jointUSR.rod1.frame_a.R.w[1];
//   jointRRR2.jointUSR.frame_a.R.w[2] = jointRRR2.jointUSR.relativePosition.frame_b.R.w[2];
//   jointRRR2.jointUSR.frame_a.R.w[2] = jointRRR2.jointUSR.rod1.frame_a.R.w[2];
//   jointRRR2.jointUSR.frame_a.R.w[3] = jointRRR2.jointUSR.relativePosition.frame_b.R.w[3];
//   jointRRR2.jointUSR.frame_a.R.w[3] = jointRRR2.jointUSR.rod1.frame_a.R.w[3];
//   jointRRR2.jointUSR.frame_a.R.T[1,1] = jointRRR2.jointUSR.relativePosition.frame_b.R.T[1,1];
//   jointRRR2.jointUSR.frame_a.R.T[1,1] = jointRRR2.jointUSR.rod1.frame_a.R.T[1,1];
//   jointRRR2.jointUSR.frame_a.R.T[1,2] = jointRRR2.jointUSR.relativePosition.frame_b.R.T[1,2];
//   jointRRR2.jointUSR.frame_a.R.T[1,2] = jointRRR2.jointUSR.rod1.frame_a.R.T[1,2];
//   jointRRR2.jointUSR.frame_a.R.T[1,3] = jointRRR2.jointUSR.relativePosition.frame_b.R.T[1,3];
//   jointRRR2.jointUSR.frame_a.R.T[1,3] = jointRRR2.jointUSR.rod1.frame_a.R.T[1,3];
//   jointRRR2.jointUSR.frame_a.R.T[2,1] = jointRRR2.jointUSR.relativePosition.frame_b.R.T[2,1];
//   jointRRR2.jointUSR.frame_a.R.T[2,1] = jointRRR2.jointUSR.rod1.frame_a.R.T[2,1];
//   jointRRR2.jointUSR.frame_a.R.T[2,2] = jointRRR2.jointUSR.relativePosition.frame_b.R.T[2,2];
//   jointRRR2.jointUSR.frame_a.R.T[2,2] = jointRRR2.jointUSR.rod1.frame_a.R.T[2,2];
//   jointRRR2.jointUSR.frame_a.R.T[2,3] = jointRRR2.jointUSR.relativePosition.frame_b.R.T[2,3];
//   jointRRR2.jointUSR.frame_a.R.T[2,3] = jointRRR2.jointUSR.rod1.frame_a.R.T[2,3];
//   jointRRR2.jointUSR.frame_a.R.T[3,1] = jointRRR2.jointUSR.relativePosition.frame_b.R.T[3,1];
//   jointRRR2.jointUSR.frame_a.R.T[3,1] = jointRRR2.jointUSR.rod1.frame_a.R.T[3,1];
//   jointRRR2.jointUSR.frame_a.R.T[3,2] = jointRRR2.jointUSR.relativePosition.frame_b.R.T[3,2];
//   jointRRR2.jointUSR.frame_a.R.T[3,2] = jointRRR2.jointUSR.rod1.frame_a.R.T[3,2];
//   jointRRR2.jointUSR.frame_a.R.T[3,3] = jointRRR2.jointUSR.relativePosition.frame_b.R.T[3,3];
//   jointRRR2.jointUSR.frame_a.R.T[3,3] = jointRRR2.jointUSR.rod1.frame_a.R.T[3,3];
//   jointRRR2.jointUSR.frame_a.r_0[1] = jointRRR2.jointUSR.relativePosition.frame_b.r_0[1];
//   jointRRR2.jointUSR.frame_a.r_0[1] = jointRRR2.jointUSR.rod1.frame_a.r_0[1];
//   jointRRR2.jointUSR.frame_a.r_0[2] = jointRRR2.jointUSR.relativePosition.frame_b.r_0[2];
//   jointRRR2.jointUSR.frame_a.r_0[2] = jointRRR2.jointUSR.rod1.frame_a.r_0[2];
//   jointRRR2.jointUSR.frame_a.r_0[3] = jointRRR2.jointUSR.relativePosition.frame_b.r_0[3];
//   jointRRR2.jointUSR.frame_a.r_0[3] = jointRRR2.jointUSR.rod1.frame_a.r_0[3];
//   jointRRR2.jointUSR.revolute.frame_b.t[1] + (jointRRR2.jointUSR.rod2.frame_a.t[1] + (-jointRRR2.jointUSR.frame_ib.t[1])) = 0.0;
//   jointRRR2.jointUSR.revolute.frame_b.t[2] + (jointRRR2.jointUSR.rod2.frame_a.t[2] + (-jointRRR2.jointUSR.frame_ib.t[2])) = 0.0;
//   jointRRR2.jointUSR.revolute.frame_b.t[3] + (jointRRR2.jointUSR.rod2.frame_a.t[3] + (-jointRRR2.jointUSR.frame_ib.t[3])) = 0.0;
//   jointRRR2.jointUSR.revolute.frame_b.f[1] + (jointRRR2.jointUSR.rod2.frame_a.f[1] + (-jointRRR2.jointUSR.frame_ib.f[1])) = 0.0;
//   jointRRR2.jointUSR.revolute.frame_b.f[2] + (jointRRR2.jointUSR.rod2.frame_a.f[2] + (-jointRRR2.jointUSR.frame_ib.f[2])) = 0.0;
//   jointRRR2.jointUSR.revolute.frame_b.f[3] + (jointRRR2.jointUSR.rod2.frame_a.f[3] + (-jointRRR2.jointUSR.frame_ib.f[3])) = 0.0;
//   jointRRR2.jointUSR.frame_ib.R.w[1] = jointRRR2.jointUSR.revolute.frame_b.R.w[1];
//   jointRRR2.jointUSR.frame_ib.R.w[1] = jointRRR2.jointUSR.rod2.frame_a.R.w[1];
//   jointRRR2.jointUSR.frame_ib.R.w[2] = jointRRR2.jointUSR.revolute.frame_b.R.w[2];
//   jointRRR2.jointUSR.frame_ib.R.w[2] = jointRRR2.jointUSR.rod2.frame_a.R.w[2];
//   jointRRR2.jointUSR.frame_ib.R.w[3] = jointRRR2.jointUSR.revolute.frame_b.R.w[3];
//   jointRRR2.jointUSR.frame_ib.R.w[3] = jointRRR2.jointUSR.rod2.frame_a.R.w[3];
//   jointRRR2.jointUSR.frame_ib.R.T[1,1] = jointRRR2.jointUSR.revolute.frame_b.R.T[1,1];
//   jointRRR2.jointUSR.frame_ib.R.T[1,1] = jointRRR2.jointUSR.rod2.frame_a.R.T[1,1];
//   jointRRR2.jointUSR.frame_ib.R.T[1,2] = jointRRR2.jointUSR.revolute.frame_b.R.T[1,2];
//   jointRRR2.jointUSR.frame_ib.R.T[1,2] = jointRRR2.jointUSR.rod2.frame_a.R.T[1,2];
//   jointRRR2.jointUSR.frame_ib.R.T[1,3] = jointRRR2.jointUSR.revolute.frame_b.R.T[1,3];
//   jointRRR2.jointUSR.frame_ib.R.T[1,3] = jointRRR2.jointUSR.rod2.frame_a.R.T[1,3];
//   jointRRR2.jointUSR.frame_ib.R.T[2,1] = jointRRR2.jointUSR.revolute.frame_b.R.T[2,1];
//   jointRRR2.jointUSR.frame_ib.R.T[2,1] = jointRRR2.jointUSR.rod2.frame_a.R.T[2,1];
//   jointRRR2.jointUSR.frame_ib.R.T[2,2] = jointRRR2.jointUSR.revolute.frame_b.R.T[2,2];
//   jointRRR2.jointUSR.frame_ib.R.T[2,2] = jointRRR2.jointUSR.rod2.frame_a.R.T[2,2];
//   jointRRR2.jointUSR.frame_ib.R.T[2,3] = jointRRR2.jointUSR.revolute.frame_b.R.T[2,3];
//   jointRRR2.jointUSR.frame_ib.R.T[2,3] = jointRRR2.jointUSR.rod2.frame_a.R.T[2,3];
//   jointRRR2.jointUSR.frame_ib.R.T[3,1] = jointRRR2.jointUSR.revolute.frame_b.R.T[3,1];
//   jointRRR2.jointUSR.frame_ib.R.T[3,1] = jointRRR2.jointUSR.rod2.frame_a.R.T[3,1];
//   jointRRR2.jointUSR.frame_ib.R.T[3,2] = jointRRR2.jointUSR.revolute.frame_b.R.T[3,2];
//   jointRRR2.jointUSR.frame_ib.R.T[3,2] = jointRRR2.jointUSR.rod2.frame_a.R.T[3,2];
//   jointRRR2.jointUSR.frame_ib.R.T[3,3] = jointRRR2.jointUSR.revolute.frame_b.R.T[3,3];
//   jointRRR2.jointUSR.frame_ib.R.T[3,3] = jointRRR2.jointUSR.rod2.frame_a.R.T[3,3];
//   jointRRR2.jointUSR.frame_ib.r_0[1] = jointRRR2.jointUSR.revolute.frame_b.r_0[1];
//   jointRRR2.jointUSR.frame_ib.r_0[1] = jointRRR2.jointUSR.rod2.frame_a.r_0[1];
//   jointRRR2.jointUSR.frame_ib.r_0[2] = jointRRR2.jointUSR.revolute.frame_b.r_0[2];
//   jointRRR2.jointUSR.frame_ib.r_0[2] = jointRRR2.jointUSR.rod2.frame_a.r_0[2];
//   jointRRR2.jointUSR.frame_ib.r_0[3] = jointRRR2.jointUSR.revolute.frame_b.r_0[3];
//   jointRRR2.jointUSR.frame_ib.r_0[3] = jointRRR2.jointUSR.rod2.frame_a.r_0[3];
//   jointRRR2.jointUSR.relativePosition.r_rel[1] = jointRRR2.jointUSR.relativePosition.relativePosition.r_rel[1];
//   jointRRR2.jointUSR.relativePosition.r_rel[2] = jointRRR2.jointUSR.relativePosition.relativePosition.r_rel[2];
//   jointRRR2.jointUSR.relativePosition.r_rel[3] = jointRRR2.jointUSR.relativePosition.relativePosition.r_rel[3];
//   jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.t[1] + jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.t[1] = 0.0;
//   jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.t[2] + jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.t[2] = 0.0;
//   jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.t[3] + jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.t[3] = 0.0;
//   jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.f[1] + jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.f[1] = 0.0;
//   jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.f[2] + jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.f[2] = 0.0;
//   jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.f[3] + jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.f[3] = 0.0;
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.R.w[1] = jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.w[1];
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.R.w[2] = jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.w[2];
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.R.w[3] = jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.w[3];
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[1,1] = jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[1,1];
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[1,2] = jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[1,2];
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[1,3] = jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[1,3];
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[2,1] = jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[2,1];
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[2,2] = jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[2,2];
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[2,3] = jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[2,3];
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[3,1] = jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[3,1];
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[3,2] = jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[3,2];
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[3,3] = jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[3,3];
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.r_0[1] = jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.r_0[1];
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.r_0[2] = jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.r_0[2];
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_resolve.r_0[3] = jointRRR2.jointUSR.relativePosition.zeroPosition.frame_resolve.r_0[3];
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.t[1] + (-jointRRR2.jointUSR.relativePosition.frame_b.t[1]) = 0.0;
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.t[2] + (-jointRRR2.jointUSR.relativePosition.frame_b.t[2]) = 0.0;
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.t[3] + (-jointRRR2.jointUSR.relativePosition.frame_b.t[3]) = 0.0;
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.f[1] + (-jointRRR2.jointUSR.relativePosition.frame_b.f[1]) = 0.0;
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.f[2] + (-jointRRR2.jointUSR.relativePosition.frame_b.f[2]) = 0.0;
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.f[3] + (-jointRRR2.jointUSR.relativePosition.frame_b.f[3]) = 0.0;
//   jointRRR2.jointUSR.relativePosition.frame_b.R.w[1] = jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.R.w[1];
//   jointRRR2.jointUSR.relativePosition.frame_b.R.w[2] = jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.R.w[2];
//   jointRRR2.jointUSR.relativePosition.frame_b.R.w[3] = jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.R.w[3];
//   jointRRR2.jointUSR.relativePosition.frame_b.R.T[1,1] = jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.R.T[1,1];
//   jointRRR2.jointUSR.relativePosition.frame_b.R.T[1,2] = jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.R.T[1,2];
//   jointRRR2.jointUSR.relativePosition.frame_b.R.T[1,3] = jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.R.T[1,3];
//   jointRRR2.jointUSR.relativePosition.frame_b.R.T[2,1] = jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.R.T[2,1];
//   jointRRR2.jointUSR.relativePosition.frame_b.R.T[2,2] = jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.R.T[2,2];
//   jointRRR2.jointUSR.relativePosition.frame_b.R.T[2,3] = jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.R.T[2,3];
//   jointRRR2.jointUSR.relativePosition.frame_b.R.T[3,1] = jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.R.T[3,1];
//   jointRRR2.jointUSR.relativePosition.frame_b.R.T[3,2] = jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.R.T[3,2];
//   jointRRR2.jointUSR.relativePosition.frame_b.R.T[3,3] = jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.R.T[3,3];
//   jointRRR2.jointUSR.relativePosition.frame_b.r_0[1] = jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.r_0[1];
//   jointRRR2.jointUSR.relativePosition.frame_b.r_0[2] = jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.r_0[2];
//   jointRRR2.jointUSR.relativePosition.frame_b.r_0[3] = jointRRR2.jointUSR.relativePosition.relativePosition.frame_b.r_0[3];
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.t[1] + (-jointRRR2.jointUSR.relativePosition.frame_a.t[1]) = 0.0;
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.t[2] + (-jointRRR2.jointUSR.relativePosition.frame_a.t[2]) = 0.0;
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.t[3] + (-jointRRR2.jointUSR.relativePosition.frame_a.t[3]) = 0.0;
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.f[1] + (-jointRRR2.jointUSR.relativePosition.frame_a.f[1]) = 0.0;
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.f[2] + (-jointRRR2.jointUSR.relativePosition.frame_a.f[2]) = 0.0;
//   jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.f[3] + (-jointRRR2.jointUSR.relativePosition.frame_a.f[3]) = 0.0;
//   jointRRR2.jointUSR.relativePosition.frame_a.R.w[1] = jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.R.w[1];
//   jointRRR2.jointUSR.relativePosition.frame_a.R.w[2] = jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.R.w[2];
//   jointRRR2.jointUSR.relativePosition.frame_a.R.w[3] = jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.R.w[3];
//   jointRRR2.jointUSR.relativePosition.frame_a.R.T[1,1] = jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.R.T[1,1];
//   jointRRR2.jointUSR.relativePosition.frame_a.R.T[1,2] = jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.R.T[1,2];
//   jointRRR2.jointUSR.relativePosition.frame_a.R.T[1,3] = jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.R.T[1,3];
//   jointRRR2.jointUSR.relativePosition.frame_a.R.T[2,1] = jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.R.T[2,1];
//   jointRRR2.jointUSR.relativePosition.frame_a.R.T[2,2] = jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.R.T[2,2];
//   jointRRR2.jointUSR.relativePosition.frame_a.R.T[2,3] = jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.R.T[2,3];
//   jointRRR2.jointUSR.relativePosition.frame_a.R.T[3,1] = jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.R.T[3,1];
//   jointRRR2.jointUSR.relativePosition.frame_a.R.T[3,2] = jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.R.T[3,2];
//   jointRRR2.jointUSR.relativePosition.frame_a.R.T[3,3] = jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.R.T[3,3];
//   jointRRR2.jointUSR.relativePosition.frame_a.r_0[1] = jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.r_0[1];
//   jointRRR2.jointUSR.relativePosition.frame_a.r_0[2] = jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.r_0[2];
//   jointRRR2.jointUSR.relativePosition.frame_a.r_0[3] = jointRRR2.jointUSR.relativePosition.relativePosition.frame_a.r_0[3];
//   jointRRR2.bearing.tau = 0.0;
//   jointRRR2.axis.tau = 0.0;
//   jointRRR2.frame_ib.t[3] = 0.0;
//   jointRRR2.frame_ib.t[2] = 0.0;
//   jointRRR2.frame_ib.t[1] = 0.0;
//   jointRRR2.frame_ib.f[3] = 0.0;
//   jointRRR2.frame_ib.f[2] = 0.0;
//   jointRRR2.frame_ib.f[1] = 0.0;
//   rev.internalAxis.flange.tau + (-rev.axis.tau) = 0.0;
//   rev.axis.phi = rev.internalAxis.flange.phi;
//   rev.fixed.flange.tau + (-rev.support.tau) = 0.0;
//   rev.fixed.flange.phi = rev.support.phi;
//   rev.support.tau = 0.0;
//   jointRRR1.jointUSR.bearing.tau + (-jointRRR1.bearing.tau) = 0.0;
//   jointRRR1.bearing.phi = jointRRR1.jointUSR.bearing.phi;
//   jointRRR1.jointUSR.axis.tau + (-jointRRR1.axis.tau) = 0.0;
//   jointRRR1.axis.phi = jointRRR1.jointUSR.axis.phi;
//   jointRRR1.jointUSR.frame_ib.t[1] + (-jointRRR1.frame_ib.t[1]) = 0.0;
//   jointRRR1.jointUSR.frame_ib.t[2] + (-jointRRR1.frame_ib.t[2]) = 0.0;
//   jointRRR1.jointUSR.frame_ib.t[3] + (-jointRRR1.frame_ib.t[3]) = 0.0;
//   jointRRR1.jointUSR.frame_ib.f[1] + (-jointRRR1.frame_ib.f[1]) = 0.0;
//   jointRRR1.jointUSR.frame_ib.f[2] + (-jointRRR1.frame_ib.f[2]) = 0.0;
//   jointRRR1.jointUSR.frame_ib.f[3] + (-jointRRR1.frame_ib.f[3]) = 0.0;
//   jointRRR1.frame_ib.R.w[1] = jointRRR1.jointUSR.frame_ib.R.w[1];
//   jointRRR1.frame_ib.R.w[2] = jointRRR1.jointUSR.frame_ib.R.w[2];
//   jointRRR1.frame_ib.R.w[3] = jointRRR1.jointUSR.frame_ib.R.w[3];
//   jointRRR1.frame_ib.R.T[1,1] = jointRRR1.jointUSR.frame_ib.R.T[1,1];
//   jointRRR1.frame_ib.R.T[1,2] = jointRRR1.jointUSR.frame_ib.R.T[1,2];
//   jointRRR1.frame_ib.R.T[1,3] = jointRRR1.jointUSR.frame_ib.R.T[1,3];
//   jointRRR1.frame_ib.R.T[2,1] = jointRRR1.jointUSR.frame_ib.R.T[2,1];
//   jointRRR1.frame_ib.R.T[2,2] = jointRRR1.jointUSR.frame_ib.R.T[2,2];
//   jointRRR1.frame_ib.R.T[2,3] = jointRRR1.jointUSR.frame_ib.R.T[2,3];
//   jointRRR1.frame_ib.R.T[3,1] = jointRRR1.jointUSR.frame_ib.R.T[3,1];
//   jointRRR1.frame_ib.R.T[3,2] = jointRRR1.jointUSR.frame_ib.R.T[3,2];
//   jointRRR1.frame_ib.R.T[3,3] = jointRRR1.jointUSR.frame_ib.R.T[3,3];
//   jointRRR1.frame_ib.r_0[1] = jointRRR1.jointUSR.frame_ib.r_0[1];
//   jointRRR1.frame_ib.r_0[2] = jointRRR1.jointUSR.frame_ib.r_0[2];
//   jointRRR1.frame_ib.r_0[3] = jointRRR1.jointUSR.frame_ib.r_0[3];
//   jointRRR1.jointUSR.frame_im.t[1] + (-jointRRR1.frame_im.t[1]) = 0.0;
//   jointRRR1.jointUSR.frame_im.t[2] + (-jointRRR1.frame_im.t[2]) = 0.0;
//   jointRRR1.jointUSR.frame_im.t[3] + (-jointRRR1.frame_im.t[3]) = 0.0;
//   jointRRR1.jointUSR.frame_im.f[1] + (-jointRRR1.frame_im.f[1]) = 0.0;
//   jointRRR1.jointUSR.frame_im.f[2] + (-jointRRR1.frame_im.f[2]) = 0.0;
//   jointRRR1.jointUSR.frame_im.f[3] + (-jointRRR1.frame_im.f[3]) = 0.0;
//   jointRRR1.frame_im.R.w[1] = jointRRR1.jointUSR.frame_im.R.w[1];
//   jointRRR1.frame_im.R.w[2] = jointRRR1.jointUSR.frame_im.R.w[2];
//   jointRRR1.frame_im.R.w[3] = jointRRR1.jointUSR.frame_im.R.w[3];
//   jointRRR1.frame_im.R.T[1,1] = jointRRR1.jointUSR.frame_im.R.T[1,1];
//   jointRRR1.frame_im.R.T[1,2] = jointRRR1.jointUSR.frame_im.R.T[1,2];
//   jointRRR1.frame_im.R.T[1,3] = jointRRR1.jointUSR.frame_im.R.T[1,3];
//   jointRRR1.frame_im.R.T[2,1] = jointRRR1.jointUSR.frame_im.R.T[2,1];
//   jointRRR1.frame_im.R.T[2,2] = jointRRR1.jointUSR.frame_im.R.T[2,2];
//   jointRRR1.frame_im.R.T[2,3] = jointRRR1.jointUSR.frame_im.R.T[2,3];
//   jointRRR1.frame_im.R.T[3,1] = jointRRR1.jointUSR.frame_im.R.T[3,1];
//   jointRRR1.frame_im.R.T[3,2] = jointRRR1.jointUSR.frame_im.R.T[3,2];
//   jointRRR1.frame_im.R.T[3,3] = jointRRR1.jointUSR.frame_im.R.T[3,3];
//   jointRRR1.frame_im.r_0[1] = jointRRR1.jointUSR.frame_im.r_0[1];
//   jointRRR1.frame_im.r_0[2] = jointRRR1.jointUSR.frame_im.r_0[2];
//   jointRRR1.frame_im.r_0[3] = jointRRR1.jointUSR.frame_im.r_0[3];
//   jointRRR1.jointUSR.frame_ia.t[1] + (-jointRRR1.frame_ia.t[1]) = 0.0;
//   jointRRR1.jointUSR.frame_ia.t[2] + (-jointRRR1.frame_ia.t[2]) = 0.0;
//   jointRRR1.jointUSR.frame_ia.t[3] + (-jointRRR1.frame_ia.t[3]) = 0.0;
//   jointRRR1.jointUSR.frame_ia.f[1] + (-jointRRR1.frame_ia.f[1]) = 0.0;
//   jointRRR1.jointUSR.frame_ia.f[2] + (-jointRRR1.frame_ia.f[2]) = 0.0;
//   jointRRR1.jointUSR.frame_ia.f[3] + (-jointRRR1.frame_ia.f[3]) = 0.0;
//   jointRRR1.frame_ia.R.w[1] = jointRRR1.jointUSR.frame_ia.R.w[1];
//   jointRRR1.frame_ia.R.w[2] = jointRRR1.jointUSR.frame_ia.R.w[2];
//   jointRRR1.frame_ia.R.w[3] = jointRRR1.jointUSR.frame_ia.R.w[3];
//   jointRRR1.frame_ia.R.T[1,1] = jointRRR1.jointUSR.frame_ia.R.T[1,1];
//   jointRRR1.frame_ia.R.T[1,2] = jointRRR1.jointUSR.frame_ia.R.T[1,2];
//   jointRRR1.frame_ia.R.T[1,3] = jointRRR1.jointUSR.frame_ia.R.T[1,3];
//   jointRRR1.frame_ia.R.T[2,1] = jointRRR1.jointUSR.frame_ia.R.T[2,1];
//   jointRRR1.frame_ia.R.T[2,2] = jointRRR1.jointUSR.frame_ia.R.T[2,2];
//   jointRRR1.frame_ia.R.T[2,3] = jointRRR1.jointUSR.frame_ia.R.T[2,3];
//   jointRRR1.frame_ia.R.T[3,1] = jointRRR1.jointUSR.frame_ia.R.T[3,1];
//   jointRRR1.frame_ia.R.T[3,2] = jointRRR1.jointUSR.frame_ia.R.T[3,2];
//   jointRRR1.frame_ia.R.T[3,3] = jointRRR1.jointUSR.frame_ia.R.T[3,3];
//   jointRRR1.frame_ia.r_0[1] = jointRRR1.jointUSR.frame_ia.r_0[1];
//   jointRRR1.frame_ia.r_0[2] = jointRRR1.jointUSR.frame_ia.r_0[2];
//   jointRRR1.frame_ia.r_0[3] = jointRRR1.jointUSR.frame_ia.r_0[3];
//   jointRRR1.jointUSR.frame_b.t[1] + (-jointRRR1.frame_b.t[1]) = 0.0;
//   jointRRR1.jointUSR.frame_b.t[2] + (-jointRRR1.frame_b.t[2]) = 0.0;
//   jointRRR1.jointUSR.frame_b.t[3] + (-jointRRR1.frame_b.t[3]) = 0.0;
//   jointRRR1.jointUSR.frame_b.f[1] + (-jointRRR1.frame_b.f[1]) = 0.0;
//   jointRRR1.jointUSR.frame_b.f[2] + (-jointRRR1.frame_b.f[2]) = 0.0;
//   jointRRR1.jointUSR.frame_b.f[3] + (-jointRRR1.frame_b.f[3]) = 0.0;
//   jointRRR1.frame_b.R.w[1] = jointRRR1.jointUSR.frame_b.R.w[1];
//   jointRRR1.frame_b.R.w[2] = jointRRR1.jointUSR.frame_b.R.w[2];
//   jointRRR1.frame_b.R.w[3] = jointRRR1.jointUSR.frame_b.R.w[3];
//   jointRRR1.frame_b.R.T[1,1] = jointRRR1.jointUSR.frame_b.R.T[1,1];
//   jointRRR1.frame_b.R.T[1,2] = jointRRR1.jointUSR.frame_b.R.T[1,2];
//   jointRRR1.frame_b.R.T[1,3] = jointRRR1.jointUSR.frame_b.R.T[1,3];
//   jointRRR1.frame_b.R.T[2,1] = jointRRR1.jointUSR.frame_b.R.T[2,1];
//   jointRRR1.frame_b.R.T[2,2] = jointRRR1.jointUSR.frame_b.R.T[2,2];
//   jointRRR1.frame_b.R.T[2,3] = jointRRR1.jointUSR.frame_b.R.T[2,3];
//   jointRRR1.frame_b.R.T[3,1] = jointRRR1.jointUSR.frame_b.R.T[3,1];
//   jointRRR1.frame_b.R.T[3,2] = jointRRR1.jointUSR.frame_b.R.T[3,2];
//   jointRRR1.frame_b.R.T[3,3] = jointRRR1.jointUSR.frame_b.R.T[3,3];
//   jointRRR1.frame_b.r_0[1] = jointRRR1.jointUSR.frame_b.r_0[1];
//   jointRRR1.frame_b.r_0[2] = jointRRR1.jointUSR.frame_b.r_0[2];
//   jointRRR1.frame_b.r_0[3] = jointRRR1.jointUSR.frame_b.r_0[3];
//   jointRRR1.jointUSR.frame_a.t[1] + (-jointRRR1.frame_a.t[1]) = 0.0;
//   jointRRR1.jointUSR.frame_a.t[2] + (-jointRRR1.frame_a.t[2]) = 0.0;
//   jointRRR1.jointUSR.frame_a.t[3] + (-jointRRR1.frame_a.t[3]) = 0.0;
//   jointRRR1.jointUSR.frame_a.f[1] + (-jointRRR1.frame_a.f[1]) = 0.0;
//   jointRRR1.jointUSR.frame_a.f[2] + (-jointRRR1.frame_a.f[2]) = 0.0;
//   jointRRR1.jointUSR.frame_a.f[3] + (-jointRRR1.frame_a.f[3]) = 0.0;
//   jointRRR1.frame_a.R.w[1] = jointRRR1.jointUSR.frame_a.R.w[1];
//   jointRRR1.frame_a.R.w[2] = jointRRR1.jointUSR.frame_a.R.w[2];
//   jointRRR1.frame_a.R.w[3] = jointRRR1.jointUSR.frame_a.R.w[3];
//   jointRRR1.frame_a.R.T[1,1] = jointRRR1.jointUSR.frame_a.R.T[1,1];
//   jointRRR1.frame_a.R.T[1,2] = jointRRR1.jointUSR.frame_a.R.T[1,2];
//   jointRRR1.frame_a.R.T[1,3] = jointRRR1.jointUSR.frame_a.R.T[1,3];
//   jointRRR1.frame_a.R.T[2,1] = jointRRR1.jointUSR.frame_a.R.T[2,1];
//   jointRRR1.frame_a.R.T[2,2] = jointRRR1.jointUSR.frame_a.R.T[2,2];
//   jointRRR1.frame_a.R.T[2,3] = jointRRR1.jointUSR.frame_a.R.T[2,3];
//   jointRRR1.frame_a.R.T[3,1] = jointRRR1.jointUSR.frame_a.R.T[3,1];
//   jointRRR1.frame_a.R.T[3,2] = jointRRR1.jointUSR.frame_a.R.T[3,2];
//   jointRRR1.frame_a.R.T[3,3] = jointRRR1.jointUSR.frame_a.R.T[3,3];
//   jointRRR1.frame_a.r_0[1] = jointRRR1.jointUSR.frame_a.r_0[1];
//   jointRRR1.frame_a.r_0[2] = jointRRR1.jointUSR.frame_a.r_0[2];
//   jointRRR1.frame_a.r_0[3] = jointRRR1.jointUSR.frame_a.r_0[3];
//   jointRRR1.jointUSR.revolute.bearing.tau + (-jointRRR1.jointUSR.bearing.tau) = 0.0;
//   jointRRR1.jointUSR.bearing.phi = jointRRR1.jointUSR.revolute.bearing.phi;
//   jointRRR1.jointUSR.relativePosition.r_rel[1] = jointRRR1.jointUSR.revolute.position_a[1];
//   jointRRR1.jointUSR.relativePosition.r_rel[2] = jointRRR1.jointUSR.revolute.position_a[2];
//   jointRRR1.jointUSR.relativePosition.r_rel[3] = jointRRR1.jointUSR.revolute.position_a[3];
//   jointRRR1.jointUSR.revolute.axis.tau + (-jointRRR1.jointUSR.axis.tau) = 0.0;
//   jointRRR1.jointUSR.axis.phi = jointRRR1.jointUSR.revolute.axis.phi;
//   jointRRR1.jointUSR.rod1.frame_ia.t[1] + (-jointRRR1.jointUSR.frame_ia.t[1]) = 0.0;
//   jointRRR1.jointUSR.rod1.frame_ia.t[2] + (-jointRRR1.jointUSR.frame_ia.t[2]) = 0.0;
//   jointRRR1.jointUSR.rod1.frame_ia.t[3] + (-jointRRR1.jointUSR.frame_ia.t[3]) = 0.0;
//   jointRRR1.jointUSR.rod1.frame_ia.f[1] + (-jointRRR1.jointUSR.frame_ia.f[1]) = 0.0;
//   jointRRR1.jointUSR.rod1.frame_ia.f[2] + (-jointRRR1.jointUSR.frame_ia.f[2]) = 0.0;
//   jointRRR1.jointUSR.rod1.frame_ia.f[3] + (-jointRRR1.jointUSR.frame_ia.f[3]) = 0.0;
//   jointRRR1.jointUSR.frame_ia.R.w[1] = jointRRR1.jointUSR.rod1.frame_ia.R.w[1];
//   jointRRR1.jointUSR.frame_ia.R.w[2] = jointRRR1.jointUSR.rod1.frame_ia.R.w[2];
//   jointRRR1.jointUSR.frame_ia.R.w[3] = jointRRR1.jointUSR.rod1.frame_ia.R.w[3];
//   jointRRR1.jointUSR.frame_ia.R.T[1,1] = jointRRR1.jointUSR.rod1.frame_ia.R.T[1,1];
//   jointRRR1.jointUSR.frame_ia.R.T[1,2] = jointRRR1.jointUSR.rod1.frame_ia.R.T[1,2];
//   jointRRR1.jointUSR.frame_ia.R.T[1,3] = jointRRR1.jointUSR.rod1.frame_ia.R.T[1,3];
//   jointRRR1.jointUSR.frame_ia.R.T[2,1] = jointRRR1.jointUSR.rod1.frame_ia.R.T[2,1];
//   jointRRR1.jointUSR.frame_ia.R.T[2,2] = jointRRR1.jointUSR.rod1.frame_ia.R.T[2,2];
//   jointRRR1.jointUSR.frame_ia.R.T[2,3] = jointRRR1.jointUSR.rod1.frame_ia.R.T[2,3];
//   jointRRR1.jointUSR.frame_ia.R.T[3,1] = jointRRR1.jointUSR.rod1.frame_ia.R.T[3,1];
//   jointRRR1.jointUSR.frame_ia.R.T[3,2] = jointRRR1.jointUSR.rod1.frame_ia.R.T[3,2];
//   jointRRR1.jointUSR.frame_ia.R.T[3,3] = jointRRR1.jointUSR.rod1.frame_ia.R.T[3,3];
//   jointRRR1.jointUSR.frame_ia.r_0[1] = jointRRR1.jointUSR.rod1.frame_ia.r_0[1];
//   jointRRR1.jointUSR.frame_ia.r_0[2] = jointRRR1.jointUSR.rod1.frame_ia.r_0[2];
//   jointRRR1.jointUSR.frame_ia.r_0[3] = jointRRR1.jointUSR.rod1.frame_ia.r_0[3];
//   jointRRR1.jointUSR.rod2.frame_b.t[1] + (jointRRR1.jointUSR.rod1.frame_b.t[1] + (-jointRRR1.jointUSR.frame_im.t[1])) = 0.0;
//   jointRRR1.jointUSR.rod2.frame_b.t[2] + (jointRRR1.jointUSR.rod1.frame_b.t[2] + (-jointRRR1.jointUSR.frame_im.t[2])) = 0.0;
//   jointRRR1.jointUSR.rod2.frame_b.t[3] + (jointRRR1.jointUSR.rod1.frame_b.t[3] + (-jointRRR1.jointUSR.frame_im.t[3])) = 0.0;
//   jointRRR1.jointUSR.rod2.frame_b.f[1] + (jointRRR1.jointUSR.rod1.frame_b.f[1] + (-jointRRR1.jointUSR.frame_im.f[1])) = 0.0;
//   jointRRR1.jointUSR.rod2.frame_b.f[2] + (jointRRR1.jointUSR.rod1.frame_b.f[2] + (-jointRRR1.jointUSR.frame_im.f[2])) = 0.0;
//   jointRRR1.jointUSR.rod2.frame_b.f[3] + (jointRRR1.jointUSR.rod1.frame_b.f[3] + (-jointRRR1.jointUSR.frame_im.f[3])) = 0.0;
//   jointRRR1.jointUSR.frame_im.R.w[1] = jointRRR1.jointUSR.rod1.frame_b.R.w[1];
//   jointRRR1.jointUSR.frame_im.R.w[1] = jointRRR1.jointUSR.rod2.frame_b.R.w[1];
//   jointRRR1.jointUSR.frame_im.R.w[2] = jointRRR1.jointUSR.rod1.frame_b.R.w[2];
//   jointRRR1.jointUSR.frame_im.R.w[2] = jointRRR1.jointUSR.rod2.frame_b.R.w[2];
//   jointRRR1.jointUSR.frame_im.R.w[3] = jointRRR1.jointUSR.rod1.frame_b.R.w[3];
//   jointRRR1.jointUSR.frame_im.R.w[3] = jointRRR1.jointUSR.rod2.frame_b.R.w[3];
//   jointRRR1.jointUSR.frame_im.R.T[1,1] = jointRRR1.jointUSR.rod1.frame_b.R.T[1,1];
//   jointRRR1.jointUSR.frame_im.R.T[1,1] = jointRRR1.jointUSR.rod2.frame_b.R.T[1,1];
//   jointRRR1.jointUSR.frame_im.R.T[1,2] = jointRRR1.jointUSR.rod1.frame_b.R.T[1,2];
//   jointRRR1.jointUSR.frame_im.R.T[1,2] = jointRRR1.jointUSR.rod2.frame_b.R.T[1,2];
//   jointRRR1.jointUSR.frame_im.R.T[1,3] = jointRRR1.jointUSR.rod1.frame_b.R.T[1,3];
//   jointRRR1.jointUSR.frame_im.R.T[1,3] = jointRRR1.jointUSR.rod2.frame_b.R.T[1,3];
//   jointRRR1.jointUSR.frame_im.R.T[2,1] = jointRRR1.jointUSR.rod1.frame_b.R.T[2,1];
//   jointRRR1.jointUSR.frame_im.R.T[2,1] = jointRRR1.jointUSR.rod2.frame_b.R.T[2,1];
//   jointRRR1.jointUSR.frame_im.R.T[2,2] = jointRRR1.jointUSR.rod1.frame_b.R.T[2,2];
//   jointRRR1.jointUSR.frame_im.R.T[2,2] = jointRRR1.jointUSR.rod2.frame_b.R.T[2,2];
//   jointRRR1.jointUSR.frame_im.R.T[2,3] = jointRRR1.jointUSR.rod1.frame_b.R.T[2,3];
//   jointRRR1.jointUSR.frame_im.R.T[2,3] = jointRRR1.jointUSR.rod2.frame_b.R.T[2,3];
//   jointRRR1.jointUSR.frame_im.R.T[3,1] = jointRRR1.jointUSR.rod1.frame_b.R.T[3,1];
//   jointRRR1.jointUSR.frame_im.R.T[3,1] = jointRRR1.jointUSR.rod2.frame_b.R.T[3,1];
//   jointRRR1.jointUSR.frame_im.R.T[3,2] = jointRRR1.jointUSR.rod1.frame_b.R.T[3,2];
//   jointRRR1.jointUSR.frame_im.R.T[3,2] = jointRRR1.jointUSR.rod2.frame_b.R.T[3,2];
//   jointRRR1.jointUSR.frame_im.R.T[3,3] = jointRRR1.jointUSR.rod1.frame_b.R.T[3,3];
//   jointRRR1.jointUSR.frame_im.R.T[3,3] = jointRRR1.jointUSR.rod2.frame_b.R.T[3,3];
//   jointRRR1.jointUSR.frame_im.r_0[1] = jointRRR1.jointUSR.rod1.frame_b.r_0[1];
//   jointRRR1.jointUSR.frame_im.r_0[1] = jointRRR1.jointUSR.rod2.frame_b.r_0[1];
//   jointRRR1.jointUSR.frame_im.r_0[2] = jointRRR1.jointUSR.rod1.frame_b.r_0[2];
//   jointRRR1.jointUSR.frame_im.r_0[2] = jointRRR1.jointUSR.rod2.frame_b.r_0[2];
//   jointRRR1.jointUSR.frame_im.r_0[3] = jointRRR1.jointUSR.rod1.frame_b.r_0[3];
//   jointRRR1.jointUSR.frame_im.r_0[3] = jointRRR1.jointUSR.rod2.frame_b.r_0[3];
//   jointRRR1.jointUSR.position_b[1].y = jointRRR1.jointUSR.revolute.position_b[1];
//   jointRRR1.jointUSR.position_b[2].y = jointRRR1.jointUSR.revolute.position_b[2];
//   jointRRR1.jointUSR.position_b[3].y = jointRRR1.jointUSR.revolute.position_b[3];
//   jointRRR1.jointUSR.relativePosition.frame_a.t[1] + (jointRRR1.jointUSR.revolute.frame_a.t[1] + (-jointRRR1.jointUSR.frame_b.t[1])) = 0.0;
//   jointRRR1.jointUSR.relativePosition.frame_a.t[2] + (jointRRR1.jointUSR.revolute.frame_a.t[2] + (-jointRRR1.jointUSR.frame_b.t[2])) = 0.0;
//   jointRRR1.jointUSR.relativePosition.frame_a.t[3] + (jointRRR1.jointUSR.revolute.frame_a.t[3] + (-jointRRR1.jointUSR.frame_b.t[3])) = 0.0;
//   jointRRR1.jointUSR.relativePosition.frame_a.f[1] + (jointRRR1.jointUSR.revolute.frame_a.f[1] + (-jointRRR1.jointUSR.frame_b.f[1])) = 0.0;
//   jointRRR1.jointUSR.relativePosition.frame_a.f[2] + (jointRRR1.jointUSR.revolute.frame_a.f[2] + (-jointRRR1.jointUSR.frame_b.f[2])) = 0.0;
//   jointRRR1.jointUSR.relativePosition.frame_a.f[3] + (jointRRR1.jointUSR.revolute.frame_a.f[3] + (-jointRRR1.jointUSR.frame_b.f[3])) = 0.0;
//   jointRRR1.jointUSR.frame_b.R.w[1] = jointRRR1.jointUSR.relativePosition.frame_a.R.w[1];
//   jointRRR1.jointUSR.frame_b.R.w[1] = jointRRR1.jointUSR.revolute.frame_a.R.w[1];
//   jointRRR1.jointUSR.frame_b.R.w[2] = jointRRR1.jointUSR.relativePosition.frame_a.R.w[2];
//   jointRRR1.jointUSR.frame_b.R.w[2] = jointRRR1.jointUSR.revolute.frame_a.R.w[2];
//   jointRRR1.jointUSR.frame_b.R.w[3] = jointRRR1.jointUSR.relativePosition.frame_a.R.w[3];
//   jointRRR1.jointUSR.frame_b.R.w[3] = jointRRR1.jointUSR.revolute.frame_a.R.w[3];
//   jointRRR1.jointUSR.frame_b.R.T[1,1] = jointRRR1.jointUSR.relativePosition.frame_a.R.T[1,1];
//   jointRRR1.jointUSR.frame_b.R.T[1,1] = jointRRR1.jointUSR.revolute.frame_a.R.T[1,1];
//   jointRRR1.jointUSR.frame_b.R.T[1,2] = jointRRR1.jointUSR.relativePosition.frame_a.R.T[1,2];
//   jointRRR1.jointUSR.frame_b.R.T[1,2] = jointRRR1.jointUSR.revolute.frame_a.R.T[1,2];
//   jointRRR1.jointUSR.frame_b.R.T[1,3] = jointRRR1.jointUSR.relativePosition.frame_a.R.T[1,3];
//   jointRRR1.jointUSR.frame_b.R.T[1,3] = jointRRR1.jointUSR.revolute.frame_a.R.T[1,3];
//   jointRRR1.jointUSR.frame_b.R.T[2,1] = jointRRR1.jointUSR.relativePosition.frame_a.R.T[2,1];
//   jointRRR1.jointUSR.frame_b.R.T[2,1] = jointRRR1.jointUSR.revolute.frame_a.R.T[2,1];
//   jointRRR1.jointUSR.frame_b.R.T[2,2] = jointRRR1.jointUSR.relativePosition.frame_a.R.T[2,2];
//   jointRRR1.jointUSR.frame_b.R.T[2,2] = jointRRR1.jointUSR.revolute.frame_a.R.T[2,2];
//   jointRRR1.jointUSR.frame_b.R.T[2,3] = jointRRR1.jointUSR.relativePosition.frame_a.R.T[2,3];
//   jointRRR1.jointUSR.frame_b.R.T[2,3] = jointRRR1.jointUSR.revolute.frame_a.R.T[2,3];
//   jointRRR1.jointUSR.frame_b.R.T[3,1] = jointRRR1.jointUSR.relativePosition.frame_a.R.T[3,1];
//   jointRRR1.jointUSR.frame_b.R.T[3,1] = jointRRR1.jointUSR.revolute.frame_a.R.T[3,1];
//   jointRRR1.jointUSR.frame_b.R.T[3,2] = jointRRR1.jointUSR.relativePosition.frame_a.R.T[3,2];
//   jointRRR1.jointUSR.frame_b.R.T[3,2] = jointRRR1.jointUSR.revolute.frame_a.R.T[3,2];
//   jointRRR1.jointUSR.frame_b.R.T[3,3] = jointRRR1.jointUSR.relativePosition.frame_a.R.T[3,3];
//   jointRRR1.jointUSR.frame_b.R.T[3,3] = jointRRR1.jointUSR.revolute.frame_a.R.T[3,3];
//   jointRRR1.jointUSR.frame_b.r_0[1] = jointRRR1.jointUSR.relativePosition.frame_a.r_0[1];
//   jointRRR1.jointUSR.frame_b.r_0[1] = jointRRR1.jointUSR.revolute.frame_a.r_0[1];
//   jointRRR1.jointUSR.frame_b.r_0[2] = jointRRR1.jointUSR.relativePosition.frame_a.r_0[2];
//   jointRRR1.jointUSR.frame_b.r_0[2] = jointRRR1.jointUSR.revolute.frame_a.r_0[2];
//   jointRRR1.jointUSR.frame_b.r_0[3] = jointRRR1.jointUSR.relativePosition.frame_a.r_0[3];
//   jointRRR1.jointUSR.frame_b.r_0[3] = jointRRR1.jointUSR.revolute.frame_a.r_0[3];
//   jointRRR1.jointUSR.relativePosition.frame_b.t[1] + (jointRRR1.jointUSR.rod1.frame_a.t[1] + (-jointRRR1.jointUSR.frame_a.t[1])) = 0.0;
//   jointRRR1.jointUSR.relativePosition.frame_b.t[2] + (jointRRR1.jointUSR.rod1.frame_a.t[2] + (-jointRRR1.jointUSR.frame_a.t[2])) = 0.0;
//   jointRRR1.jointUSR.relativePosition.frame_b.t[3] + (jointRRR1.jointUSR.rod1.frame_a.t[3] + (-jointRRR1.jointUSR.frame_a.t[3])) = 0.0;
//   jointRRR1.jointUSR.relativePosition.frame_b.f[1] + (jointRRR1.jointUSR.rod1.frame_a.f[1] + (-jointRRR1.jointUSR.frame_a.f[1])) = 0.0;
//   jointRRR1.jointUSR.relativePosition.frame_b.f[2] + (jointRRR1.jointUSR.rod1.frame_a.f[2] + (-jointRRR1.jointUSR.frame_a.f[2])) = 0.0;
//   jointRRR1.jointUSR.relativePosition.frame_b.f[3] + (jointRRR1.jointUSR.rod1.frame_a.f[3] + (-jointRRR1.jointUSR.frame_a.f[3])) = 0.0;
//   jointRRR1.jointUSR.frame_a.R.w[1] = jointRRR1.jointUSR.relativePosition.frame_b.R.w[1];
//   jointRRR1.jointUSR.frame_a.R.w[1] = jointRRR1.jointUSR.rod1.frame_a.R.w[1];
//   jointRRR1.jointUSR.frame_a.R.w[2] = jointRRR1.jointUSR.relativePosition.frame_b.R.w[2];
//   jointRRR1.jointUSR.frame_a.R.w[2] = jointRRR1.jointUSR.rod1.frame_a.R.w[2];
//   jointRRR1.jointUSR.frame_a.R.w[3] = jointRRR1.jointUSR.relativePosition.frame_b.R.w[3];
//   jointRRR1.jointUSR.frame_a.R.w[3] = jointRRR1.jointUSR.rod1.frame_a.R.w[3];
//   jointRRR1.jointUSR.frame_a.R.T[1,1] = jointRRR1.jointUSR.relativePosition.frame_b.R.T[1,1];
//   jointRRR1.jointUSR.frame_a.R.T[1,1] = jointRRR1.jointUSR.rod1.frame_a.R.T[1,1];
//   jointRRR1.jointUSR.frame_a.R.T[1,2] = jointRRR1.jointUSR.relativePosition.frame_b.R.T[1,2];
//   jointRRR1.jointUSR.frame_a.R.T[1,2] = jointRRR1.jointUSR.rod1.frame_a.R.T[1,2];
//   jointRRR1.jointUSR.frame_a.R.T[1,3] = jointRRR1.jointUSR.relativePosition.frame_b.R.T[1,3];
//   jointRRR1.jointUSR.frame_a.R.T[1,3] = jointRRR1.jointUSR.rod1.frame_a.R.T[1,3];
//   jointRRR1.jointUSR.frame_a.R.T[2,1] = jointRRR1.jointUSR.relativePosition.frame_b.R.T[2,1];
//   jointRRR1.jointUSR.frame_a.R.T[2,1] = jointRRR1.jointUSR.rod1.frame_a.R.T[2,1];
//   jointRRR1.jointUSR.frame_a.R.T[2,2] = jointRRR1.jointUSR.relativePosition.frame_b.R.T[2,2];
//   jointRRR1.jointUSR.frame_a.R.T[2,2] = jointRRR1.jointUSR.rod1.frame_a.R.T[2,2];
//   jointRRR1.jointUSR.frame_a.R.T[2,3] = jointRRR1.jointUSR.relativePosition.frame_b.R.T[2,3];
//   jointRRR1.jointUSR.frame_a.R.T[2,3] = jointRRR1.jointUSR.rod1.frame_a.R.T[2,3];
//   jointRRR1.jointUSR.frame_a.R.T[3,1] = jointRRR1.jointUSR.relativePosition.frame_b.R.T[3,1];
//   jointRRR1.jointUSR.frame_a.R.T[3,1] = jointRRR1.jointUSR.rod1.frame_a.R.T[3,1];
//   jointRRR1.jointUSR.frame_a.R.T[3,2] = jointRRR1.jointUSR.relativePosition.frame_b.R.T[3,2];
//   jointRRR1.jointUSR.frame_a.R.T[3,2] = jointRRR1.jointUSR.rod1.frame_a.R.T[3,2];
//   jointRRR1.jointUSR.frame_a.R.T[3,3] = jointRRR1.jointUSR.relativePosition.frame_b.R.T[3,3];
//   jointRRR1.jointUSR.frame_a.R.T[3,3] = jointRRR1.jointUSR.rod1.frame_a.R.T[3,3];
//   jointRRR1.jointUSR.frame_a.r_0[1] = jointRRR1.jointUSR.relativePosition.frame_b.r_0[1];
//   jointRRR1.jointUSR.frame_a.r_0[1] = jointRRR1.jointUSR.rod1.frame_a.r_0[1];
//   jointRRR1.jointUSR.frame_a.r_0[2] = jointRRR1.jointUSR.relativePosition.frame_b.r_0[2];
//   jointRRR1.jointUSR.frame_a.r_0[2] = jointRRR1.jointUSR.rod1.frame_a.r_0[2];
//   jointRRR1.jointUSR.frame_a.r_0[3] = jointRRR1.jointUSR.relativePosition.frame_b.r_0[3];
//   jointRRR1.jointUSR.frame_a.r_0[3] = jointRRR1.jointUSR.rod1.frame_a.r_0[3];
//   jointRRR1.jointUSR.revolute.frame_b.t[1] + (jointRRR1.jointUSR.rod2.frame_a.t[1] + (-jointRRR1.jointUSR.frame_ib.t[1])) = 0.0;
//   jointRRR1.jointUSR.revolute.frame_b.t[2] + (jointRRR1.jointUSR.rod2.frame_a.t[2] + (-jointRRR1.jointUSR.frame_ib.t[2])) = 0.0;
//   jointRRR1.jointUSR.revolute.frame_b.t[3] + (jointRRR1.jointUSR.rod2.frame_a.t[3] + (-jointRRR1.jointUSR.frame_ib.t[3])) = 0.0;
//   jointRRR1.jointUSR.revolute.frame_b.f[1] + (jointRRR1.jointUSR.rod2.frame_a.f[1] + (-jointRRR1.jointUSR.frame_ib.f[1])) = 0.0;
//   jointRRR1.jointUSR.revolute.frame_b.f[2] + (jointRRR1.jointUSR.rod2.frame_a.f[2] + (-jointRRR1.jointUSR.frame_ib.f[2])) = 0.0;
//   jointRRR1.jointUSR.revolute.frame_b.f[3] + (jointRRR1.jointUSR.rod2.frame_a.f[3] + (-jointRRR1.jointUSR.frame_ib.f[3])) = 0.0;
//   jointRRR1.jointUSR.frame_ib.R.w[1] = jointRRR1.jointUSR.revolute.frame_b.R.w[1];
//   jointRRR1.jointUSR.frame_ib.R.w[1] = jointRRR1.jointUSR.rod2.frame_a.R.w[1];
//   jointRRR1.jointUSR.frame_ib.R.w[2] = jointRRR1.jointUSR.revolute.frame_b.R.w[2];
//   jointRRR1.jointUSR.frame_ib.R.w[2] = jointRRR1.jointUSR.rod2.frame_a.R.w[2];
//   jointRRR1.jointUSR.frame_ib.R.w[3] = jointRRR1.jointUSR.revolute.frame_b.R.w[3];
//   jointRRR1.jointUSR.frame_ib.R.w[3] = jointRRR1.jointUSR.rod2.frame_a.R.w[3];
//   jointRRR1.jointUSR.frame_ib.R.T[1,1] = jointRRR1.jointUSR.revolute.frame_b.R.T[1,1];
//   jointRRR1.jointUSR.frame_ib.R.T[1,1] = jointRRR1.jointUSR.rod2.frame_a.R.T[1,1];
//   jointRRR1.jointUSR.frame_ib.R.T[1,2] = jointRRR1.jointUSR.revolute.frame_b.R.T[1,2];
//   jointRRR1.jointUSR.frame_ib.R.T[1,2] = jointRRR1.jointUSR.rod2.frame_a.R.T[1,2];
//   jointRRR1.jointUSR.frame_ib.R.T[1,3] = jointRRR1.jointUSR.revolute.frame_b.R.T[1,3];
//   jointRRR1.jointUSR.frame_ib.R.T[1,3] = jointRRR1.jointUSR.rod2.frame_a.R.T[1,3];
//   jointRRR1.jointUSR.frame_ib.R.T[2,1] = jointRRR1.jointUSR.revolute.frame_b.R.T[2,1];
//   jointRRR1.jointUSR.frame_ib.R.T[2,1] = jointRRR1.jointUSR.rod2.frame_a.R.T[2,1];
//   jointRRR1.jointUSR.frame_ib.R.T[2,2] = jointRRR1.jointUSR.revolute.frame_b.R.T[2,2];
//   jointRRR1.jointUSR.frame_ib.R.T[2,2] = jointRRR1.jointUSR.rod2.frame_a.R.T[2,2];
//   jointRRR1.jointUSR.frame_ib.R.T[2,3] = jointRRR1.jointUSR.revolute.frame_b.R.T[2,3];
//   jointRRR1.jointUSR.frame_ib.R.T[2,3] = jointRRR1.jointUSR.rod2.frame_a.R.T[2,3];
//   jointRRR1.jointUSR.frame_ib.R.T[3,1] = jointRRR1.jointUSR.revolute.frame_b.R.T[3,1];
//   jointRRR1.jointUSR.frame_ib.R.T[3,1] = jointRRR1.jointUSR.rod2.frame_a.R.T[3,1];
//   jointRRR1.jointUSR.frame_ib.R.T[3,2] = jointRRR1.jointUSR.revolute.frame_b.R.T[3,2];
//   jointRRR1.jointUSR.frame_ib.R.T[3,2] = jointRRR1.jointUSR.rod2.frame_a.R.T[3,2];
//   jointRRR1.jointUSR.frame_ib.R.T[3,3] = jointRRR1.jointUSR.revolute.frame_b.R.T[3,3];
//   jointRRR1.jointUSR.frame_ib.R.T[3,3] = jointRRR1.jointUSR.rod2.frame_a.R.T[3,3];
//   jointRRR1.jointUSR.frame_ib.r_0[1] = jointRRR1.jointUSR.revolute.frame_b.r_0[1];
//   jointRRR1.jointUSR.frame_ib.r_0[1] = jointRRR1.jointUSR.rod2.frame_a.r_0[1];
//   jointRRR1.jointUSR.frame_ib.r_0[2] = jointRRR1.jointUSR.revolute.frame_b.r_0[2];
//   jointRRR1.jointUSR.frame_ib.r_0[2] = jointRRR1.jointUSR.rod2.frame_a.r_0[2];
//   jointRRR1.jointUSR.frame_ib.r_0[3] = jointRRR1.jointUSR.revolute.frame_b.r_0[3];
//   jointRRR1.jointUSR.frame_ib.r_0[3] = jointRRR1.jointUSR.rod2.frame_a.r_0[3];
//   jointRRR1.jointUSR.relativePosition.r_rel[1] = jointRRR1.jointUSR.relativePosition.relativePosition.r_rel[1];
//   jointRRR1.jointUSR.relativePosition.r_rel[2] = jointRRR1.jointUSR.relativePosition.relativePosition.r_rel[2];
//   jointRRR1.jointUSR.relativePosition.r_rel[3] = jointRRR1.jointUSR.relativePosition.relativePosition.r_rel[3];
//   jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.t[1] + jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.t[1] = 0.0;
//   jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.t[2] + jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.t[2] = 0.0;
//   jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.t[3] + jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.t[3] = 0.0;
//   jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.f[1] + jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.f[1] = 0.0;
//   jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.f[2] + jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.f[2] = 0.0;
//   jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.f[3] + jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.f[3] = 0.0;
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.R.w[1] = jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.w[1];
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.R.w[2] = jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.w[2];
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.R.w[3] = jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.w[3];
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[1,1] = jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[1,1];
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[1,2] = jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[1,2];
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[1,3] = jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[1,3];
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[2,1] = jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[2,1];
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[2,2] = jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[2,2];
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[2,3] = jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[2,3];
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[3,1] = jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[3,1];
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[3,2] = jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[3,2];
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.R.T[3,3] = jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.R.T[3,3];
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.r_0[1] = jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.r_0[1];
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.r_0[2] = jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.r_0[2];
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_resolve.r_0[3] = jointRRR1.jointUSR.relativePosition.zeroPosition.frame_resolve.r_0[3];
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.t[1] + (-jointRRR1.jointUSR.relativePosition.frame_b.t[1]) = 0.0;
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.t[2] + (-jointRRR1.jointUSR.relativePosition.frame_b.t[2]) = 0.0;
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.t[3] + (-jointRRR1.jointUSR.relativePosition.frame_b.t[3]) = 0.0;
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.f[1] + (-jointRRR1.jointUSR.relativePosition.frame_b.f[1]) = 0.0;
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.f[2] + (-jointRRR1.jointUSR.relativePosition.frame_b.f[2]) = 0.0;
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.f[3] + (-jointRRR1.jointUSR.relativePosition.frame_b.f[3]) = 0.0;
//   jointRRR1.jointUSR.relativePosition.frame_b.R.w[1] = jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.R.w[1];
//   jointRRR1.jointUSR.relativePosition.frame_b.R.w[2] = jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.R.w[2];
//   jointRRR1.jointUSR.relativePosition.frame_b.R.w[3] = jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.R.w[3];
//   jointRRR1.jointUSR.relativePosition.frame_b.R.T[1,1] = jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.R.T[1,1];
//   jointRRR1.jointUSR.relativePosition.frame_b.R.T[1,2] = jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.R.T[1,2];
//   jointRRR1.jointUSR.relativePosition.frame_b.R.T[1,3] = jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.R.T[1,3];
//   jointRRR1.jointUSR.relativePosition.frame_b.R.T[2,1] = jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.R.T[2,1];
//   jointRRR1.jointUSR.relativePosition.frame_b.R.T[2,2] = jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.R.T[2,2];
//   jointRRR1.jointUSR.relativePosition.frame_b.R.T[2,3] = jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.R.T[2,3];
//   jointRRR1.jointUSR.relativePosition.frame_b.R.T[3,1] = jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.R.T[3,1];
//   jointRRR1.jointUSR.relativePosition.frame_b.R.T[3,2] = jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.R.T[3,2];
//   jointRRR1.jointUSR.relativePosition.frame_b.R.T[3,3] = jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.R.T[3,3];
//   jointRRR1.jointUSR.relativePosition.frame_b.r_0[1] = jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.r_0[1];
//   jointRRR1.jointUSR.relativePosition.frame_b.r_0[2] = jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.r_0[2];
//   jointRRR1.jointUSR.relativePosition.frame_b.r_0[3] = jointRRR1.jointUSR.relativePosition.relativePosition.frame_b.r_0[3];
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.t[1] + (-jointRRR1.jointUSR.relativePosition.frame_a.t[1]) = 0.0;
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.t[2] + (-jointRRR1.jointUSR.relativePosition.frame_a.t[2]) = 0.0;
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.t[3] + (-jointRRR1.jointUSR.relativePosition.frame_a.t[3]) = 0.0;
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.f[1] + (-jointRRR1.jointUSR.relativePosition.frame_a.f[1]) = 0.0;
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.f[2] + (-jointRRR1.jointUSR.relativePosition.frame_a.f[2]) = 0.0;
//   jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.f[3] + (-jointRRR1.jointUSR.relativePosition.frame_a.f[3]) = 0.0;
//   jointRRR1.jointUSR.relativePosition.frame_a.R.w[1] = jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.R.w[1];
//   jointRRR1.jointUSR.relativePosition.frame_a.R.w[2] = jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.R.w[2];
//   jointRRR1.jointUSR.relativePosition.frame_a.R.w[3] = jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.R.w[3];
//   jointRRR1.jointUSR.relativePosition.frame_a.R.T[1,1] = jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.R.T[1,1];
//   jointRRR1.jointUSR.relativePosition.frame_a.R.T[1,2] = jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.R.T[1,2];
//   jointRRR1.jointUSR.relativePosition.frame_a.R.T[1,3] = jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.R.T[1,3];
//   jointRRR1.jointUSR.relativePosition.frame_a.R.T[2,1] = jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.R.T[2,1];
//   jointRRR1.jointUSR.relativePosition.frame_a.R.T[2,2] = jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.R.T[2,2];
//   jointRRR1.jointUSR.relativePosition.frame_a.R.T[2,3] = jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.R.T[2,3];
//   jointRRR1.jointUSR.relativePosition.frame_a.R.T[3,1] = jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.R.T[3,1];
//   jointRRR1.jointUSR.relativePosition.frame_a.R.T[3,2] = jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.R.T[3,2];
//   jointRRR1.jointUSR.relativePosition.frame_a.R.T[3,3] = jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.R.T[3,3];
//   jointRRR1.jointUSR.relativePosition.frame_a.r_0[1] = jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.r_0[1];
//   jointRRR1.jointUSR.relativePosition.frame_a.r_0[2] = jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.r_0[2];
//   jointRRR1.jointUSR.relativePosition.frame_a.r_0[3] = jointRRR1.jointUSR.relativePosition.relativePosition.frame_a.r_0[3];
//   jointRRR1.bearing.tau = 0.0;
//   jointRRR1.axis.tau = 0.0;
//   jointRRR1.frame_ib.t[3] = 0.0;
//   jointRRR1.frame_ib.t[2] = 0.0;
//   jointRRR1.frame_ib.t[1] = 0.0;
//   jointRRR1.frame_ib.f[3] = 0.0;
//   jointRRR1.frame_ib.f[2] = 0.0;
//   jointRRR1.frame_ib.f[1] = 0.0;
// end Modelica.Mechanics.MultiBody.Examples.Loops.PlanarLoops_analytic;
// "
// ""
// "Check of Modelica.Mechanics.MultiBody.Examples.Loops.PlanarLoops_analytic completed successfully.
// 
// 
// Class Modelica.Mechanics.MultiBody.Examples.Loops.PlanarLoops_analytic has 5241 equation(s) and 5241 variable(s).
// 3263 of these are trivial equation(s).
// "
// ""
// endResult
