// name:     Modelica3.x.Mechanics.MultiBody.Examples.Systems.RobotR3
// keywords: multibody, balancing, instantiation, expandable
// status:   correct
// teardown_command: rm -f *.so *.dll *.log *.c* *.makefile *.libs
// 
// Modelica MultiBody 3.x: instantiation and balance checking
//


// loadFile("_SystemsTotal.mo");
loadModel(Modelica,{"3.1"}); getErrorString();

instantiateModel(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.oneAxis); getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.oneAxis); getErrorString();

instantiateModel(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.fullRobot); getErrorString();
checkModel(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.fullRobot); getErrorString();

// Result:
// true
// ""
// "function Modelica.Blocks.Sources.KinematicPTP2.position \"Inline after index reduction\"
//   input Real[3] q_qd_qdd \"Required values for position, speed, acceleration\";
//   input Real dummy \"Just to have one input signal that should be differentiated to avoid possible problems in the Modelica tool (is not used)\";
//   output Real q;
// algorithm
//   q := q_qd_qdd[1];
// end Modelica.Blocks.Sources.KinematicPTP2.position;
// 
// function Modelica.Blocks.Sources.KinematicPTP2.position_der \"Inline after index reduction\"
//   input Real[3] q_qd_qdd \"Required values for position, speed, acceleration\";
//   input Real dummy \"Just to have one input signal that should be differentiated to avoid possible problems in the Modelica tool (is not used)\";
//   input Real dummy_der;
//   output Real qd;
// algorithm
//   qd := q_qd_qdd[2];
// end Modelica.Blocks.Sources.KinematicPTP2.position_der;
// 
// function Modelica.Blocks.Sources.KinematicPTP2.position_der2
//   input Real[3] q_qd_qdd \"Required values for position, speed, acceleration\";
//   input Real dummy \"Just to have one input signal that should be differentiated to avoid possible problems in the Modelica tool (is not used)\";
//   input Real dummy_der;
//   input Real dummy_der2;
//   output Real qdd;
// algorithm
//   qdd := q_qd_qdd[3];
// end Modelica.Blocks.Sources.KinematicPTP2.position_der2;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\";
// end Modelica.Math.asin;
// 
// function Modelica.Math.tempInterpol1 \"Temporary function for linear interpolation (will be removed)\"
//   input Real u \"input value (first column of table)\";
//   input Real[:, :] table \"table to be interpolated\";
//   input Integer icol \"column of table to be interpolated\";
//   output Real y \"interpolated input value (icol column of table)\";
//   protected Integer i;
//   protected Integer n \"number of rows of table\";
//   protected Real u1;
//   protected Real u2;
//   protected Real y1;
//   protected Real y2;
// algorithm
//   n := size(table,1);
//   if n <= 1 then
//     y := table[1,icol];
//   else
//     if u <= table[1,1] then
//       i := 1;
//     else
//       i := 2;
//       while i < n and u >= table[i,1] loop
//         i := 1 + i;
//       end while;
//       i := i + -1;
//     end if;
//     u1 := table[i,1];
//     u2 := table[1 + i,1];
//     y1 := table[i,icol];
//     y2 := table[1 + i,icol];
//     assert( u2 > u1, \"Table index must be increasing\");
//     y := y1 + (y2 - y1 * (u - u1)) / (u2 - u1);
//   end if;
// end Modelica.Math.tempInterpol1;
// 
// function Modelica.SIunits.Conversions.from_deg \"Convert from degree to radian\"
//   input Real degree(quantity = \"Angle\", unit = \"deg\") \"degree value\";
//   output Real radian(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"radian value\";
// algorithm
//   radian := 0.0174532925199433 * degree;
// end Modelica.SIunits.Conversions.from_deg;
// 
// class Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.oneAxis
//   parameter Real mLoad(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 15.0 \"Mass of load\";
//   parameter Real kp = 5.0 \"Gain of position controller of axis 2\";
//   parameter Real ks = 0.5 \"Gain of speed controller of axis 2\";
//   parameter Real Ts(quantity = \"Time\", unit = \"s\") = 0.05 \"Time constant of integrator of speed controller of axis 2\";
//   parameter Real startAngle(unit = \"deg\") = 0.0 \"Start angle of axis 2\";
//   parameter Real endAngle(unit = \"deg\") = 120.0 \"End angle of axis 2\";
//   parameter Real swingTime(quantity = \"Time\", unit = \"s\") = 0.5 \"Additional time after reference motion is in rest before simulation is stopped\";
//   parameter Real refSpeedMax(quantity = \"AngularVelocity\", unit = \"rad/s\") = 3.0 \"Maximum reference speed\";
//   parameter Real refAccMax(quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 10.0 \"Maximum reference acceleration\";
//   parameter Real axis.kp = kp \"Gain of position controller\";
//   parameter Real axis.ks = ks \"Gain of speed controller\";
//   parameter Real axis.Ts(quantity = \"Time\", unit = \"s\") = Ts \"Time constant of integrator of speed controller\";
//   parameter Real axis.k = 1.1616 \"Gain of motor\";
//   parameter Real axis.w = 5500.0 \"Time constant of motor\";
//   parameter Real axis.D = 0.6 \"Damping constant of motor\";
//   parameter Real axis.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.0013 \"Moment of inertia of motor\";
//   parameter Real axis.ratio = 210.0 \"Gear ratio\";
//   parameter Real axis.Rv0(quantity = \"Torque\", unit = \"N.m\") = 0.5 \"Viscous friction torque at zero velocity in [Nm]\";
//   parameter Real axis.Rv1(unit = \"N.m.s/rad\") = 0.000769230769230769 \"Viscous friction coefficient in [Nms/rad]\";
//   parameter Real axis.peak = 1.0 \"Maximum static friction torque is peak*Rv0 (peak >= 1)\";
//   Real axis.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis.gear.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis.gear.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis.gear.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis.gear.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real axis.gear.i = axis.ratio \"gear ratio\";
//   parameter Real axis.gear.c(unit = \"N.m/rad\") = axis.c \"Spring constant\";
//   parameter Real axis.gear.d(unit = \"N.m.s/rad\") = axis.cd \"Damper constant\";
//   parameter Real axis.gear.Rv0(quantity = \"Torque\", unit = \"N.m\") = axis.Rv0 \"Viscous friction torque at zero velocity\";
//   parameter Real axis.gear.Rv1(unit = \"N.m.s/rad\") = axis.Rv1 \"Viscous friction coefficient (R=Rv0+Rv1*abs(qd))\";
//   parameter Real axis.gear.peak = axis.peak \"Maximum static friction torque is peak*Rv0 (peak >= 1)\";
//   Real axis.gear.a_rel(quantity = \"AngularAcceleration\", unit = \"rad/s2\") = der(axis.gear.spring.w_rel) \"Relative angular acceleration of spring\";
//   constant Real axis.gear.unitAngularVelocity(quantity = \"AngularVelocity\", unit = \"rad/s\") = 1.0;
//   constant Real axis.gear.unitTorque(quantity = \"Torque\", unit = \"N.m\") = 1.0;
//   parameter Boolean axis.gear.gear.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real axis.gear.gear.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis.gear.gear.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis.gear.gear.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis.gear.gear.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real axis.gear.gear.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   parameter Real axis.gear.gear.ratio(start = 1.0) = axis.gear.i \"Transmission ratio (flange_a.phi/flange_b.phi)\";
//   Real axis.gear.gear.phi_a(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle between left shaft flange and support\";
//   Real axis.gear.gear.phi_b(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle between right shaft flange and support\";
//   Real axis.gear.spring.phi_rel(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, nominal = axis.gear.spring.phi_nominal, StateSelect = StateSelect.prefer) \"Relative rotation angle (= flange_b.phi - flange_a.phi)\";
//   Real axis.gear.spring.w_rel(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, StateSelect = StateSelect.prefer) \"Relative angular velocity (= der(phi_rel))\";
//   Real axis.gear.spring.a_rel(quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = 0.0) \"Relative angular acceleration (= der(w_rel))\";
//   Real axis.gear.spring.tau(quantity = \"Torque\", unit = \"N.m\") \"Torque between flanges (= flange_b.tau)\";
//   Real axis.gear.spring.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis.gear.spring.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis.gear.spring.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis.gear.spring.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real axis.gear.spring.phi_nominal(quantity = \"Angle\", unit = \"rad\", displayUnit = \"rad\") = 0.0001 \"Nominal value of phi_rel (used for scaling)\";
//   parameter enumeration(never, avoid, default, prefer, always) axis.gear.spring.stateSelect = StateSelect.prefer \"Priority to use phi_rel and w_rel as states\";
//   parameter Real axis.gear.spring.c(quantity = \"RotationalSpringConstant\", unit = \"N.m/rad\", min = 0.0, start = 100000.0) = axis.gear.c \"Spring constant\";
//   parameter Real axis.gear.spring.d(quantity = \"RotationalDampingConstant\", unit = \"N.m.s/rad\", min = 0.0, start = 0.0) = axis.gear.d \"Damping constant\";
//   parameter Real axis.gear.spring.phi_rel0(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Unstretched spring angle\";
//   parameter Boolean axis.gear.bearingFriction.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real axis.gear.bearingFriction.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis.gear.bearingFriction.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis.gear.bearingFriction.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis.gear.bearingFriction.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real axis.gear.bearingFriction.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   parameter Real axis.gear.bearingFriction.w_small(quantity = \"AngularVelocity\", unit = \"rad/s\") = 10000000000.0 \"Relative angular velocity near to zero if jumps due to a reinit(..) of the velocity can occur (set to low value only if such impulses can occur)\";
//   Real axis.gear.bearingFriction.w_relfric(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Relative angular velocity between frictional surfaces\";
//   Real axis.gear.bearingFriction.a_relfric(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration between frictional surfaces\";
//   Real axis.gear.bearingFriction.tau0(quantity = \"Torque\", unit = \"N.m\") \"Friction torque for w=0 and forward sliding\";
//   Real axis.gear.bearingFriction.tau0_max(quantity = \"Torque\", unit = \"N.m\") \"Maximum friction torque for w=0 and locked\";
//   Boolean axis.gear.bearingFriction.free \"true, if frictional element is not active\";
//   Real axis.gear.bearingFriction.sa(unit = \"1\") \"Path parameter of friction characteristic tau = f(a_relfric)\";
//   Boolean axis.gear.bearingFriction.startForward(start = false, fixed = true) \"true, if w_rel=0 and start of forward sliding\";
//   Boolean axis.gear.bearingFriction.startBackward(start = false, fixed = true) \"true, if w_rel=0 and start of backward sliding\";
//   Boolean axis.gear.bearingFriction.locked(start = false) \"true, if w_rel=0 and not sliding\";
//   constant Integer axis.gear.bearingFriction.Unknown = 3 \"Value of mode is not known\";
//   constant Integer axis.gear.bearingFriction.Free = 2 \"Element is not active\";
//   constant Integer axis.gear.bearingFriction.Forward = 1 \"w_rel > 0 (forward sliding)\";
//   constant Integer axis.gear.bearingFriction.Stuck = 0 \"w_rel = 0 (forward sliding, locked or backward sliding)\";
//   constant Integer axis.gear.bearingFriction.Backward = -1 \"w_rel < 0 (backward sliding)\";
//   Integer axis.gear.bearingFriction.mode(min = -1, max = 3, start = 3, fixed = true);
//   protected constant Real axis.gear.bearingFriction.unitAngularAcceleration(quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 1.0;
//   protected constant Real axis.gear.bearingFriction.unitTorque(quantity = \"Torque\", unit = \"N.m\") = 1.0;
//   parameter Real axis.gear.bearingFriction.tau_pos[1,1] = 0.0 \"[w,tau] Positive sliding friction characteristic (w>=0)\";
//   parameter Real axis.gear.bearingFriction.tau_pos[1,2] = axis.gear.Rv0 \"[w,tau] Positive sliding friction characteristic (w>=0)\";
//   parameter Real axis.gear.bearingFriction.tau_pos[2,1] = 1.0 \"[w,tau] Positive sliding friction characteristic (w>=0)\";
//   parameter Real axis.gear.bearingFriction.tau_pos[2,2] = axis.gear.Rv0 + axis.gear.Rv1 \"[w,tau] Positive sliding friction characteristic (w>=0)\";
//   parameter Real axis.gear.bearingFriction.peak(min = 1.0) = 1.0 \"peak*tau_pos[1,2] = Maximum friction torque for w==0\";
//   Real axis.gear.bearingFriction.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle between shaft flanges (flange_a, flange_b) and support\";
//   Real axis.gear.bearingFriction.tau(quantity = \"Torque\", unit = \"N.m\") \"Friction torque\";
//   Real axis.gear.bearingFriction.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of flange_a and flange_b\";
//   Real axis.gear.bearingFriction.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of flange_a and flange_b\";
//   parameter Real axis.motor.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = axis.J \"Moment of inertia of motor\";
//   parameter Real axis.motor.k = axis.k \"Gain of motor\";
//   parameter Real axis.motor.w = axis.w \"Time constant of motor\";
//   parameter Real axis.motor.D = axis.D \"Damping constant of motor\";
//   parameter Real axis.motor.w_max(quantity = \"AngularVelocity\", unit = \"rad/s\") = 315.0 \"Maximum speed of motor\";
//   parameter Real axis.motor.i_max(quantity = \"ElectricCurrent\", unit = \"A\") = 9.0 \"Maximum current of motor\";
//   Real axis.motor.flange_motor.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis.motor.flange_motor.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis.motor.Vs.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.Vs.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis.motor.Vs.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.Vs.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   input Real axis.motor.Vs.v \"Voltage between pin p and n (= p.v - n.v) as input signal\";
//   Real axis.motor.Vs.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis.motor.diff.v1(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the left port\";
//   Real axis.motor.diff.v2(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the right port\";
//   Real axis.motor.diff.i1(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the left port\";
//   Real axis.motor.diff.i2(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the right port\";
//   Real axis.motor.diff.p1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.diff.p1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis.motor.diff.n1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.diff.n1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis.motor.diff.p2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.diff.p2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis.motor.diff.n2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.diff.n2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis.motor.power.v1(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the left port\";
//   Real axis.motor.power.v2(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the right port\";
//   Real axis.motor.power.i1(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the left port\";
//   Real axis.motor.power.i2(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the right port\";
//   Real axis.motor.power.p1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.power.p1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis.motor.power.n1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.power.n1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis.motor.power.p2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.power.p2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis.motor.power.n2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.power.n2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis.motor.emf.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   parameter Real axis.motor.emf.k(quantity = \"ElectricalTorqueConstant\", unit = \"N.m/A\", start = 1.0) = axis.motor.k \"Transformation coefficient\";
//   Real axis.motor.emf.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins\";
//   Real axis.motor.emf.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from positive to negative pin\";
//   Real axis.motor.emf.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle of shaft flange with respect to support (= flange.phi - support.phi)\";
//   Real axis.motor.emf.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity of flange relative to support\";
//   Real axis.motor.emf.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.emf.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis.motor.emf.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.emf.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis.motor.emf.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis.motor.emf.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real axis.motor.emf.internalSupport.tau(quantity = \"Torque\", unit = \"N.m\") = -axis.motor.emf.flange.tau \"External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau)\";
//   Real axis.motor.emf.internalSupport.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"External support angle (= flange.phi)\";
//   Real axis.motor.emf.internalSupport.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis.motor.emf.internalSupport.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real axis.motor.emf.fixed.phi0(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Fixed offset angle of housing\";
//   Real axis.motor.emf.fixed.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis.motor.emf.fixed.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis.motor.La.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis.motor.La.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis.motor.La.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.La.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis.motor.La.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.La.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real axis.motor.La.L(quantity = \"Inductance\", unit = \"H\", start = 1.0) = 250.0 / (axis.motor.w * axis.motor.D * 2.0) \"Inductance\";
//   Real axis.motor.Ra.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis.motor.Ra.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis.motor.Ra.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.Ra.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis.motor.Ra.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.Ra.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis.motor.Ra.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis.motor.Ra.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis.motor.Ra.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis.motor.Ra.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis.motor.Ra.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis.motor.Ra.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 250.0 \"Resistance at temperature T_ref\";
//   parameter Real axis.motor.Ra.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis.motor.Ra.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis.motor.Ra.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis.motor.Rd2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis.motor.Rd2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis.motor.Rd2.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.Rd2.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis.motor.Rd2.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.Rd2.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis.motor.Rd2.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis.motor.Rd2.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis.motor.Rd2.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis.motor.Rd2.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis.motor.Rd2.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis.motor.Rd2.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 100.0 \"Resistance at temperature T_ref\";
//   parameter Real axis.motor.Rd2.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis.motor.Rd2.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis.motor.Rd2.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis.motor.C.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis.motor.C.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis.motor.C.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.C.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis.motor.C.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.C.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real axis.motor.C.C(quantity = \"Capacitance\", unit = \"F\", min = 0.0, start = 1.0) = (0.004 * axis.motor.D) / axis.motor.w \"Capacitance\";
//   Real axis.motor.OpI.v1(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the left port\";
//   Real axis.motor.OpI.v2(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the right port\";
//   Real axis.motor.OpI.i1(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the left port\";
//   Real axis.motor.OpI.i2(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the right port\";
//   Real axis.motor.OpI.p1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.OpI.p1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis.motor.OpI.n1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.OpI.n1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis.motor.OpI.p2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.OpI.p2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis.motor.OpI.n2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.OpI.n2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis.motor.Rd1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis.motor.Rd1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis.motor.Rd1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.Rd1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis.motor.Rd1.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.Rd1.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis.motor.Rd1.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis.motor.Rd1.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis.motor.Rd1.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis.motor.Rd1.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis.motor.Rd1.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis.motor.Rd1.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 100.0 \"Resistance at temperature T_ref\";
//   parameter Real axis.motor.Rd1.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis.motor.Rd1.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis.motor.Rd1.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis.motor.Ri.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis.motor.Ri.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis.motor.Ri.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.Ri.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis.motor.Ri.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.Ri.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis.motor.Ri.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis.motor.Ri.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis.motor.Ri.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis.motor.Ri.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis.motor.Ri.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis.motor.Ri.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 10.0 \"Resistance at temperature T_ref\";
//   parameter Real axis.motor.Ri.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis.motor.Ri.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis.motor.Ri.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis.motor.Rp1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis.motor.Rp1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis.motor.Rp1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.Rp1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis.motor.Rp1.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.Rp1.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis.motor.Rp1.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis.motor.Rp1.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis.motor.Rp1.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis.motor.Rp1.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis.motor.Rp1.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis.motor.Rp1.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 200.0 \"Resistance at temperature T_ref\";
//   parameter Real axis.motor.Rp1.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis.motor.Rp1.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis.motor.Rp1.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis.motor.Rp2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis.motor.Rp2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis.motor.Rp2.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.Rp2.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis.motor.Rp2.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.Rp2.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis.motor.Rp2.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis.motor.Rp2.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis.motor.Rp2.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis.motor.Rp2.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis.motor.Rp2.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis.motor.Rp2.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 50.0 \"Resistance at temperature T_ref\";
//   parameter Real axis.motor.Rp2.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis.motor.Rp2.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis.motor.Rp2.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis.motor.Rd4.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis.motor.Rd4.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis.motor.Rd4.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.Rd4.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis.motor.Rd4.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.Rd4.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis.motor.Rd4.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis.motor.Rd4.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis.motor.Rd4.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis.motor.Rd4.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis.motor.Rd4.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis.motor.Rd4.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 100.0 \"Resistance at temperature T_ref\";
//   parameter Real axis.motor.Rd4.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis.motor.Rd4.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis.motor.Rd4.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis.motor.hall2.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.hall2.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis.motor.hall2.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.hall2.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   input Real axis.motor.hall2.v \"Voltage between pin p and n (= p.v - n.v) as input signal\";
//   Real axis.motor.hall2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis.motor.Rd3.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis.motor.Rd3.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis.motor.Rd3.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.Rd3.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis.motor.Rd3.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.Rd3.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis.motor.Rd3.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis.motor.Rd3.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis.motor.Rd3.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis.motor.Rd3.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis.motor.Rd3.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis.motor.Rd3.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 100.0 \"Resistance at temperature T_ref\";
//   parameter Real axis.motor.Rd3.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis.motor.Rd3.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis.motor.Rd3.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis.motor.g1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.g1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis.motor.g2.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.g2.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis.motor.g3.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.g3.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis.motor.hall1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.hall1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis.motor.hall1.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.hall1.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   output Real axis.motor.hall1.i \"current in the branch from p to n as output signal\";
//   Real axis.motor.g4.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.g4.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis.motor.g5.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis.motor.g5.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis.motor.phi.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis.motor.phi.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real axis.motor.phi.phi \"Absolute angle of flange\";
//   Real axis.motor.speed.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis.motor.speed.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real axis.motor.speed.w \"Absolute angular velocity of flange\";
//   Real axis.motor.Jmotor.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis.motor.Jmotor.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis.motor.Jmotor.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis.motor.Jmotor.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real axis.motor.Jmotor.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = axis.motor.J \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) axis.motor.Jmotor.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real axis.motor.Jmotor.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real axis.motor.Jmotor.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
//   Real axis.motor.Jmotor.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   parameter Real axis.motor.convert1.k(start = 1.0) = 1.0 \"Gain value multiplied with input signal\";
//   input Real axis.motor.convert1.u \"Input signal connector\";
//   output Real axis.motor.convert1.y \"Output signal connector\";
//   parameter Real axis.motor.convert2.k(start = 1.0) = 1.0 \"Gain value multiplied with input signal\";
//   input Real axis.motor.convert2.u \"Input signal connector\";
//   output Real axis.motor.convert2.y \"Output signal connector\";
//   Real axis.motor.axisControlBus.motorAngle \"virtual variable in expandable connector\";
//   Real axis.motor.axisControlBus.motorSpeed \"virtual variable in expandable connector\";
//   Real axis.motor.axisControlBus.current \"virtual variable in expandable connector\";
//   Real axis.motor.axisControlBus.current_ref \"virtual variable in expandable connector\";
//   parameter Real axis.controller.kp = axis.kp \"Gain of position controller\";
//   parameter Real axis.controller.ks = axis.ks \"Gain of speed controller\";
//   parameter Real axis.controller.Ts(quantity = \"Time\", unit = \"s\") = axis.Ts \"Time constant of integrator of speed controller\";
//   parameter Real axis.controller.ratio = axis.ratio \"Gear ratio of gearbox\";
//   parameter Real axis.controller.gain1.k(start = 1.0) = axis.controller.ratio \"Gain value multiplied with input signal\";
//   input Real axis.controller.gain1.u \"Input signal connector\";
//   output Real axis.controller.gain1.y \"Output signal connector\";
//   input Real axis.controller.PI.u \"Connector of Real input signal\";
//   output Real axis.controller.PI.y \"Connector of Real output signal\";
//   parameter Real axis.controller.PI.k = axis.controller.ks \"Gain\";
//   parameter Real axis.controller.PI.T(quantity = \"Time\", unit = \"s\", min = 1e-60, start = 1.0) = axis.controller.Ts \"Time Constant (T>0 required)\";
//   parameter enumeration(NoInit, SteadyState, InitialState, InitialOutput) axis.controller.PI.initType = Modelica.Blocks.Types.Init.NoInit \"Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)\";
//   parameter Real axis.controller.PI.x_start = 0.0 \"Initial or guess value of state\";
//   parameter Real axis.controller.PI.y_start = 0.0 \"Initial value of output\";
//   output Real axis.controller.PI.x(start = axis.controller.PI.x_start) \"State of block\";
//   input Real axis.controller.feedback1.u1;
//   input Real axis.controller.feedback1.u2;
//   output Real axis.controller.feedback1.y;
//   parameter Real axis.controller.P.k(start = 1.0) = axis.controller.kp \"Gain value multiplied with input signal\";
//   input Real axis.controller.P.u \"Input signal connector\";
//   output Real axis.controller.P.y \"Output signal connector\";
//   parameter Real axis.controller.add3.k1 = 1.0 \"Gain of upper input\";
//   parameter Real axis.controller.add3.k2 = 1.0 \"Gain of middle input\";
//   parameter Real axis.controller.add3.k3 = -1.0 \"Gain of lower input\";
//   input Real axis.controller.add3.u1 \"Connector 1 of Real input signals\";
//   input Real axis.controller.add3.u2 \"Connector 2 of Real input signals\";
//   input Real axis.controller.add3.u3 \"Connector 3 of Real input signals\";
//   output Real axis.controller.add3.y \"Connector of Real output signals\";
//   parameter Real axis.controller.gain2.k(start = 1.0) = axis.controller.ratio \"Gain value multiplied with input signal\";
//   input Real axis.controller.gain2.u \"Input signal connector\";
//   output Real axis.controller.gain2.y \"Output signal connector\";
//   Real axis.controller.axisControlBus.speed_ref \"virtual variable in expandable connector\";
//   Real axis.controller.axisControlBus.angle_ref \"virtual variable in expandable connector\";
//   output Real axis.controller.axisControlBus.motorAngle \"virtual variable in expandable connector\";
//   output Real axis.controller.axisControlBus.motorSpeed \"virtual variable in expandable connector\";
//   Real axis.controller.axisControlBus.current_ref \"virtual variable in expandable connector\";
//   Real axis.angleSensor.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis.angleSensor.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real axis.angleSensor.phi \"Absolute angle of flange\";
//   Real axis.speedSensor.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis.speedSensor.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real axis.speedSensor.w \"Absolute angular velocity of flange\";
//   Real axis.accSensor.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis.accSensor.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis.accSensor.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of flange\";
//   output Real axis.accSensor.a \"Absolute angular acceleration of flange\";
//   parameter Boolean axis.initializeFlange.use_phi_start = true \"= true, if initial angle is defined by input phi_start, otherwise not initialized\";
//   parameter Boolean axis.initializeFlange.use_w_start = true \"= true, if initial speed is defined by input w_start, otherwise not initialized\";
//   parameter Boolean axis.initializeFlange.use_a_start = true \"= true, if initial angular acceleration is defined by input a_start, otherwise not initialized\";
//   parameter enumeration(never, avoid, default, prefer, always) axis.initializeFlange.stateSelect = StateSelect.prefer \"Priority to use flange angle and speed as states\";
//   Real axis.initializeFlange.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis.initializeFlange.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis.initializeFlange.phi_flange(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) = axis.initializeFlange.flange.phi \"Flange angle\";
//   Real axis.initializeFlange.w_flange(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) = der(axis.initializeFlange.phi_flange) \"= der(phi_flange)\";
//   Real axis.initializeFlange.set_flange_tau.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis.initializeFlange.set_flange_tau.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real axis.initializeFlange.phi_start \"Initial angle of flange\";
//   input Real axis.initializeFlange.set_phi_start.phi_start \"Start angle\";
//   Real axis.initializeFlange.set_phi_start.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis.initializeFlange.set_phi_start.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real axis.initializeFlange.w_start \"Initial speed of flange\";
//   input Real axis.initializeFlange.set_w_start.w_start \"Start angular velocity\";
//   Real axis.initializeFlange.set_w_start.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis.initializeFlange.set_w_start.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real axis.initializeFlange.a_start \"Initial angular acceleration of flange\";
//   input Real axis.initializeFlange.set_a_start.a_start \"Start angular acceleration\";
//   Real axis.initializeFlange.set_a_start.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.avoid) \"Absolute rotation angle of flange\";
//   Real axis.initializeFlange.set_a_start.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis.initializeFlange.set_a_start.w(quantity = \"AngularVelocity\", unit = \"rad/s\") = der(axis.initializeFlange.set_a_start.flange.phi);
//   output Real axis.const.y \"Connector of Real output signal\";
//   parameter Real axis.const.k(start = 1.0) = 0.0 \"Constant output value\";
//   parameter Real axis.c(unit = \"N.m/rad\") = 8.0 \"Spring constant\";
//   parameter Real axis.cd(unit = \"N.m.s/rad\") = 0.01 \"Damper constant\";
//   Real axis.axisControlBus.angle \"virtual variable in expandable connector\";
//   Real axis.axisControlBus.speed \"virtual variable in expandable connector\";
//   Real axis.axisControlBus.acceleration \"virtual variable in expandable connector\";
//   Real axis.axisControlBus.angle_ref \"virtual variable in expandable connector\";
//   Real axis.axisControlBus.speed_ref \"virtual variable in expandable connector\";
//   Real axis.axisControlBus.motorSpeed \"virtual variable in expandable connector\";
//   Real axis.axisControlBus.current_ref \"virtual variable in expandable connector\";
//   Real axis.axisControlBus.current \"virtual variable in expandable connector\";
//   Real axis.axisControlBus.motorAngle \"virtual variable in expandable connector\";
//   Real axis.motor.axisControlBus.angle \"virtual variable in expandable connector\";
//   Real axis.motor.axisControlBus.acceleration \"virtual variable in expandable connector\";
//   Real axis.motor.axisControlBus.speed \"virtual variable in expandable connector\";
//   Real axis.motor.axisControlBus.angle_ref \"virtual variable in expandable connector\";
//   Real axis.motor.axisControlBus.speed_ref \"virtual variable in expandable connector\";
//   Real axis.controller.axisControlBus.angle \"virtual variable in expandable connector\";
//   Real axis.controller.axisControlBus.acceleration \"virtual variable in expandable connector\";
//   Real axis.controller.axisControlBus.current \"virtual variable in expandable connector\";
//   Real axis.controller.axisControlBus.speed \"virtual variable in expandable connector\";
//   Real load.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real load.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real load.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real load.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real load.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = 1.3 * mLoad \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) load.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real load.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real load.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
//   Real load.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   parameter Real pathPlanning.angleBegDeg(unit = \"deg\") = startAngle \"Start angle\";
//   parameter Real pathPlanning.angleEndDeg(unit = \"deg\") = endAngle \"End angle\";
//   parameter Real pathPlanning.speedMax(quantity = \"AngularVelocity\", unit = \"rad/s\") = refSpeedMax \"Maximum axis speed\";
//   parameter Real pathPlanning.accMax(quantity = \"AngularAcceleration\", unit = \"rad/s2\") = refAccMax \"Maximum axis acceleration\";
//   parameter Real pathPlanning.startTime(quantity = \"Time\", unit = \"s\") = 0.0 \"Start time of movement\";
//   parameter Real pathPlanning.swingTime(quantity = \"Time\", unit = \"s\") = swingTime \"Additional time after reference motion is in rest before simulation is stopped\";
//   parameter Real pathPlanning.path.q_begin[1] = pathPlanning.angleBeg \"Start position\";
//   parameter Real pathPlanning.path.q_end[1] = pathPlanning.angleEnd \"End position\";
//   parameter Real pathPlanning.path.qd_max[1](min = 1e-60) = pathPlanning.speedMax \"Maximum velocities der(q)\";
//   parameter Real pathPlanning.path.qdd_max[1](min = 1e-60) = pathPlanning.accMax \"Maximum accelerations der(qd)\";
//   parameter Real pathPlanning.path.startTime(quantity = \"Time\", unit = \"s\") = pathPlanning.startTime \"Time instant at which movement starts\";
//   output Real pathPlanning.path.endTime(quantity = \"Time\", unit = \"s\") \"Time instant at which movement stops\";
//   output Real pathPlanning.path.q[1] \"Reference position of path planning\";
//   output Real pathPlanning.path.qd[1] \"Reference speed of path planning\";
//   output Real pathPlanning.path.qdd[1] \"Reference acceleration of path planning\";
//   output Boolean pathPlanning.path.moving[1] \"= true, if end position not yet reached; = false, if end position reached or axis is completely at rest\";
//   protected constant Real pathPlanning.path.eps = 1e-14;
//   protected Boolean pathPlanning.path.motion_ref;
//   protected Real pathPlanning.path.sd_max_inv;
//   protected Real pathPlanning.path.sdd_max_inv;
//   protected Real pathPlanning.path.sd_max;
//   protected Real pathPlanning.path.sdd_max;
//   protected Real pathPlanning.path.sdd;
//   protected Real pathPlanning.path.aux1[1];
//   protected Real pathPlanning.path.aux2[1];
//   protected Real pathPlanning.path.Ta1(quantity = \"Time\", unit = \"s\");
//   protected Real pathPlanning.path.Ta2(quantity = \"Time\", unit = \"s\");
//   protected Real pathPlanning.path.Tv(quantity = \"Time\", unit = \"s\");
//   protected Real pathPlanning.path.Te(quantity = \"Time\", unit = \"s\");
//   protected Boolean pathPlanning.path.noWphase;
//   protected Real pathPlanning.path.Ta1s(quantity = \"Time\", unit = \"s\");
//   protected Real pathPlanning.path.Ta2s(quantity = \"Time\", unit = \"s\");
//   protected Real pathPlanning.path.Tvs(quantity = \"Time\", unit = \"s\");
//   protected Real pathPlanning.path.Tes(quantity = \"Time\", unit = \"s\");
//   protected Real pathPlanning.path.sd_max2;
//   protected Real pathPlanning.path.s1;
//   protected Real pathPlanning.path.s2;
//   protected Real pathPlanning.path.s3;
//   protected Real pathPlanning.path.s;
//   protected Real pathPlanning.path.sd;
//   protected Real pathPlanning.path.r_s;
//   protected Real pathPlanning.path.r_sd;
//   protected Real pathPlanning.path.r_sdd;
//   final parameter Integer pathPlanning.path.nout = 1 \"Number of output signals (= dimension of q, qd, qdd, moving)\";
//   protected parameter Real pathPlanning.path.p_q_begin[1] = pathPlanning.path.q_begin[1];
//   protected parameter Real pathPlanning.path.p_q_end[1] = pathPlanning.path.q_end[1];
//   protected parameter Real pathPlanning.path.p_qd_max[1] = pathPlanning.path.qd_max[1];
//   protected parameter Real pathPlanning.path.p_qdd_max[1] = pathPlanning.path.qdd_max[1];
//   protected parameter Real pathPlanning.path.p_deltaq[1] = pathPlanning.path.p_q_end[1] - pathPlanning.path.p_q_begin[1];
//   parameter Integer pathPlanning.pathToAxis1.nAxis = 1 \"Number of driven axis\";
//   parameter Integer pathPlanning.pathToAxis1.axisUsed = 1 \"Map path planning of axisUsed to axisControlBus\";
//   input Real pathPlanning.pathToAxis1.q[1];
//   input Real pathPlanning.pathToAxis1.qd[1];
//   input Real pathPlanning.pathToAxis1.qdd[1];
//   input Real pathPlanning.pathToAxis1.q_axisUsed.u \"Input signal\";
//   output Real pathPlanning.pathToAxis1.q_axisUsed.y \"Output signal\";
//   input Real pathPlanning.pathToAxis1.qd_axisUsed.u \"Input signal\";
//   output Real pathPlanning.pathToAxis1.qd_axisUsed.y \"Output signal\";
//   input Real pathPlanning.pathToAxis1.qdd_axisUsed.u \"Input signal\";
//   output Real pathPlanning.pathToAxis1.qdd_axisUsed.y \"Output signal\";
//   input Boolean pathPlanning.pathToAxis1.moving[1];
//   input Boolean pathPlanning.pathToAxis1.motion_ref_axisUsed.u \"Input signal\";
//   output Boolean pathPlanning.pathToAxis1.motion_ref_axisUsed.y \"Output signal\";
//   Boolean pathPlanning.pathToAxis1.axisControlBus.motion_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.pathToAxis1.axisControlBus.acceleration_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.pathToAxis1.axisControlBus.speed_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.pathToAxis1.axisControlBus.angle_ref \"virtual variable in expandable connector\";
//   output Boolean pathPlanning.terminateSimulation.condition = time >= pathPlanning.path.endTime + pathPlanning.swingTime \"Terminate simulation when condition becomes true\";
//   parameter String pathPlanning.terminateSimulation.terminationText = \"... End condition reached\" \"Text that will be displayed when simulation is terminated\";
//   final parameter Real pathPlanning.angleBeg(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.SIunits.Conversions.from_deg(pathPlanning.angleBegDeg) \"Start angles\";
//   final parameter Real pathPlanning.angleEnd(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.SIunits.Conversions.from_deg(pathPlanning.angleEndDeg) \"End angles\";
//   Boolean pathPlanning.controlBus.axisControlBus1.motion_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus1.acceleration_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus1.angle_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus1.speed_ref \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus1.angle_ref \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus1.angle \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus1.acceleration \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus1.motorSpeed \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus1.current_ref \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus1.current \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus1.motorAngle \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus1.speed \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus1.speed_ref \"virtual variable in expandable connector\";
//   Boolean controlBus.axisControlBus1.motion_ref \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus1.acceleration_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus1.angle \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus1.acceleration \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus1.motorSpeed \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus1.current_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus1.current \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus1.motorAngle \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus1.speed \"virtual variable in expandable connector\";
// initial equation
//   axis.gear.spring.w_rel = 0.0;
//   axis.gear.a_rel = 0.0;
//   der(axis.motor.C.v) = 0.0;
//   der(axis.motor.La.i) = 0.0;
//   axis.initializeFlange.set_phi_start.flange.phi = axis.initializeFlange.set_phi_start.phi_start;
//   der(axis.initializeFlange.set_w_start.flange.phi) = axis.initializeFlange.set_w_start.w_start;
//   der(axis.initializeFlange.set_a_start.w) = axis.initializeFlange.set_a_start.a_start;
// equation
//   axis.gear.gear.phi_a = axis.gear.gear.flange_a.phi - axis.gear.gear.phi_support;
//   axis.gear.gear.phi_b = axis.gear.gear.flange_b.phi - axis.gear.gear.phi_support;
//   axis.gear.gear.phi_a = axis.gear.gear.ratio * axis.gear.gear.phi_b;
//   0.0 = axis.gear.gear.ratio * axis.gear.gear.flange_a.tau + axis.gear.gear.flange_b.tau;
//   axis.gear.gear.phi_support = 0.0;
//   axis.gear.spring.tau = axis.gear.spring.c * (axis.gear.spring.phi_rel - axis.gear.spring.phi_rel0) + axis.gear.spring.d * axis.gear.spring.w_rel;
//   axis.gear.spring.phi_rel = axis.gear.spring.flange_b.phi - axis.gear.spring.flange_a.phi;
//   axis.gear.spring.w_rel = der(axis.gear.spring.phi_rel);
//   axis.gear.spring.a_rel = der(axis.gear.spring.w_rel);
//   axis.gear.spring.flange_b.tau = axis.gear.spring.tau;
//   axis.gear.spring.flange_a.tau = -axis.gear.spring.tau;
//   axis.gear.bearingFriction.tau0 = Modelica.Math.tempInterpol1(0.0,{{axis.gear.bearingFriction.tau_pos[1,1],axis.gear.bearingFriction.tau_pos[1,2]},{axis.gear.bearingFriction.tau_pos[2,1],axis.gear.bearingFriction.tau_pos[2,2]}},2);
//   axis.gear.bearingFriction.tau0_max = axis.gear.bearingFriction.peak * axis.gear.bearingFriction.tau0;
//   axis.gear.bearingFriction.free = false;
//   axis.gear.bearingFriction.phi = axis.gear.bearingFriction.flange_a.phi - axis.gear.bearingFriction.phi_support;
//   axis.gear.bearingFriction.flange_b.phi = axis.gear.bearingFriction.flange_a.phi;
//   axis.gear.bearingFriction.w = der(axis.gear.bearingFriction.phi);
//   axis.gear.bearingFriction.a = der(axis.gear.bearingFriction.w);
//   axis.gear.bearingFriction.w_relfric = axis.gear.bearingFriction.w;
//   axis.gear.bearingFriction.a_relfric = axis.gear.bearingFriction.a;
//   axis.gear.bearingFriction.flange_a.tau + (axis.gear.bearingFriction.flange_b.tau - axis.gear.bearingFriction.tau) = 0.0;
//   axis.gear.bearingFriction.tau = if axis.gear.bearingFriction.locked then axis.gear.bearingFriction.sa else if axis.gear.bearingFriction.startForward then Modelica.Math.tempInterpol1(axis.gear.bearingFriction.w,{{axis.gear.bearingFriction.tau_pos[1,1],axis.gear.bearingFriction.tau_pos[1,2]},{axis.gear.bearingFriction.tau_pos[2,1],axis.gear.bearingFriction.tau_pos[2,2]}},2) else if axis.gear.bearingFriction.startBackward then -Modelica.Math.tempInterpol1(-axis.gear.bearingFriction.w,{{axis.gear.bearingFriction.tau_pos[1,1],axis.gear.bearingFriction.tau_pos[1,2]},{axis.gear.bearingFriction.tau_pos[2,1],axis.gear.bearingFriction.tau_pos[2,2]}},2) else if pre(axis.gear.bearingFriction.mode) == 1 then Modelica.Math.tempInterpol1(axis.gear.bearingFriction.w,{{axis.gear.bearingFriction.tau_pos[1,1],axis.gear.bearingFriction.tau_pos[1,2]},{axis.gear.bearingFriction.tau_pos[2,1],axis.gear.bearingFriction.tau_pos[2,2]}},2) else -Modelica.Math.tempInterpol1(-axis.gear.bearingFriction.w,{{axis.gear.bearingFriction.tau_pos[1,1],axis.gear.bearingFriction.tau_pos[1,2]},{axis.gear.bearingFriction.tau_pos[2,1],axis.gear.bearingFriction.tau_pos[2,2]}},2);
//   axis.gear.bearingFriction.phi_support = 0.0;
//   axis.gear.bearingFriction.startForward = pre(axis.gear.bearingFriction.mode) == 0 and (axis.gear.bearingFriction.sa > axis.gear.bearingFriction.tau0_max or pre(axis.gear.bearingFriction.startForward) and axis.gear.bearingFriction.sa > axis.gear.bearingFriction.tau0) or pre(axis.gear.bearingFriction.mode) == -1 and axis.gear.bearingFriction.w_relfric > axis.gear.bearingFriction.w_small or initial() and axis.gear.bearingFriction.w_relfric > 0.0;
//   axis.gear.bearingFriction.startBackward = pre(axis.gear.bearingFriction.mode) == 0 and (axis.gear.bearingFriction.sa < -axis.gear.bearingFriction.tau0_max or pre(axis.gear.bearingFriction.startBackward) and axis.gear.bearingFriction.sa < -axis.gear.bearingFriction.tau0) or pre(axis.gear.bearingFriction.mode) == 1 and axis.gear.bearingFriction.w_relfric < -axis.gear.bearingFriction.w_small or initial() and axis.gear.bearingFriction.w_relfric < 0.0;
//   axis.gear.bearingFriction.locked = not axis.gear.bearingFriction.free and not (pre(axis.gear.bearingFriction.mode) == 1 or axis.gear.bearingFriction.startForward or pre(axis.gear.bearingFriction.mode) == -1 or axis.gear.bearingFriction.startBackward);
//   axis.gear.bearingFriction.a_relfric = if axis.gear.bearingFriction.locked then 0.0 else if axis.gear.bearingFriction.free then axis.gear.bearingFriction.sa else if axis.gear.bearingFriction.startForward then axis.gear.bearingFriction.sa - axis.gear.bearingFriction.tau0_max else if axis.gear.bearingFriction.startBackward then axis.gear.bearingFriction.sa + axis.gear.bearingFriction.tau0_max else if pre(axis.gear.bearingFriction.mode) == 1 then axis.gear.bearingFriction.sa - axis.gear.bearingFriction.tau0_max else axis.gear.bearingFriction.sa + axis.gear.bearingFriction.tau0_max;
//   axis.gear.bearingFriction.mode = if axis.gear.bearingFriction.free then 2 else if (pre(axis.gear.bearingFriction.mode) == 1 or pre(axis.gear.bearingFriction.mode) == 2 or axis.gear.bearingFriction.startForward) and axis.gear.bearingFriction.w_relfric > 0.0 then 1 else if (pre(axis.gear.bearingFriction.mode) == -1 or pre(axis.gear.bearingFriction.mode) == 2 or axis.gear.bearingFriction.startBackward) and axis.gear.bearingFriction.w_relfric < 0.0 then -1 else 0;
//   axis.motor.Vs.v = axis.motor.Vs.p.v - axis.motor.Vs.n.v;
//   0.0 = axis.motor.Vs.p.i + axis.motor.Vs.n.i;
//   axis.motor.Vs.i = axis.motor.Vs.p.i;
//   axis.motor.diff.v1 = axis.motor.diff.p1.v - axis.motor.diff.n1.v;
//   axis.motor.diff.v2 = axis.motor.diff.p2.v - axis.motor.diff.n2.v;
//   0.0 = axis.motor.diff.p1.i + axis.motor.diff.n1.i;
//   0.0 = axis.motor.diff.p2.i + axis.motor.diff.n2.i;
//   axis.motor.diff.i1 = axis.motor.diff.p1.i;
//   axis.motor.diff.i2 = axis.motor.diff.p2.i;
//   axis.motor.diff.v1 = 0.0;
//   axis.motor.diff.i1 = 0.0;
//   axis.motor.power.v1 = axis.motor.power.p1.v - axis.motor.power.n1.v;
//   axis.motor.power.v2 = axis.motor.power.p2.v - axis.motor.power.n2.v;
//   0.0 = axis.motor.power.p1.i + axis.motor.power.n1.i;
//   0.0 = axis.motor.power.p2.i + axis.motor.power.n2.i;
//   axis.motor.power.i1 = axis.motor.power.p1.i;
//   axis.motor.power.i2 = axis.motor.power.p2.i;
//   axis.motor.power.v1 = 0.0;
//   axis.motor.power.i1 = 0.0;
//   axis.motor.emf.internalSupport.flange.tau = axis.motor.emf.internalSupport.tau;
//   axis.motor.emf.internalSupport.flange.phi = axis.motor.emf.internalSupport.phi;
//   axis.motor.emf.fixed.flange.phi = axis.motor.emf.fixed.phi0;
//   axis.motor.emf.v = axis.motor.emf.p.v - axis.motor.emf.n.v;
//   0.0 = axis.motor.emf.p.i + axis.motor.emf.n.i;
//   axis.motor.emf.i = axis.motor.emf.p.i;
//   axis.motor.emf.phi = axis.motor.emf.flange.phi - axis.motor.emf.internalSupport.phi;
//   axis.motor.emf.w = der(axis.motor.emf.phi);
//   axis.motor.emf.k * axis.motor.emf.w = axis.motor.emf.v;
//   axis.motor.emf.flange.tau = (-axis.motor.emf.k) * axis.motor.emf.i;
//   axis.motor.La.L * der(axis.motor.La.i) = axis.motor.La.v;
//   axis.motor.La.v = axis.motor.La.p.v - axis.motor.La.n.v;
//   0.0 = axis.motor.La.p.i + axis.motor.La.n.i;
//   axis.motor.La.i = axis.motor.La.p.i;
//   assert(1.0 + axis.motor.Ra.alpha * (axis.motor.Ra.T_heatPort - axis.motor.Ra.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis.motor.Ra.R_actual = axis.motor.Ra.R * (1.0 + axis.motor.Ra.alpha * (axis.motor.Ra.T_heatPort - axis.motor.Ra.T_ref));
//   axis.motor.Ra.v = axis.motor.Ra.R_actual * axis.motor.Ra.i;
//   axis.motor.Ra.LossPower = axis.motor.Ra.v * axis.motor.Ra.i;
//   axis.motor.Ra.i = axis.motor.Ra.p.i;
//   0.0 = axis.motor.Ra.p.i + axis.motor.Ra.n.i;
//   axis.motor.Ra.v = axis.motor.Ra.p.v - axis.motor.Ra.n.v;
//   axis.motor.Ra.T_heatPort = axis.motor.Ra.T;
//   assert(1.0 + axis.motor.Rd2.alpha * (axis.motor.Rd2.T_heatPort - axis.motor.Rd2.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis.motor.Rd2.R_actual = axis.motor.Rd2.R * (1.0 + axis.motor.Rd2.alpha * (axis.motor.Rd2.T_heatPort - axis.motor.Rd2.T_ref));
//   axis.motor.Rd2.v = axis.motor.Rd2.R_actual * axis.motor.Rd2.i;
//   axis.motor.Rd2.LossPower = axis.motor.Rd2.v * axis.motor.Rd2.i;
//   axis.motor.Rd2.i = axis.motor.Rd2.p.i;
//   0.0 = axis.motor.Rd2.p.i + axis.motor.Rd2.n.i;
//   axis.motor.Rd2.v = axis.motor.Rd2.p.v - axis.motor.Rd2.n.v;
//   axis.motor.Rd2.T_heatPort = axis.motor.Rd2.T;
//   axis.motor.C.i = axis.motor.C.C * der(axis.motor.C.v);
//   axis.motor.C.v = axis.motor.C.p.v - axis.motor.C.n.v;
//   0.0 = axis.motor.C.p.i + axis.motor.C.n.i;
//   axis.motor.C.i = axis.motor.C.p.i;
//   axis.motor.OpI.v1 = axis.motor.OpI.p1.v - axis.motor.OpI.n1.v;
//   axis.motor.OpI.v2 = axis.motor.OpI.p2.v - axis.motor.OpI.n2.v;
//   0.0 = axis.motor.OpI.p1.i + axis.motor.OpI.n1.i;
//   0.0 = axis.motor.OpI.p2.i + axis.motor.OpI.n2.i;
//   axis.motor.OpI.i1 = axis.motor.OpI.p1.i;
//   axis.motor.OpI.i2 = axis.motor.OpI.p2.i;
//   axis.motor.OpI.v1 = 0.0;
//   axis.motor.OpI.i1 = 0.0;
//   assert(1.0 + axis.motor.Rd1.alpha * (axis.motor.Rd1.T_heatPort - axis.motor.Rd1.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis.motor.Rd1.R_actual = axis.motor.Rd1.R * (1.0 + axis.motor.Rd1.alpha * (axis.motor.Rd1.T_heatPort - axis.motor.Rd1.T_ref));
//   axis.motor.Rd1.v = axis.motor.Rd1.R_actual * axis.motor.Rd1.i;
//   axis.motor.Rd1.LossPower = axis.motor.Rd1.v * axis.motor.Rd1.i;
//   axis.motor.Rd1.i = axis.motor.Rd1.p.i;
//   0.0 = axis.motor.Rd1.p.i + axis.motor.Rd1.n.i;
//   axis.motor.Rd1.v = axis.motor.Rd1.p.v - axis.motor.Rd1.n.v;
//   axis.motor.Rd1.T_heatPort = axis.motor.Rd1.T;
//   assert(1.0 + axis.motor.Ri.alpha * (axis.motor.Ri.T_heatPort - axis.motor.Ri.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis.motor.Ri.R_actual = axis.motor.Ri.R * (1.0 + axis.motor.Ri.alpha * (axis.motor.Ri.T_heatPort - axis.motor.Ri.T_ref));
//   axis.motor.Ri.v = axis.motor.Ri.R_actual * axis.motor.Ri.i;
//   axis.motor.Ri.LossPower = axis.motor.Ri.v * axis.motor.Ri.i;
//   axis.motor.Ri.i = axis.motor.Ri.p.i;
//   0.0 = axis.motor.Ri.p.i + axis.motor.Ri.n.i;
//   axis.motor.Ri.v = axis.motor.Ri.p.v - axis.motor.Ri.n.v;
//   axis.motor.Ri.T_heatPort = axis.motor.Ri.T;
//   assert(1.0 + axis.motor.Rp1.alpha * (axis.motor.Rp1.T_heatPort - axis.motor.Rp1.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis.motor.Rp1.R_actual = axis.motor.Rp1.R * (1.0 + axis.motor.Rp1.alpha * (axis.motor.Rp1.T_heatPort - axis.motor.Rp1.T_ref));
//   axis.motor.Rp1.v = axis.motor.Rp1.R_actual * axis.motor.Rp1.i;
//   axis.motor.Rp1.LossPower = axis.motor.Rp1.v * axis.motor.Rp1.i;
//   axis.motor.Rp1.i = axis.motor.Rp1.p.i;
//   0.0 = axis.motor.Rp1.p.i + axis.motor.Rp1.n.i;
//   axis.motor.Rp1.v = axis.motor.Rp1.p.v - axis.motor.Rp1.n.v;
//   axis.motor.Rp1.T_heatPort = axis.motor.Rp1.T;
//   assert(1.0 + axis.motor.Rp2.alpha * (axis.motor.Rp2.T_heatPort - axis.motor.Rp2.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis.motor.Rp2.R_actual = axis.motor.Rp2.R * (1.0 + axis.motor.Rp2.alpha * (axis.motor.Rp2.T_heatPort - axis.motor.Rp2.T_ref));
//   axis.motor.Rp2.v = axis.motor.Rp2.R_actual * axis.motor.Rp2.i;
//   axis.motor.Rp2.LossPower = axis.motor.Rp2.v * axis.motor.Rp2.i;
//   axis.motor.Rp2.i = axis.motor.Rp2.p.i;
//   0.0 = axis.motor.Rp2.p.i + axis.motor.Rp2.n.i;
//   axis.motor.Rp2.v = axis.motor.Rp2.p.v - axis.motor.Rp2.n.v;
//   axis.motor.Rp2.T_heatPort = axis.motor.Rp2.T;
//   assert(1.0 + axis.motor.Rd4.alpha * (axis.motor.Rd4.T_heatPort - axis.motor.Rd4.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis.motor.Rd4.R_actual = axis.motor.Rd4.R * (1.0 + axis.motor.Rd4.alpha * (axis.motor.Rd4.T_heatPort - axis.motor.Rd4.T_ref));
//   axis.motor.Rd4.v = axis.motor.Rd4.R_actual * axis.motor.Rd4.i;
//   axis.motor.Rd4.LossPower = axis.motor.Rd4.v * axis.motor.Rd4.i;
//   axis.motor.Rd4.i = axis.motor.Rd4.p.i;
//   0.0 = axis.motor.Rd4.p.i + axis.motor.Rd4.n.i;
//   axis.motor.Rd4.v = axis.motor.Rd4.p.v - axis.motor.Rd4.n.v;
//   axis.motor.Rd4.T_heatPort = axis.motor.Rd4.T;
//   axis.motor.hall2.v = axis.motor.hall2.p.v - axis.motor.hall2.n.v;
//   0.0 = axis.motor.hall2.p.i + axis.motor.hall2.n.i;
//   axis.motor.hall2.i = axis.motor.hall2.p.i;
//   assert(1.0 + axis.motor.Rd3.alpha * (axis.motor.Rd3.T_heatPort - axis.motor.Rd3.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis.motor.Rd3.R_actual = axis.motor.Rd3.R * (1.0 + axis.motor.Rd3.alpha * (axis.motor.Rd3.T_heatPort - axis.motor.Rd3.T_ref));
//   axis.motor.Rd3.v = axis.motor.Rd3.R_actual * axis.motor.Rd3.i;
//   axis.motor.Rd3.LossPower = axis.motor.Rd3.v * axis.motor.Rd3.i;
//   axis.motor.Rd3.i = axis.motor.Rd3.p.i;
//   0.0 = axis.motor.Rd3.p.i + axis.motor.Rd3.n.i;
//   axis.motor.Rd3.v = axis.motor.Rd3.p.v - axis.motor.Rd3.n.v;
//   axis.motor.Rd3.T_heatPort = axis.motor.Rd3.T;
//   axis.motor.g1.p.v = 0.0;
//   axis.motor.g2.p.v = 0.0;
//   axis.motor.g3.p.v = 0.0;
//   axis.motor.hall1.p.v = axis.motor.hall1.n.v;
//   axis.motor.hall1.p.i = axis.motor.hall1.i;
//   axis.motor.hall1.n.i = -axis.motor.hall1.i;
//   axis.motor.g4.p.v = 0.0;
//   axis.motor.g5.p.v = 0.0;
//   axis.motor.phi.phi = axis.motor.phi.flange.phi;
//   0.0 = axis.motor.phi.flange.tau;
//   axis.motor.speed.w = der(axis.motor.speed.flange.phi);
//   0.0 = axis.motor.speed.flange.tau;
//   axis.motor.Jmotor.phi = axis.motor.Jmotor.flange_a.phi;
//   axis.motor.Jmotor.phi = axis.motor.Jmotor.flange_b.phi;
//   axis.motor.Jmotor.w = der(axis.motor.Jmotor.phi);
//   axis.motor.Jmotor.a = der(axis.motor.Jmotor.w);
//   axis.motor.Jmotor.J * axis.motor.Jmotor.a = axis.motor.Jmotor.flange_a.tau + axis.motor.Jmotor.flange_b.tau;
//   axis.motor.convert1.y = axis.motor.convert1.k * axis.motor.convert1.u;
//   axis.motor.convert2.y = axis.motor.convert2.k * axis.motor.convert2.u;
//   axis.controller.gain1.y = axis.controller.gain1.k * axis.controller.gain1.u;
//   der(axis.controller.PI.x) = axis.controller.PI.u / axis.controller.PI.T;
//   axis.controller.PI.y = axis.controller.PI.k * (axis.controller.PI.x + axis.controller.PI.u);
//   axis.controller.feedback1.y = axis.controller.feedback1.u1 - axis.controller.feedback1.u2;
//   axis.controller.P.y = axis.controller.P.k * axis.controller.P.u;
//   axis.controller.add3.y = axis.controller.add3.k1 * axis.controller.add3.u1 + (axis.controller.add3.k2 * axis.controller.add3.u2 + axis.controller.add3.k3 * axis.controller.add3.u3);
//   axis.controller.gain2.y = axis.controller.gain2.k * axis.controller.gain2.u;
//   axis.angleSensor.phi = axis.angleSensor.flange.phi;
//   0.0 = axis.angleSensor.flange.tau;
//   axis.speedSensor.w = der(axis.speedSensor.flange.phi);
//   0.0 = axis.speedSensor.flange.tau;
//   axis.accSensor.w = der(axis.accSensor.flange.phi);
//   axis.accSensor.a = der(axis.accSensor.w);
//   0.0 = axis.accSensor.flange.tau;
//   axis.initializeFlange.set_flange_tau.flange.tau = 0.0;
//   axis.initializeFlange.set_phi_start.flange.tau = 0.0;
//   axis.initializeFlange.set_w_start.flange.tau = 0.0;
//   axis.initializeFlange.set_a_start.flange.tau = 0.0;
//   axis.const.y = axis.const.k;
//   load.phi = load.flange_a.phi;
//   load.phi = load.flange_b.phi;
//   load.w = der(load.phi);
//   load.a = der(load.w);
//   load.J * load.a = load.flange_a.tau + load.flange_b.tau;
//   pathPlanning.path.aux1[1] = pathPlanning.path.p_deltaq[1] / pathPlanning.path.p_qd_max[1];
//   pathPlanning.path.aux2[1] = pathPlanning.path.p_deltaq[1] / pathPlanning.path.p_qdd_max[1];
//   pathPlanning.path.sd_max_inv = abs(pathPlanning.path.aux1[1]);
//   pathPlanning.path.sdd_max_inv = abs(pathPlanning.path.aux2[1]);
//   if pathPlanning.path.sd_max_inv <= 1e-14 or pathPlanning.path.sdd_max_inv <= 1e-14 then
//   pathPlanning.path.sd_max = 0.0;
//   pathPlanning.path.sdd_max = 0.0;
//   pathPlanning.path.Ta1 = 0.0;
//   pathPlanning.path.Ta2 = 0.0;
//   pathPlanning.path.noWphase = false;
//   pathPlanning.path.Tv = 0.0;
//   pathPlanning.path.Te = 0.0;
//   pathPlanning.path.Ta1s = 0.0;
//   pathPlanning.path.Ta2s = 0.0;
//   pathPlanning.path.Tvs = 0.0;
//   pathPlanning.path.Tes = 0.0;
//   pathPlanning.path.sd_max2 = 0.0;
//   pathPlanning.path.s1 = 0.0;
//   pathPlanning.path.s2 = 0.0;
//   pathPlanning.path.s3 = 0.0;
//   pathPlanning.path.r_sdd = 0.0;
//   pathPlanning.path.r_sd = 0.0;
//   pathPlanning.path.r_s = 0.0;
//   else
//   pathPlanning.path.sd_max = 1.0 / abs(pathPlanning.path.aux1[1]);
//   pathPlanning.path.sdd_max = 1.0 / abs(pathPlanning.path.aux2[1]);
//   pathPlanning.path.Ta1 = sqrt(1.0 / pathPlanning.path.sdd_max);
//   pathPlanning.path.Ta2 = pathPlanning.path.sd_max / pathPlanning.path.sdd_max;
//   pathPlanning.path.noWphase = pathPlanning.path.Ta2 >= pathPlanning.path.Ta1;
//   pathPlanning.path.Tv = if pathPlanning.path.noWphase then pathPlanning.path.Ta1 else 1.0 / pathPlanning.path.sd_max;
//   pathPlanning.path.Te = if pathPlanning.path.noWphase then 2.0 * pathPlanning.path.Ta1 else pathPlanning.path.Tv + pathPlanning.path.Ta2;
//   pathPlanning.path.Ta1s = pathPlanning.path.Ta1 + pathPlanning.path.startTime;
//   pathPlanning.path.Ta2s = pathPlanning.path.Ta2 + pathPlanning.path.startTime;
//   pathPlanning.path.Tvs = pathPlanning.path.Tv + pathPlanning.path.startTime;
//   pathPlanning.path.Tes = pathPlanning.path.Te + pathPlanning.path.startTime;
//   pathPlanning.path.sd_max2 = pathPlanning.path.sdd_max * pathPlanning.path.Ta1;
//   pathPlanning.path.s1 = (pathPlanning.path.sdd_max * (if pathPlanning.path.noWphase then pathPlanning.path.Ta1 ^ 2.0 else pathPlanning.path.Ta2 ^ 2.0)) / 2.0;
//   pathPlanning.path.s2 = pathPlanning.path.s1 + (if pathPlanning.path.noWphase then pathPlanning.path.sd_max2 * (pathPlanning.path.Te - pathPlanning.path.Ta1) + ((-(pathPlanning.path.Te - pathPlanning.path.Ta1) ^ 2.0) * pathPlanning.path.sdd_max) / 2.0 else pathPlanning.path.sd_max * (pathPlanning.path.Tv - pathPlanning.path.Ta2));
//   pathPlanning.path.s3 = pathPlanning.path.s2 + (pathPlanning.path.sd_max * (pathPlanning.path.Te - pathPlanning.path.Tv) + ((-(pathPlanning.path.Te - pathPlanning.path.Tv) ^ 2.0) * pathPlanning.path.sdd_max) / 2.0);
//   if time < pathPlanning.path.startTime then
//   pathPlanning.path.r_sdd = 0.0;
//   pathPlanning.path.r_sd = 0.0;
//   pathPlanning.path.r_s = 0.0;
//   elseif pathPlanning.path.noWphase then
//   if time < pathPlanning.path.Ta1s then
//   pathPlanning.path.r_sdd = pathPlanning.path.sdd_max;
//   pathPlanning.path.r_sd = pathPlanning.path.sdd_max * (time - pathPlanning.path.startTime);
//   pathPlanning.path.r_s = ((time - pathPlanning.path.startTime) ^ 2.0 * pathPlanning.path.sdd_max) / 2.0;
//   elseif time < pathPlanning.path.Tes then
//   pathPlanning.path.r_sdd = -pathPlanning.path.sdd_max;
//   pathPlanning.path.r_sd = pathPlanning.path.sd_max2 - pathPlanning.path.sdd_max * (time - pathPlanning.path.Ta1s);
//   pathPlanning.path.r_s = pathPlanning.path.s1 + (pathPlanning.path.sd_max2 * (time - pathPlanning.path.Ta1s) + ((-(time - pathPlanning.path.Ta1s) ^ 2.0) * pathPlanning.path.sdd_max) / 2.0);
//   else
//   pathPlanning.path.r_sdd = 0.0;
//   pathPlanning.path.r_sd = 0.0;
//   pathPlanning.path.r_s = pathPlanning.path.s2;
//   end if;
//   elseif time < pathPlanning.path.Ta2s then
//   pathPlanning.path.r_sdd = pathPlanning.path.sdd_max;
//   pathPlanning.path.r_sd = pathPlanning.path.sdd_max * (time - pathPlanning.path.startTime);
//   pathPlanning.path.r_s = ((time - pathPlanning.path.startTime) ^ 2.0 * pathPlanning.path.sdd_max) / 2.0;
//   elseif time < pathPlanning.path.Tvs then
//   pathPlanning.path.r_sdd = 0.0;
//   pathPlanning.path.r_sd = pathPlanning.path.sd_max;
//   pathPlanning.path.r_s = pathPlanning.path.s1 + pathPlanning.path.sd_max * (time - pathPlanning.path.Ta2s);
//   elseif time < pathPlanning.path.Tes then
//   pathPlanning.path.r_sdd = -pathPlanning.path.sdd_max;
//   pathPlanning.path.r_sd = pathPlanning.path.sd_max - pathPlanning.path.sdd_max * (time - pathPlanning.path.Tvs);
//   pathPlanning.path.r_s = pathPlanning.path.s2 + (pathPlanning.path.sd_max * (time - pathPlanning.path.Tvs) + ((-(time - pathPlanning.path.Tvs) ^ 2.0) * pathPlanning.path.sdd_max) / 2.0);
//   else
//   pathPlanning.path.r_sdd = 0.0;
//   pathPlanning.path.r_sd = 0.0;
//   pathPlanning.path.r_s = pathPlanning.path.s3;
//   end if;
//   end if;
//   pathPlanning.path.qdd[1] = pathPlanning.path.sdd * pathPlanning.path.p_deltaq[1];
//   pathPlanning.path.qd[1] = pathPlanning.path.sd * pathPlanning.path.p_deltaq[1];
//   pathPlanning.path.q[1] = pathPlanning.path.p_q_begin[1] + pathPlanning.path.s * pathPlanning.path.p_deltaq[1];
//   pathPlanning.path.endTime = pathPlanning.path.Tes;
//   pathPlanning.path.s = Modelica.Blocks.Sources.KinematicPTP2.position({pathPlanning.path.r_s,pathPlanning.path.r_sd,pathPlanning.path.r_sdd},time);
//   pathPlanning.path.sd = der(pathPlanning.path.s);
//   pathPlanning.path.sdd = der(pathPlanning.path.sd);
//   pathPlanning.path.motion_ref = time <= pathPlanning.path.endTime;
//   pathPlanning.path.moving[1] = if abs(pathPlanning.path.q_begin[1] - pathPlanning.path.q_end[1]) > 1e-14 then pathPlanning.path.motion_ref else false;
//   pathPlanning.pathToAxis1.q_axisUsed.y = pathPlanning.pathToAxis1.q_axisUsed.u;
//   pathPlanning.pathToAxis1.qd_axisUsed.y = pathPlanning.pathToAxis1.qd_axisUsed.u;
//   pathPlanning.pathToAxis1.qdd_axisUsed.y = pathPlanning.pathToAxis1.qdd_axisUsed.u;
//   pathPlanning.pathToAxis1.motion_ref_axisUsed.y = pathPlanning.pathToAxis1.motion_ref_axisUsed.u;
//   when pathPlanning.terminateSimulation.condition then
//   terminate(pathPlanning.terminateSimulation.terminationText);
//   end when;
//   axis.axisControlBus.speed_ref = controlBus.axisControlBus1.speed_ref;
//   axis.axisControlBus.speed_ref = pathPlanning.controlBus.axisControlBus1.speed_ref;
//   axis.axisControlBus.speed = controlBus.axisControlBus1.speed;
//   axis.axisControlBus.speed = pathPlanning.controlBus.axisControlBus1.speed;
//   axis.axisControlBus.motorAngle = controlBus.axisControlBus1.motorAngle;
//   axis.axisControlBus.motorAngle = pathPlanning.controlBus.axisControlBus1.motorAngle;
//   axis.axisControlBus.current = controlBus.axisControlBus1.current;
//   axis.axisControlBus.current = pathPlanning.controlBus.axisControlBus1.current;
//   axis.axisControlBus.current_ref = controlBus.axisControlBus1.current_ref;
//   axis.axisControlBus.current_ref = pathPlanning.controlBus.axisControlBus1.current_ref;
//   axis.axisControlBus.motorSpeed = controlBus.axisControlBus1.motorSpeed;
//   axis.axisControlBus.motorSpeed = pathPlanning.controlBus.axisControlBus1.motorSpeed;
//   axis.axisControlBus.acceleration = controlBus.axisControlBus1.acceleration;
//   axis.axisControlBus.acceleration = pathPlanning.controlBus.axisControlBus1.acceleration;
//   axis.axisControlBus.angle = controlBus.axisControlBus1.angle;
//   axis.axisControlBus.angle = pathPlanning.controlBus.axisControlBus1.angle;
//   axis.axisControlBus.angle_ref = controlBus.axisControlBus1.angle_ref;
//   axis.axisControlBus.angle_ref = pathPlanning.controlBus.axisControlBus1.angle_ref;
//   controlBus.axisControlBus1.acceleration_ref = pathPlanning.controlBus.axisControlBus1.acceleration_ref;
//   controlBus.axisControlBus1.motion_ref = pathPlanning.controlBus.axisControlBus1.motion_ref;
//   axis.flange.tau + load.flange_a.tau = 0.0;
//   axis.flange.phi = load.flange_a.phi;
//   pathPlanning.controlBus.axisControlBus1.speed_ref = pathPlanning.pathToAxis1.axisControlBus.speed_ref;
//   pathPlanning.controlBus.axisControlBus1.angle_ref = pathPlanning.pathToAxis1.axisControlBus.angle_ref;
//   pathPlanning.controlBus.axisControlBus1.acceleration_ref = pathPlanning.pathToAxis1.axisControlBus.acceleration_ref;
//   pathPlanning.controlBus.axisControlBus1.motion_ref = pathPlanning.pathToAxis1.axisControlBus.motion_ref;
//   pathPlanning.path.moving[1] = pathPlanning.pathToAxis1.moving[1];
//   pathPlanning.path.qdd[1] = pathPlanning.pathToAxis1.qdd[1];
//   pathPlanning.path.qd[1] = pathPlanning.pathToAxis1.qd[1];
//   pathPlanning.path.q[1] = pathPlanning.pathToAxis1.q[1];
//   pathPlanning.pathToAxis1.axisControlBus.angle_ref = pathPlanning.pathToAxis1.q_axisUsed.y;
//   pathPlanning.pathToAxis1.axisControlBus.speed_ref = pathPlanning.pathToAxis1.qd_axisUsed.y;
//   pathPlanning.pathToAxis1.axisControlBus.acceleration_ref = pathPlanning.pathToAxis1.qdd_axisUsed.y;
//   pathPlanning.pathToAxis1.axisControlBus.motion_ref = pathPlanning.pathToAxis1.motion_ref_axisUsed.y;
//   pathPlanning.pathToAxis1.motion_ref_axisUsed.u = pathPlanning.pathToAxis1.moving[1];
//   pathPlanning.pathToAxis1.qdd[1] = pathPlanning.pathToAxis1.qdd_axisUsed.u;
//   pathPlanning.pathToAxis1.qd[1] = pathPlanning.pathToAxis1.qd_axisUsed.u;
//   pathPlanning.pathToAxis1.q[1] = pathPlanning.pathToAxis1.q_axisUsed.u;
//   load.flange_b.tau = 0.0;
//   axis.axisControlBus.speed_ref = axis.controller.axisControlBus.speed_ref;
//   axis.axisControlBus.speed_ref = axis.initializeFlange.w_start;
//   axis.axisControlBus.speed_ref = axis.motor.axisControlBus.speed_ref;
//   axis.axisControlBus.speed = axis.controller.axisControlBus.speed;
//   axis.axisControlBus.speed = axis.motor.axisControlBus.speed;
//   axis.axisControlBus.speed = axis.speedSensor.w;
//   axis.axisControlBus.motorAngle = axis.controller.axisControlBus.motorAngle;
//   axis.axisControlBus.motorAngle = axis.motor.axisControlBus.motorAngle;
//   axis.axisControlBus.current = axis.controller.axisControlBus.current;
//   axis.axisControlBus.current = axis.motor.axisControlBus.current;
//   axis.axisControlBus.current_ref = axis.controller.axisControlBus.current_ref;
//   axis.axisControlBus.current_ref = axis.motor.axisControlBus.current_ref;
//   axis.axisControlBus.motorSpeed = axis.controller.axisControlBus.motorSpeed;
//   axis.axisControlBus.motorSpeed = axis.motor.axisControlBus.motorSpeed;
//   axis.accSensor.a = axis.axisControlBus.acceleration;
//   axis.accSensor.a = axis.controller.axisControlBus.acceleration;
//   axis.accSensor.a = axis.motor.axisControlBus.acceleration;
//   axis.angleSensor.phi = axis.axisControlBus.angle;
//   axis.angleSensor.phi = axis.controller.axisControlBus.angle;
//   axis.angleSensor.phi = axis.motor.axisControlBus.angle;
//   axis.axisControlBus.angle_ref = axis.controller.axisControlBus.angle_ref;
//   axis.axisControlBus.angle_ref = axis.initializeFlange.phi_start;
//   axis.axisControlBus.angle_ref = axis.motor.axisControlBus.angle_ref;
//   axis.const.y = axis.initializeFlange.a_start;
//   axis.initializeFlange.flange.tau + (axis.gear.flange_b.tau + ((-axis.flange.tau) + (axis.angleSensor.flange.tau + (axis.speedSensor.flange.tau + axis.accSensor.flange.tau)))) = 0.0;
//   axis.accSensor.flange.phi = axis.angleSensor.flange.phi;
//   axis.accSensor.flange.phi = axis.flange.phi;
//   axis.accSensor.flange.phi = axis.gear.flange_b.phi;
//   axis.accSensor.flange.phi = axis.initializeFlange.flange.phi;
//   axis.accSensor.flange.phi = axis.speedSensor.flange.phi;
//   axis.motor.flange_motor.tau + axis.gear.flange_a.tau = 0.0;
//   axis.gear.flange_a.phi = axis.motor.flange_motor.phi;
//   axis.initializeFlange.set_flange_tau.flange.tau + (axis.initializeFlange.set_a_start.flange.tau + (axis.initializeFlange.set_w_start.flange.tau + (axis.initializeFlange.set_phi_start.flange.tau + (-axis.initializeFlange.flange.tau)))) = 0.0;
//   axis.initializeFlange.flange.phi = axis.initializeFlange.set_a_start.flange.phi;
//   axis.initializeFlange.flange.phi = axis.initializeFlange.set_flange_tau.flange.phi;
//   axis.initializeFlange.flange.phi = axis.initializeFlange.set_phi_start.flange.phi;
//   axis.initializeFlange.flange.phi = axis.initializeFlange.set_w_start.flange.phi;
//   axis.initializeFlange.a_start = axis.initializeFlange.set_a_start.a_start;
//   axis.initializeFlange.set_w_start.w_start = axis.initializeFlange.w_start;
//   axis.initializeFlange.phi_start = axis.initializeFlange.set_phi_start.phi_start;
//   axis.controller.PI.y = axis.controller.axisControlBus.current_ref;
//   axis.controller.add3.u3 = axis.controller.axisControlBus.motorSpeed;
//   axis.controller.axisControlBus.motorAngle = axis.controller.feedback1.u2;
//   axis.controller.axisControlBus.angle_ref = axis.controller.gain1.u;
//   axis.controller.axisControlBus.speed_ref = axis.controller.gain2.u;
//   axis.controller.PI.u = axis.controller.add3.y;
//   axis.controller.add3.u1 = axis.controller.gain2.y;
//   axis.controller.P.y = axis.controller.add3.u2;
//   axis.controller.P.u = axis.controller.feedback1.y;
//   axis.controller.feedback1.u1 = axis.controller.gain1.y;
//   axis.motor.emf.flange.tau + (axis.motor.phi.flange.tau + (axis.motor.speed.flange.tau + axis.motor.Jmotor.flange_a.tau)) = 0.0;
//   axis.motor.Jmotor.flange_a.phi = axis.motor.emf.flange.phi;
//   axis.motor.Jmotor.flange_a.phi = axis.motor.phi.flange.phi;
//   axis.motor.Jmotor.flange_a.phi = axis.motor.speed.flange.phi;
//   axis.motor.Vs.v = axis.motor.convert2.y;
//   axis.motor.axisControlBus.current_ref = axis.motor.convert2.u;
//   axis.motor.convert1.y = axis.motor.hall2.v;
//   axis.motor.axisControlBus.current = axis.motor.convert1.u;
//   axis.motor.axisControlBus.current = axis.motor.hall1.i;
//   axis.motor.axisControlBus.motorSpeed = axis.motor.speed.w;
//   axis.motor.axisControlBus.motorAngle = axis.motor.phi.phi;
//   axis.motor.Jmotor.flange_b.tau + (-axis.motor.flange_motor.tau) = 0.0;
//   axis.motor.Jmotor.flange_b.phi = axis.motor.flange_motor.phi;
//   axis.motor.Rd4.n.i + (axis.motor.g3.p.i + (axis.motor.OpI.p1.i + (axis.motor.OpI.n2.i + (axis.motor.power.n2.i + axis.motor.diff.n2.i)))) = 0.0;
//   axis.motor.OpI.n2.v = axis.motor.OpI.p1.v;
//   axis.motor.OpI.n2.v = axis.motor.Rd4.n.v;
//   axis.motor.OpI.n2.v = axis.motor.diff.n2.v;
//   axis.motor.OpI.n2.v = axis.motor.g3.p.v;
//   axis.motor.OpI.n2.v = axis.motor.power.n2.v;
//   axis.motor.hall1.n.i + axis.motor.g4.p.i = 0.0;
//   axis.motor.g4.p.v = axis.motor.hall1.n.v;
//   axis.motor.emf.n.i + axis.motor.hall1.p.i = 0.0;
//   axis.motor.emf.n.v = axis.motor.hall1.p.v;
//   axis.motor.g5.p.i + axis.motor.Rp2.n.i = 0.0;
//   axis.motor.Rp2.n.v = axis.motor.g5.p.v;
//   axis.motor.g2.p.i + axis.motor.hall2.n.i = 0.0;
//   axis.motor.g2.p.v = axis.motor.hall2.n.v;
//   axis.motor.Vs.n.i + axis.motor.g1.p.i = 0.0;
//   axis.motor.Vs.n.v = axis.motor.g1.p.v;
//   axis.motor.Rd3.n.i + (axis.motor.diff.p1.i + axis.motor.Rd4.p.i) = 0.0;
//   axis.motor.Rd3.n.v = axis.motor.Rd4.p.v;
//   axis.motor.Rd3.n.v = axis.motor.diff.p1.v;
//   axis.motor.Rd3.p.i + axis.motor.hall2.p.i = 0.0;
//   axis.motor.Rd3.p.v = axis.motor.hall2.p.v;
//   axis.motor.power.p2.i + (axis.motor.Rp1.n.i + axis.motor.Ra.p.i) = 0.0;
//   axis.motor.Ra.p.v = axis.motor.Rp1.n.v;
//   axis.motor.Ra.p.v = axis.motor.power.p2.v;
//   axis.motor.power.n1.i + (axis.motor.Rp1.p.i + axis.motor.Rp2.p.i) = 0.0;
//   axis.motor.Rp1.p.v = axis.motor.Rp2.p.v;
//   axis.motor.Rp1.p.v = axis.motor.power.n1.v;
//   axis.motor.Ri.n.i + (axis.motor.OpI.n1.i + axis.motor.C.p.i) = 0.0;
//   axis.motor.C.p.v = axis.motor.OpI.n1.v;
//   axis.motor.C.p.v = axis.motor.Ri.n.v;
//   axis.motor.Rd1.n.i + (axis.motor.diff.p2.i + axis.motor.Ri.p.i) = 0.0;
//   axis.motor.Rd1.n.v = axis.motor.Ri.p.v;
//   axis.motor.Rd1.n.v = axis.motor.diff.p2.v;
//   axis.motor.Rd2.n.i + (axis.motor.diff.n1.i + axis.motor.Rd1.p.i) = 0.0;
//   axis.motor.Rd1.p.v = axis.motor.Rd2.n.v;
//   axis.motor.Rd1.p.v = axis.motor.diff.n1.v;
//   axis.motor.Vs.p.i + axis.motor.Rd2.p.i = 0.0;
//   axis.motor.Rd2.p.v = axis.motor.Vs.p.v;
//   axis.motor.C.n.i + (axis.motor.OpI.p2.i + axis.motor.power.p1.i) = 0.0;
//   axis.motor.C.n.v = axis.motor.OpI.p2.v;
//   axis.motor.C.n.v = axis.motor.power.p1.v;
//   axis.motor.Ra.n.i + axis.motor.La.p.i = 0.0;
//   axis.motor.La.p.v = axis.motor.Ra.n.v;
//   axis.motor.La.n.i + axis.motor.emf.p.i = 0.0;
//   axis.motor.La.n.v = axis.motor.emf.p.v;
//   axis.motor.emf.internalSupport.flange.tau + axis.motor.emf.fixed.flange.tau = 0.0;
//   axis.motor.emf.fixed.flange.phi = axis.motor.emf.internalSupport.flange.phi;
//   axis.gear.bearingFriction.flange_a.tau + (-axis.gear.flange_a.tau) = 0.0;
//   axis.gear.bearingFriction.flange_a.phi = axis.gear.flange_a.phi;
//   axis.gear.gear.flange_b.tau + (-axis.gear.flange_b.tau) = 0.0;
//   axis.gear.flange_b.phi = axis.gear.gear.flange_b.phi;
//   axis.gear.bearingFriction.flange_b.tau + axis.gear.spring.flange_a.tau = 0.0;
//   axis.gear.bearingFriction.flange_b.phi = axis.gear.spring.flange_a.phi;
//   axis.gear.spring.flange_b.tau + axis.gear.gear.flange_a.tau = 0.0;
//   axis.gear.gear.flange_a.phi = axis.gear.spring.flange_b.phi;
// end Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.oneAxis;
// "
// "[RobotR3.mo:1367:7-1369:21:writable] Warning: Component PI has the same name as its type Modelica.Blocks.Continuous.PI.
// 	This is forbidden by Modelica specification and may lead to lookup errors.
// "
// "Check of Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.oneAxis completed successfully.
// 
// [RobotR3.mo:1367:7-1369:21:writable] Warning: Component PI has the same name as its type Modelica.Blocks.Continuous.PI.
// 	This is forbidden by Modelica specification and may lead to lookup errors.
// 
// Class Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.oneAxis has 373 equation(s) and 373 variable(s).
// 261 of these are trivial equation(s).
// "
// ""
// "function Modelica.Blocks.Sources.KinematicPTP2.position \"Inline after index reduction\"
//   input Real[3] q_qd_qdd \"Required values for position, speed, acceleration\";
//   input Real dummy \"Just to have one input signal that should be differentiated to avoid possible problems in the Modelica tool (is not used)\";
//   output Real q;
// algorithm
//   q := q_qd_qdd[1];
// end Modelica.Blocks.Sources.KinematicPTP2.position;
// 
// function Modelica.Blocks.Sources.KinematicPTP2.position_der \"Inline after index reduction\"
//   input Real[3] q_qd_qdd \"Required values for position, speed, acceleration\";
//   input Real dummy \"Just to have one input signal that should be differentiated to avoid possible problems in the Modelica tool (is not used)\";
//   input Real dummy_der;
//   output Real qd;
// algorithm
//   qd := q_qd_qdd[2];
// end Modelica.Blocks.Sources.KinematicPTP2.position_der;
// 
// function Modelica.Blocks.Sources.KinematicPTP2.position_der2
//   input Real[3] q_qd_qdd \"Required values for position, speed, acceleration\";
//   input Real dummy \"Just to have one input signal that should be differentiated to avoid possible problems in the Modelica tool (is not used)\";
//   input Real dummy_der;
//   input Real dummy_der2;
//   output Real qdd;
// algorithm
//   qdd := q_qd_qdd[3];
// end Modelica.Blocks.Sources.KinematicPTP2.position_der2;
// 
// function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)\"
//   input Real[:] v \"Vector\";
//   output Real result \"Length of vector v\";
// algorithm
//   result := sqrt(v * v);
// end Modelica.Math.Vectors.length;
// 
// function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
//   input Real[:] v \"Vector\";
//   input Real eps = 1e-13 \"if |v| < eps then result = v/eps\";
//   output Real[size(v,1)] result \"Input vector v normalized to length=1\";
// algorithm
//   result := if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps;
// end Modelica.Math.Vectors.normalize;
// 
// function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\";
// end Modelica.Math.asin;
// 
// function Modelica.Math.atan2
//   input Real u1;
//   input Real u2;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
//   external \"C\";
// end Modelica.Math.atan2;
// 
// function Modelica.Math.cos
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\";
// end Modelica.Math.cos;
// 
// function Modelica.Math.sin
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
//   external \"C\";
// end Modelica.Math.sin;
// 
// function Modelica.Math.tempInterpol1 \"Temporary function for linear interpolation (will be removed)\"
//   input Real u \"input value (first column of table)\";
//   input Real[:, :] table \"table to be interpolated\";
//   input Integer icol \"column of table to be interpolated\";
//   output Real y \"interpolated input value (icol column of table)\";
//   protected Integer i;
//   protected Integer n \"number of rows of table\";
//   protected Real u1;
//   protected Real u2;
//   protected Real y1;
//   protected Real y2;
// algorithm
//   n := size(table,1);
//   if n <= 1 then
//     y := table[1,icol];
//   else
//     if u <= table[1,1] then
//       i := 1;
//     else
//       i := 2;
//       while i < n and u >= table[i,1] loop
//         i := 1 + i;
//       end while;
//       i := i + -1;
//     end if;
//     u1 := table[i,1];
//     u2 := table[1 + i,1];
//     y1 := table[i,icol];
//     y2 := table[1 + i,icol];
//     assert( u2 > u1, \"Table index must be increasing\");
//     y := y1 + (y2 - y1 * (u - u1)) / (u2 - u1);
//   end if;
// end Modelica.Math.tempInterpol1;
// 
// function Modelica.Mechanics.MultiBody.Frames.Internal.resolve1_der \"Inline before index reduction\" \"Derivative of function Frames.resolve1(..)\"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector resolved in frame 2\";
//   input Real[3] v2_der \"= der(v2)\";
//   output Real[3] v1_der \"Derivative of vector v resolved in frame 1\";
// algorithm
//   v1_der := Modelica.Mechanics.MultiBody.Frames.resolve1(R,{v2_der[1] + R.w[2] * v2[3] - R.w[3] * v2[2],v2_der[2] + R.w[3] * v2[1] - R.w[1] * v2[3],v2_der[3] + R.w[1] * v2[2] - R.w[2] * v2[1]});
// end Modelica.Mechanics.MultiBody.Frames.Internal.resolve1_der;
// 
// function Modelica.Mechanics.MultiBody.Frames.Internal.resolve2_der \"Inline before index reduction\" \"Derivative of function Frames.resolve2(..)\"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v1 \"Vector resolved in frame 1\";
//   input Real[3] v1_der \"= der(v1)\";
//   output Real[3] v2_der \"Derivative of vector v resolved in frame 2\";
// algorithm
//   v2_der := Modelica.Mechanics.MultiBody.Frames.resolve2(R,{v1_der[1],v1_der[2],v1_der[3]}) - cross({R.w[1],R.w[2],R.w[3]},Modelica.Mechanics.MultiBody.Frames.resolve2(R,{v1[1],v1[2],v1[3]}));
// end Modelica.Mechanics.MultiBody.Frames.Internal.resolve2_der;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation \"Automatically generated record constructor for Modelica.Mechanics.MultiBody.Frames.Orientation\"
//   input Real[3, 3] T;
//   input Real(quantity=\"AngularVelocity\", unit=\"rad/s\")[3] w;
//   output Orientation res;
// end Modelica.Mechanics.MultiBody.Frames.Orientation;
// 
// function Modelica.Mechanics.MultiBody.Frames.Orientation.equalityConstraint \"Inline before index reduction\" \"Return the constraint residues to express that two frames have the same orientation\"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R1 \"Orientation object to rotate frame 0 into frame 1\";
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R2 \"Orientation object to rotate frame 0 into frame 2\";
//   output Real[3] residue \"The rotation angles around x-, y-, and z-axis of frame 1 to rotate frame 1 into frame 2 for a small rotation (should be zero)\";
// algorithm
//   residue := {atan2((R1.T[1,2] * R1.T[2,3] - R1.T[1,3] * R1.T[2,2]) * R2.T[2,1] + (R1.T[1,3] * R1.T[2,1] - R1.T[1,1] * R1.T[2,3]) * R2.T[2,2] + (R1.T[1,1] * R1.T[2,2] - R1.T[1,2] * R1.T[2,1]) * R2.T[2,3],R1.T[1,1] * R2.T[1,1] + R1.T[1,2] * R2.T[1,2] + R1.T[1,3] * R2.T[1,3]),atan2((R1.T[1,3] * R1.T[2,2] - R1.T[1,2] * R1.T[2,3]) * R2.T[1,1] + (R1.T[1,1] * R1.T[2,3] - R1.T[1,3] * R1.T[2,1]) * R2.T[1,2] + (R1.T[1,2] * R1.T[2,1] - R1.T[1,1] * R1.T[2,2]) * R2.T[1,3],R1.T[2,1] * R2.T[2,1] + R1.T[2,2] * R2.T[2,2] + R1.T[2,3] * R2.T[2,3]),atan2(R1.T[2,1] * R2.T[1,1] + R1.T[2,2] * R2.T[1,2] + R1.T[2,3] * R2.T[1,3],R1.T[3,1] * R2.T[3,1] + R1.T[3,2] * R2.T[3,2] + R1.T[3,3] * R2.T[3,3])};
// end Modelica.Mechanics.MultiBody.Frames.Orientation.equalityConstraint;
// 
// function Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2 \"Inline before index reduction\" \"Compute angular velocity resolved in frame 2 from quaternions orientation object and its derivative\"
//   input Real[4] Q \"Quaternions orientation object to rotate frame 1 into frame 2\";
//   input Real[4] der_Q(unit = \"1/s\") \"Derivative of Q\";
//   output Real[3] w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity of frame 2 with respect to frame 1 resolved in frame 2\";
// algorithm
//   w := {2.0 * Q[4] * der_Q[1] + 2.0 * Q[3] * der_Q[2] + 2.0 * -Q[2] * der_Q[3] + 2.0 * -Q[1] * der_Q[4],2.0 * -Q[3] * der_Q[1] + 2.0 * Q[4] * der_Q[2] + 2.0 * Q[1] * der_Q[3] + 2.0 * -Q[2] * der_Q[4],2.0 * Q[2] * der_Q[1] + 2.0 * -Q[1] * der_Q[2] + 2.0 * Q[4] * der_Q[3] + 2.0 * -Q[3] * der_Q[4]};
// end Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2;
// 
// function Modelica.Mechanics.MultiBody.Frames.Quaternions.from_T \"Return quaternions orientation object Q from transformation matrix T\"
//   input Real[3, 3] T \"Transformation matrix to transform vector from frame 1 to frame 2 (v2=T*v1)\";
//   input Real[4] Q_guess = {0.0,0.0,0.0,1.0} \"Guess value for Q (there are 2 solutions; the one close to Q_guess is used\";
//   output Real[4] Q \"Quaternions orientation object to rotate frame 1 into frame 2 (Q and -Q have same transformation matrix)\";
//   protected Real paux;
//   protected Real paux4;
//   protected Real c1;
//   protected Real c2;
//   protected Real c3;
//   protected Real c4;
//   protected constant Real p4limit = 0.1;
//   protected constant Real c4limit = 0.04;
// algorithm
//   c1 := 1.0 + T[1,1] + -T[2,2] - T[3,3];
//   c2 := 1.0 + T[2,2] + -T[1,1] - T[3,3];
//   c3 := 1.0 + T[3,3] + -T[1,1] - T[2,2];
//   c4 := 1.0 + T[1,1] + T[2,2] + T[3,3];
//   if c4 > 0.04 or c4 > c1 and c4 > c2 and c4 > c3 then
//     paux := sqrt(c4) / 2.0;
//     paux4 := 4.0 * paux;
//     Q := {(T[2,3] - T[3,2]) / paux4,(T[3,1] - T[1,3]) / paux4,(T[1,2] - T[2,1]) / paux4,paux};
//   elseif c1 > c2 and c1 > c3 and c1 > c4 then
//     paux := sqrt(c1) / 2.0;
//     paux4 := 4.0 * paux;
//     Q := {paux,(T[1,2] + T[2,1]) / paux4,(T[1,3] + T[3,1]) / paux4,(T[2,3] - T[3,2]) / paux4};
//   elseif c2 > c1 and c2 > c3 and c2 > c4 then
//     paux := sqrt(c2) / 2.0;
//     paux4 := 4.0 * paux;
//     Q := {(T[1,2] + T[2,1]) / paux4,paux,(T[2,3] + T[3,2]) / paux4,(T[3,1] - T[1,3]) / paux4};
//   else
//     paux := sqrt(c3) / 2.0;
//     paux4 := 4.0 * paux;
//     Q := {(T[1,3] + T[3,1]) / paux4,(T[2,3] + T[3,2]) / paux4,paux,(T[1,2] - T[2,1]) / paux4};
//   end if;
//   if Q[1] * Q_guess[1] + Q[2] * Q_guess[2] + Q[3] * Q_guess[3] + Q[4] * Q_guess[4] < 0.0 then
//     Q := -{Q[1],Q[2],Q[3],Q[4]};
//   end if;
// end Modelica.Mechanics.MultiBody.Frames.Quaternions.from_T;
// 
// function Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation \"Inline before index reduction\" \"Return quaternions orientation object that does not rotate a frame\"
//   output Real[4] Q \"Quaternions orientation object to rotate frame 1 into frame 2\";
// algorithm
//   Q := {0.0,0.0,0.0,1.0};
// end Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint \"Inline before index reduction\" \"Return residues of orientation constraints (shall be zero)\"
//   input Real[4] Q \"Quaternions orientation object to rotate frame 1 into frame 2\";
//   output Real[1] residue \"Residue constraint (shall be zero)\";
// algorithm
//   residue := {Q[1] ^ 2.0 + Q[2] ^ 2.0 + Q[3] ^ 2.0 + Q[4] ^ 2.0 + -1.0};
// end Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation \"Inline before index reduction\" \"Return rotation object to rotate around one frame axis\"
//   input Integer axis(min = 1, max = 3) \"Rotate around 'axis' of frame 1\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along 'axis' of frame 1\";
//   output Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   T := if axis == 1 then <matrix>[1.0,0.0,0.0;0.0,cos(angle),sin(angle);0.0,-sin(angle),cos(angle)] else if axis == 2 then <matrix>[cos(angle),0.0,-sin(angle);0.0,1.0,0.0;sin(angle),0.0,cos(angle)] else <matrix>[cos(angle),sin(angle),0.0;-sin(angle),cos(angle),0.0;0.0,0.0,1.0];
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.planarRotation \"Inline before index reduction\" \"Return orientation object of a planar rotation\"
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation (must have length=1)\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e\";
//   output Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   T := <matrix>[e[1] * e[1] + cos(angle) * (1.0 - e[1] * e[1]),(e[1] * e[2] + cos(angle) * -e[1] * e[2]) - -sin(angle) * e[3],(e[1] * e[3] + cos(angle) * -e[1] * e[3]) - sin(angle) * e[2];(e[2] * e[1] + cos(angle) * -e[2] * e[1]) - sin(angle) * e[3],e[2] * e[2] + cos(angle) * (1.0 - e[2] * e[2]),(e[2] * e[3] + cos(angle) * -e[2] * e[3]) - -sin(angle) * e[1];(e[3] * e[1] + cos(angle) * -e[3] * e[1]) - -sin(angle) * e[2],(e[3] * e[2] + cos(angle) * -e[3] * e[2]) - sin(angle) * e[1],e[3] * e[3] + cos(angle) * (1.0 - e[3] * e[3])];
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.planarRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1 \"Inline before index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {T[1,1] * v2[1] + T[2,1] * v2[2] + T[3,1] * v2[3],T[1,2] * v2[1] + T[2,2] * v2[2] + T[3,2] * v2[3],T[1,3] * v2[1] + T[2,3] * v2[2] + T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2 \"Inline before index reduction\" \"Transform vector from frame 1 to frame 2\"
//   input Real[3, 3] T \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v1 \"Vector in frame 1\";
//   output Real[3] v2 \"Vector in frame 2\";
// algorithm
//   v2 := {T[1,1] * v1[1] + T[1,2] * v1[2] + T[1,3] * v1[3],T[2,1] * v1[1] + T[2,2] * v1[2] + T[2,3] * v1[3],T[3,1] * v1[1] + T[3,2] * v1[2] + T[3,3] * v1[3]};
// end Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2;
// 
// function Modelica.Mechanics.MultiBody.Frames.absoluteRotation \"Inline before index reduction\" \"Return absolute orientation object from another absolute and a relative orientation object\"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R1 \"Orientation object to rotate frame 0 into frame 1\";
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R_rel \"Orientation object to rotate frame 1 into frame 2\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R2 \"Orientation object to rotate frame 0 into frame 2\";
// algorithm
//   R2 := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[R_rel.T[1,1] * R1.T[1,1] + R_rel.T[1,2] * R1.T[2,1] + R_rel.T[1,3] * R1.T[3,1],R_rel.T[1,1] * R1.T[1,2] + R_rel.T[1,2] * R1.T[2,2] + R_rel.T[1,3] * R1.T[3,2],R_rel.T[1,1] * R1.T[1,3] + R_rel.T[1,2] * R1.T[2,3] + R_rel.T[1,3] * R1.T[3,3];R_rel.T[2,1] * R1.T[1,1] + R_rel.T[2,2] * R1.T[2,1] + R_rel.T[2,3] * R1.T[3,1],R_rel.T[2,1] * R1.T[1,2] + R_rel.T[2,2] * R1.T[2,2] + R_rel.T[2,3] * R1.T[3,2],R_rel.T[2,1] * R1.T[1,3] + R_rel.T[2,2] * R1.T[2,3] + R_rel.T[2,3] * R1.T[3,3];R_rel.T[3,1] * R1.T[1,1] + R_rel.T[3,2] * R1.T[2,1] + R_rel.T[3,3] * R1.T[3,1],R_rel.T[3,1] * R1.T[1,2] + R_rel.T[3,2] * R1.T[2,2] + R_rel.T[3,3] * R1.T[3,2],R_rel.T[3,1] * R1.T[1,3] + R_rel.T[3,2] * R1.T[2,3] + R_rel.T[3,3] * R1.T[3,3]],Modelica.Mechanics.MultiBody.Frames.resolve2(R_rel,{R1.w[1],R1.w[2],R1.w[3]}) + {R_rel.w[1],R_rel.w[2],R_rel.w[3]});
// end Modelica.Mechanics.MultiBody.Frames.absoluteRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.angularVelocity2 \"Inline before index reduction\" \"Return angular velocity resolved in frame 2 from orientation object\"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   output Real[3] w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity of frame 2 with respect to frame 1 resolved in frame 2\";
// algorithm
//   w := {R.w[1],R.w[2],R.w[3]};
// end Modelica.Mechanics.MultiBody.Frames.angularVelocity2;
// 
// function Modelica.Mechanics.MultiBody.Frames.axesRotations \"Inline before index reduction\" \"Return fixed rotation object to rotate in sequence around fixed angles along 3 axes\"
//   input Integer[3] sequence = {1,2,3} \"Sequence of rotations from frame 1 to frame 2 along axis sequence[i]\";
//   input Real[3] angles(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angles around the axes defined in 'sequence'\";
//   input Real[3] der_angles(quantity = \"AngularVelocity\", unit = \"rad/s\") \"= der(angles)\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[3],angles[3]) * Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[2],angles[2]) * Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[1],angles[1]),Modelica.Mechanics.MultiBody.Frames.axis(sequence[3]) * der_angles[3] + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[3],angles[3]),Modelica.Mechanics.MultiBody.Frames.axis(sequence[2]) * der_angles[2]) + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[3],angles[3]) * Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation(sequence[2],angles[2]),Modelica.Mechanics.MultiBody.Frames.axis(sequence[1]) * der_angles[1]));
// end Modelica.Mechanics.MultiBody.Frames.axesRotations;
// 
// function Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles \"Return the 3 angles to rotate in sequence around 3 axes to construct the given orientation object\"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   input Integer[3] sequence = {1,2,3} \"Sequence of rotations from frame 1 to frame 2 along axis sequence[i]\";
//   input Real guessAngle1(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Select angles[1] such that |angles[1] - guessAngle1| is a minimum\";
//   output Real[3] angles(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angles around the axes defined in 'sequence' such that R=Frames.axesRotation(sequence,angles); -pi < angles[i] <= pi\";
//   protected Real[3] e1_1(unit = \"1\") \"First rotation axis, resolved in frame 1\";
//   protected Real[3] e2_1a(unit = \"1\") \"Second rotation axis, resolved in frame 1a\";
//   protected Real[3] e3_1(unit = \"1\") \"Third rotation axis, resolved in frame 1\";
//   protected Real[3] e3_2(unit = \"1\") \"Third rotation axis, resolved in frame 2\";
//   protected Real A \"Coefficient A in the equation A*cos(angles[1])+B*sin(angles[1]) = 0\";
//   protected Real B \"Coefficient B in the equation A*cos(angles[1])+B*sin(angles[1]) = 0\";
//   protected Real angle_1a(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Solution 1 for angles[1]\";
//   protected Real angle_1b(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Solution 2 for angles[1]\";
//   protected Real[3, 3] T_1a \"Orientation object to rotate frame 1 into frame 1a\";
// algorithm
//   assert( sequence[1] <> sequence[2] and sequence[2] <> sequence[3], \"input argument 'sequence[1:3]' is not valid\");
//   e1_1 := if sequence[1] == 1 then {1.0,0.0,0.0} else if sequence[1] == 2 then {0.0,1.0,0.0} else {0.0,0.0,1.0};
//   e2_1a := if sequence[2] == 1 then {1.0,0.0,0.0} else if sequence[2] == 2 then {0.0,1.0,0.0} else {0.0,0.0,1.0};
//   e3_1 := {R.T[sequence[3],1],R.T[sequence[3],2],R.T[sequence[3],3]};
//   e3_2 := if sequence[3] == 1 then {1.0,0.0,0.0} else if sequence[3] == 2 then {0.0,1.0,0.0} else {0.0,0.0,1.0};
//   A := e2_1a[1] * e3_1[1] + e2_1a[2] * e3_1[2] + e2_1a[3] * e3_1[3];
//   B := (e1_1[2] * e2_1a[3] - e1_1[3] * e2_1a[2]) * e3_1[1] + (e1_1[3] * e2_1a[1] - e1_1[1] * e2_1a[3]) * e3_1[2] + (e1_1[1] * e2_1a[2] - e1_1[2] * e2_1a[1]) * e3_1[3];
//   if abs(A) <= 1e-12 and abs(B) <= 1e-12 then
//     angles[1] := guessAngle1;
//   else
//     angle_1a := atan2(A,-B);
//     angle_1b := atan2(-A,B);
//     angles[1] := if abs(angle_1a - guessAngle1) <= abs(angle_1b - guessAngle1) then angle_1a else angle_1b;
//   end if;
//   T_1a := Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.planarRotation({e1_1[1],e1_1[2],e1_1[3]},angles[1]);
//   angles[2] := Modelica.Mechanics.MultiBody.Frames.planarRotationAngle({e2_1a[1],e2_1a[2],e2_1a[3]},Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2(<matrix>[T_1a[1,1],T_1a[1,2],T_1a[1,3];T_1a[2,1],T_1a[2,2],T_1a[2,3];T_1a[3,1],T_1a[3,2],T_1a[3,3]],{e3_1[1],e3_1[2],e3_1[3]}),{e3_2[1],e3_2[2],e3_2[3]});
//   angles[3] := Modelica.Mechanics.MultiBody.Frames.planarRotationAngle({e3_2[1],e3_2[2],e3_2[3]},{e2_1a[1],e2_1a[2],e2_1a[3]},Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2(<matrix>[R.T[1,1],R.T[1,2],R.T[1,3];R.T[2,1],R.T[2,2],R.T[2,3];R.T[3,1],R.T[3,2],R.T[3,3]],Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1(<matrix>[T_1a[1,1],T_1a[1,2],T_1a[1,3];T_1a[2,1],T_1a[2,2],T_1a[2,3];T_1a[3,1],T_1a[3,2],T_1a[3,3]],{e2_1a[1],e2_1a[2],e2_1a[3]})));
// end Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles;
// 
// function Modelica.Mechanics.MultiBody.Frames.axis \"Inline before index reduction\" \"Return unit vector for x-, y-, or z-axis\"
//   input Integer axis(min = 1, max = 3) \"Axis vector to be returned\";
//   output Real[3] e(unit = \"1\") \"Unit axis vector\";
// algorithm
//   e := if axis == 1 then {1.0,0.0,0.0} else if axis == 2 then {0.0,1.0,0.0} else {0.0,0.0,1.0};
// end Modelica.Mechanics.MultiBody.Frames.axis;
// 
// function Modelica.Mechanics.MultiBody.Frames.from_Q \"Inline before index reduction\" \"Return orientation object R from quaternion orientation object Q\"
//   input Real[4] Q \"Quaternions orientation object to rotate frame 1 into frame 2\";
//   input Real[3] w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity from frame 2 with respect to frame 1, resolved in frame 2\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[2.0 * Q[1] ^ 2.0 + 2.0 * Q[4] ^ 2.0 + -1.0,2.0 * Q[1] * Q[2] + 2.0 * Q[3] * Q[4],2.0 * Q[1] * Q[3] + -2.0 * Q[2] * Q[4];2.0 * Q[2] * Q[1] + -2.0 * Q[3] * Q[4],2.0 * Q[2] ^ 2.0 + 2.0 * Q[4] ^ 2.0 + -1.0,2.0 * Q[2] * Q[3] + 2.0 * Q[1] * Q[4];2.0 * Q[3] * Q[1] + 2.0 * Q[2] * Q[4],2.0 * Q[3] * Q[2] + -2.0 * Q[1] * Q[4],2.0 * Q[3] ^ 2.0 + 2.0 * Q[4] ^ 2.0 + -1.0],{w[1],w[2],w[3]});
// end Modelica.Mechanics.MultiBody.Frames.from_Q;
// 
// function Modelica.Mechanics.MultiBody.Frames.nullRotation \"Inline before index reduction\" \"Return orientation object that does not rotate a frame\"
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object such that frame 1 and frame 2 are identical\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[1.0,0.0,0.0;0.0,1.0,0.0;0.0,0.0,1.0],{0.0,0.0,0.0});
// end Modelica.Mechanics.MultiBody.Frames.nullRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.planarRotation \"Inline before index reduction\" \"Return orientation object of a planar rotation\"
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation (must have length=1)\";
//   input Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e\";
//   input Real der_angle(quantity = \"AngularVelocity\", unit = \"rad/s\") \"= der(angle)\";
//   output Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
// algorithm
//   R := Modelica.Mechanics.MultiBody.Frames.Orientation(<matrix>[e[1] * e[1] + cos(angle) * (1.0 - e[1] * e[1]),(e[1] * e[2] + cos(angle) * -e[1] * e[2]) - -sin(angle) * e[3],(e[1] * e[3] + cos(angle) * -e[1] * e[3]) - sin(angle) * e[2];(e[2] * e[1] + cos(angle) * -e[2] * e[1]) - sin(angle) * e[3],e[2] * e[2] + cos(angle) * (1.0 - e[2] * e[2]),(e[2] * e[3] + cos(angle) * -e[2] * e[3]) - -sin(angle) * e[1];(e[3] * e[1] + cos(angle) * -e[3] * e[1]) - -sin(angle) * e[2],(e[3] * e[2] + cos(angle) * -e[3] * e[2]) - sin(angle) * e[1],e[3] * e[3] + cos(angle) * (1.0 - e[3] * e[3])],{der_angle * e[1],der_angle * e[2],der_angle * e[3]});
// end Modelica.Mechanics.MultiBody.Frames.planarRotation;
// 
// function Modelica.Mechanics.MultiBody.Frames.planarRotationAngle \"Inline before index reduction\" \"Return angle of a planar rotation, given the rotation axis and the representations of a vector in frame 1 and frame 2\"
//   input Real[3] e(unit = \"1\") \"Normalized axis of rotation to rotate frame 1 around e into frame 2 (must have length=1)\";
//   input Real[3] v1 \"A vector v resolved in frame 1 (shall not be parallel to e)\";
//   input Real[3] v2 \"Vector v resolved in frame 2, i.e., v2 = resolve2(planarRotation(e,angle),v1)\";
//   output Real angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Rotation angle to rotate frame 1 into frame 2 along axis e in the range: -pi <= angle <= pi\";
// algorithm
//   angle := atan2((e[3] * v1[2] - e[2] * v1[3]) * v2[1] + (e[1] * v1[3] - e[3] * v1[1]) * v2[2] + (e[2] * v1[1] - e[1] * v1[2]) * v2[3],v1[1] * v2[1] + v1[2] * v2[2] + v1[3] * v2[3] - (e[1] * v1[1] + e[2] * v1[2] + e[3] * v1[3]) * (e[1] * v2[1] + e[2] * v2[2] + e[3] * v2[3]));
// end Modelica.Mechanics.MultiBody.Frames.planarRotationAngle;
// 
// function Modelica.Mechanics.MultiBody.Frames.resolve1 \"Inline after index reduction\" \"Transform vector from frame 2 to frame 1\"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v2 \"Vector in frame 2\";
//   output Real[3] v1 \"Vector in frame 1\";
// algorithm
//   v1 := {R.T[1,1] * v2[1] + R.T[2,1] * v2[2] + R.T[3,1] * v2[3],R.T[1,2] * v2[1] + R.T[2,2] * v2[2] + R.T[3,2] * v2[3],R.T[1,3] * v2[1] + R.T[2,3] * v2[2] + R.T[3,3] * v2[3]};
// end Modelica.Mechanics.MultiBody.Frames.resolve1;
// 
// function Modelica.Mechanics.MultiBody.Frames.resolve2 \"Inline after index reduction\" \"Transform vector from frame 1 to frame 2\"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[3] v1 \"Vector in frame 1\";
//   output Real[3] v2 \"Vector in frame 2\";
// algorithm
//   v2 := {R.T[1,1] * v1[1] + R.T[1,2] * v1[2] + R.T[1,3] * v1[3],R.T[2,1] * v1[1] + R.T[2,2] * v1[2] + R.T[2,3] * v1[3],R.T[3,1] * v1[1] + R.T[3,2] * v1[2] + R.T[3,3] * v1[3]};
// end Modelica.Mechanics.MultiBody.Frames.resolve2;
// 
// function Modelica.Mechanics.MultiBody.Frames.to_Q \"Inline before index reduction\" \"Return quaternion orientation object Q from orientation object R\"
//   input Modelica.Mechanics.MultiBody.Frames.Orientation R \"Orientation object to rotate frame 1 into frame 2\";
//   input Real[4] Q_guess = {0.0,0.0,0.0,1.0} \"Guess value for output Q (there are 2 solutions; the one closer to Q_guess is used\";
//   output Real[4] Q \"Quaternions orientation object to rotate frame 1 into frame 2\";
// algorithm
//   Q := Modelica.Mechanics.MultiBody.Frames.Quaternions.from_T(<matrix>[R.T[1,1],R.T[1,2],R.T[1,3];R.T[2,1],R.T[2,2],R.T[2,3];R.T[3,1],R.T[3,2],R.T[3,3]],{Q_guess[1],Q_guess[2],Q_guess[3],Q_guess[4]});
// end Modelica.Mechanics.MultiBody.Frames.to_Q;
// 
// function Modelica.Mechanics.MultiBody.Parts.Body.world__gravityAcceleration \"Gravity field acceleration depending on field type and position\"
//   input Real[3] r(quantity = \"Length\", unit = \"m\") \"Position vector from world frame to actual point, resolved in world frame\";
//   input enumeration(NoGravity, UniformGravity, PointGravity) gravityType \"Type of gravity field\";
//   input Real[3] g(quantity = \"Acceleration\", unit = \"m/s2\") \"Constant gravity acceleration, resolved in world frame, if gravityType=1\";
//   input Real mue(unit = \"m3/s2\") \"Field constant of point gravity field, if gravityType=2\";
//   output Real[3] gravity(quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration at point r, resolved in world frame\";
// algorithm
//   gravity := if gravityType == Modelica.Mechanics.MultiBody.Types.GravityTypes.UniformGravity then {g[1],g[2],g[3]} else if gravityType == Modelica.Mechanics.MultiBody.Types.GravityTypes.PointGravity then -{(r[1] * mue) / (r[1] ^ 2.0 + r[2] ^ 2.0 + r[3] ^ 2.0 * Modelica.Math.Vectors.length({r[1],r[2],r[3]})),(r[2] * mue) / (r[1] ^ 2.0 + r[2] ^ 2.0 + r[3] ^ 2.0 * Modelica.Math.Vectors.length({r[1],r[2],r[3]})),(r[3] * mue) / (r[1] ^ 2.0 + r[2] ^ 2.0 + r[3] ^ 2.0 * Modelica.Math.Vectors.length({r[1],r[2],r[3]}))} else {0.0,0.0,0.0};
// end Modelica.Mechanics.MultiBody.Parts.Body.world__gravityAcceleration;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial \"Inline before index reduction\"
//   input Real c1;
//   input Real c2;
//   input Real c3;
//   input Real sc;
//   output Real m;
//   protected Real cc1;
//   protected Real cc2;
//   protected Real cc3;
//   protected Real cc4;
//   protected Real csc;
//   protected Real yc1;
//   protected Real yc2;
//   protected Real yc3;
//   protected Real ysc;
// algorithm
//   cc1 := if c1 > 1.0 then 1.0 else if c1 < 0.005 then 0.01 else c1;
//   yc1 := /*REAL*/(100000 * integer(mod(-0.5 + 100.0 * cc1,100.0)));
//   cc2 := if c2 > 1.0 then 1.0 else if c2 < 0.005 then 0.01 else c2;
//   yc2 := /*REAL*/(1000 * integer(mod(-0.5 + 100.0 * cc2,100.0)));
//   cc3 := if c3 > 1.0 then 1.0 else if c3 < 0.005 then 0.01 else c3;
//   yc3 := /*REAL*/(10 * integer(mod(-0.5 + 100.0 * cc3,100.0)));
//   csc := if sc > 1.0 then 1.0 else if sc < 0.05 then 0.1 else sc;
//   ysc := /*REAL*/(integer(mod(-0.5 + 10.0 * csc,10.0)));
//   m := yc1 + yc2 + yc3 + ysc;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial;
// 
// function Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape \"Inline before index reduction\"
//   input String shapeType;
//   output Real pack;
// algorithm
//   pack := if shapeType == \"box\" then 101.0 else if shapeType == \"sphere\" then 102.0 else if shapeType == \"cylinder\" then 103.0 else if shapeType == \"pipecylinder\" then 110.0 else if shapeType == \"cone\" then 104.0 else if shapeType == \"pipe\" then 105.0 else if shapeType == \"beam\" then 106.0 else if shapeType == \"gearwheel\" then 108.0 else if shapeType == \"spring\" then 111.0 else 1.2;
// end Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape;
// 
// function Modelica.SIunits.Conversions.from_deg \"Convert from degree to radian\"
//   input Real degree(quantity = \"Angle\", unit = \"deg\") \"degree value\";
//   output Real radian(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"radian value\";
// algorithm
//   radian := 0.0174532925199433 * degree;
// end Modelica.SIunits.Conversions.from_deg;
// 
// class Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.fullRobot
//   parameter Real mLoad(quantity = \"Mass\", unit = \"kg\", min = 0.0) = 15.0 \"Mass of load\";
//   parameter Real rLoad[1](quantity = \"Length\", unit = \"m\") = 0.1 \"Distance from last flange to load mass\";
//   parameter Real rLoad[2](quantity = \"Length\", unit = \"m\") = 0.25 \"Distance from last flange to load mass\";
//   parameter Real rLoad[3](quantity = \"Length\", unit = \"m\") = 0.1 \"Distance from last flange to load mass\";
//   parameter Real g(quantity = \"Acceleration\", unit = \"m/s2\") = 9.81 \"Gravity acceleration\";
//   parameter Real refStartTime(quantity = \"Time\", unit = \"s\") = 0.0 \"Start time of reference motion\";
//   parameter Real refSwingTime(quantity = \"Time\", unit = \"s\") = 0.5 \"Additional time after reference motion is in rest before simulation is stopped\";
//   parameter Real startAngle1(unit = \"deg\") = -60.0 \"Start angle of axis 1\";
//   parameter Real startAngle2(unit = \"deg\") = 20.0 \"Start angle of axis 2\";
//   parameter Real startAngle3(unit = \"deg\") = 90.0 \"Start angle of axis 3\";
//   parameter Real startAngle4(unit = \"deg\") = 0.0 \"Start angle of axis 4\";
//   parameter Real startAngle5(unit = \"deg\") = -110.0 \"Start angle of axis 5\";
//   parameter Real startAngle6(unit = \"deg\") = 0.0 \"Start angle of axis 6\";
//   parameter Real endAngle1(unit = \"deg\") = 60.0 \"End angle of axis 1\";
//   parameter Real endAngle2(unit = \"deg\") = -70.0 \"End angle of axis 2\";
//   parameter Real endAngle3(unit = \"deg\") = -35.0 \"End angle of axis 3\";
//   parameter Real endAngle4(unit = \"deg\") = 45.0 \"End angle of axis 4\";
//   parameter Real endAngle5(unit = \"deg\") = 110.0 \"End angle of axis 5\";
//   parameter Real endAngle6(unit = \"deg\") = 45.0 \"End angle of axis 6\";
//   parameter Real refSpeedMax[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 3.0 \"Maximum reference speeds of all joints\";
//   parameter Real refSpeedMax[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 1.5 \"Maximum reference speeds of all joints\";
//   parameter Real refSpeedMax[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 5.0 \"Maximum reference speeds of all joints\";
//   parameter Real refSpeedMax[4](quantity = \"AngularVelocity\", unit = \"rad/s\") = 3.1 \"Maximum reference speeds of all joints\";
//   parameter Real refSpeedMax[5](quantity = \"AngularVelocity\", unit = \"rad/s\") = 3.1 \"Maximum reference speeds of all joints\";
//   parameter Real refSpeedMax[6](quantity = \"AngularVelocity\", unit = \"rad/s\") = 4.1 \"Maximum reference speeds of all joints\";
//   parameter Real refAccMax[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 15.0 \"Maximum reference accelerations of all joints\";
//   parameter Real refAccMax[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 15.0 \"Maximum reference accelerations of all joints\";
//   parameter Real refAccMax[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 15.0 \"Maximum reference accelerations of all joints\";
//   parameter Real refAccMax[4](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 60.0 \"Maximum reference accelerations of all joints\";
//   parameter Real refAccMax[5](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 60.0 \"Maximum reference accelerations of all joints\";
//   parameter Real refAccMax[6](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 60.0 \"Maximum reference accelerations of all joints\";
//   parameter Real kp1 = 5.0 \"Gain of position controller\";
//   parameter Real ks1 = 0.5 \"Gain of speed controller\";
//   parameter Real Ts1(quantity = \"Time\", unit = \"s\") = 0.05 \"Time constant of integrator of speed controller\";
//   parameter Real kp2 = 5.0 \"Gain of position controller\";
//   parameter Real ks2 = 0.5 \"Gain of speed controller\";
//   parameter Real Ts2(quantity = \"Time\", unit = \"s\") = 0.05 \"Time constant of integrator of speed controller\";
//   parameter Real kp3 = 5.0 \"Gain of position controller\";
//   parameter Real ks3 = 0.5 \"Gain of speed controller\";
//   parameter Real Ts3(quantity = \"Time\", unit = \"s\") = 0.05 \"Time constant of integrator of speed controller\";
//   parameter Real kp4 = 5.0 \"Gain of position controller\";
//   parameter Real ks4 = 0.5 \"Gain of speed controller\";
//   parameter Real Ts4(quantity = \"Time\", unit = \"s\") = 0.05 \"Time constant of integrator of speed controller\";
//   parameter Real kp5 = 5.0 \"Gain of position controller\";
//   parameter Real ks5 = 0.5 \"Gain of speed controller\";
//   parameter Real Ts5(quantity = \"Time\", unit = \"s\") = 0.05 \"Time constant of integrator of speed controller\";
//   parameter Real kp6 = 5.0 \"Gain of position controller\";
//   parameter Real ks6 = 0.5 \"Gain of speed controller\";
//   parameter Real Ts6(quantity = \"Time\", unit = \"s\") = 0.05 \"Time constant of integrator of speed controller\";
//   Real mechanics.world.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.world.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.world.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.world.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.world.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.world.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.world.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.world.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.world.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.world.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.world.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.world.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.world.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.world.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.world.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.world.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.world.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.world.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.world.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.world.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.world.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean mechanics.world.enableAnimation = mechanics.animation \"= true, if animation of all components is enabled\";
//   parameter Boolean mechanics.world.animateWorld = false \"= true, if world coordinate system shall be visualized\";
//   parameter Boolean mechanics.world.animateGravity = false \"= true, if gravity field shall be visualized (acceleration vector or field center)\";
//   parameter String mechanics.world.label1 = \"x\" \"Label of horizontal axis in icon\";
//   parameter String mechanics.world.label2 = \"y\" \"Label of vertical axis in icon\";
//   parameter enumeration(NoGravity, UniformGravity, PointGravity) mechanics.world.gravityType = Modelica.Mechanics.MultiBody.Types.GravityTypes.UniformGravity \"Type of gravity field\";
//   parameter Real mechanics.world.g(quantity = \"Acceleration\", unit = \"m/s2\") = mechanics.g * Modelica.Math.Vectors.length({0.0,-1.0,0.0}) \"Constant gravity acceleration\";
//   parameter Real mechanics.world.n[1](unit = \"1\") = 0.0 \"Direction of gravity resolved in world frame (gravity = g*n/length(n))\";
//   parameter Real mechanics.world.n[2](unit = \"1\") = -1.0 \"Direction of gravity resolved in world frame (gravity = g*n/length(n))\";
//   parameter Real mechanics.world.n[3](unit = \"1\") = 0.0 \"Direction of gravity resolved in world frame (gravity = g*n/length(n))\";
//   parameter Real mechanics.world.mue(unit = \"m3/s2\", min = 0.0) = 398600000000000.0 \"Gravity field constant (default = field constant of earth)\";
//   parameter Boolean mechanics.world.driveTrainMechanics3D = true \"= true, if 3-dim. mechanical effects of Parts.Mounting1D/Rotor1D/BevelGear1D shall be taken into account\";
//   parameter Boolean mechanics.world.axisShowLabels = true \"= true, if labels shall be shown\";
//   input Integer mechanics.world.axisColor_x[1](min = 0, max = 255) = 0 \"Color of x-arrow\";
//   input Integer mechanics.world.axisColor_x[2](min = 0, max = 255) = 0 \"Color of x-arrow\";
//   input Integer mechanics.world.axisColor_x[3](min = 0, max = 255) = 0 \"Color of x-arrow\";
//   input Integer mechanics.world.axisColor_y[1](min = 0, max = 255) = mechanics.world.axisColor_x[1];
//   input Integer mechanics.world.axisColor_y[2](min = 0, max = 255) = mechanics.world.axisColor_x[2];
//   input Integer mechanics.world.axisColor_y[3](min = 0, max = 255) = mechanics.world.axisColor_x[3];
//   input Integer mechanics.world.axisColor_z[1](min = 0, max = 255) = mechanics.world.axisColor_x[1] \"Color of z-arrow\";
//   input Integer mechanics.world.axisColor_z[2](min = 0, max = 255) = mechanics.world.axisColor_x[2] \"Color of z-arrow\";
//   input Integer mechanics.world.axisColor_z[3](min = 0, max = 255) = mechanics.world.axisColor_x[3] \"Color of z-arrow\";
//   parameter Real mechanics.world.gravityArrowTail[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to arrow tail, resolved in world frame\";
//   parameter Real mechanics.world.gravityArrowTail[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to arrow tail, resolved in world frame\";
//   parameter Real mechanics.world.gravityArrowTail[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Position vector from origin of world frame to arrow tail, resolved in world frame\";
//   input Integer mechanics.world.gravityArrowColor[1](min = 0, max = 255) = 0 \"Color of gravity arrow\";
//   input Integer mechanics.world.gravityArrowColor[2](min = 0, max = 255) = 230 \"Color of gravity arrow\";
//   input Integer mechanics.world.gravityArrowColor[3](min = 0, max = 255) = 0 \"Color of gravity arrow\";
//   parameter Real mechanics.world.gravitySphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 12742000.0 \"Diameter of sphere representing gravity center (default = mean diameter of earth)\";
//   input Integer mechanics.world.gravitySphereColor[1](min = 0, max = 255) = 0 \"Color of gravity sphere\";
//   input Integer mechanics.world.gravitySphereColor[2](min = 0, max = 255) = 230 \"Color of gravity sphere\";
//   input Integer mechanics.world.gravitySphereColor[3](min = 0, max = 255) = 0 \"Color of gravity sphere\";
//   parameter Real mechanics.world.nominalLength(quantity = \"Length\", unit = \"m\") = 1.0 \"\\\"Nominal\\\" length of multi-body system\";
//   parameter Real mechanics.world.defaultWidthFraction = 20.0 \"Default for shape width as a fraction of shape length (e.g., for Parts.FixedTranslation)\";
//   parameter Real mechanics.world.defaultFrameDiameterFraction = 40.0 \"Default for arrow diameter of a coordinate system as a fraction of axis length\";
//   parameter Real mechanics.world.defaultSpecularCoefficient(min = 0.0) = 0.7 \"Default reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Real mechanics.world.defaultN_to_m(unit = \"N/m\", min = 0.0) = 1000.0 \"Default scaling of force arrows (length = force/defaultN_to_m)\";
//   parameter Real mechanics.world.defaultNm_to_m(unit = \"N.m/m\", min = 0.0) = 1000.0 \"Default scaling of torque arrows (length = torque/defaultNm_to_m)\";
//   protected parameter Integer mechanics.world.ndim = if mechanics.world.enableAnimation and mechanics.world.animateWorld then 1 else 0;
//   protected parameter Integer mechanics.world.ndim_pointGravity = if mechanics.world.enableAnimation and mechanics.world.animateGravity and mechanics.world.gravityType == Modelica.Mechanics.MultiBody.Types.GravityTypes.UniformGravity then 1 else 0;
//   protected parameter Integer mechanics.world.ndim2 = if mechanics.world.enableAnimation and mechanics.world.animateWorld and mechanics.world.axisShowLabels then 1 else 0;
//   parameter Real mechanics.world.axisLength(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.world.nominalLength / 2.0 \"Length of world axes arrows\";
//   parameter Real mechanics.world.defaultAxisLength(quantity = \"Length\", unit = \"m\") = mechanics.world.nominalLength / 5.0 \"Default for length of a frame axis (but not world frame)\";
//   parameter Real mechanics.world.defaultJointLength(quantity = \"Length\", unit = \"m\") = mechanics.world.nominalLength / 10.0 \"Default for the fixed length of a shape representing a joint\";
//   parameter Real mechanics.world.defaultJointWidth(quantity = \"Length\", unit = \"m\") = mechanics.world.nominalLength / 20.0 \"Default for the fixed width of a shape representing a joint\";
//   parameter Real mechanics.world.defaultForceLength(quantity = \"Length\", unit = \"m\") = mechanics.world.nominalLength / 10.0 \"Default for the fixed length of a shape representing a force (e.g. damper)\";
//   parameter Real mechanics.world.defaultForceWidth(quantity = \"Length\", unit = \"m\") = mechanics.world.nominalLength / 20.0 \"Default for the fixed width of a shape represening a force (e.g. spring, bushing)\";
//   parameter Real mechanics.world.defaultBodyDiameter(quantity = \"Length\", unit = \"m\") = mechanics.world.nominalLength / 9.0 \"Default for diameter of sphere representing the center of mass of a body\";
//   parameter Real mechanics.world.defaultArrowDiameter(quantity = \"Length\", unit = \"m\") = mechanics.world.nominalLength / 40.0 \"Default for arrow diameter (e.g., of forces, torques, sensors)\";
//   parameter Real mechanics.world.axisDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.world.axisLength / mechanics.world.defaultFrameDiameterFraction \"Diameter of world axes arrows\";
//   parameter Real mechanics.world.gravityArrowLength(quantity = \"Length\", unit = \"m\") = mechanics.world.axisLength / 2.0 \"Length of gravity arrow\";
//   protected parameter Real mechanics.world.labelStart(quantity = \"Length\", unit = \"m\") = 1.05 * mechanics.world.axisLength;
//   protected parameter Real mechanics.world.headLength(quantity = \"Length\", unit = \"m\") = min(mechanics.world.axisLength,5.0 * mechanics.world.axisDiameter);
//   protected parameter Real mechanics.world.headWidth(quantity = \"Length\", unit = \"m\") = 3.0 * mechanics.world.axisDiameter;
//   protected parameter Real mechanics.world.lineWidth(quantity = \"Length\", unit = \"m\") = mechanics.world.axisDiameter;
//   protected parameter Real mechanics.world.scaledLabel(quantity = \"Length\", unit = \"m\") = 3.0 * mechanics.world.axisDiameter;
//   parameter Real mechanics.world.gravityArrowDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.world.gravityArrowLength / mechanics.world.defaultWidthFraction \"Diameter of gravity arrow\";
//   protected parameter Real mechanics.world.lineLength(quantity = \"Length\", unit = \"m\") = max(0.0,mechanics.world.axisLength - mechanics.world.headLength);
//   protected parameter Real mechanics.world.gravityHeadLength(quantity = \"Length\", unit = \"m\") = min(mechanics.world.gravityArrowLength,4.0 * mechanics.world.gravityArrowDiameter);
//   protected parameter Real mechanics.world.gravityHeadWidth(quantity = \"Length\", unit = \"m\") = 3.0 * mechanics.world.gravityArrowDiameter;
//   protected parameter Real mechanics.world.gravityLineLength(quantity = \"Length\", unit = \"m\") = max(0.0,mechanics.world.gravityArrowLength - mechanics.world.gravityHeadLength);
//   parameter Boolean mechanics.animation = true \"= true, if animation shall be enabled\";
//   parameter Real mechanics.mLoad(quantity = \"Mass\", unit = \"kg\", min = 0.0) = mLoad \"Mass of load\";
//   parameter Real mechanics.rLoad[1](quantity = \"Length\", unit = \"m\") = rLoad[1] \"Distance from last flange to load mass>\";
//   parameter Real mechanics.rLoad[2](quantity = \"Length\", unit = \"m\") = rLoad[2] \"Distance from last flange to load mass>\";
//   parameter Real mechanics.rLoad[3](quantity = \"Length\", unit = \"m\") = rLoad[3] \"Distance from last flange to load mass>\";
//   parameter Real mechanics.g(quantity = \"Acceleration\", unit = \"m/s2\") = g \"Gravity acceleration\";
//   Real mechanics.q[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Joint angles\";
//   Real mechanics.q[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Joint angles\";
//   Real mechanics.q[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Joint angles\";
//   Real mechanics.q[4](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Joint angles\";
//   Real mechanics.q[5](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Joint angles\";
//   Real mechanics.q[6](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Joint angles\";
//   Real mechanics.qd[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Joint speeds\";
//   Real mechanics.qd[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Joint speeds\";
//   Real mechanics.qd[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Joint speeds\";
//   Real mechanics.qd[4](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Joint speeds\";
//   Real mechanics.qd[5](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Joint speeds\";
//   Real mechanics.qd[6](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Joint speeds\";
//   Real mechanics.qdd[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Joint accelerations\";
//   Real mechanics.qdd[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Joint accelerations\";
//   Real mechanics.qdd[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Joint accelerations\";
//   Real mechanics.qdd[4](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Joint accelerations\";
//   Real mechanics.qdd[5](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Joint accelerations\";
//   Real mechanics.qdd[6](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Joint accelerations\";
//   Real mechanics.tau[1](quantity = \"Torque\", unit = \"N.m\") \"Joint driving torques\";
//   Real mechanics.tau[2](quantity = \"Torque\", unit = \"N.m\") \"Joint driving torques\";
//   Real mechanics.tau[3](quantity = \"Torque\", unit = \"N.m\") \"Joint driving torques\";
//   Real mechanics.tau[4](quantity = \"Torque\", unit = \"N.m\") \"Joint driving torques\";
//   Real mechanics.tau[5](quantity = \"Torque\", unit = \"N.m\") \"Joint driving torques\";
//   Real mechanics.tau[6](quantity = \"Torque\", unit = \"N.m\") \"Joint driving torques\";
//   Real mechanics.axis1.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real mechanics.axis1.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real mechanics.axis2.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real mechanics.axis2.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real mechanics.axis3.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real mechanics.axis3.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real mechanics.axis4.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real mechanics.axis4.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real mechanics.axis5.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real mechanics.axis5.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real mechanics.axis6.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real mechanics.axis6.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real mechanics.r1.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r1.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r1.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r1.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r1.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r1.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r1.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r1.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r1.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r1.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r1.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r1.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r1.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r1.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r1.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r1.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r1.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r1.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r1.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.r1.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.r1.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.r1.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r1.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r1.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r1.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r1.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r1.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r1.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r1.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r1.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r1.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r1.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r1.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r1.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r1.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r1.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r1.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r1.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r1.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r1.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.r1.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.r1.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean mechanics.r1.useAxisFlange = true \"= true, if axis flange is enabled\";
//   parameter Boolean mechanics.r1.animation = mechanics.animation \"= true, if animation shall be enabled (show axis as cylinder)\";
//   parameter Real mechanics.r1.n[1](unit = \"1\") = 0.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real mechanics.r1.n[2](unit = \"1\") = 1.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real mechanics.r1.n[3](unit = \"1\") = 0.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   constant Real mechanics.r1.phi_offset(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Relative angle offset (angle = phi_offset + phi)\";
//   parameter Real mechanics.r1.cylinderLength(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.world.defaultJointLength \"Length of cylinder representing the joint axis\";
//   parameter Real mechanics.r1.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.world.defaultJointWidth \"Diameter of cylinder representing the joint axis\";
//   input Integer mechanics.r1.cylinderColor[1](min = 0, max = 255) = 255 \"Color of cylinder representing the joint axis\";
//   input Integer mechanics.r1.cylinderColor[2](min = 0, max = 255) = 0 \"Color of cylinder representing the joint axis\";
//   input Integer mechanics.r1.cylinderColor[3](min = 0, max = 255) = 0 \"Color of cylinder representing the joint axis\";
//   input Real mechanics.r1.specularCoefficient = mechanics.world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter enumeration(never, avoid, default, prefer, always) mechanics.r1.stateSelect = StateSelect.prefer \"Priority to use joint angle phi and w=der(phi) as states\";
//   Real mechanics.r1.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, StateSelect = StateSelect.prefer) \"Relative rotation angle from frame_a to frame_b\";
//   Real mechanics.r1.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, StateSelect = StateSelect.prefer) \"First derivative of angle phi (relative angular velocity)\";
//   Real mechanics.r1.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = 0.0) \"Second derivative of angle phi (relative angular acceleration)\";
//   Real mechanics.r1.tau(quantity = \"Torque\", unit = \"N.m\") \"Driving torque in direction of axis of rotation\";
//   Real mechanics.r1.angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"= phi_offset + phi\";
//   Real mechanics.r1.R_rel.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r1.R_rel.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r1.R_rel.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r1.R_rel.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r1.R_rel.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r1.R_rel.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r1.R_rel.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r1.R_rel.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r1.R_rel.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r1.R_rel.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r1.R_rel.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r1.R_rel.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real mechanics.r1.fixed.phi0(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Fixed offset angle of housing\";
//   Real mechanics.r1.fixed.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real mechanics.r1.fixed.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real mechanics.r1.internalAxis.tau(quantity = \"Torque\", unit = \"N.m\") = mechanics.r1.tau \"External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau)\";
//   Real mechanics.r1.internalAxis.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"External support angle (= flange.phi)\";
//   Real mechanics.r1.internalAxis.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real mechanics.r1.internalAxis.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real mechanics.r1.axis.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real mechanics.r1.axis.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real mechanics.r1.support.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real mechanics.r1.support.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter String mechanics.r1.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real mechanics.r1.cylinder.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r1.cylinder.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r1.cylinder.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r1.cylinder.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r1.cylinder.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r1.cylinder.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r1.cylinder.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r1.cylinder.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r1.cylinder.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r1.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.r1.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.r1.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.r1.cylinder.r[1](quantity = \"Length\", unit = \"m\") = mechanics.r1.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.r1.cylinder.r[2](quantity = \"Length\", unit = \"m\") = mechanics.r1.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.r1.cylinder.r[3](quantity = \"Length\", unit = \"m\") = mechanics.r1.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.r1.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = ((-mechanics.r1.e[1]) * mechanics.r1.cylinderLength) / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.r1.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = ((-mechanics.r1.e[2]) * mechanics.r1.cylinderLength) / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.r1.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = ((-mechanics.r1.e[3]) * mechanics.r1.cylinderLength) / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.r1.cylinder.lengthDirection[1](unit = \"1\") = mechanics.r1.e[1] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.r1.cylinder.lengthDirection[2](unit = \"1\") = mechanics.r1.e[2] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.r1.cylinder.lengthDirection[3](unit = \"1\") = mechanics.r1.e[3] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.r1.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.r1.cylinder.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.r1.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.r1.cylinder.length(quantity = \"Length\", unit = \"m\") = mechanics.r1.cylinderLength \"Length of visual object\";
//   input Real mechanics.r1.cylinder.width(quantity = \"Length\", unit = \"m\") = mechanics.r1.cylinderDiameter \"Width of visual object\";
//   input Real mechanics.r1.cylinder.height(quantity = \"Length\", unit = \"m\") = mechanics.r1.cylinderDiameter \"Height of visual object\";
//   input Real mechanics.r1.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real mechanics.r1.cylinder.color[1] = Real(mechanics.r1.cylinderColor[1]) \"Color of shape\";
//   input Real mechanics.r1.cylinder.color[2] = Real(mechanics.r1.cylinderColor[2]) \"Color of shape\";
//   input Real mechanics.r1.cylinder.color[3] = Real(mechanics.r1.cylinderColor[3]) \"Color of shape\";
//   input Real mechanics.r1.cylinder.specularCoefficient = mechanics.r1.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real mechanics.r1.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({mechanics.r1.cylinder.lengthDirection[1],mechanics.r1.cylinder.lengthDirection[2],mechanics.r1.cylinder.lengthDirection[3]});
//   protected Real mechanics.r1.cylinder.e_x[1](unit = \"1\") = if noEvent(mechanics.r1.cylinder.abs_n_x < 1e-10) then 1.0 else mechanics.r1.cylinder.lengthDirection[1] / mechanics.r1.cylinder.abs_n_x;
//   protected Real mechanics.r1.cylinder.e_x[2](unit = \"1\") = if noEvent(mechanics.r1.cylinder.abs_n_x < 1e-10) then 0.0 else mechanics.r1.cylinder.lengthDirection[2] / mechanics.r1.cylinder.abs_n_x;
//   protected Real mechanics.r1.cylinder.e_x[3](unit = \"1\") = if noEvent(mechanics.r1.cylinder.abs_n_x < 1e-10) then 0.0 else mechanics.r1.cylinder.lengthDirection[3] / mechanics.r1.cylinder.abs_n_x;
//   protected Real mechanics.r1.cylinder.n_z_aux[1](unit = \"1\") = mechanics.r1.cylinder.e_x[2] * mechanics.r1.cylinder.widthDirection[3] - mechanics.r1.cylinder.e_x[3] * mechanics.r1.cylinder.widthDirection[2];
//   protected Real mechanics.r1.cylinder.n_z_aux[2](unit = \"1\") = mechanics.r1.cylinder.e_x[3] * mechanics.r1.cylinder.widthDirection[1] - mechanics.r1.cylinder.e_x[1] * mechanics.r1.cylinder.widthDirection[3];
//   protected Real mechanics.r1.cylinder.n_z_aux[3](unit = \"1\") = mechanics.r1.cylinder.e_x[1] * mechanics.r1.cylinder.widthDirection[2] - mechanics.r1.cylinder.e_x[2] * mechanics.r1.cylinder.widthDirection[1];
//   protected Real mechanics.r1.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.r1.cylinder.e_x[1],mechanics.r1.cylinder.e_x[2],mechanics.r1.cylinder.e_x[3]},if noEvent(mechanics.r1.cylinder.n_z_aux[1] ^ 2.0 + (mechanics.r1.cylinder.n_z_aux[2] ^ 2.0 + mechanics.r1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.r1.cylinder.widthDirection[1],mechanics.r1.cylinder.widthDirection[2],mechanics.r1.cylinder.widthDirection[3]} else if noEvent(abs(mechanics.r1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.r1.cylinder.e_x[1],mechanics.r1.cylinder.e_x[2],mechanics.r1.cylinder.e_x[3]})[1];
//   protected Real mechanics.r1.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.r1.cylinder.e_x[1],mechanics.r1.cylinder.e_x[2],mechanics.r1.cylinder.e_x[3]},if noEvent(mechanics.r1.cylinder.n_z_aux[1] ^ 2.0 + (mechanics.r1.cylinder.n_z_aux[2] ^ 2.0 + mechanics.r1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.r1.cylinder.widthDirection[1],mechanics.r1.cylinder.widthDirection[2],mechanics.r1.cylinder.widthDirection[3]} else if noEvent(abs(mechanics.r1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.r1.cylinder.e_x[1],mechanics.r1.cylinder.e_x[2],mechanics.r1.cylinder.e_x[3]})[2];
//   protected Real mechanics.r1.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.r1.cylinder.e_x[1],mechanics.r1.cylinder.e_x[2],mechanics.r1.cylinder.e_x[3]},if noEvent(mechanics.r1.cylinder.n_z_aux[1] ^ 2.0 + (mechanics.r1.cylinder.n_z_aux[2] ^ 2.0 + mechanics.r1.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.r1.cylinder.widthDirection[1],mechanics.r1.cylinder.widthDirection[2],mechanics.r1.cylinder.widthDirection[3]} else if noEvent(abs(mechanics.r1.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.r1.cylinder.e_x[1],mechanics.r1.cylinder.e_x[2],mechanics.r1.cylinder.e_x[3]})[3];
//   protected output Real mechanics.r1.cylinder.Form;
//   output Real mechanics.r1.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r1.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r1.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r1.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r1.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r1.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r1.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real mechanics.r1.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real mechanics.r1.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real mechanics.r1.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.r1.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.r1.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.r1.cylinder.Material;
//   protected output Real mechanics.r1.cylinder.Extra;
//   protected parameter Real mechanics.r1.e[1](unit = \"1\") = Modelica.Math.Vectors.normalize({mechanics.r1.n[1],mechanics.r1.n[2],mechanics.r1.n[3]},1e-13)[1] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   protected parameter Real mechanics.r1.e[2](unit = \"1\") = Modelica.Math.Vectors.normalize({mechanics.r1.n[1],mechanics.r1.n[2],mechanics.r1.n[3]},1e-13)[2] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   protected parameter Real mechanics.r1.e[3](unit = \"1\") = Modelica.Math.Vectors.normalize({mechanics.r1.n[1],mechanics.r1.n[2],mechanics.r1.n[3]},1e-13)[3] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   Real mechanics.r2.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r2.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r2.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r2.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r2.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r2.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r2.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r2.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r2.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r2.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r2.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r2.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r2.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r2.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r2.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r2.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r2.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r2.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r2.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.r2.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.r2.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.r2.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r2.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r2.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r2.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r2.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r2.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r2.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r2.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r2.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r2.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r2.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r2.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r2.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r2.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r2.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r2.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r2.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r2.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r2.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.r2.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.r2.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean mechanics.r2.useAxisFlange = true \"= true, if axis flange is enabled\";
//   parameter Boolean mechanics.r2.animation = mechanics.animation \"= true, if animation shall be enabled (show axis as cylinder)\";
//   parameter Real mechanics.r2.n[1](unit = \"1\") = 1.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real mechanics.r2.n[2](unit = \"1\") = 0.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real mechanics.r2.n[3](unit = \"1\") = 0.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   constant Real mechanics.r2.phi_offset(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Relative angle offset (angle = phi_offset + phi)\";
//   parameter Real mechanics.r2.cylinderLength(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.world.defaultJointLength \"Length of cylinder representing the joint axis\";
//   parameter Real mechanics.r2.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.world.defaultJointWidth \"Diameter of cylinder representing the joint axis\";
//   input Integer mechanics.r2.cylinderColor[1](min = 0, max = 255) = 255 \"Color of cylinder representing the joint axis\";
//   input Integer mechanics.r2.cylinderColor[2](min = 0, max = 255) = 0 \"Color of cylinder representing the joint axis\";
//   input Integer mechanics.r2.cylinderColor[3](min = 0, max = 255) = 0 \"Color of cylinder representing the joint axis\";
//   input Real mechanics.r2.specularCoefficient = mechanics.world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter enumeration(never, avoid, default, prefer, always) mechanics.r2.stateSelect = StateSelect.prefer \"Priority to use joint angle phi and w=der(phi) as states\";
//   Real mechanics.r2.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, StateSelect = StateSelect.prefer) \"Relative rotation angle from frame_a to frame_b\";
//   Real mechanics.r2.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, StateSelect = StateSelect.prefer) \"First derivative of angle phi (relative angular velocity)\";
//   Real mechanics.r2.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = 0.0) \"Second derivative of angle phi (relative angular acceleration)\";
//   Real mechanics.r2.tau(quantity = \"Torque\", unit = \"N.m\") \"Driving torque in direction of axis of rotation\";
//   Real mechanics.r2.angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"= phi_offset + phi\";
//   Real mechanics.r2.R_rel.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r2.R_rel.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r2.R_rel.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r2.R_rel.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r2.R_rel.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r2.R_rel.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r2.R_rel.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r2.R_rel.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r2.R_rel.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r2.R_rel.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r2.R_rel.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r2.R_rel.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real mechanics.r2.fixed.phi0(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Fixed offset angle of housing\";
//   Real mechanics.r2.fixed.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real mechanics.r2.fixed.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real mechanics.r2.internalAxis.tau(quantity = \"Torque\", unit = \"N.m\") = mechanics.r2.tau \"External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau)\";
//   Real mechanics.r2.internalAxis.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"External support angle (= flange.phi)\";
//   Real mechanics.r2.internalAxis.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real mechanics.r2.internalAxis.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real mechanics.r2.axis.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real mechanics.r2.axis.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real mechanics.r2.support.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real mechanics.r2.support.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter String mechanics.r2.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real mechanics.r2.cylinder.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r2.cylinder.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r2.cylinder.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r2.cylinder.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r2.cylinder.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r2.cylinder.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r2.cylinder.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r2.cylinder.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r2.cylinder.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r2.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.r2.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.r2.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.r2.cylinder.r[1](quantity = \"Length\", unit = \"m\") = mechanics.r2.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.r2.cylinder.r[2](quantity = \"Length\", unit = \"m\") = mechanics.r2.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.r2.cylinder.r[3](quantity = \"Length\", unit = \"m\") = mechanics.r2.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.r2.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = ((-mechanics.r2.e[1]) * mechanics.r2.cylinderLength) / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.r2.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = ((-mechanics.r2.e[2]) * mechanics.r2.cylinderLength) / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.r2.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = ((-mechanics.r2.e[3]) * mechanics.r2.cylinderLength) / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.r2.cylinder.lengthDirection[1](unit = \"1\") = mechanics.r2.e[1] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.r2.cylinder.lengthDirection[2](unit = \"1\") = mechanics.r2.e[2] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.r2.cylinder.lengthDirection[3](unit = \"1\") = mechanics.r2.e[3] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.r2.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.r2.cylinder.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.r2.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.r2.cylinder.length(quantity = \"Length\", unit = \"m\") = mechanics.r2.cylinderLength \"Length of visual object\";
//   input Real mechanics.r2.cylinder.width(quantity = \"Length\", unit = \"m\") = mechanics.r2.cylinderDiameter \"Width of visual object\";
//   input Real mechanics.r2.cylinder.height(quantity = \"Length\", unit = \"m\") = mechanics.r2.cylinderDiameter \"Height of visual object\";
//   input Real mechanics.r2.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real mechanics.r2.cylinder.color[1] = Real(mechanics.r2.cylinderColor[1]) \"Color of shape\";
//   input Real mechanics.r2.cylinder.color[2] = Real(mechanics.r2.cylinderColor[2]) \"Color of shape\";
//   input Real mechanics.r2.cylinder.color[3] = Real(mechanics.r2.cylinderColor[3]) \"Color of shape\";
//   input Real mechanics.r2.cylinder.specularCoefficient = mechanics.r2.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real mechanics.r2.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({mechanics.r2.cylinder.lengthDirection[1],mechanics.r2.cylinder.lengthDirection[2],mechanics.r2.cylinder.lengthDirection[3]});
//   protected Real mechanics.r2.cylinder.e_x[1](unit = \"1\") = if noEvent(mechanics.r2.cylinder.abs_n_x < 1e-10) then 1.0 else mechanics.r2.cylinder.lengthDirection[1] / mechanics.r2.cylinder.abs_n_x;
//   protected Real mechanics.r2.cylinder.e_x[2](unit = \"1\") = if noEvent(mechanics.r2.cylinder.abs_n_x < 1e-10) then 0.0 else mechanics.r2.cylinder.lengthDirection[2] / mechanics.r2.cylinder.abs_n_x;
//   protected Real mechanics.r2.cylinder.e_x[3](unit = \"1\") = if noEvent(mechanics.r2.cylinder.abs_n_x < 1e-10) then 0.0 else mechanics.r2.cylinder.lengthDirection[3] / mechanics.r2.cylinder.abs_n_x;
//   protected Real mechanics.r2.cylinder.n_z_aux[1](unit = \"1\") = mechanics.r2.cylinder.e_x[2] * mechanics.r2.cylinder.widthDirection[3] - mechanics.r2.cylinder.e_x[3] * mechanics.r2.cylinder.widthDirection[2];
//   protected Real mechanics.r2.cylinder.n_z_aux[2](unit = \"1\") = mechanics.r2.cylinder.e_x[3] * mechanics.r2.cylinder.widthDirection[1] - mechanics.r2.cylinder.e_x[1] * mechanics.r2.cylinder.widthDirection[3];
//   protected Real mechanics.r2.cylinder.n_z_aux[3](unit = \"1\") = mechanics.r2.cylinder.e_x[1] * mechanics.r2.cylinder.widthDirection[2] - mechanics.r2.cylinder.e_x[2] * mechanics.r2.cylinder.widthDirection[1];
//   protected Real mechanics.r2.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.r2.cylinder.e_x[1],mechanics.r2.cylinder.e_x[2],mechanics.r2.cylinder.e_x[3]},if noEvent(mechanics.r2.cylinder.n_z_aux[1] ^ 2.0 + (mechanics.r2.cylinder.n_z_aux[2] ^ 2.0 + mechanics.r2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.r2.cylinder.widthDirection[1],mechanics.r2.cylinder.widthDirection[2],mechanics.r2.cylinder.widthDirection[3]} else if noEvent(abs(mechanics.r2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.r2.cylinder.e_x[1],mechanics.r2.cylinder.e_x[2],mechanics.r2.cylinder.e_x[3]})[1];
//   protected Real mechanics.r2.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.r2.cylinder.e_x[1],mechanics.r2.cylinder.e_x[2],mechanics.r2.cylinder.e_x[3]},if noEvent(mechanics.r2.cylinder.n_z_aux[1] ^ 2.0 + (mechanics.r2.cylinder.n_z_aux[2] ^ 2.0 + mechanics.r2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.r2.cylinder.widthDirection[1],mechanics.r2.cylinder.widthDirection[2],mechanics.r2.cylinder.widthDirection[3]} else if noEvent(abs(mechanics.r2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.r2.cylinder.e_x[1],mechanics.r2.cylinder.e_x[2],mechanics.r2.cylinder.e_x[3]})[2];
//   protected Real mechanics.r2.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.r2.cylinder.e_x[1],mechanics.r2.cylinder.e_x[2],mechanics.r2.cylinder.e_x[3]},if noEvent(mechanics.r2.cylinder.n_z_aux[1] ^ 2.0 + (mechanics.r2.cylinder.n_z_aux[2] ^ 2.0 + mechanics.r2.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.r2.cylinder.widthDirection[1],mechanics.r2.cylinder.widthDirection[2],mechanics.r2.cylinder.widthDirection[3]} else if noEvent(abs(mechanics.r2.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.r2.cylinder.e_x[1],mechanics.r2.cylinder.e_x[2],mechanics.r2.cylinder.e_x[3]})[3];
//   protected output Real mechanics.r2.cylinder.Form;
//   output Real mechanics.r2.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r2.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r2.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r2.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r2.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r2.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r2.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real mechanics.r2.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real mechanics.r2.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real mechanics.r2.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.r2.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.r2.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.r2.cylinder.Material;
//   protected output Real mechanics.r2.cylinder.Extra;
//   protected parameter Real mechanics.r2.e[1](unit = \"1\") = Modelica.Math.Vectors.normalize({mechanics.r2.n[1],mechanics.r2.n[2],mechanics.r2.n[3]},1e-13)[1] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   protected parameter Real mechanics.r2.e[2](unit = \"1\") = Modelica.Math.Vectors.normalize({mechanics.r2.n[1],mechanics.r2.n[2],mechanics.r2.n[3]},1e-13)[2] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   protected parameter Real mechanics.r2.e[3](unit = \"1\") = Modelica.Math.Vectors.normalize({mechanics.r2.n[1],mechanics.r2.n[2],mechanics.r2.n[3]},1e-13)[3] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   Real mechanics.r3.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r3.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r3.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r3.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r3.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r3.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r3.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r3.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r3.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r3.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r3.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r3.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r3.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r3.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r3.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r3.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r3.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r3.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r3.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.r3.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.r3.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.r3.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r3.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r3.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r3.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r3.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r3.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r3.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r3.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r3.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r3.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r3.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r3.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r3.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r3.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r3.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r3.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r3.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r3.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r3.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.r3.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.r3.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean mechanics.r3.useAxisFlange = true \"= true, if axis flange is enabled\";
//   parameter Boolean mechanics.r3.animation = mechanics.animation \"= true, if animation shall be enabled (show axis as cylinder)\";
//   parameter Real mechanics.r3.n[1](unit = \"1\") = 1.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real mechanics.r3.n[2](unit = \"1\") = 0.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real mechanics.r3.n[3](unit = \"1\") = 0.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   constant Real mechanics.r3.phi_offset(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Relative angle offset (angle = phi_offset + phi)\";
//   parameter Real mechanics.r3.cylinderLength(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.world.defaultJointLength \"Length of cylinder representing the joint axis\";
//   parameter Real mechanics.r3.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.world.defaultJointWidth \"Diameter of cylinder representing the joint axis\";
//   input Integer mechanics.r3.cylinderColor[1](min = 0, max = 255) = 255 \"Color of cylinder representing the joint axis\";
//   input Integer mechanics.r3.cylinderColor[2](min = 0, max = 255) = 0 \"Color of cylinder representing the joint axis\";
//   input Integer mechanics.r3.cylinderColor[3](min = 0, max = 255) = 0 \"Color of cylinder representing the joint axis\";
//   input Real mechanics.r3.specularCoefficient = mechanics.world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter enumeration(never, avoid, default, prefer, always) mechanics.r3.stateSelect = StateSelect.prefer \"Priority to use joint angle phi and w=der(phi) as states\";
//   Real mechanics.r3.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, StateSelect = StateSelect.prefer) \"Relative rotation angle from frame_a to frame_b\";
//   Real mechanics.r3.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, StateSelect = StateSelect.prefer) \"First derivative of angle phi (relative angular velocity)\";
//   Real mechanics.r3.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = 0.0) \"Second derivative of angle phi (relative angular acceleration)\";
//   Real mechanics.r3.tau(quantity = \"Torque\", unit = \"N.m\") \"Driving torque in direction of axis of rotation\";
//   Real mechanics.r3.angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"= phi_offset + phi\";
//   Real mechanics.r3.R_rel.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r3.R_rel.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r3.R_rel.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r3.R_rel.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r3.R_rel.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r3.R_rel.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r3.R_rel.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r3.R_rel.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r3.R_rel.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r3.R_rel.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r3.R_rel.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r3.R_rel.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real mechanics.r3.fixed.phi0(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Fixed offset angle of housing\";
//   Real mechanics.r3.fixed.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real mechanics.r3.fixed.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real mechanics.r3.internalAxis.tau(quantity = \"Torque\", unit = \"N.m\") = mechanics.r3.tau \"External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau)\";
//   Real mechanics.r3.internalAxis.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"External support angle (= flange.phi)\";
//   Real mechanics.r3.internalAxis.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real mechanics.r3.internalAxis.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real mechanics.r3.axis.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real mechanics.r3.axis.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real mechanics.r3.support.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real mechanics.r3.support.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter String mechanics.r3.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real mechanics.r3.cylinder.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r3.cylinder.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r3.cylinder.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r3.cylinder.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r3.cylinder.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r3.cylinder.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r3.cylinder.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r3.cylinder.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r3.cylinder.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r3.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.r3.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.r3.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.r3.cylinder.r[1](quantity = \"Length\", unit = \"m\") = mechanics.r3.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.r3.cylinder.r[2](quantity = \"Length\", unit = \"m\") = mechanics.r3.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.r3.cylinder.r[3](quantity = \"Length\", unit = \"m\") = mechanics.r3.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.r3.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = ((-mechanics.r3.e[1]) * mechanics.r3.cylinderLength) / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.r3.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = ((-mechanics.r3.e[2]) * mechanics.r3.cylinderLength) / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.r3.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = ((-mechanics.r3.e[3]) * mechanics.r3.cylinderLength) / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.r3.cylinder.lengthDirection[1](unit = \"1\") = mechanics.r3.e[1] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.r3.cylinder.lengthDirection[2](unit = \"1\") = mechanics.r3.e[2] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.r3.cylinder.lengthDirection[3](unit = \"1\") = mechanics.r3.e[3] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.r3.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.r3.cylinder.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.r3.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.r3.cylinder.length(quantity = \"Length\", unit = \"m\") = mechanics.r3.cylinderLength \"Length of visual object\";
//   input Real mechanics.r3.cylinder.width(quantity = \"Length\", unit = \"m\") = mechanics.r3.cylinderDiameter \"Width of visual object\";
//   input Real mechanics.r3.cylinder.height(quantity = \"Length\", unit = \"m\") = mechanics.r3.cylinderDiameter \"Height of visual object\";
//   input Real mechanics.r3.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real mechanics.r3.cylinder.color[1] = Real(mechanics.r3.cylinderColor[1]) \"Color of shape\";
//   input Real mechanics.r3.cylinder.color[2] = Real(mechanics.r3.cylinderColor[2]) \"Color of shape\";
//   input Real mechanics.r3.cylinder.color[3] = Real(mechanics.r3.cylinderColor[3]) \"Color of shape\";
//   input Real mechanics.r3.cylinder.specularCoefficient = mechanics.r3.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real mechanics.r3.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({mechanics.r3.cylinder.lengthDirection[1],mechanics.r3.cylinder.lengthDirection[2],mechanics.r3.cylinder.lengthDirection[3]});
//   protected Real mechanics.r3.cylinder.e_x[1](unit = \"1\") = if noEvent(mechanics.r3.cylinder.abs_n_x < 1e-10) then 1.0 else mechanics.r3.cylinder.lengthDirection[1] / mechanics.r3.cylinder.abs_n_x;
//   protected Real mechanics.r3.cylinder.e_x[2](unit = \"1\") = if noEvent(mechanics.r3.cylinder.abs_n_x < 1e-10) then 0.0 else mechanics.r3.cylinder.lengthDirection[2] / mechanics.r3.cylinder.abs_n_x;
//   protected Real mechanics.r3.cylinder.e_x[3](unit = \"1\") = if noEvent(mechanics.r3.cylinder.abs_n_x < 1e-10) then 0.0 else mechanics.r3.cylinder.lengthDirection[3] / mechanics.r3.cylinder.abs_n_x;
//   protected Real mechanics.r3.cylinder.n_z_aux[1](unit = \"1\") = mechanics.r3.cylinder.e_x[2] * mechanics.r3.cylinder.widthDirection[3] - mechanics.r3.cylinder.e_x[3] * mechanics.r3.cylinder.widthDirection[2];
//   protected Real mechanics.r3.cylinder.n_z_aux[2](unit = \"1\") = mechanics.r3.cylinder.e_x[3] * mechanics.r3.cylinder.widthDirection[1] - mechanics.r3.cylinder.e_x[1] * mechanics.r3.cylinder.widthDirection[3];
//   protected Real mechanics.r3.cylinder.n_z_aux[3](unit = \"1\") = mechanics.r3.cylinder.e_x[1] * mechanics.r3.cylinder.widthDirection[2] - mechanics.r3.cylinder.e_x[2] * mechanics.r3.cylinder.widthDirection[1];
//   protected Real mechanics.r3.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.r3.cylinder.e_x[1],mechanics.r3.cylinder.e_x[2],mechanics.r3.cylinder.e_x[3]},if noEvent(mechanics.r3.cylinder.n_z_aux[1] ^ 2.0 + (mechanics.r3.cylinder.n_z_aux[2] ^ 2.0 + mechanics.r3.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.r3.cylinder.widthDirection[1],mechanics.r3.cylinder.widthDirection[2],mechanics.r3.cylinder.widthDirection[3]} else if noEvent(abs(mechanics.r3.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.r3.cylinder.e_x[1],mechanics.r3.cylinder.e_x[2],mechanics.r3.cylinder.e_x[3]})[1];
//   protected Real mechanics.r3.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.r3.cylinder.e_x[1],mechanics.r3.cylinder.e_x[2],mechanics.r3.cylinder.e_x[3]},if noEvent(mechanics.r3.cylinder.n_z_aux[1] ^ 2.0 + (mechanics.r3.cylinder.n_z_aux[2] ^ 2.0 + mechanics.r3.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.r3.cylinder.widthDirection[1],mechanics.r3.cylinder.widthDirection[2],mechanics.r3.cylinder.widthDirection[3]} else if noEvent(abs(mechanics.r3.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.r3.cylinder.e_x[1],mechanics.r3.cylinder.e_x[2],mechanics.r3.cylinder.e_x[3]})[2];
//   protected Real mechanics.r3.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.r3.cylinder.e_x[1],mechanics.r3.cylinder.e_x[2],mechanics.r3.cylinder.e_x[3]},if noEvent(mechanics.r3.cylinder.n_z_aux[1] ^ 2.0 + (mechanics.r3.cylinder.n_z_aux[2] ^ 2.0 + mechanics.r3.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.r3.cylinder.widthDirection[1],mechanics.r3.cylinder.widthDirection[2],mechanics.r3.cylinder.widthDirection[3]} else if noEvent(abs(mechanics.r3.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.r3.cylinder.e_x[1],mechanics.r3.cylinder.e_x[2],mechanics.r3.cylinder.e_x[3]})[3];
//   protected output Real mechanics.r3.cylinder.Form;
//   output Real mechanics.r3.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r3.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r3.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r3.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r3.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r3.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r3.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real mechanics.r3.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real mechanics.r3.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real mechanics.r3.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.r3.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.r3.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.r3.cylinder.Material;
//   protected output Real mechanics.r3.cylinder.Extra;
//   protected parameter Real mechanics.r3.e[1](unit = \"1\") = Modelica.Math.Vectors.normalize({mechanics.r3.n[1],mechanics.r3.n[2],mechanics.r3.n[3]},1e-13)[1] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   protected parameter Real mechanics.r3.e[2](unit = \"1\") = Modelica.Math.Vectors.normalize({mechanics.r3.n[1],mechanics.r3.n[2],mechanics.r3.n[3]},1e-13)[2] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   protected parameter Real mechanics.r3.e[3](unit = \"1\") = Modelica.Math.Vectors.normalize({mechanics.r3.n[1],mechanics.r3.n[2],mechanics.r3.n[3]},1e-13)[3] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   Real mechanics.r4.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r4.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r4.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r4.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r4.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r4.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r4.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r4.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r4.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r4.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r4.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r4.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r4.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r4.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r4.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r4.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r4.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r4.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r4.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.r4.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.r4.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.r4.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r4.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r4.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r4.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r4.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r4.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r4.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r4.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r4.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r4.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r4.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r4.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r4.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r4.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r4.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r4.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r4.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r4.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r4.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.r4.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.r4.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean mechanics.r4.useAxisFlange = true \"= true, if axis flange is enabled\";
//   parameter Boolean mechanics.r4.animation = mechanics.animation \"= true, if animation shall be enabled (show axis as cylinder)\";
//   parameter Real mechanics.r4.n[1](unit = \"1\") = 0.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real mechanics.r4.n[2](unit = \"1\") = 1.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real mechanics.r4.n[3](unit = \"1\") = 0.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   constant Real mechanics.r4.phi_offset(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Relative angle offset (angle = phi_offset + phi)\";
//   parameter Real mechanics.r4.cylinderLength(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.world.defaultJointLength \"Length of cylinder representing the joint axis\";
//   parameter Real mechanics.r4.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.world.defaultJointWidth \"Diameter of cylinder representing the joint axis\";
//   input Integer mechanics.r4.cylinderColor[1](min = 0, max = 255) = 255 \"Color of cylinder representing the joint axis\";
//   input Integer mechanics.r4.cylinderColor[2](min = 0, max = 255) = 0 \"Color of cylinder representing the joint axis\";
//   input Integer mechanics.r4.cylinderColor[3](min = 0, max = 255) = 0 \"Color of cylinder representing the joint axis\";
//   input Real mechanics.r4.specularCoefficient = mechanics.world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter enumeration(never, avoid, default, prefer, always) mechanics.r4.stateSelect = StateSelect.prefer \"Priority to use joint angle phi and w=der(phi) as states\";
//   Real mechanics.r4.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, StateSelect = StateSelect.prefer) \"Relative rotation angle from frame_a to frame_b\";
//   Real mechanics.r4.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, StateSelect = StateSelect.prefer) \"First derivative of angle phi (relative angular velocity)\";
//   Real mechanics.r4.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = 0.0) \"Second derivative of angle phi (relative angular acceleration)\";
//   Real mechanics.r4.tau(quantity = \"Torque\", unit = \"N.m\") \"Driving torque in direction of axis of rotation\";
//   Real mechanics.r4.angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"= phi_offset + phi\";
//   Real mechanics.r4.R_rel.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r4.R_rel.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r4.R_rel.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r4.R_rel.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r4.R_rel.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r4.R_rel.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r4.R_rel.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r4.R_rel.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r4.R_rel.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r4.R_rel.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r4.R_rel.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r4.R_rel.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real mechanics.r4.fixed.phi0(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Fixed offset angle of housing\";
//   Real mechanics.r4.fixed.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real mechanics.r4.fixed.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real mechanics.r4.internalAxis.tau(quantity = \"Torque\", unit = \"N.m\") = mechanics.r4.tau \"External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau)\";
//   Real mechanics.r4.internalAxis.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"External support angle (= flange.phi)\";
//   Real mechanics.r4.internalAxis.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real mechanics.r4.internalAxis.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real mechanics.r4.axis.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real mechanics.r4.axis.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real mechanics.r4.support.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real mechanics.r4.support.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter String mechanics.r4.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real mechanics.r4.cylinder.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r4.cylinder.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r4.cylinder.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r4.cylinder.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r4.cylinder.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r4.cylinder.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r4.cylinder.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r4.cylinder.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r4.cylinder.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r4.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.r4.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.r4.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.r4.cylinder.r[1](quantity = \"Length\", unit = \"m\") = mechanics.r4.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.r4.cylinder.r[2](quantity = \"Length\", unit = \"m\") = mechanics.r4.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.r4.cylinder.r[3](quantity = \"Length\", unit = \"m\") = mechanics.r4.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.r4.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = ((-mechanics.r4.e[1]) * mechanics.r4.cylinderLength) / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.r4.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = ((-mechanics.r4.e[2]) * mechanics.r4.cylinderLength) / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.r4.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = ((-mechanics.r4.e[3]) * mechanics.r4.cylinderLength) / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.r4.cylinder.lengthDirection[1](unit = \"1\") = mechanics.r4.e[1] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.r4.cylinder.lengthDirection[2](unit = \"1\") = mechanics.r4.e[2] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.r4.cylinder.lengthDirection[3](unit = \"1\") = mechanics.r4.e[3] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.r4.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.r4.cylinder.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.r4.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.r4.cylinder.length(quantity = \"Length\", unit = \"m\") = mechanics.r4.cylinderLength \"Length of visual object\";
//   input Real mechanics.r4.cylinder.width(quantity = \"Length\", unit = \"m\") = mechanics.r4.cylinderDiameter \"Width of visual object\";
//   input Real mechanics.r4.cylinder.height(quantity = \"Length\", unit = \"m\") = mechanics.r4.cylinderDiameter \"Height of visual object\";
//   input Real mechanics.r4.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real mechanics.r4.cylinder.color[1] = Real(mechanics.r4.cylinderColor[1]) \"Color of shape\";
//   input Real mechanics.r4.cylinder.color[2] = Real(mechanics.r4.cylinderColor[2]) \"Color of shape\";
//   input Real mechanics.r4.cylinder.color[3] = Real(mechanics.r4.cylinderColor[3]) \"Color of shape\";
//   input Real mechanics.r4.cylinder.specularCoefficient = mechanics.r4.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real mechanics.r4.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({mechanics.r4.cylinder.lengthDirection[1],mechanics.r4.cylinder.lengthDirection[2],mechanics.r4.cylinder.lengthDirection[3]});
//   protected Real mechanics.r4.cylinder.e_x[1](unit = \"1\") = if noEvent(mechanics.r4.cylinder.abs_n_x < 1e-10) then 1.0 else mechanics.r4.cylinder.lengthDirection[1] / mechanics.r4.cylinder.abs_n_x;
//   protected Real mechanics.r4.cylinder.e_x[2](unit = \"1\") = if noEvent(mechanics.r4.cylinder.abs_n_x < 1e-10) then 0.0 else mechanics.r4.cylinder.lengthDirection[2] / mechanics.r4.cylinder.abs_n_x;
//   protected Real mechanics.r4.cylinder.e_x[3](unit = \"1\") = if noEvent(mechanics.r4.cylinder.abs_n_x < 1e-10) then 0.0 else mechanics.r4.cylinder.lengthDirection[3] / mechanics.r4.cylinder.abs_n_x;
//   protected Real mechanics.r4.cylinder.n_z_aux[1](unit = \"1\") = mechanics.r4.cylinder.e_x[2] * mechanics.r4.cylinder.widthDirection[3] - mechanics.r4.cylinder.e_x[3] * mechanics.r4.cylinder.widthDirection[2];
//   protected Real mechanics.r4.cylinder.n_z_aux[2](unit = \"1\") = mechanics.r4.cylinder.e_x[3] * mechanics.r4.cylinder.widthDirection[1] - mechanics.r4.cylinder.e_x[1] * mechanics.r4.cylinder.widthDirection[3];
//   protected Real mechanics.r4.cylinder.n_z_aux[3](unit = \"1\") = mechanics.r4.cylinder.e_x[1] * mechanics.r4.cylinder.widthDirection[2] - mechanics.r4.cylinder.e_x[2] * mechanics.r4.cylinder.widthDirection[1];
//   protected Real mechanics.r4.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.r4.cylinder.e_x[1],mechanics.r4.cylinder.e_x[2],mechanics.r4.cylinder.e_x[3]},if noEvent(mechanics.r4.cylinder.n_z_aux[1] ^ 2.0 + (mechanics.r4.cylinder.n_z_aux[2] ^ 2.0 + mechanics.r4.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.r4.cylinder.widthDirection[1],mechanics.r4.cylinder.widthDirection[2],mechanics.r4.cylinder.widthDirection[3]} else if noEvent(abs(mechanics.r4.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.r4.cylinder.e_x[1],mechanics.r4.cylinder.e_x[2],mechanics.r4.cylinder.e_x[3]})[1];
//   protected Real mechanics.r4.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.r4.cylinder.e_x[1],mechanics.r4.cylinder.e_x[2],mechanics.r4.cylinder.e_x[3]},if noEvent(mechanics.r4.cylinder.n_z_aux[1] ^ 2.0 + (mechanics.r4.cylinder.n_z_aux[2] ^ 2.0 + mechanics.r4.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.r4.cylinder.widthDirection[1],mechanics.r4.cylinder.widthDirection[2],mechanics.r4.cylinder.widthDirection[3]} else if noEvent(abs(mechanics.r4.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.r4.cylinder.e_x[1],mechanics.r4.cylinder.e_x[2],mechanics.r4.cylinder.e_x[3]})[2];
//   protected Real mechanics.r4.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.r4.cylinder.e_x[1],mechanics.r4.cylinder.e_x[2],mechanics.r4.cylinder.e_x[3]},if noEvent(mechanics.r4.cylinder.n_z_aux[1] ^ 2.0 + (mechanics.r4.cylinder.n_z_aux[2] ^ 2.0 + mechanics.r4.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.r4.cylinder.widthDirection[1],mechanics.r4.cylinder.widthDirection[2],mechanics.r4.cylinder.widthDirection[3]} else if noEvent(abs(mechanics.r4.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.r4.cylinder.e_x[1],mechanics.r4.cylinder.e_x[2],mechanics.r4.cylinder.e_x[3]})[3];
//   protected output Real mechanics.r4.cylinder.Form;
//   output Real mechanics.r4.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r4.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r4.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r4.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r4.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r4.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r4.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real mechanics.r4.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real mechanics.r4.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real mechanics.r4.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.r4.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.r4.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.r4.cylinder.Material;
//   protected output Real mechanics.r4.cylinder.Extra;
//   protected parameter Real mechanics.r4.e[1](unit = \"1\") = Modelica.Math.Vectors.normalize({mechanics.r4.n[1],mechanics.r4.n[2],mechanics.r4.n[3]},1e-13)[1] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   protected parameter Real mechanics.r4.e[2](unit = \"1\") = Modelica.Math.Vectors.normalize({mechanics.r4.n[1],mechanics.r4.n[2],mechanics.r4.n[3]},1e-13)[2] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   protected parameter Real mechanics.r4.e[3](unit = \"1\") = Modelica.Math.Vectors.normalize({mechanics.r4.n[1],mechanics.r4.n[2],mechanics.r4.n[3]},1e-13)[3] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   Real mechanics.r5.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r5.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r5.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r5.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r5.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r5.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r5.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r5.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r5.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r5.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r5.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r5.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r5.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r5.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r5.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r5.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r5.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r5.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r5.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.r5.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.r5.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.r5.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r5.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r5.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r5.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r5.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r5.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r5.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r5.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r5.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r5.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r5.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r5.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r5.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r5.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r5.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r5.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r5.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r5.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r5.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.r5.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.r5.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean mechanics.r5.useAxisFlange = true \"= true, if axis flange is enabled\";
//   parameter Boolean mechanics.r5.animation = mechanics.animation \"= true, if animation shall be enabled (show axis as cylinder)\";
//   parameter Real mechanics.r5.n[1](unit = \"1\") = 1.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real mechanics.r5.n[2](unit = \"1\") = 0.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real mechanics.r5.n[3](unit = \"1\") = 0.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   constant Real mechanics.r5.phi_offset(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Relative angle offset (angle = phi_offset + phi)\";
//   parameter Real mechanics.r5.cylinderLength(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.world.defaultJointLength \"Length of cylinder representing the joint axis\";
//   parameter Real mechanics.r5.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.world.defaultJointWidth \"Diameter of cylinder representing the joint axis\";
//   input Integer mechanics.r5.cylinderColor[1](min = 0, max = 255) = 255 \"Color of cylinder representing the joint axis\";
//   input Integer mechanics.r5.cylinderColor[2](min = 0, max = 255) = 0 \"Color of cylinder representing the joint axis\";
//   input Integer mechanics.r5.cylinderColor[3](min = 0, max = 255) = 0 \"Color of cylinder representing the joint axis\";
//   input Real mechanics.r5.specularCoefficient = mechanics.world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter enumeration(never, avoid, default, prefer, always) mechanics.r5.stateSelect = StateSelect.prefer \"Priority to use joint angle phi and w=der(phi) as states\";
//   Real mechanics.r5.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, StateSelect = StateSelect.prefer) \"Relative rotation angle from frame_a to frame_b\";
//   Real mechanics.r5.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, StateSelect = StateSelect.prefer) \"First derivative of angle phi (relative angular velocity)\";
//   Real mechanics.r5.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = 0.0) \"Second derivative of angle phi (relative angular acceleration)\";
//   Real mechanics.r5.tau(quantity = \"Torque\", unit = \"N.m\") \"Driving torque in direction of axis of rotation\";
//   Real mechanics.r5.angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"= phi_offset + phi\";
//   Real mechanics.r5.R_rel.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r5.R_rel.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r5.R_rel.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r5.R_rel.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r5.R_rel.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r5.R_rel.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r5.R_rel.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r5.R_rel.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r5.R_rel.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r5.R_rel.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r5.R_rel.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r5.R_rel.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real mechanics.r5.fixed.phi0(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Fixed offset angle of housing\";
//   Real mechanics.r5.fixed.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real mechanics.r5.fixed.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real mechanics.r5.internalAxis.tau(quantity = \"Torque\", unit = \"N.m\") = mechanics.r5.tau \"External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau)\";
//   Real mechanics.r5.internalAxis.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"External support angle (= flange.phi)\";
//   Real mechanics.r5.internalAxis.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real mechanics.r5.internalAxis.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real mechanics.r5.axis.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real mechanics.r5.axis.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real mechanics.r5.support.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real mechanics.r5.support.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter String mechanics.r5.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real mechanics.r5.cylinder.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r5.cylinder.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r5.cylinder.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r5.cylinder.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r5.cylinder.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r5.cylinder.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r5.cylinder.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r5.cylinder.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r5.cylinder.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r5.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.r5.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.r5.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.r5.cylinder.r[1](quantity = \"Length\", unit = \"m\") = mechanics.r5.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.r5.cylinder.r[2](quantity = \"Length\", unit = \"m\") = mechanics.r5.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.r5.cylinder.r[3](quantity = \"Length\", unit = \"m\") = mechanics.r5.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.r5.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = ((-mechanics.r5.e[1]) * mechanics.r5.cylinderLength) / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.r5.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = ((-mechanics.r5.e[2]) * mechanics.r5.cylinderLength) / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.r5.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = ((-mechanics.r5.e[3]) * mechanics.r5.cylinderLength) / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.r5.cylinder.lengthDirection[1](unit = \"1\") = mechanics.r5.e[1] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.r5.cylinder.lengthDirection[2](unit = \"1\") = mechanics.r5.e[2] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.r5.cylinder.lengthDirection[3](unit = \"1\") = mechanics.r5.e[3] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.r5.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.r5.cylinder.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.r5.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.r5.cylinder.length(quantity = \"Length\", unit = \"m\") = mechanics.r5.cylinderLength \"Length of visual object\";
//   input Real mechanics.r5.cylinder.width(quantity = \"Length\", unit = \"m\") = mechanics.r5.cylinderDiameter \"Width of visual object\";
//   input Real mechanics.r5.cylinder.height(quantity = \"Length\", unit = \"m\") = mechanics.r5.cylinderDiameter \"Height of visual object\";
//   input Real mechanics.r5.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real mechanics.r5.cylinder.color[1] = Real(mechanics.r5.cylinderColor[1]) \"Color of shape\";
//   input Real mechanics.r5.cylinder.color[2] = Real(mechanics.r5.cylinderColor[2]) \"Color of shape\";
//   input Real mechanics.r5.cylinder.color[3] = Real(mechanics.r5.cylinderColor[3]) \"Color of shape\";
//   input Real mechanics.r5.cylinder.specularCoefficient = mechanics.r5.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real mechanics.r5.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({mechanics.r5.cylinder.lengthDirection[1],mechanics.r5.cylinder.lengthDirection[2],mechanics.r5.cylinder.lengthDirection[3]});
//   protected Real mechanics.r5.cylinder.e_x[1](unit = \"1\") = if noEvent(mechanics.r5.cylinder.abs_n_x < 1e-10) then 1.0 else mechanics.r5.cylinder.lengthDirection[1] / mechanics.r5.cylinder.abs_n_x;
//   protected Real mechanics.r5.cylinder.e_x[2](unit = \"1\") = if noEvent(mechanics.r5.cylinder.abs_n_x < 1e-10) then 0.0 else mechanics.r5.cylinder.lengthDirection[2] / mechanics.r5.cylinder.abs_n_x;
//   protected Real mechanics.r5.cylinder.e_x[3](unit = \"1\") = if noEvent(mechanics.r5.cylinder.abs_n_x < 1e-10) then 0.0 else mechanics.r5.cylinder.lengthDirection[3] / mechanics.r5.cylinder.abs_n_x;
//   protected Real mechanics.r5.cylinder.n_z_aux[1](unit = \"1\") = mechanics.r5.cylinder.e_x[2] * mechanics.r5.cylinder.widthDirection[3] - mechanics.r5.cylinder.e_x[3] * mechanics.r5.cylinder.widthDirection[2];
//   protected Real mechanics.r5.cylinder.n_z_aux[2](unit = \"1\") = mechanics.r5.cylinder.e_x[3] * mechanics.r5.cylinder.widthDirection[1] - mechanics.r5.cylinder.e_x[1] * mechanics.r5.cylinder.widthDirection[3];
//   protected Real mechanics.r5.cylinder.n_z_aux[3](unit = \"1\") = mechanics.r5.cylinder.e_x[1] * mechanics.r5.cylinder.widthDirection[2] - mechanics.r5.cylinder.e_x[2] * mechanics.r5.cylinder.widthDirection[1];
//   protected Real mechanics.r5.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.r5.cylinder.e_x[1],mechanics.r5.cylinder.e_x[2],mechanics.r5.cylinder.e_x[3]},if noEvent(mechanics.r5.cylinder.n_z_aux[1] ^ 2.0 + (mechanics.r5.cylinder.n_z_aux[2] ^ 2.0 + mechanics.r5.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.r5.cylinder.widthDirection[1],mechanics.r5.cylinder.widthDirection[2],mechanics.r5.cylinder.widthDirection[3]} else if noEvent(abs(mechanics.r5.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.r5.cylinder.e_x[1],mechanics.r5.cylinder.e_x[2],mechanics.r5.cylinder.e_x[3]})[1];
//   protected Real mechanics.r5.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.r5.cylinder.e_x[1],mechanics.r5.cylinder.e_x[2],mechanics.r5.cylinder.e_x[3]},if noEvent(mechanics.r5.cylinder.n_z_aux[1] ^ 2.0 + (mechanics.r5.cylinder.n_z_aux[2] ^ 2.0 + mechanics.r5.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.r5.cylinder.widthDirection[1],mechanics.r5.cylinder.widthDirection[2],mechanics.r5.cylinder.widthDirection[3]} else if noEvent(abs(mechanics.r5.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.r5.cylinder.e_x[1],mechanics.r5.cylinder.e_x[2],mechanics.r5.cylinder.e_x[3]})[2];
//   protected Real mechanics.r5.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.r5.cylinder.e_x[1],mechanics.r5.cylinder.e_x[2],mechanics.r5.cylinder.e_x[3]},if noEvent(mechanics.r5.cylinder.n_z_aux[1] ^ 2.0 + (mechanics.r5.cylinder.n_z_aux[2] ^ 2.0 + mechanics.r5.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.r5.cylinder.widthDirection[1],mechanics.r5.cylinder.widthDirection[2],mechanics.r5.cylinder.widthDirection[3]} else if noEvent(abs(mechanics.r5.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.r5.cylinder.e_x[1],mechanics.r5.cylinder.e_x[2],mechanics.r5.cylinder.e_x[3]})[3];
//   protected output Real mechanics.r5.cylinder.Form;
//   output Real mechanics.r5.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r5.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r5.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r5.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r5.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r5.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r5.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real mechanics.r5.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real mechanics.r5.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real mechanics.r5.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.r5.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.r5.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.r5.cylinder.Material;
//   protected output Real mechanics.r5.cylinder.Extra;
//   protected parameter Real mechanics.r5.e[1](unit = \"1\") = Modelica.Math.Vectors.normalize({mechanics.r5.n[1],mechanics.r5.n[2],mechanics.r5.n[3]},1e-13)[1] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   protected parameter Real mechanics.r5.e[2](unit = \"1\") = Modelica.Math.Vectors.normalize({mechanics.r5.n[1],mechanics.r5.n[2],mechanics.r5.n[3]},1e-13)[2] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   protected parameter Real mechanics.r5.e[3](unit = \"1\") = Modelica.Math.Vectors.normalize({mechanics.r5.n[1],mechanics.r5.n[2],mechanics.r5.n[3]},1e-13)[3] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   Real mechanics.r6.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r6.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r6.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r6.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r6.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r6.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r6.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r6.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r6.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r6.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r6.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r6.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r6.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r6.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r6.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r6.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r6.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r6.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r6.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.r6.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.r6.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.r6.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r6.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r6.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.r6.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r6.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r6.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r6.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r6.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r6.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r6.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r6.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r6.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r6.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r6.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r6.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r6.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r6.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r6.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.r6.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.r6.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.r6.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean mechanics.r6.useAxisFlange = true \"= true, if axis flange is enabled\";
//   parameter Boolean mechanics.r6.animation = mechanics.animation \"= true, if animation shall be enabled (show axis as cylinder)\";
//   parameter Real mechanics.r6.n[1](unit = \"1\") = 0.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real mechanics.r6.n[2](unit = \"1\") = 1.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   parameter Real mechanics.r6.n[3](unit = \"1\") = 0.0 \"Axis of rotation resolved in frame_a (= same as in frame_b)\";
//   constant Real mechanics.r6.phi_offset(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Relative angle offset (angle = phi_offset + phi)\";
//   parameter Real mechanics.r6.cylinderLength(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.world.defaultJointLength \"Length of cylinder representing the joint axis\";
//   parameter Real mechanics.r6.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.world.defaultJointWidth \"Diameter of cylinder representing the joint axis\";
//   input Integer mechanics.r6.cylinderColor[1](min = 0, max = 255) = 255 \"Color of cylinder representing the joint axis\";
//   input Integer mechanics.r6.cylinderColor[2](min = 0, max = 255) = 0 \"Color of cylinder representing the joint axis\";
//   input Integer mechanics.r6.cylinderColor[3](min = 0, max = 255) = 0 \"Color of cylinder representing the joint axis\";
//   input Real mechanics.r6.specularCoefficient = mechanics.world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter enumeration(never, avoid, default, prefer, always) mechanics.r6.stateSelect = StateSelect.prefer \"Priority to use joint angle phi and w=der(phi) as states\";
//   Real mechanics.r6.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, StateSelect = StateSelect.prefer) \"Relative rotation angle from frame_a to frame_b\";
//   Real mechanics.r6.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, StateSelect = StateSelect.prefer) \"First derivative of angle phi (relative angular velocity)\";
//   Real mechanics.r6.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = 0.0) \"Second derivative of angle phi (relative angular acceleration)\";
//   Real mechanics.r6.tau(quantity = \"Torque\", unit = \"N.m\") \"Driving torque in direction of axis of rotation\";
//   Real mechanics.r6.angle(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"= phi_offset + phi\";
//   Real mechanics.r6.R_rel.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r6.R_rel.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r6.R_rel.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r6.R_rel.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r6.R_rel.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r6.R_rel.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r6.R_rel.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r6.R_rel.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r6.R_rel.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.r6.R_rel.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r6.R_rel.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.r6.R_rel.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real mechanics.r6.fixed.phi0(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Fixed offset angle of housing\";
//   Real mechanics.r6.fixed.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real mechanics.r6.fixed.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real mechanics.r6.internalAxis.tau(quantity = \"Torque\", unit = \"N.m\") = mechanics.r6.tau \"External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau)\";
//   Real mechanics.r6.internalAxis.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"External support angle (= flange.phi)\";
//   Real mechanics.r6.internalAxis.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real mechanics.r6.internalAxis.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real mechanics.r6.axis.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real mechanics.r6.axis.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real mechanics.r6.support.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real mechanics.r6.support.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter String mechanics.r6.cylinder.shapeType = \"cylinder\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real mechanics.r6.cylinder.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r6.cylinder.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r6.cylinder.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r6.cylinder.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r6.cylinder.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r6.cylinder.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r6.cylinder.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r6.cylinder.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r6.cylinder.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.r6.cylinder.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.r6.cylinder.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.r6.cylinder.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.r6.cylinder.r[1](quantity = \"Length\", unit = \"m\") = mechanics.r6.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.r6.cylinder.r[2](quantity = \"Length\", unit = \"m\") = mechanics.r6.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.r6.cylinder.r[3](quantity = \"Length\", unit = \"m\") = mechanics.r6.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.r6.cylinder.r_shape[1](quantity = \"Length\", unit = \"m\") = ((-mechanics.r6.e[1]) * mechanics.r6.cylinderLength) / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.r6.cylinder.r_shape[2](quantity = \"Length\", unit = \"m\") = ((-mechanics.r6.e[2]) * mechanics.r6.cylinderLength) / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.r6.cylinder.r_shape[3](quantity = \"Length\", unit = \"m\") = ((-mechanics.r6.e[3]) * mechanics.r6.cylinderLength) / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.r6.cylinder.lengthDirection[1](unit = \"1\") = mechanics.r6.e[1] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.r6.cylinder.lengthDirection[2](unit = \"1\") = mechanics.r6.e[2] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.r6.cylinder.lengthDirection[3](unit = \"1\") = mechanics.r6.e[3] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.r6.cylinder.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.r6.cylinder.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.r6.cylinder.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.r6.cylinder.length(quantity = \"Length\", unit = \"m\") = mechanics.r6.cylinderLength \"Length of visual object\";
//   input Real mechanics.r6.cylinder.width(quantity = \"Length\", unit = \"m\") = mechanics.r6.cylinderDiameter \"Width of visual object\";
//   input Real mechanics.r6.cylinder.height(quantity = \"Length\", unit = \"m\") = mechanics.r6.cylinderDiameter \"Height of visual object\";
//   input Real mechanics.r6.cylinder.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real mechanics.r6.cylinder.color[1] = Real(mechanics.r6.cylinderColor[1]) \"Color of shape\";
//   input Real mechanics.r6.cylinder.color[2] = Real(mechanics.r6.cylinderColor[2]) \"Color of shape\";
//   input Real mechanics.r6.cylinder.color[3] = Real(mechanics.r6.cylinderColor[3]) \"Color of shape\";
//   input Real mechanics.r6.cylinder.specularCoefficient = mechanics.r6.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real mechanics.r6.cylinder.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({mechanics.r6.cylinder.lengthDirection[1],mechanics.r6.cylinder.lengthDirection[2],mechanics.r6.cylinder.lengthDirection[3]});
//   protected Real mechanics.r6.cylinder.e_x[1](unit = \"1\") = if noEvent(mechanics.r6.cylinder.abs_n_x < 1e-10) then 1.0 else mechanics.r6.cylinder.lengthDirection[1] / mechanics.r6.cylinder.abs_n_x;
//   protected Real mechanics.r6.cylinder.e_x[2](unit = \"1\") = if noEvent(mechanics.r6.cylinder.abs_n_x < 1e-10) then 0.0 else mechanics.r6.cylinder.lengthDirection[2] / mechanics.r6.cylinder.abs_n_x;
//   protected Real mechanics.r6.cylinder.e_x[3](unit = \"1\") = if noEvent(mechanics.r6.cylinder.abs_n_x < 1e-10) then 0.0 else mechanics.r6.cylinder.lengthDirection[3] / mechanics.r6.cylinder.abs_n_x;
//   protected Real mechanics.r6.cylinder.n_z_aux[1](unit = \"1\") = mechanics.r6.cylinder.e_x[2] * mechanics.r6.cylinder.widthDirection[3] - mechanics.r6.cylinder.e_x[3] * mechanics.r6.cylinder.widthDirection[2];
//   protected Real mechanics.r6.cylinder.n_z_aux[2](unit = \"1\") = mechanics.r6.cylinder.e_x[3] * mechanics.r6.cylinder.widthDirection[1] - mechanics.r6.cylinder.e_x[1] * mechanics.r6.cylinder.widthDirection[3];
//   protected Real mechanics.r6.cylinder.n_z_aux[3](unit = \"1\") = mechanics.r6.cylinder.e_x[1] * mechanics.r6.cylinder.widthDirection[2] - mechanics.r6.cylinder.e_x[2] * mechanics.r6.cylinder.widthDirection[1];
//   protected Real mechanics.r6.cylinder.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.r6.cylinder.e_x[1],mechanics.r6.cylinder.e_x[2],mechanics.r6.cylinder.e_x[3]},if noEvent(mechanics.r6.cylinder.n_z_aux[1] ^ 2.0 + (mechanics.r6.cylinder.n_z_aux[2] ^ 2.0 + mechanics.r6.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.r6.cylinder.widthDirection[1],mechanics.r6.cylinder.widthDirection[2],mechanics.r6.cylinder.widthDirection[3]} else if noEvent(abs(mechanics.r6.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.r6.cylinder.e_x[1],mechanics.r6.cylinder.e_x[2],mechanics.r6.cylinder.e_x[3]})[1];
//   protected Real mechanics.r6.cylinder.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.r6.cylinder.e_x[1],mechanics.r6.cylinder.e_x[2],mechanics.r6.cylinder.e_x[3]},if noEvent(mechanics.r6.cylinder.n_z_aux[1] ^ 2.0 + (mechanics.r6.cylinder.n_z_aux[2] ^ 2.0 + mechanics.r6.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.r6.cylinder.widthDirection[1],mechanics.r6.cylinder.widthDirection[2],mechanics.r6.cylinder.widthDirection[3]} else if noEvent(abs(mechanics.r6.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.r6.cylinder.e_x[1],mechanics.r6.cylinder.e_x[2],mechanics.r6.cylinder.e_x[3]})[2];
//   protected Real mechanics.r6.cylinder.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.r6.cylinder.e_x[1],mechanics.r6.cylinder.e_x[2],mechanics.r6.cylinder.e_x[3]},if noEvent(mechanics.r6.cylinder.n_z_aux[1] ^ 2.0 + (mechanics.r6.cylinder.n_z_aux[2] ^ 2.0 + mechanics.r6.cylinder.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.r6.cylinder.widthDirection[1],mechanics.r6.cylinder.widthDirection[2],mechanics.r6.cylinder.widthDirection[3]} else if noEvent(abs(mechanics.r6.cylinder.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.r6.cylinder.e_x[1],mechanics.r6.cylinder.e_x[2],mechanics.r6.cylinder.e_x[3]})[3];
//   protected output Real mechanics.r6.cylinder.Form;
//   output Real mechanics.r6.cylinder.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r6.cylinder.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r6.cylinder.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r6.cylinder.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r6.cylinder.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r6.cylinder.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.r6.cylinder.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real mechanics.r6.cylinder.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real mechanics.r6.cylinder.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real mechanics.r6.cylinder.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.r6.cylinder.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.r6.cylinder.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.r6.cylinder.Material;
//   protected output Real mechanics.r6.cylinder.Extra;
//   protected parameter Real mechanics.r6.e[1](unit = \"1\") = Modelica.Math.Vectors.normalize({mechanics.r6.n[1],mechanics.r6.n[2],mechanics.r6.n[3]},1e-13)[1] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   protected parameter Real mechanics.r6.e[2](unit = \"1\") = Modelica.Math.Vectors.normalize({mechanics.r6.n[1],mechanics.r6.n[2],mechanics.r6.n[3]},1e-13)[2] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   protected parameter Real mechanics.r6.e[3](unit = \"1\") = Modelica.Math.Vectors.normalize({mechanics.r6.n[1],mechanics.r6.n[2],mechanics.r6.n[3]},1e-13)[3] \"Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)\";
//   Real mechanics.b0.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b0.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b0.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b0.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b0.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b0.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b0.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b0.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b0.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b0.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b0.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b0.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b0.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b0.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b0.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b0.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b0.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b0.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b0.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b0.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b0.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b0.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b0.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b0.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean mechanics.b0.animation = mechanics.animation \"= true, if animation shall be enabled (show shape between frame_a and frame_b and optionally a sphere at the center of mass)\";
//   parameter Boolean mechanics.b0.animateSphere = false \"= true, if mass shall be animated as sphere provided animation=true\";
//   parameter Real mechanics.b0.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b0.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.351 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b0.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b0.r_CM[1](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b0.r_CM[2](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b0.r_CM[3](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b0.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 1.0) = 1.0 \"Mass of rigid body\";
//   parameter Real mechanics.b0.I_11(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.001 \" (1,1) element of inertia tensor\";
//   parameter Real mechanics.b0.I_22(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.001 \" (2,2) element of inertia tensor\";
//   parameter Real mechanics.b0.I_33(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.001 \" (3,3) element of inertia tensor\";
//   parameter Real mechanics.b0.I_21(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (2,1) element of inertia tensor\";
//   parameter Real mechanics.b0.I_31(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (3,1) element of inertia tensor\";
//   parameter Real mechanics.b0.I_32(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (3,2) element of inertia tensor\";
//   Real mechanics.b0.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b0.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b0.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b0.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b0.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b0.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b0.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real mechanics.b0.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real mechanics.b0.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean mechanics.b0.angles_fixed = false \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b0.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real mechanics.b0.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real mechanics.b0.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer mechanics.b0.sequence_start[1](min = 1, max = 3) = 1 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer mechanics.b0.sequence_start[2](min = 1, max = 3) = 2 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer mechanics.b0.sequence_start[3](min = 1, max = 3) = 3 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean mechanics.b0.w_0_fixed = false \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b0.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real mechanics.b0.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real mechanics.b0.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean mechanics.b0.z_0_fixed = false \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b0.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b0.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b0.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter String mechanics.b0.shapeType = \"0\" \" Type of shape\";
//   parameter Real mechanics.b0.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b0.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b0.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b0.widthDirection[1](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b0.widthDirection[2](unit = \"1\") = 1.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b0.widthDirection[3](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b0.extra = 0.0 \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer mechanics.b0.color[1](min = 0, max = 255) = 0 \" Color of shape\";
//   input Integer mechanics.b0.color[2](min = 0, max = 255) = 0 \" Color of shape\";
//   input Integer mechanics.b0.color[3](min = 0, max = 255) = 255 \" Color of shape\";
//   input Integer mechanics.b0.sphereColor[1](min = 0, max = 255) = mechanics.b0.color[1] \" Color of sphere of mass\";
//   input Integer mechanics.b0.sphereColor[2](min = 0, max = 255) = mechanics.b0.color[2] \" Color of sphere of mass\";
//   input Integer mechanics.b0.sphereColor[3](min = 0, max = 255) = mechanics.b0.color[3] \" Color of sphere of mass\";
//   input Real mechanics.b0.specularCoefficient = mechanics.world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean mechanics.b0.enforceStates = false \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean mechanics.b0.useQuaternions = true \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer mechanics.b0.sequence_angleStates[1](min = 1, max = 3) = 1 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer mechanics.b0.sequence_angleStates[2](min = 1, max = 3) = 2 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer mechanics.b0.sequence_angleStates[3](min = 1, max = 3) = 3 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   Real mechanics.b0.frameTranslation.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b0.frameTranslation.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b0.frameTranslation.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b0.frameTranslation.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frameTranslation.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frameTranslation.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frameTranslation.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frameTranslation.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frameTranslation.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frameTranslation.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frameTranslation.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frameTranslation.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frameTranslation.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b0.frameTranslation.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b0.frameTranslation.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b0.frameTranslation.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b0.frameTranslation.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b0.frameTranslation.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b0.frameTranslation.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b0.frameTranslation.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b0.frameTranslation.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b0.frameTranslation.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b0.frameTranslation.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b0.frameTranslation.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b0.frameTranslation.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frameTranslation.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frameTranslation.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frameTranslation.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frameTranslation.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frameTranslation.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frameTranslation.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frameTranslation.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frameTranslation.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.frameTranslation.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b0.frameTranslation.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b0.frameTranslation.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b0.frameTranslation.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b0.frameTranslation.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b0.frameTranslation.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b0.frameTranslation.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b0.frameTranslation.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b0.frameTranslation.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean mechanics.b0.frameTranslation.animation = false \"= true, if animation shall be enabled\";
//   parameter Real mechanics.b0.frameTranslation.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b0.r[1] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b0.frameTranslation.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b0.r[2] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b0.frameTranslation.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b0.r[3] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter String mechanics.b0.frameTranslation.shapeType = \"cylinder\" \" Type of shape\";
//   parameter Real mechanics.b0.frameTranslation.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b0.frameTranslation.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b0.frameTranslation.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b0.frameTranslation.widthDirection[1](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b0.frameTranslation.widthDirection[2](unit = \"1\") = 1.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b0.frameTranslation.widthDirection[3](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b0.frameTranslation.extra = 0.0 \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer mechanics.b0.frameTranslation.color[1](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer mechanics.b0.frameTranslation.color[2](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer mechanics.b0.frameTranslation.color[3](min = 0, max = 255) = 155 \" Color of shape\";
//   input Real mechanics.b0.frameTranslation.specularCoefficient = mechanics.world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Real mechanics.b0.frameTranslation.lengthDirection[1](unit = \"1\") = mechanics.b0.frameTranslation.r[1] - mechanics.b0.frameTranslation.r_shape[1] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b0.frameTranslation.lengthDirection[2](unit = \"1\") = mechanics.b0.frameTranslation.r[2] - mechanics.b0.frameTranslation.r_shape[2] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b0.frameTranslation.lengthDirection[3](unit = \"1\") = mechanics.b0.frameTranslation.r[3] - mechanics.b0.frameTranslation.r_shape[3] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b0.frameTranslation.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({mechanics.b0.frameTranslation.r[1] - mechanics.b0.frameTranslation.r_shape[1],mechanics.b0.frameTranslation.r[2] - mechanics.b0.frameTranslation.r_shape[2],mechanics.b0.frameTranslation.r[3] - mechanics.b0.frameTranslation.r_shape[3]}) \" Length of shape\";
//   parameter Real mechanics.b0.frameTranslation.width(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.b0.frameTranslation.length / mechanics.world.defaultWidthFraction \" Width of shape\";
//   parameter Real mechanics.b0.frameTranslation.height(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.b0.frameTranslation.width \" Height of shape.\";
//   Real mechanics.b0.body.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b0.body.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b0.body.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b0.body.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.body.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.body.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.body.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.body.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.body.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.body.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.body.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.body.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b0.body.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b0.body.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b0.body.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b0.body.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b0.body.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b0.body.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b0.body.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b0.body.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b0.body.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean mechanics.b0.body.animation = false \"= true, if animation shall be enabled (show cylinder and sphere)\";
//   parameter Real mechanics.b0.body.r_CM[1](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b0.r_CM[1] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b0.body.r_CM[2](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b0.r_CM[2] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b0.body.r_CM[3](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b0.r_CM[3] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b0.body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 1.0) = mechanics.b0.m \"Mass of rigid body\";
//   parameter Real mechanics.b0.body.I_11(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = mechanics.b0.I_11 \" (1,1) element of inertia tensor\";
//   parameter Real mechanics.b0.body.I_22(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = mechanics.b0.I_22 \" (2,2) element of inertia tensor\";
//   parameter Real mechanics.b0.body.I_33(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = mechanics.b0.I_33 \" (3,3) element of inertia tensor\";
//   parameter Real mechanics.b0.body.I_21(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = mechanics.b0.I_21 \" (2,1) element of inertia tensor\";
//   parameter Real mechanics.b0.body.I_31(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = mechanics.b0.I_31 \" (3,1) element of inertia tensor\";
//   parameter Real mechanics.b0.body.I_32(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = mechanics.b0.I_32 \" (3,2) element of inertia tensor\";
//   Real mechanics.b0.body.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b0.body.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b0.body.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b0.body.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b0.body.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b0.body.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b0.body.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real mechanics.b0.body.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real mechanics.b0.body.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean mechanics.b0.body.angles_fixed = mechanics.b0.angles_fixed \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b0.body.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = mechanics.b0.angles_start[1] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real mechanics.b0.body.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = mechanics.b0.angles_start[2] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real mechanics.b0.body.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = mechanics.b0.angles_start[3] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer mechanics.b0.body.sequence_start[1](min = 1, max = 3) = mechanics.b0.sequence_start[1] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer mechanics.b0.body.sequence_start[2](min = 1, max = 3) = mechanics.b0.sequence_start[2] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer mechanics.b0.body.sequence_start[3](min = 1, max = 3) = mechanics.b0.sequence_start[3] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean mechanics.b0.body.w_0_fixed = mechanics.b0.w_0_fixed \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b0.body.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = mechanics.b0.w_0_start[1] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real mechanics.b0.body.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = mechanics.b0.w_0_start[2] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real mechanics.b0.body.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = mechanics.b0.w_0_start[3] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean mechanics.b0.body.z_0_fixed = mechanics.b0.z_0_fixed \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b0.body.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = mechanics.b0.z_0_start[1] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b0.body.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = mechanics.b0.z_0_start[2] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b0.body.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = mechanics.b0.z_0_start[3] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b0.body.sphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.world.defaultBodyDiameter \"Diameter of sphere\";
//   input Integer mechanics.b0.body.sphereColor[1](min = 0, max = 255) = 0 \"Color of sphere\";
//   input Integer mechanics.b0.body.sphereColor[2](min = 0, max = 255) = 128 \"Color of sphere\";
//   input Integer mechanics.b0.body.sphereColor[3](min = 0, max = 255) = 255 \"Color of sphere\";
//   input Integer mechanics.b0.body.cylinderColor[1](min = 0, max = 255) = mechanics.b0.body.sphereColor[1] \"Color of cylinder\";
//   input Integer mechanics.b0.body.cylinderColor[2](min = 0, max = 255) = mechanics.b0.body.sphereColor[2] \"Color of cylinder\";
//   input Integer mechanics.b0.body.cylinderColor[3](min = 0, max = 255) = mechanics.b0.body.sphereColor[3] \"Color of cylinder\";
//   input Real mechanics.b0.body.specularCoefficient = mechanics.world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean mechanics.b0.body.enforceStates = mechanics.b0.enforceStates \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean mechanics.b0.body.useQuaternions = mechanics.b0.useQuaternions \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer mechanics.b0.body.sequence_angleStates[1](min = 1, max = 3) = mechanics.b0.sequence_angleStates[1] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer mechanics.b0.body.sequence_angleStates[2](min = 1, max = 3) = mechanics.b0.sequence_angleStates[2] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer mechanics.b0.body.sequence_angleStates[3](min = 1, max = 3) = mechanics.b0.sequence_angleStates[3] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   Real mechanics.b0.body.w_a[1](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b0.body.R_start,{mechanics.b0.body.w_0_start[1],mechanics.b0.body.w_0_start[2],mechanics.b0.body.w_0_start[3]})[1], fixed = mechanics.b0.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real mechanics.b0.body.w_a[2](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b0.body.R_start,{mechanics.b0.body.w_0_start[1],mechanics.b0.body.w_0_start[2],mechanics.b0.body.w_0_start[3]})[2], fixed = mechanics.b0.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real mechanics.b0.body.w_a[3](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b0.body.R_start,{mechanics.b0.body.w_0_start[1],mechanics.b0.body.w_0_start[2],mechanics.b0.body.w_0_start[3]})[3], fixed = mechanics.b0.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real mechanics.b0.body.z_a[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b0.body.R_start,{mechanics.b0.body.z_0_start[1],mechanics.b0.body.z_0_start[2],mechanics.b0.body.z_0_start[3]})[1], fixed = mechanics.b0.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real mechanics.b0.body.z_a[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b0.body.R_start,{mechanics.b0.body.z_0_start[1],mechanics.b0.body.z_0_start[2],mechanics.b0.body.z_0_start[3]})[2], fixed = mechanics.b0.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real mechanics.b0.body.z_a[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b0.body.R_start,{mechanics.b0.body.z_0_start[1],mechanics.b0.body.z_0_start[2],mechanics.b0.body.z_0_start[3]})[3], fixed = mechanics.b0.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real mechanics.b0.body.g_0[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real mechanics.b0.body.g_0[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real mechanics.b0.body.g_0[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   protected Real mechanics.b0.body.Q[1](start = mechanics.b0.body.Q_start[1], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real mechanics.b0.body.Q[2](start = mechanics.b0.body.Q_start[2], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real mechanics.b0.body.Q[3](start = mechanics.b0.body.Q_start[3], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real mechanics.b0.body.Q[4](start = mechanics.b0.body.Q_start[4], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real mechanics.b0.body.phi[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = mechanics.b0.body.phi_start[1], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real mechanics.b0.body.phi[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = mechanics.b0.body.phi_start[2], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real mechanics.b0.body.phi[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = mechanics.b0.body.phi_start[3], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real mechanics.b0.body.phi_d[1](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real mechanics.b0.body.phi_d[2](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real mechanics.b0.body.phi_d[3](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real mechanics.b0.body.phi_dd[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real mechanics.b0.body.phi_dd[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real mechanics.b0.body.phi_dd[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   final parameter Real mechanics.b0.body.I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b0.body.I_11 \"inertia tensor\";
//   final parameter Real mechanics.b0.body.I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b0.body.I_21 \"inertia tensor\";
//   final parameter Real mechanics.b0.body.I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b0.body.I_31 \"inertia tensor\";
//   final parameter Real mechanics.b0.body.I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b0.body.I_21 \"inertia tensor\";
//   final parameter Real mechanics.b0.body.I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b0.body.I_22 \"inertia tensor\";
//   final parameter Real mechanics.b0.body.I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b0.body.I_32 \"inertia tensor\";
//   final parameter Real mechanics.b0.body.I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b0.body.I_31 \"inertia tensor\";
//   final parameter Real mechanics.b0.body.I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b0.body.I_32 \"inertia tensor\";
//   final parameter Real mechanics.b0.body.I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b0.body.I_33 \"inertia tensor\";
//   final parameter Real mechanics.b0.body.R_start.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b0.body.R_start.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b0.body.R_start.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b0.body.R_start.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b0.body.R_start.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b0.body.R_start.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b0.body.R_start.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b0.body.R_start.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b0.body.R_start.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b0.body.R_start.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   final parameter Real mechanics.b0.body.R_start.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   final parameter Real mechanics.b0.body.R_start.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real mechanics.b0.body.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.b0.body.sphereDiameter / 3.0 \"Diameter of cylinder\";
//   final parameter Real mechanics.b0.body.z_a_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b0.body.R_start,{mechanics.b0.body.z_0_start[1],mechanics.b0.body.z_0_start[2],mechanics.b0.body.z_0_start[3]})[1] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   final parameter Real mechanics.b0.body.z_a_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b0.body.R_start,{mechanics.b0.body.z_0_start[1],mechanics.b0.body.z_0_start[2],mechanics.b0.body.z_0_start[3]})[2] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   final parameter Real mechanics.b0.body.z_a_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b0.body.R_start,{mechanics.b0.body.z_0_start[1],mechanics.b0.body.z_0_start[2],mechanics.b0.body.z_0_start[3]})[3] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   protected parameter Real mechanics.b0.body.Q_start[1] = Modelica.Mechanics.MultiBody.Frames.to_Q(mechanics.b0.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[1] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real mechanics.b0.body.Q_start[2] = Modelica.Mechanics.MultiBody.Frames.to_Q(mechanics.b0.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[2] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real mechanics.b0.body.Q_start[3] = Modelica.Mechanics.MultiBody.Frames.to_Q(mechanics.b0.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[3] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real mechanics.b0.body.Q_start[4] = Modelica.Mechanics.MultiBody.Frames.to_Q(mechanics.b0.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[4] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real mechanics.b0.body.phi_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if mechanics.b0.body.sequence_start[1] == mechanics.b0.body.sequence_angleStates[1] and mechanics.b0.body.sequence_start[2] == mechanics.b0.body.sequence_angleStates[2] and mechanics.b0.body.sequence_start[3] == mechanics.b0.body.sequence_angleStates[3] then mechanics.b0.body.angles_start[1] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(mechanics.b0.body.R_start,{mechanics.b0.body.sequence_angleStates[1],mechanics.b0.body.sequence_angleStates[2],mechanics.b0.body.sequence_angleStates[3]},0.0)[1] \"Potential angle states at initial time\";
//   protected parameter Real mechanics.b0.body.phi_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if mechanics.b0.body.sequence_start[1] == mechanics.b0.body.sequence_angleStates[1] and mechanics.b0.body.sequence_start[2] == mechanics.b0.body.sequence_angleStates[2] and mechanics.b0.body.sequence_start[3] == mechanics.b0.body.sequence_angleStates[3] then mechanics.b0.body.angles_start[2] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(mechanics.b0.body.R_start,{mechanics.b0.body.sequence_angleStates[1],mechanics.b0.body.sequence_angleStates[2],mechanics.b0.body.sequence_angleStates[3]},0.0)[2] \"Potential angle states at initial time\";
//   protected parameter Real mechanics.b0.body.phi_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if mechanics.b0.body.sequence_start[1] == mechanics.b0.body.sequence_angleStates[1] and mechanics.b0.body.sequence_start[2] == mechanics.b0.body.sequence_angleStates[2] and mechanics.b0.body.sequence_start[3] == mechanics.b0.body.sequence_angleStates[3] then mechanics.b0.body.angles_start[3] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(mechanics.b0.body.R_start,{mechanics.b0.body.sequence_angleStates[1],mechanics.b0.body.sequence_angleStates[2],mechanics.b0.body.sequence_angleStates[3]},0.0)[3] \"Potential angle states at initial time\";
//   parameter String mechanics.b0.shape1.shapeType = mechanics.b0.shapeType \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real mechanics.b0.shape1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b0.shape1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b0.shape1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b0.shape1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b0.shape1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b0.shape1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b0.shape1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b0.shape1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b0.shape1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b0.shape1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.b0.shape1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.b0.shape1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.b0.shape1.r[1](quantity = \"Length\", unit = \"m\") = mechanics.b0.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.b0.shape1.r[2](quantity = \"Length\", unit = \"m\") = mechanics.b0.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.b0.shape1.r[3](quantity = \"Length\", unit = \"m\") = mechanics.b0.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.b0.shape1.r_shape[1](quantity = \"Length\", unit = \"m\") = mechanics.b0.r_shape[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.b0.shape1.r_shape[2](quantity = \"Length\", unit = \"m\") = mechanics.b0.r_shape[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.b0.shape1.r_shape[3](quantity = \"Length\", unit = \"m\") = mechanics.b0.r_shape[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.b0.shape1.lengthDirection[1](unit = \"1\") = mechanics.b0.lengthDirection[1] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.b0.shape1.lengthDirection[2](unit = \"1\") = mechanics.b0.lengthDirection[2] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.b0.shape1.lengthDirection[3](unit = \"1\") = mechanics.b0.lengthDirection[3] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.b0.shape1.widthDirection[1](unit = \"1\") = mechanics.b0.widthDirection[1] \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.b0.shape1.widthDirection[2](unit = \"1\") = mechanics.b0.widthDirection[2] \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.b0.shape1.widthDirection[3](unit = \"1\") = mechanics.b0.widthDirection[3] \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.b0.shape1.length(quantity = \"Length\", unit = \"m\") = mechanics.b0.length \"Length of visual object\";
//   input Real mechanics.b0.shape1.width(quantity = \"Length\", unit = \"m\") = mechanics.b0.width \"Width of visual object\";
//   input Real mechanics.b0.shape1.height(quantity = \"Length\", unit = \"m\") = mechanics.b0.height \"Height of visual object\";
//   input Real mechanics.b0.shape1.extra = mechanics.b0.extra \"Additional size data for some of the shape types\";
//   input Real mechanics.b0.shape1.color[1] = Real(mechanics.b0.color[1]) \"Color of shape\";
//   input Real mechanics.b0.shape1.color[2] = Real(mechanics.b0.color[2]) \"Color of shape\";
//   input Real mechanics.b0.shape1.color[3] = Real(mechanics.b0.color[3]) \"Color of shape\";
//   input Real mechanics.b0.shape1.specularCoefficient = mechanics.b0.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real mechanics.b0.shape1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({mechanics.b0.shape1.lengthDirection[1],mechanics.b0.shape1.lengthDirection[2],mechanics.b0.shape1.lengthDirection[3]});
//   protected Real mechanics.b0.shape1.e_x[1](unit = \"1\") = if noEvent(mechanics.b0.shape1.abs_n_x < 1e-10) then 1.0 else mechanics.b0.shape1.lengthDirection[1] / mechanics.b0.shape1.abs_n_x;
//   protected Real mechanics.b0.shape1.e_x[2](unit = \"1\") = if noEvent(mechanics.b0.shape1.abs_n_x < 1e-10) then 0.0 else mechanics.b0.shape1.lengthDirection[2] / mechanics.b0.shape1.abs_n_x;
//   protected Real mechanics.b0.shape1.e_x[3](unit = \"1\") = if noEvent(mechanics.b0.shape1.abs_n_x < 1e-10) then 0.0 else mechanics.b0.shape1.lengthDirection[3] / mechanics.b0.shape1.abs_n_x;
//   protected Real mechanics.b0.shape1.n_z_aux[1](unit = \"1\") = mechanics.b0.shape1.e_x[2] * mechanics.b0.shape1.widthDirection[3] - mechanics.b0.shape1.e_x[3] * mechanics.b0.shape1.widthDirection[2];
//   protected Real mechanics.b0.shape1.n_z_aux[2](unit = \"1\") = mechanics.b0.shape1.e_x[3] * mechanics.b0.shape1.widthDirection[1] - mechanics.b0.shape1.e_x[1] * mechanics.b0.shape1.widthDirection[3];
//   protected Real mechanics.b0.shape1.n_z_aux[3](unit = \"1\") = mechanics.b0.shape1.e_x[1] * mechanics.b0.shape1.widthDirection[2] - mechanics.b0.shape1.e_x[2] * mechanics.b0.shape1.widthDirection[1];
//   protected Real mechanics.b0.shape1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.b0.shape1.e_x[1],mechanics.b0.shape1.e_x[2],mechanics.b0.shape1.e_x[3]},if noEvent(mechanics.b0.shape1.n_z_aux[1] ^ 2.0 + (mechanics.b0.shape1.n_z_aux[2] ^ 2.0 + mechanics.b0.shape1.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.b0.shape1.widthDirection[1],mechanics.b0.shape1.widthDirection[2],mechanics.b0.shape1.widthDirection[3]} else if noEvent(abs(mechanics.b0.shape1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.b0.shape1.e_x[1],mechanics.b0.shape1.e_x[2],mechanics.b0.shape1.e_x[3]})[1];
//   protected Real mechanics.b0.shape1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.b0.shape1.e_x[1],mechanics.b0.shape1.e_x[2],mechanics.b0.shape1.e_x[3]},if noEvent(mechanics.b0.shape1.n_z_aux[1] ^ 2.0 + (mechanics.b0.shape1.n_z_aux[2] ^ 2.0 + mechanics.b0.shape1.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.b0.shape1.widthDirection[1],mechanics.b0.shape1.widthDirection[2],mechanics.b0.shape1.widthDirection[3]} else if noEvent(abs(mechanics.b0.shape1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.b0.shape1.e_x[1],mechanics.b0.shape1.e_x[2],mechanics.b0.shape1.e_x[3]})[2];
//   protected Real mechanics.b0.shape1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.b0.shape1.e_x[1],mechanics.b0.shape1.e_x[2],mechanics.b0.shape1.e_x[3]},if noEvent(mechanics.b0.shape1.n_z_aux[1] ^ 2.0 + (mechanics.b0.shape1.n_z_aux[2] ^ 2.0 + mechanics.b0.shape1.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.b0.shape1.widthDirection[1],mechanics.b0.shape1.widthDirection[2],mechanics.b0.shape1.widthDirection[3]} else if noEvent(abs(mechanics.b0.shape1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.b0.shape1.e_x[1],mechanics.b0.shape1.e_x[2],mechanics.b0.shape1.e_x[3]})[3];
//   protected output Real mechanics.b0.shape1.Form;
//   output Real mechanics.b0.shape1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b0.shape1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b0.shape1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b0.shape1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b0.shape1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b0.shape1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b0.shape1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real mechanics.b0.shape1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real mechanics.b0.shape1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real mechanics.b0.shape1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.b0.shape1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.b0.shape1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.b0.shape1.Material;
//   protected output Real mechanics.b0.shape1.Extra;
//   parameter Real mechanics.b0.lengthDirection[1](unit = \"1\") = 1.0 \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b0.lengthDirection[2](unit = \"1\") = 0.0 \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b0.lengthDirection[3](unit = \"1\") = 0.0 \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b0.length(quantity = \"Length\", unit = \"m\") = 0.225 \" Length of shape\";
//   parameter Real mechanics.b0.width(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.3 \" Width of shape\";
//   parameter Real mechanics.b0.height(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.3 \" Height of shape.\";
//   parameter Real mechanics.b0.sphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 2.0 * mechanics.b0.width \" Diameter of sphere\";
//   Real mechanics.b1.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b1.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b1.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b1.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b1.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b1.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b1.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b1.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b1.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b1.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b1.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b1.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b1.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b1.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b1.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b1.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b1.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b1.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b1.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b1.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b1.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b1.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b1.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b1.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean mechanics.b1.animation = mechanics.animation \"= true, if animation shall be enabled (show shape between frame_a and frame_b and optionally a sphere at the center of mass)\";
//   parameter Boolean mechanics.b1.animateSphere = false \"= true, if mass shall be animated as sphere provided animation=true\";
//   parameter Real mechanics.b1.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b1.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.324 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b1.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.3 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b1.r_CM[1](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b1.r_CM[2](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b1.r_CM[3](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b1.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 1.0) = 1.0 \"Mass of rigid body\";
//   parameter Real mechanics.b1.I_11(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.001 \" (1,1) element of inertia tensor\";
//   parameter Real mechanics.b1.I_22(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 1.16 \" (2,2) element of inertia tensor\";
//   parameter Real mechanics.b1.I_33(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.001 \" (3,3) element of inertia tensor\";
//   parameter Real mechanics.b1.I_21(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (2,1) element of inertia tensor\";
//   parameter Real mechanics.b1.I_31(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (3,1) element of inertia tensor\";
//   parameter Real mechanics.b1.I_32(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (3,2) element of inertia tensor\";
//   Real mechanics.b1.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b1.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b1.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b1.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b1.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b1.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b1.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real mechanics.b1.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real mechanics.b1.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean mechanics.b1.angles_fixed = false \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b1.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real mechanics.b1.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real mechanics.b1.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer mechanics.b1.sequence_start[1](min = 1, max = 3) = 1 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer mechanics.b1.sequence_start[2](min = 1, max = 3) = 2 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer mechanics.b1.sequence_start[3](min = 1, max = 3) = 3 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean mechanics.b1.w_0_fixed = false \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b1.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real mechanics.b1.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real mechanics.b1.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean mechanics.b1.z_0_fixed = false \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b1.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b1.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b1.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter String mechanics.b1.shapeType = \"1\" \" Type of shape\";
//   parameter Real mechanics.b1.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b1.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b1.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b1.widthDirection[1](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b1.widthDirection[2](unit = \"1\") = 1.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b1.widthDirection[3](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b1.extra = 0.0 \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer mechanics.b1.color[1](min = 0, max = 255) = 255 \" Color of shape\";
//   input Integer mechanics.b1.color[2](min = 0, max = 255) = 0 \" Color of shape\";
//   input Integer mechanics.b1.color[3](min = 0, max = 255) = 0 \" Color of shape\";
//   input Integer mechanics.b1.sphereColor[1](min = 0, max = 255) = mechanics.b1.color[1] \" Color of sphere of mass\";
//   input Integer mechanics.b1.sphereColor[2](min = 0, max = 255) = mechanics.b1.color[2] \" Color of sphere of mass\";
//   input Integer mechanics.b1.sphereColor[3](min = 0, max = 255) = mechanics.b1.color[3] \" Color of sphere of mass\";
//   input Real mechanics.b1.specularCoefficient = mechanics.world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean mechanics.b1.enforceStates = false \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean mechanics.b1.useQuaternions = true \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer mechanics.b1.sequence_angleStates[1](min = 1, max = 3) = 1 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer mechanics.b1.sequence_angleStates[2](min = 1, max = 3) = 2 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer mechanics.b1.sequence_angleStates[3](min = 1, max = 3) = 3 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   Real mechanics.b1.frameTranslation.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b1.frameTranslation.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b1.frameTranslation.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b1.frameTranslation.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frameTranslation.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frameTranslation.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frameTranslation.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frameTranslation.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frameTranslation.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frameTranslation.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frameTranslation.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frameTranslation.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frameTranslation.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b1.frameTranslation.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b1.frameTranslation.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b1.frameTranslation.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b1.frameTranslation.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b1.frameTranslation.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b1.frameTranslation.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b1.frameTranslation.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b1.frameTranslation.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b1.frameTranslation.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b1.frameTranslation.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b1.frameTranslation.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b1.frameTranslation.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frameTranslation.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frameTranslation.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frameTranslation.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frameTranslation.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frameTranslation.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frameTranslation.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frameTranslation.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frameTranslation.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.frameTranslation.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b1.frameTranslation.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b1.frameTranslation.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b1.frameTranslation.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b1.frameTranslation.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b1.frameTranslation.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b1.frameTranslation.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b1.frameTranslation.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b1.frameTranslation.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean mechanics.b1.frameTranslation.animation = false \"= true, if animation shall be enabled\";
//   parameter Real mechanics.b1.frameTranslation.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b1.r[1] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b1.frameTranslation.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b1.r[2] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b1.frameTranslation.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b1.r[3] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter String mechanics.b1.frameTranslation.shapeType = \"cylinder\" \" Type of shape\";
//   parameter Real mechanics.b1.frameTranslation.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b1.frameTranslation.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b1.frameTranslation.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b1.frameTranslation.widthDirection[1](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b1.frameTranslation.widthDirection[2](unit = \"1\") = 1.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b1.frameTranslation.widthDirection[3](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b1.frameTranslation.extra = 0.0 \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer mechanics.b1.frameTranslation.color[1](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer mechanics.b1.frameTranslation.color[2](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer mechanics.b1.frameTranslation.color[3](min = 0, max = 255) = 155 \" Color of shape\";
//   input Real mechanics.b1.frameTranslation.specularCoefficient = mechanics.world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Real mechanics.b1.frameTranslation.lengthDirection[1](unit = \"1\") = mechanics.b1.frameTranslation.r[1] - mechanics.b1.frameTranslation.r_shape[1] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b1.frameTranslation.lengthDirection[2](unit = \"1\") = mechanics.b1.frameTranslation.r[2] - mechanics.b1.frameTranslation.r_shape[2] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b1.frameTranslation.lengthDirection[3](unit = \"1\") = mechanics.b1.frameTranslation.r[3] - mechanics.b1.frameTranslation.r_shape[3] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b1.frameTranslation.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({mechanics.b1.frameTranslation.r[1] - mechanics.b1.frameTranslation.r_shape[1],mechanics.b1.frameTranslation.r[2] - mechanics.b1.frameTranslation.r_shape[2],mechanics.b1.frameTranslation.r[3] - mechanics.b1.frameTranslation.r_shape[3]}) \" Length of shape\";
//   parameter Real mechanics.b1.frameTranslation.width(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.b1.frameTranslation.length / mechanics.world.defaultWidthFraction \" Width of shape\";
//   parameter Real mechanics.b1.frameTranslation.height(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.b1.frameTranslation.width \" Height of shape.\";
//   Real mechanics.b1.body.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b1.body.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b1.body.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b1.body.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.body.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.body.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.body.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.body.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.body.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.body.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.body.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.body.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b1.body.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b1.body.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b1.body.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b1.body.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b1.body.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b1.body.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b1.body.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b1.body.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b1.body.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean mechanics.b1.body.animation = false \"= true, if animation shall be enabled (show cylinder and sphere)\";
//   parameter Real mechanics.b1.body.r_CM[1](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b1.r_CM[1] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b1.body.r_CM[2](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b1.r_CM[2] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b1.body.r_CM[3](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b1.r_CM[3] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b1.body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 1.0) = mechanics.b1.m \"Mass of rigid body\";
//   parameter Real mechanics.b1.body.I_11(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = mechanics.b1.I_11 \" (1,1) element of inertia tensor\";
//   parameter Real mechanics.b1.body.I_22(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = mechanics.b1.I_22 \" (2,2) element of inertia tensor\";
//   parameter Real mechanics.b1.body.I_33(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = mechanics.b1.I_33 \" (3,3) element of inertia tensor\";
//   parameter Real mechanics.b1.body.I_21(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = mechanics.b1.I_21 \" (2,1) element of inertia tensor\";
//   parameter Real mechanics.b1.body.I_31(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = mechanics.b1.I_31 \" (3,1) element of inertia tensor\";
//   parameter Real mechanics.b1.body.I_32(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = mechanics.b1.I_32 \" (3,2) element of inertia tensor\";
//   Real mechanics.b1.body.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b1.body.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b1.body.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b1.body.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b1.body.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b1.body.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b1.body.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real mechanics.b1.body.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real mechanics.b1.body.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean mechanics.b1.body.angles_fixed = mechanics.b1.angles_fixed \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b1.body.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = mechanics.b1.angles_start[1] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real mechanics.b1.body.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = mechanics.b1.angles_start[2] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real mechanics.b1.body.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = mechanics.b1.angles_start[3] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer mechanics.b1.body.sequence_start[1](min = 1, max = 3) = mechanics.b1.sequence_start[1] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer mechanics.b1.body.sequence_start[2](min = 1, max = 3) = mechanics.b1.sequence_start[2] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer mechanics.b1.body.sequence_start[3](min = 1, max = 3) = mechanics.b1.sequence_start[3] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean mechanics.b1.body.w_0_fixed = mechanics.b1.w_0_fixed \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b1.body.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = mechanics.b1.w_0_start[1] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real mechanics.b1.body.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = mechanics.b1.w_0_start[2] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real mechanics.b1.body.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = mechanics.b1.w_0_start[3] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean mechanics.b1.body.z_0_fixed = mechanics.b1.z_0_fixed \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b1.body.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = mechanics.b1.z_0_start[1] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b1.body.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = mechanics.b1.z_0_start[2] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b1.body.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = mechanics.b1.z_0_start[3] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b1.body.sphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.world.defaultBodyDiameter \"Diameter of sphere\";
//   input Integer mechanics.b1.body.sphereColor[1](min = 0, max = 255) = 0 \"Color of sphere\";
//   input Integer mechanics.b1.body.sphereColor[2](min = 0, max = 255) = 128 \"Color of sphere\";
//   input Integer mechanics.b1.body.sphereColor[3](min = 0, max = 255) = 255 \"Color of sphere\";
//   input Integer mechanics.b1.body.cylinderColor[1](min = 0, max = 255) = mechanics.b1.body.sphereColor[1] \"Color of cylinder\";
//   input Integer mechanics.b1.body.cylinderColor[2](min = 0, max = 255) = mechanics.b1.body.sphereColor[2] \"Color of cylinder\";
//   input Integer mechanics.b1.body.cylinderColor[3](min = 0, max = 255) = mechanics.b1.body.sphereColor[3] \"Color of cylinder\";
//   input Real mechanics.b1.body.specularCoefficient = mechanics.world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean mechanics.b1.body.enforceStates = mechanics.b1.enforceStates \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean mechanics.b1.body.useQuaternions = mechanics.b1.useQuaternions \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer mechanics.b1.body.sequence_angleStates[1](min = 1, max = 3) = mechanics.b1.sequence_angleStates[1] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer mechanics.b1.body.sequence_angleStates[2](min = 1, max = 3) = mechanics.b1.sequence_angleStates[2] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer mechanics.b1.body.sequence_angleStates[3](min = 1, max = 3) = mechanics.b1.sequence_angleStates[3] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   Real mechanics.b1.body.w_a[1](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b1.body.R_start,{mechanics.b1.body.w_0_start[1],mechanics.b1.body.w_0_start[2],mechanics.b1.body.w_0_start[3]})[1], fixed = mechanics.b1.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real mechanics.b1.body.w_a[2](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b1.body.R_start,{mechanics.b1.body.w_0_start[1],mechanics.b1.body.w_0_start[2],mechanics.b1.body.w_0_start[3]})[2], fixed = mechanics.b1.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real mechanics.b1.body.w_a[3](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b1.body.R_start,{mechanics.b1.body.w_0_start[1],mechanics.b1.body.w_0_start[2],mechanics.b1.body.w_0_start[3]})[3], fixed = mechanics.b1.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real mechanics.b1.body.z_a[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b1.body.R_start,{mechanics.b1.body.z_0_start[1],mechanics.b1.body.z_0_start[2],mechanics.b1.body.z_0_start[3]})[1], fixed = mechanics.b1.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real mechanics.b1.body.z_a[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b1.body.R_start,{mechanics.b1.body.z_0_start[1],mechanics.b1.body.z_0_start[2],mechanics.b1.body.z_0_start[3]})[2], fixed = mechanics.b1.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real mechanics.b1.body.z_a[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b1.body.R_start,{mechanics.b1.body.z_0_start[1],mechanics.b1.body.z_0_start[2],mechanics.b1.body.z_0_start[3]})[3], fixed = mechanics.b1.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real mechanics.b1.body.g_0[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real mechanics.b1.body.g_0[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real mechanics.b1.body.g_0[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   protected Real mechanics.b1.body.Q[1](start = mechanics.b1.body.Q_start[1], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real mechanics.b1.body.Q[2](start = mechanics.b1.body.Q_start[2], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real mechanics.b1.body.Q[3](start = mechanics.b1.body.Q_start[3], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real mechanics.b1.body.Q[4](start = mechanics.b1.body.Q_start[4], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real mechanics.b1.body.phi[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = mechanics.b1.body.phi_start[1], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real mechanics.b1.body.phi[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = mechanics.b1.body.phi_start[2], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real mechanics.b1.body.phi[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = mechanics.b1.body.phi_start[3], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real mechanics.b1.body.phi_d[1](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real mechanics.b1.body.phi_d[2](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real mechanics.b1.body.phi_d[3](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real mechanics.b1.body.phi_dd[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real mechanics.b1.body.phi_dd[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real mechanics.b1.body.phi_dd[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   final parameter Real mechanics.b1.body.I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b1.body.I_11 \"inertia tensor\";
//   final parameter Real mechanics.b1.body.I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b1.body.I_21 \"inertia tensor\";
//   final parameter Real mechanics.b1.body.I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b1.body.I_31 \"inertia tensor\";
//   final parameter Real mechanics.b1.body.I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b1.body.I_21 \"inertia tensor\";
//   final parameter Real mechanics.b1.body.I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b1.body.I_22 \"inertia tensor\";
//   final parameter Real mechanics.b1.body.I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b1.body.I_32 \"inertia tensor\";
//   final parameter Real mechanics.b1.body.I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b1.body.I_31 \"inertia tensor\";
//   final parameter Real mechanics.b1.body.I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b1.body.I_32 \"inertia tensor\";
//   final parameter Real mechanics.b1.body.I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b1.body.I_33 \"inertia tensor\";
//   final parameter Real mechanics.b1.body.R_start.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b1.body.R_start.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b1.body.R_start.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b1.body.R_start.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b1.body.R_start.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b1.body.R_start.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b1.body.R_start.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b1.body.R_start.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b1.body.R_start.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b1.body.R_start.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   final parameter Real mechanics.b1.body.R_start.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   final parameter Real mechanics.b1.body.R_start.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real mechanics.b1.body.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.b1.body.sphereDiameter / 3.0 \"Diameter of cylinder\";
//   final parameter Real mechanics.b1.body.z_a_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b1.body.R_start,{mechanics.b1.body.z_0_start[1],mechanics.b1.body.z_0_start[2],mechanics.b1.body.z_0_start[3]})[1] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   final parameter Real mechanics.b1.body.z_a_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b1.body.R_start,{mechanics.b1.body.z_0_start[1],mechanics.b1.body.z_0_start[2],mechanics.b1.body.z_0_start[3]})[2] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   final parameter Real mechanics.b1.body.z_a_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b1.body.R_start,{mechanics.b1.body.z_0_start[1],mechanics.b1.body.z_0_start[2],mechanics.b1.body.z_0_start[3]})[3] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   protected parameter Real mechanics.b1.body.Q_start[1] = Modelica.Mechanics.MultiBody.Frames.to_Q(mechanics.b1.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[1] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real mechanics.b1.body.Q_start[2] = Modelica.Mechanics.MultiBody.Frames.to_Q(mechanics.b1.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[2] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real mechanics.b1.body.Q_start[3] = Modelica.Mechanics.MultiBody.Frames.to_Q(mechanics.b1.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[3] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real mechanics.b1.body.Q_start[4] = Modelica.Mechanics.MultiBody.Frames.to_Q(mechanics.b1.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[4] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real mechanics.b1.body.phi_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if mechanics.b1.body.sequence_start[1] == mechanics.b1.body.sequence_angleStates[1] and mechanics.b1.body.sequence_start[2] == mechanics.b1.body.sequence_angleStates[2] and mechanics.b1.body.sequence_start[3] == mechanics.b1.body.sequence_angleStates[3] then mechanics.b1.body.angles_start[1] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(mechanics.b1.body.R_start,{mechanics.b1.body.sequence_angleStates[1],mechanics.b1.body.sequence_angleStates[2],mechanics.b1.body.sequence_angleStates[3]},0.0)[1] \"Potential angle states at initial time\";
//   protected parameter Real mechanics.b1.body.phi_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if mechanics.b1.body.sequence_start[1] == mechanics.b1.body.sequence_angleStates[1] and mechanics.b1.body.sequence_start[2] == mechanics.b1.body.sequence_angleStates[2] and mechanics.b1.body.sequence_start[3] == mechanics.b1.body.sequence_angleStates[3] then mechanics.b1.body.angles_start[2] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(mechanics.b1.body.R_start,{mechanics.b1.body.sequence_angleStates[1],mechanics.b1.body.sequence_angleStates[2],mechanics.b1.body.sequence_angleStates[3]},0.0)[2] \"Potential angle states at initial time\";
//   protected parameter Real mechanics.b1.body.phi_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if mechanics.b1.body.sequence_start[1] == mechanics.b1.body.sequence_angleStates[1] and mechanics.b1.body.sequence_start[2] == mechanics.b1.body.sequence_angleStates[2] and mechanics.b1.body.sequence_start[3] == mechanics.b1.body.sequence_angleStates[3] then mechanics.b1.body.angles_start[3] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(mechanics.b1.body.R_start,{mechanics.b1.body.sequence_angleStates[1],mechanics.b1.body.sequence_angleStates[2],mechanics.b1.body.sequence_angleStates[3]},0.0)[3] \"Potential angle states at initial time\";
//   parameter String mechanics.b1.shape1.shapeType = mechanics.b1.shapeType \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real mechanics.b1.shape1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b1.shape1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b1.shape1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b1.shape1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b1.shape1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b1.shape1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b1.shape1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b1.shape1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b1.shape1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b1.shape1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.b1.shape1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.b1.shape1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.b1.shape1.r[1](quantity = \"Length\", unit = \"m\") = mechanics.b1.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.b1.shape1.r[2](quantity = \"Length\", unit = \"m\") = mechanics.b1.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.b1.shape1.r[3](quantity = \"Length\", unit = \"m\") = mechanics.b1.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.b1.shape1.r_shape[1](quantity = \"Length\", unit = \"m\") = mechanics.b1.r_shape[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.b1.shape1.r_shape[2](quantity = \"Length\", unit = \"m\") = mechanics.b1.r_shape[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.b1.shape1.r_shape[3](quantity = \"Length\", unit = \"m\") = mechanics.b1.r_shape[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.b1.shape1.lengthDirection[1](unit = \"1\") = mechanics.b1.lengthDirection[1] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.b1.shape1.lengthDirection[2](unit = \"1\") = mechanics.b1.lengthDirection[2] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.b1.shape1.lengthDirection[3](unit = \"1\") = mechanics.b1.lengthDirection[3] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.b1.shape1.widthDirection[1](unit = \"1\") = mechanics.b1.widthDirection[1] \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.b1.shape1.widthDirection[2](unit = \"1\") = mechanics.b1.widthDirection[2] \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.b1.shape1.widthDirection[3](unit = \"1\") = mechanics.b1.widthDirection[3] \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.b1.shape1.length(quantity = \"Length\", unit = \"m\") = mechanics.b1.length \"Length of visual object\";
//   input Real mechanics.b1.shape1.width(quantity = \"Length\", unit = \"m\") = mechanics.b1.width \"Width of visual object\";
//   input Real mechanics.b1.shape1.height(quantity = \"Length\", unit = \"m\") = mechanics.b1.height \"Height of visual object\";
//   input Real mechanics.b1.shape1.extra = mechanics.b1.extra \"Additional size data for some of the shape types\";
//   input Real mechanics.b1.shape1.color[1] = Real(mechanics.b1.color[1]) \"Color of shape\";
//   input Real mechanics.b1.shape1.color[2] = Real(mechanics.b1.color[2]) \"Color of shape\";
//   input Real mechanics.b1.shape1.color[3] = Real(mechanics.b1.color[3]) \"Color of shape\";
//   input Real mechanics.b1.shape1.specularCoefficient = mechanics.b1.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real mechanics.b1.shape1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({mechanics.b1.shape1.lengthDirection[1],mechanics.b1.shape1.lengthDirection[2],mechanics.b1.shape1.lengthDirection[3]});
//   protected Real mechanics.b1.shape1.e_x[1](unit = \"1\") = if noEvent(mechanics.b1.shape1.abs_n_x < 1e-10) then 1.0 else mechanics.b1.shape1.lengthDirection[1] / mechanics.b1.shape1.abs_n_x;
//   protected Real mechanics.b1.shape1.e_x[2](unit = \"1\") = if noEvent(mechanics.b1.shape1.abs_n_x < 1e-10) then 0.0 else mechanics.b1.shape1.lengthDirection[2] / mechanics.b1.shape1.abs_n_x;
//   protected Real mechanics.b1.shape1.e_x[3](unit = \"1\") = if noEvent(mechanics.b1.shape1.abs_n_x < 1e-10) then 0.0 else mechanics.b1.shape1.lengthDirection[3] / mechanics.b1.shape1.abs_n_x;
//   protected Real mechanics.b1.shape1.n_z_aux[1](unit = \"1\") = mechanics.b1.shape1.e_x[2] * mechanics.b1.shape1.widthDirection[3] - mechanics.b1.shape1.e_x[3] * mechanics.b1.shape1.widthDirection[2];
//   protected Real mechanics.b1.shape1.n_z_aux[2](unit = \"1\") = mechanics.b1.shape1.e_x[3] * mechanics.b1.shape1.widthDirection[1] - mechanics.b1.shape1.e_x[1] * mechanics.b1.shape1.widthDirection[3];
//   protected Real mechanics.b1.shape1.n_z_aux[3](unit = \"1\") = mechanics.b1.shape1.e_x[1] * mechanics.b1.shape1.widthDirection[2] - mechanics.b1.shape1.e_x[2] * mechanics.b1.shape1.widthDirection[1];
//   protected Real mechanics.b1.shape1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.b1.shape1.e_x[1],mechanics.b1.shape1.e_x[2],mechanics.b1.shape1.e_x[3]},if noEvent(mechanics.b1.shape1.n_z_aux[1] ^ 2.0 + (mechanics.b1.shape1.n_z_aux[2] ^ 2.0 + mechanics.b1.shape1.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.b1.shape1.widthDirection[1],mechanics.b1.shape1.widthDirection[2],mechanics.b1.shape1.widthDirection[3]} else if noEvent(abs(mechanics.b1.shape1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.b1.shape1.e_x[1],mechanics.b1.shape1.e_x[2],mechanics.b1.shape1.e_x[3]})[1];
//   protected Real mechanics.b1.shape1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.b1.shape1.e_x[1],mechanics.b1.shape1.e_x[2],mechanics.b1.shape1.e_x[3]},if noEvent(mechanics.b1.shape1.n_z_aux[1] ^ 2.0 + (mechanics.b1.shape1.n_z_aux[2] ^ 2.0 + mechanics.b1.shape1.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.b1.shape1.widthDirection[1],mechanics.b1.shape1.widthDirection[2],mechanics.b1.shape1.widthDirection[3]} else if noEvent(abs(mechanics.b1.shape1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.b1.shape1.e_x[1],mechanics.b1.shape1.e_x[2],mechanics.b1.shape1.e_x[3]})[2];
//   protected Real mechanics.b1.shape1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.b1.shape1.e_x[1],mechanics.b1.shape1.e_x[2],mechanics.b1.shape1.e_x[3]},if noEvent(mechanics.b1.shape1.n_z_aux[1] ^ 2.0 + (mechanics.b1.shape1.n_z_aux[2] ^ 2.0 + mechanics.b1.shape1.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.b1.shape1.widthDirection[1],mechanics.b1.shape1.widthDirection[2],mechanics.b1.shape1.widthDirection[3]} else if noEvent(abs(mechanics.b1.shape1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.b1.shape1.e_x[1],mechanics.b1.shape1.e_x[2],mechanics.b1.shape1.e_x[3]})[3];
//   protected output Real mechanics.b1.shape1.Form;
//   output Real mechanics.b1.shape1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b1.shape1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b1.shape1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b1.shape1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b1.shape1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b1.shape1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b1.shape1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real mechanics.b1.shape1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real mechanics.b1.shape1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real mechanics.b1.shape1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.b1.shape1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.b1.shape1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.b1.shape1.Material;
//   protected output Real mechanics.b1.shape1.Extra;
//   parameter Real mechanics.b1.lengthDirection[1](unit = \"1\") = 1.0 \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b1.lengthDirection[2](unit = \"1\") = 0.0 \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b1.lengthDirection[3](unit = \"1\") = 0.0 \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b1.length(quantity = \"Length\", unit = \"m\") = 0.25 \" Length of shape\";
//   parameter Real mechanics.b1.width(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.15 \" Width of shape\";
//   parameter Real mechanics.b1.height(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.2 \" Height of shape.\";
//   parameter Real mechanics.b1.sphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 2.0 * mechanics.b1.width \" Diameter of sphere\";
//   Real mechanics.b2.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b2.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b2.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b2.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b2.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b2.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b2.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b2.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b2.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b2.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b2.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b2.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b2.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b2.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b2.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b2.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b2.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b2.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b2.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b2.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b2.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b2.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b2.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b2.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean mechanics.b2.animation = mechanics.animation \"= true, if animation shall be enabled (show shape between frame_a and frame_b and optionally a sphere at the center of mass)\";
//   parameter Boolean mechanics.b2.animateSphere = false \"= true, if mass shall be animated as sphere provided animation=true\";
//   parameter Real mechanics.b2.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b2.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.65 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b2.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b2.r_CM[1](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.172 \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b2.r_CM[2](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.205 \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b2.r_CM[3](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b2.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 1.0) = 56.5 \"Mass of rigid body\";
//   parameter Real mechanics.b2.I_11(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 2.58 \" (1,1) element of inertia tensor\";
//   parameter Real mechanics.b2.I_22(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.64 \" (2,2) element of inertia tensor\";
//   parameter Real mechanics.b2.I_33(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 2.73 \" (3,3) element of inertia tensor\";
//   parameter Real mechanics.b2.I_21(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = -0.46 \" (2,1) element of inertia tensor\";
//   parameter Real mechanics.b2.I_31(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (3,1) element of inertia tensor\";
//   parameter Real mechanics.b2.I_32(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (3,2) element of inertia tensor\";
//   Real mechanics.b2.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b2.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b2.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b2.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b2.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b2.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b2.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real mechanics.b2.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real mechanics.b2.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean mechanics.b2.angles_fixed = false \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b2.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real mechanics.b2.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real mechanics.b2.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer mechanics.b2.sequence_start[1](min = 1, max = 3) = 1 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer mechanics.b2.sequence_start[2](min = 1, max = 3) = 2 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer mechanics.b2.sequence_start[3](min = 1, max = 3) = 3 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean mechanics.b2.w_0_fixed = false \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b2.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real mechanics.b2.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real mechanics.b2.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean mechanics.b2.z_0_fixed = false \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b2.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b2.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b2.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter String mechanics.b2.shapeType = \"2\" \" Type of shape\";
//   parameter Real mechanics.b2.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b2.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b2.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b2.widthDirection[1](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b2.widthDirection[2](unit = \"1\") = 1.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b2.widthDirection[3](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b2.extra = 0.0 \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer mechanics.b2.color[1](min = 0, max = 255) = 255 \" Color of shape\";
//   input Integer mechanics.b2.color[2](min = 0, max = 255) = 178 \" Color of shape\";
//   input Integer mechanics.b2.color[3](min = 0, max = 255) = 0 \" Color of shape\";
//   input Integer mechanics.b2.sphereColor[1](min = 0, max = 255) = mechanics.b2.color[1] \" Color of sphere of mass\";
//   input Integer mechanics.b2.sphereColor[2](min = 0, max = 255) = mechanics.b2.color[2] \" Color of sphere of mass\";
//   input Integer mechanics.b2.sphereColor[3](min = 0, max = 255) = mechanics.b2.color[3] \" Color of sphere of mass\";
//   input Real mechanics.b2.specularCoefficient = mechanics.world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean mechanics.b2.enforceStates = false \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean mechanics.b2.useQuaternions = true \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer mechanics.b2.sequence_angleStates[1](min = 1, max = 3) = 1 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer mechanics.b2.sequence_angleStates[2](min = 1, max = 3) = 2 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer mechanics.b2.sequence_angleStates[3](min = 1, max = 3) = 3 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   Real mechanics.b2.frameTranslation.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b2.frameTranslation.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b2.frameTranslation.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b2.frameTranslation.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frameTranslation.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frameTranslation.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frameTranslation.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frameTranslation.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frameTranslation.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frameTranslation.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frameTranslation.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frameTranslation.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frameTranslation.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b2.frameTranslation.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b2.frameTranslation.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b2.frameTranslation.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b2.frameTranslation.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b2.frameTranslation.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b2.frameTranslation.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b2.frameTranslation.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b2.frameTranslation.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b2.frameTranslation.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b2.frameTranslation.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b2.frameTranslation.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b2.frameTranslation.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frameTranslation.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frameTranslation.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frameTranslation.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frameTranslation.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frameTranslation.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frameTranslation.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frameTranslation.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frameTranslation.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.frameTranslation.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b2.frameTranslation.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b2.frameTranslation.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b2.frameTranslation.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b2.frameTranslation.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b2.frameTranslation.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b2.frameTranslation.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b2.frameTranslation.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b2.frameTranslation.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean mechanics.b2.frameTranslation.animation = false \"= true, if animation shall be enabled\";
//   parameter Real mechanics.b2.frameTranslation.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b2.r[1] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b2.frameTranslation.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b2.r[2] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b2.frameTranslation.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b2.r[3] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter String mechanics.b2.frameTranslation.shapeType = \"cylinder\" \" Type of shape\";
//   parameter Real mechanics.b2.frameTranslation.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b2.frameTranslation.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b2.frameTranslation.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b2.frameTranslation.widthDirection[1](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b2.frameTranslation.widthDirection[2](unit = \"1\") = 1.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b2.frameTranslation.widthDirection[3](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b2.frameTranslation.extra = 0.0 \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer mechanics.b2.frameTranslation.color[1](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer mechanics.b2.frameTranslation.color[2](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer mechanics.b2.frameTranslation.color[3](min = 0, max = 255) = 155 \" Color of shape\";
//   input Real mechanics.b2.frameTranslation.specularCoefficient = mechanics.world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Real mechanics.b2.frameTranslation.lengthDirection[1](unit = \"1\") = mechanics.b2.frameTranslation.r[1] - mechanics.b2.frameTranslation.r_shape[1] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b2.frameTranslation.lengthDirection[2](unit = \"1\") = mechanics.b2.frameTranslation.r[2] - mechanics.b2.frameTranslation.r_shape[2] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b2.frameTranslation.lengthDirection[3](unit = \"1\") = mechanics.b2.frameTranslation.r[3] - mechanics.b2.frameTranslation.r_shape[3] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b2.frameTranslation.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({mechanics.b2.frameTranslation.r[1] - mechanics.b2.frameTranslation.r_shape[1],mechanics.b2.frameTranslation.r[2] - mechanics.b2.frameTranslation.r_shape[2],mechanics.b2.frameTranslation.r[3] - mechanics.b2.frameTranslation.r_shape[3]}) \" Length of shape\";
//   parameter Real mechanics.b2.frameTranslation.width(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.b2.frameTranslation.length / mechanics.world.defaultWidthFraction \" Width of shape\";
//   parameter Real mechanics.b2.frameTranslation.height(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.b2.frameTranslation.width \" Height of shape.\";
//   Real mechanics.b2.body.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b2.body.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b2.body.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b2.body.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.body.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.body.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.body.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.body.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.body.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.body.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.body.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.body.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b2.body.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b2.body.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b2.body.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b2.body.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b2.body.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b2.body.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b2.body.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b2.body.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b2.body.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean mechanics.b2.body.animation = false \"= true, if animation shall be enabled (show cylinder and sphere)\";
//   parameter Real mechanics.b2.body.r_CM[1](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b2.r_CM[1] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b2.body.r_CM[2](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b2.r_CM[2] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b2.body.r_CM[3](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b2.r_CM[3] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b2.body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 1.0) = mechanics.b2.m \"Mass of rigid body\";
//   parameter Real mechanics.b2.body.I_11(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = mechanics.b2.I_11 \" (1,1) element of inertia tensor\";
//   parameter Real mechanics.b2.body.I_22(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = mechanics.b2.I_22 \" (2,2) element of inertia tensor\";
//   parameter Real mechanics.b2.body.I_33(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = mechanics.b2.I_33 \" (3,3) element of inertia tensor\";
//   parameter Real mechanics.b2.body.I_21(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = mechanics.b2.I_21 \" (2,1) element of inertia tensor\";
//   parameter Real mechanics.b2.body.I_31(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = mechanics.b2.I_31 \" (3,1) element of inertia tensor\";
//   parameter Real mechanics.b2.body.I_32(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = mechanics.b2.I_32 \" (3,2) element of inertia tensor\";
//   Real mechanics.b2.body.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b2.body.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b2.body.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b2.body.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b2.body.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b2.body.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b2.body.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real mechanics.b2.body.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real mechanics.b2.body.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean mechanics.b2.body.angles_fixed = mechanics.b2.angles_fixed \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b2.body.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = mechanics.b2.angles_start[1] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real mechanics.b2.body.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = mechanics.b2.angles_start[2] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real mechanics.b2.body.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = mechanics.b2.angles_start[3] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer mechanics.b2.body.sequence_start[1](min = 1, max = 3) = mechanics.b2.sequence_start[1] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer mechanics.b2.body.sequence_start[2](min = 1, max = 3) = mechanics.b2.sequence_start[2] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer mechanics.b2.body.sequence_start[3](min = 1, max = 3) = mechanics.b2.sequence_start[3] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean mechanics.b2.body.w_0_fixed = mechanics.b2.w_0_fixed \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b2.body.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = mechanics.b2.w_0_start[1] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real mechanics.b2.body.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = mechanics.b2.w_0_start[2] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real mechanics.b2.body.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = mechanics.b2.w_0_start[3] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean mechanics.b2.body.z_0_fixed = mechanics.b2.z_0_fixed \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b2.body.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = mechanics.b2.z_0_start[1] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b2.body.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = mechanics.b2.z_0_start[2] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b2.body.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = mechanics.b2.z_0_start[3] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b2.body.sphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.world.defaultBodyDiameter \"Diameter of sphere\";
//   input Integer mechanics.b2.body.sphereColor[1](min = 0, max = 255) = 0 \"Color of sphere\";
//   input Integer mechanics.b2.body.sphereColor[2](min = 0, max = 255) = 128 \"Color of sphere\";
//   input Integer mechanics.b2.body.sphereColor[3](min = 0, max = 255) = 255 \"Color of sphere\";
//   input Integer mechanics.b2.body.cylinderColor[1](min = 0, max = 255) = mechanics.b2.body.sphereColor[1] \"Color of cylinder\";
//   input Integer mechanics.b2.body.cylinderColor[2](min = 0, max = 255) = mechanics.b2.body.sphereColor[2] \"Color of cylinder\";
//   input Integer mechanics.b2.body.cylinderColor[3](min = 0, max = 255) = mechanics.b2.body.sphereColor[3] \"Color of cylinder\";
//   input Real mechanics.b2.body.specularCoefficient = mechanics.world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean mechanics.b2.body.enforceStates = mechanics.b2.enforceStates \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean mechanics.b2.body.useQuaternions = mechanics.b2.useQuaternions \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer mechanics.b2.body.sequence_angleStates[1](min = 1, max = 3) = mechanics.b2.sequence_angleStates[1] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer mechanics.b2.body.sequence_angleStates[2](min = 1, max = 3) = mechanics.b2.sequence_angleStates[2] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer mechanics.b2.body.sequence_angleStates[3](min = 1, max = 3) = mechanics.b2.sequence_angleStates[3] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   Real mechanics.b2.body.w_a[1](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b2.body.R_start,{mechanics.b2.body.w_0_start[1],mechanics.b2.body.w_0_start[2],mechanics.b2.body.w_0_start[3]})[1], fixed = mechanics.b2.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real mechanics.b2.body.w_a[2](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b2.body.R_start,{mechanics.b2.body.w_0_start[1],mechanics.b2.body.w_0_start[2],mechanics.b2.body.w_0_start[3]})[2], fixed = mechanics.b2.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real mechanics.b2.body.w_a[3](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b2.body.R_start,{mechanics.b2.body.w_0_start[1],mechanics.b2.body.w_0_start[2],mechanics.b2.body.w_0_start[3]})[3], fixed = mechanics.b2.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real mechanics.b2.body.z_a[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b2.body.R_start,{mechanics.b2.body.z_0_start[1],mechanics.b2.body.z_0_start[2],mechanics.b2.body.z_0_start[3]})[1], fixed = mechanics.b2.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real mechanics.b2.body.z_a[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b2.body.R_start,{mechanics.b2.body.z_0_start[1],mechanics.b2.body.z_0_start[2],mechanics.b2.body.z_0_start[3]})[2], fixed = mechanics.b2.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real mechanics.b2.body.z_a[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b2.body.R_start,{mechanics.b2.body.z_0_start[1],mechanics.b2.body.z_0_start[2],mechanics.b2.body.z_0_start[3]})[3], fixed = mechanics.b2.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real mechanics.b2.body.g_0[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real mechanics.b2.body.g_0[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real mechanics.b2.body.g_0[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   protected Real mechanics.b2.body.Q[1](start = mechanics.b2.body.Q_start[1], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real mechanics.b2.body.Q[2](start = mechanics.b2.body.Q_start[2], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real mechanics.b2.body.Q[3](start = mechanics.b2.body.Q_start[3], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real mechanics.b2.body.Q[4](start = mechanics.b2.body.Q_start[4], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real mechanics.b2.body.phi[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = mechanics.b2.body.phi_start[1], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real mechanics.b2.body.phi[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = mechanics.b2.body.phi_start[2], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real mechanics.b2.body.phi[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = mechanics.b2.body.phi_start[3], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real mechanics.b2.body.phi_d[1](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real mechanics.b2.body.phi_d[2](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real mechanics.b2.body.phi_d[3](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real mechanics.b2.body.phi_dd[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real mechanics.b2.body.phi_dd[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real mechanics.b2.body.phi_dd[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   final parameter Real mechanics.b2.body.I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b2.body.I_11 \"inertia tensor\";
//   final parameter Real mechanics.b2.body.I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b2.body.I_21 \"inertia tensor\";
//   final parameter Real mechanics.b2.body.I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b2.body.I_31 \"inertia tensor\";
//   final parameter Real mechanics.b2.body.I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b2.body.I_21 \"inertia tensor\";
//   final parameter Real mechanics.b2.body.I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b2.body.I_22 \"inertia tensor\";
//   final parameter Real mechanics.b2.body.I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b2.body.I_32 \"inertia tensor\";
//   final parameter Real mechanics.b2.body.I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b2.body.I_31 \"inertia tensor\";
//   final parameter Real mechanics.b2.body.I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b2.body.I_32 \"inertia tensor\";
//   final parameter Real mechanics.b2.body.I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b2.body.I_33 \"inertia tensor\";
//   final parameter Real mechanics.b2.body.R_start.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b2.body.R_start.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b2.body.R_start.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b2.body.R_start.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b2.body.R_start.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b2.body.R_start.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b2.body.R_start.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b2.body.R_start.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b2.body.R_start.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b2.body.R_start.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   final parameter Real mechanics.b2.body.R_start.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   final parameter Real mechanics.b2.body.R_start.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real mechanics.b2.body.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.b2.body.sphereDiameter / 3.0 \"Diameter of cylinder\";
//   final parameter Real mechanics.b2.body.z_a_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b2.body.R_start,{mechanics.b2.body.z_0_start[1],mechanics.b2.body.z_0_start[2],mechanics.b2.body.z_0_start[3]})[1] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   final parameter Real mechanics.b2.body.z_a_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b2.body.R_start,{mechanics.b2.body.z_0_start[1],mechanics.b2.body.z_0_start[2],mechanics.b2.body.z_0_start[3]})[2] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   final parameter Real mechanics.b2.body.z_a_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b2.body.R_start,{mechanics.b2.body.z_0_start[1],mechanics.b2.body.z_0_start[2],mechanics.b2.body.z_0_start[3]})[3] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   protected parameter Real mechanics.b2.body.Q_start[1] = Modelica.Mechanics.MultiBody.Frames.to_Q(mechanics.b2.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[1] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real mechanics.b2.body.Q_start[2] = Modelica.Mechanics.MultiBody.Frames.to_Q(mechanics.b2.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[2] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real mechanics.b2.body.Q_start[3] = Modelica.Mechanics.MultiBody.Frames.to_Q(mechanics.b2.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[3] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real mechanics.b2.body.Q_start[4] = Modelica.Mechanics.MultiBody.Frames.to_Q(mechanics.b2.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[4] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real mechanics.b2.body.phi_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if mechanics.b2.body.sequence_start[1] == mechanics.b2.body.sequence_angleStates[1] and mechanics.b2.body.sequence_start[2] == mechanics.b2.body.sequence_angleStates[2] and mechanics.b2.body.sequence_start[3] == mechanics.b2.body.sequence_angleStates[3] then mechanics.b2.body.angles_start[1] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(mechanics.b2.body.R_start,{mechanics.b2.body.sequence_angleStates[1],mechanics.b2.body.sequence_angleStates[2],mechanics.b2.body.sequence_angleStates[3]},0.0)[1] \"Potential angle states at initial time\";
//   protected parameter Real mechanics.b2.body.phi_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if mechanics.b2.body.sequence_start[1] == mechanics.b2.body.sequence_angleStates[1] and mechanics.b2.body.sequence_start[2] == mechanics.b2.body.sequence_angleStates[2] and mechanics.b2.body.sequence_start[3] == mechanics.b2.body.sequence_angleStates[3] then mechanics.b2.body.angles_start[2] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(mechanics.b2.body.R_start,{mechanics.b2.body.sequence_angleStates[1],mechanics.b2.body.sequence_angleStates[2],mechanics.b2.body.sequence_angleStates[3]},0.0)[2] \"Potential angle states at initial time\";
//   protected parameter Real mechanics.b2.body.phi_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if mechanics.b2.body.sequence_start[1] == mechanics.b2.body.sequence_angleStates[1] and mechanics.b2.body.sequence_start[2] == mechanics.b2.body.sequence_angleStates[2] and mechanics.b2.body.sequence_start[3] == mechanics.b2.body.sequence_angleStates[3] then mechanics.b2.body.angles_start[3] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(mechanics.b2.body.R_start,{mechanics.b2.body.sequence_angleStates[1],mechanics.b2.body.sequence_angleStates[2],mechanics.b2.body.sequence_angleStates[3]},0.0)[3] \"Potential angle states at initial time\";
//   parameter String mechanics.b2.shape1.shapeType = mechanics.b2.shapeType \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real mechanics.b2.shape1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b2.shape1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b2.shape1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b2.shape1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b2.shape1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b2.shape1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b2.shape1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b2.shape1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b2.shape1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b2.shape1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.b2.shape1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.b2.shape1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.b2.shape1.r[1](quantity = \"Length\", unit = \"m\") = mechanics.b2.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.b2.shape1.r[2](quantity = \"Length\", unit = \"m\") = mechanics.b2.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.b2.shape1.r[3](quantity = \"Length\", unit = \"m\") = mechanics.b2.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.b2.shape1.r_shape[1](quantity = \"Length\", unit = \"m\") = mechanics.b2.r_shape[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.b2.shape1.r_shape[2](quantity = \"Length\", unit = \"m\") = mechanics.b2.r_shape[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.b2.shape1.r_shape[3](quantity = \"Length\", unit = \"m\") = mechanics.b2.r_shape[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.b2.shape1.lengthDirection[1](unit = \"1\") = mechanics.b2.lengthDirection[1] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.b2.shape1.lengthDirection[2](unit = \"1\") = mechanics.b2.lengthDirection[2] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.b2.shape1.lengthDirection[3](unit = \"1\") = mechanics.b2.lengthDirection[3] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.b2.shape1.widthDirection[1](unit = \"1\") = mechanics.b2.widthDirection[1] \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.b2.shape1.widthDirection[2](unit = \"1\") = mechanics.b2.widthDirection[2] \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.b2.shape1.widthDirection[3](unit = \"1\") = mechanics.b2.widthDirection[3] \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.b2.shape1.length(quantity = \"Length\", unit = \"m\") = mechanics.b2.length \"Length of visual object\";
//   input Real mechanics.b2.shape1.width(quantity = \"Length\", unit = \"m\") = mechanics.b2.width \"Width of visual object\";
//   input Real mechanics.b2.shape1.height(quantity = \"Length\", unit = \"m\") = mechanics.b2.height \"Height of visual object\";
//   input Real mechanics.b2.shape1.extra = mechanics.b2.extra \"Additional size data for some of the shape types\";
//   input Real mechanics.b2.shape1.color[1] = Real(mechanics.b2.color[1]) \"Color of shape\";
//   input Real mechanics.b2.shape1.color[2] = Real(mechanics.b2.color[2]) \"Color of shape\";
//   input Real mechanics.b2.shape1.color[3] = Real(mechanics.b2.color[3]) \"Color of shape\";
//   input Real mechanics.b2.shape1.specularCoefficient = mechanics.b2.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real mechanics.b2.shape1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({mechanics.b2.shape1.lengthDirection[1],mechanics.b2.shape1.lengthDirection[2],mechanics.b2.shape1.lengthDirection[3]});
//   protected Real mechanics.b2.shape1.e_x[1](unit = \"1\") = if noEvent(mechanics.b2.shape1.abs_n_x < 1e-10) then 1.0 else mechanics.b2.shape1.lengthDirection[1] / mechanics.b2.shape1.abs_n_x;
//   protected Real mechanics.b2.shape1.e_x[2](unit = \"1\") = if noEvent(mechanics.b2.shape1.abs_n_x < 1e-10) then 0.0 else mechanics.b2.shape1.lengthDirection[2] / mechanics.b2.shape1.abs_n_x;
//   protected Real mechanics.b2.shape1.e_x[3](unit = \"1\") = if noEvent(mechanics.b2.shape1.abs_n_x < 1e-10) then 0.0 else mechanics.b2.shape1.lengthDirection[3] / mechanics.b2.shape1.abs_n_x;
//   protected Real mechanics.b2.shape1.n_z_aux[1](unit = \"1\") = mechanics.b2.shape1.e_x[2] * mechanics.b2.shape1.widthDirection[3] - mechanics.b2.shape1.e_x[3] * mechanics.b2.shape1.widthDirection[2];
//   protected Real mechanics.b2.shape1.n_z_aux[2](unit = \"1\") = mechanics.b2.shape1.e_x[3] * mechanics.b2.shape1.widthDirection[1] - mechanics.b2.shape1.e_x[1] * mechanics.b2.shape1.widthDirection[3];
//   protected Real mechanics.b2.shape1.n_z_aux[3](unit = \"1\") = mechanics.b2.shape1.e_x[1] * mechanics.b2.shape1.widthDirection[2] - mechanics.b2.shape1.e_x[2] * mechanics.b2.shape1.widthDirection[1];
//   protected Real mechanics.b2.shape1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.b2.shape1.e_x[1],mechanics.b2.shape1.e_x[2],mechanics.b2.shape1.e_x[3]},if noEvent(mechanics.b2.shape1.n_z_aux[1] ^ 2.0 + (mechanics.b2.shape1.n_z_aux[2] ^ 2.0 + mechanics.b2.shape1.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.b2.shape1.widthDirection[1],mechanics.b2.shape1.widthDirection[2],mechanics.b2.shape1.widthDirection[3]} else if noEvent(abs(mechanics.b2.shape1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.b2.shape1.e_x[1],mechanics.b2.shape1.e_x[2],mechanics.b2.shape1.e_x[3]})[1];
//   protected Real mechanics.b2.shape1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.b2.shape1.e_x[1],mechanics.b2.shape1.e_x[2],mechanics.b2.shape1.e_x[3]},if noEvent(mechanics.b2.shape1.n_z_aux[1] ^ 2.0 + (mechanics.b2.shape1.n_z_aux[2] ^ 2.0 + mechanics.b2.shape1.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.b2.shape1.widthDirection[1],mechanics.b2.shape1.widthDirection[2],mechanics.b2.shape1.widthDirection[3]} else if noEvent(abs(mechanics.b2.shape1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.b2.shape1.e_x[1],mechanics.b2.shape1.e_x[2],mechanics.b2.shape1.e_x[3]})[2];
//   protected Real mechanics.b2.shape1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.b2.shape1.e_x[1],mechanics.b2.shape1.e_x[2],mechanics.b2.shape1.e_x[3]},if noEvent(mechanics.b2.shape1.n_z_aux[1] ^ 2.0 + (mechanics.b2.shape1.n_z_aux[2] ^ 2.0 + mechanics.b2.shape1.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.b2.shape1.widthDirection[1],mechanics.b2.shape1.widthDirection[2],mechanics.b2.shape1.widthDirection[3]} else if noEvent(abs(mechanics.b2.shape1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.b2.shape1.e_x[1],mechanics.b2.shape1.e_x[2],mechanics.b2.shape1.e_x[3]})[3];
//   protected output Real mechanics.b2.shape1.Form;
//   output Real mechanics.b2.shape1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b2.shape1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b2.shape1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b2.shape1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b2.shape1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b2.shape1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b2.shape1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real mechanics.b2.shape1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real mechanics.b2.shape1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real mechanics.b2.shape1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.b2.shape1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.b2.shape1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.b2.shape1.Material;
//   protected output Real mechanics.b2.shape1.Extra;
//   parameter Real mechanics.b2.lengthDirection[1](unit = \"1\") = 1.0 \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b2.lengthDirection[2](unit = \"1\") = 0.0 \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b2.lengthDirection[3](unit = \"1\") = 0.0 \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b2.length(quantity = \"Length\", unit = \"m\") = 0.5 \" Length of shape\";
//   parameter Real mechanics.b2.width(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.2 \" Width of shape\";
//   parameter Real mechanics.b2.height(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.15 \" Height of shape.\";
//   parameter Real mechanics.b2.sphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 2.0 * mechanics.b2.width \" Diameter of sphere\";
//   Real mechanics.b3.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b3.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b3.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b3.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b3.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b3.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b3.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b3.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b3.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b3.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b3.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b3.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b3.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b3.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b3.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b3.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b3.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b3.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b3.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b3.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b3.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b3.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b3.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b3.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean mechanics.b3.animation = mechanics.animation \"= true, if animation shall be enabled (show shape between frame_a and frame_b and optionally a sphere at the center of mass)\";
//   parameter Boolean mechanics.b3.animateSphere = false \"= true, if mass shall be animated as sphere provided animation=true\";
//   parameter Real mechanics.b3.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b3.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.414 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b3.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = -0.155 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b3.r_CM[1](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.064 \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b3.r_CM[2](quantity = \"Length\", unit = \"m\", start = 0.0) = -0.034 \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b3.r_CM[3](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b3.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 1.0) = 26.4 \"Mass of rigid body\";
//   parameter Real mechanics.b3.I_11(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.279 \" (1,1) element of inertia tensor\";
//   parameter Real mechanics.b3.I_22(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.245 \" (2,2) element of inertia tensor\";
//   parameter Real mechanics.b3.I_33(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.413 \" (3,3) element of inertia tensor\";
//   parameter Real mechanics.b3.I_21(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = -0.07 \" (2,1) element of inertia tensor\";
//   parameter Real mechanics.b3.I_31(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (3,1) element of inertia tensor\";
//   parameter Real mechanics.b3.I_32(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (3,2) element of inertia tensor\";
//   Real mechanics.b3.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b3.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b3.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b3.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b3.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b3.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b3.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real mechanics.b3.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real mechanics.b3.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean mechanics.b3.angles_fixed = false \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b3.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real mechanics.b3.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real mechanics.b3.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer mechanics.b3.sequence_start[1](min = 1, max = 3) = 1 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer mechanics.b3.sequence_start[2](min = 1, max = 3) = 2 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer mechanics.b3.sequence_start[3](min = 1, max = 3) = 3 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean mechanics.b3.w_0_fixed = false \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b3.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real mechanics.b3.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real mechanics.b3.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean mechanics.b3.z_0_fixed = false \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b3.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b3.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b3.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter String mechanics.b3.shapeType = \"3\" \" Type of shape\";
//   parameter Real mechanics.b3.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b3.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b3.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b3.widthDirection[1](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b3.widthDirection[2](unit = \"1\") = 1.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b3.widthDirection[3](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b3.extra = 0.0 \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer mechanics.b3.color[1](min = 0, max = 255) = 255 \" Color of shape\";
//   input Integer mechanics.b3.color[2](min = 0, max = 255) = 0 \" Color of shape\";
//   input Integer mechanics.b3.color[3](min = 0, max = 255) = 0 \" Color of shape\";
//   input Integer mechanics.b3.sphereColor[1](min = 0, max = 255) = mechanics.b3.color[1] \" Color of sphere of mass\";
//   input Integer mechanics.b3.sphereColor[2](min = 0, max = 255) = mechanics.b3.color[2] \" Color of sphere of mass\";
//   input Integer mechanics.b3.sphereColor[3](min = 0, max = 255) = mechanics.b3.color[3] \" Color of sphere of mass\";
//   input Real mechanics.b3.specularCoefficient = mechanics.world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean mechanics.b3.enforceStates = false \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean mechanics.b3.useQuaternions = true \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer mechanics.b3.sequence_angleStates[1](min = 1, max = 3) = 1 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer mechanics.b3.sequence_angleStates[2](min = 1, max = 3) = 2 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer mechanics.b3.sequence_angleStates[3](min = 1, max = 3) = 3 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   Real mechanics.b3.frameTranslation.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b3.frameTranslation.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b3.frameTranslation.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b3.frameTranslation.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frameTranslation.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frameTranslation.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frameTranslation.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frameTranslation.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frameTranslation.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frameTranslation.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frameTranslation.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frameTranslation.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frameTranslation.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b3.frameTranslation.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b3.frameTranslation.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b3.frameTranslation.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b3.frameTranslation.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b3.frameTranslation.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b3.frameTranslation.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b3.frameTranslation.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b3.frameTranslation.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b3.frameTranslation.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b3.frameTranslation.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b3.frameTranslation.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b3.frameTranslation.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frameTranslation.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frameTranslation.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frameTranslation.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frameTranslation.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frameTranslation.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frameTranslation.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frameTranslation.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frameTranslation.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.frameTranslation.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b3.frameTranslation.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b3.frameTranslation.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b3.frameTranslation.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b3.frameTranslation.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b3.frameTranslation.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b3.frameTranslation.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b3.frameTranslation.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b3.frameTranslation.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean mechanics.b3.frameTranslation.animation = false \"= true, if animation shall be enabled\";
//   parameter Real mechanics.b3.frameTranslation.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b3.r[1] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b3.frameTranslation.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b3.r[2] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b3.frameTranslation.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b3.r[3] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter String mechanics.b3.frameTranslation.shapeType = \"cylinder\" \" Type of shape\";
//   parameter Real mechanics.b3.frameTranslation.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b3.frameTranslation.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b3.frameTranslation.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b3.frameTranslation.widthDirection[1](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b3.frameTranslation.widthDirection[2](unit = \"1\") = 1.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b3.frameTranslation.widthDirection[3](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b3.frameTranslation.extra = 0.0 \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer mechanics.b3.frameTranslation.color[1](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer mechanics.b3.frameTranslation.color[2](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer mechanics.b3.frameTranslation.color[3](min = 0, max = 255) = 155 \" Color of shape\";
//   input Real mechanics.b3.frameTranslation.specularCoefficient = mechanics.world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Real mechanics.b3.frameTranslation.lengthDirection[1](unit = \"1\") = mechanics.b3.frameTranslation.r[1] - mechanics.b3.frameTranslation.r_shape[1] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b3.frameTranslation.lengthDirection[2](unit = \"1\") = mechanics.b3.frameTranslation.r[2] - mechanics.b3.frameTranslation.r_shape[2] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b3.frameTranslation.lengthDirection[3](unit = \"1\") = mechanics.b3.frameTranslation.r[3] - mechanics.b3.frameTranslation.r_shape[3] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b3.frameTranslation.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({mechanics.b3.frameTranslation.r[1] - mechanics.b3.frameTranslation.r_shape[1],mechanics.b3.frameTranslation.r[2] - mechanics.b3.frameTranslation.r_shape[2],mechanics.b3.frameTranslation.r[3] - mechanics.b3.frameTranslation.r_shape[3]}) \" Length of shape\";
//   parameter Real mechanics.b3.frameTranslation.width(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.b3.frameTranslation.length / mechanics.world.defaultWidthFraction \" Width of shape\";
//   parameter Real mechanics.b3.frameTranslation.height(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.b3.frameTranslation.width \" Height of shape.\";
//   Real mechanics.b3.body.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b3.body.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b3.body.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b3.body.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.body.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.body.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.body.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.body.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.body.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.body.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.body.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.body.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b3.body.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b3.body.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b3.body.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b3.body.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b3.body.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b3.body.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b3.body.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b3.body.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b3.body.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean mechanics.b3.body.animation = false \"= true, if animation shall be enabled (show cylinder and sphere)\";
//   parameter Real mechanics.b3.body.r_CM[1](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b3.r_CM[1] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b3.body.r_CM[2](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b3.r_CM[2] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b3.body.r_CM[3](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b3.r_CM[3] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b3.body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 1.0) = mechanics.b3.m \"Mass of rigid body\";
//   parameter Real mechanics.b3.body.I_11(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = mechanics.b3.I_11 \" (1,1) element of inertia tensor\";
//   parameter Real mechanics.b3.body.I_22(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = mechanics.b3.I_22 \" (2,2) element of inertia tensor\";
//   parameter Real mechanics.b3.body.I_33(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = mechanics.b3.I_33 \" (3,3) element of inertia tensor\";
//   parameter Real mechanics.b3.body.I_21(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = mechanics.b3.I_21 \" (2,1) element of inertia tensor\";
//   parameter Real mechanics.b3.body.I_31(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = mechanics.b3.I_31 \" (3,1) element of inertia tensor\";
//   parameter Real mechanics.b3.body.I_32(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = mechanics.b3.I_32 \" (3,2) element of inertia tensor\";
//   Real mechanics.b3.body.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b3.body.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b3.body.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b3.body.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b3.body.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b3.body.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b3.body.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real mechanics.b3.body.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real mechanics.b3.body.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean mechanics.b3.body.angles_fixed = mechanics.b3.angles_fixed \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b3.body.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = mechanics.b3.angles_start[1] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real mechanics.b3.body.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = mechanics.b3.angles_start[2] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real mechanics.b3.body.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = mechanics.b3.angles_start[3] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer mechanics.b3.body.sequence_start[1](min = 1, max = 3) = mechanics.b3.sequence_start[1] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer mechanics.b3.body.sequence_start[2](min = 1, max = 3) = mechanics.b3.sequence_start[2] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer mechanics.b3.body.sequence_start[3](min = 1, max = 3) = mechanics.b3.sequence_start[3] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean mechanics.b3.body.w_0_fixed = mechanics.b3.w_0_fixed \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b3.body.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = mechanics.b3.w_0_start[1] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real mechanics.b3.body.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = mechanics.b3.w_0_start[2] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real mechanics.b3.body.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = mechanics.b3.w_0_start[3] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean mechanics.b3.body.z_0_fixed = mechanics.b3.z_0_fixed \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b3.body.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = mechanics.b3.z_0_start[1] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b3.body.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = mechanics.b3.z_0_start[2] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b3.body.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = mechanics.b3.z_0_start[3] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b3.body.sphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.world.defaultBodyDiameter \"Diameter of sphere\";
//   input Integer mechanics.b3.body.sphereColor[1](min = 0, max = 255) = 0 \"Color of sphere\";
//   input Integer mechanics.b3.body.sphereColor[2](min = 0, max = 255) = 128 \"Color of sphere\";
//   input Integer mechanics.b3.body.sphereColor[3](min = 0, max = 255) = 255 \"Color of sphere\";
//   input Integer mechanics.b3.body.cylinderColor[1](min = 0, max = 255) = mechanics.b3.body.sphereColor[1] \"Color of cylinder\";
//   input Integer mechanics.b3.body.cylinderColor[2](min = 0, max = 255) = mechanics.b3.body.sphereColor[2] \"Color of cylinder\";
//   input Integer mechanics.b3.body.cylinderColor[3](min = 0, max = 255) = mechanics.b3.body.sphereColor[3] \"Color of cylinder\";
//   input Real mechanics.b3.body.specularCoefficient = mechanics.world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean mechanics.b3.body.enforceStates = mechanics.b3.enforceStates \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean mechanics.b3.body.useQuaternions = mechanics.b3.useQuaternions \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer mechanics.b3.body.sequence_angleStates[1](min = 1, max = 3) = mechanics.b3.sequence_angleStates[1] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer mechanics.b3.body.sequence_angleStates[2](min = 1, max = 3) = mechanics.b3.sequence_angleStates[2] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer mechanics.b3.body.sequence_angleStates[3](min = 1, max = 3) = mechanics.b3.sequence_angleStates[3] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   Real mechanics.b3.body.w_a[1](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b3.body.R_start,{mechanics.b3.body.w_0_start[1],mechanics.b3.body.w_0_start[2],mechanics.b3.body.w_0_start[3]})[1], fixed = mechanics.b3.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real mechanics.b3.body.w_a[2](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b3.body.R_start,{mechanics.b3.body.w_0_start[1],mechanics.b3.body.w_0_start[2],mechanics.b3.body.w_0_start[3]})[2], fixed = mechanics.b3.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real mechanics.b3.body.w_a[3](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b3.body.R_start,{mechanics.b3.body.w_0_start[1],mechanics.b3.body.w_0_start[2],mechanics.b3.body.w_0_start[3]})[3], fixed = mechanics.b3.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real mechanics.b3.body.z_a[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b3.body.R_start,{mechanics.b3.body.z_0_start[1],mechanics.b3.body.z_0_start[2],mechanics.b3.body.z_0_start[3]})[1], fixed = mechanics.b3.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real mechanics.b3.body.z_a[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b3.body.R_start,{mechanics.b3.body.z_0_start[1],mechanics.b3.body.z_0_start[2],mechanics.b3.body.z_0_start[3]})[2], fixed = mechanics.b3.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real mechanics.b3.body.z_a[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b3.body.R_start,{mechanics.b3.body.z_0_start[1],mechanics.b3.body.z_0_start[2],mechanics.b3.body.z_0_start[3]})[3], fixed = mechanics.b3.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real mechanics.b3.body.g_0[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real mechanics.b3.body.g_0[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real mechanics.b3.body.g_0[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   protected Real mechanics.b3.body.Q[1](start = mechanics.b3.body.Q_start[1], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real mechanics.b3.body.Q[2](start = mechanics.b3.body.Q_start[2], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real mechanics.b3.body.Q[3](start = mechanics.b3.body.Q_start[3], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real mechanics.b3.body.Q[4](start = mechanics.b3.body.Q_start[4], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real mechanics.b3.body.phi[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = mechanics.b3.body.phi_start[1], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real mechanics.b3.body.phi[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = mechanics.b3.body.phi_start[2], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real mechanics.b3.body.phi[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = mechanics.b3.body.phi_start[3], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real mechanics.b3.body.phi_d[1](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real mechanics.b3.body.phi_d[2](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real mechanics.b3.body.phi_d[3](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real mechanics.b3.body.phi_dd[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real mechanics.b3.body.phi_dd[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real mechanics.b3.body.phi_dd[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   final parameter Real mechanics.b3.body.I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b3.body.I_11 \"inertia tensor\";
//   final parameter Real mechanics.b3.body.I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b3.body.I_21 \"inertia tensor\";
//   final parameter Real mechanics.b3.body.I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b3.body.I_31 \"inertia tensor\";
//   final parameter Real mechanics.b3.body.I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b3.body.I_21 \"inertia tensor\";
//   final parameter Real mechanics.b3.body.I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b3.body.I_22 \"inertia tensor\";
//   final parameter Real mechanics.b3.body.I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b3.body.I_32 \"inertia tensor\";
//   final parameter Real mechanics.b3.body.I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b3.body.I_31 \"inertia tensor\";
//   final parameter Real mechanics.b3.body.I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b3.body.I_32 \"inertia tensor\";
//   final parameter Real mechanics.b3.body.I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b3.body.I_33 \"inertia tensor\";
//   final parameter Real mechanics.b3.body.R_start.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b3.body.R_start.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b3.body.R_start.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b3.body.R_start.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b3.body.R_start.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b3.body.R_start.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b3.body.R_start.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b3.body.R_start.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b3.body.R_start.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b3.body.R_start.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   final parameter Real mechanics.b3.body.R_start.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   final parameter Real mechanics.b3.body.R_start.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real mechanics.b3.body.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.b3.body.sphereDiameter / 3.0 \"Diameter of cylinder\";
//   final parameter Real mechanics.b3.body.z_a_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b3.body.R_start,{mechanics.b3.body.z_0_start[1],mechanics.b3.body.z_0_start[2],mechanics.b3.body.z_0_start[3]})[1] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   final parameter Real mechanics.b3.body.z_a_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b3.body.R_start,{mechanics.b3.body.z_0_start[1],mechanics.b3.body.z_0_start[2],mechanics.b3.body.z_0_start[3]})[2] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   final parameter Real mechanics.b3.body.z_a_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b3.body.R_start,{mechanics.b3.body.z_0_start[1],mechanics.b3.body.z_0_start[2],mechanics.b3.body.z_0_start[3]})[3] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   protected parameter Real mechanics.b3.body.Q_start[1] = Modelica.Mechanics.MultiBody.Frames.to_Q(mechanics.b3.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[1] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real mechanics.b3.body.Q_start[2] = Modelica.Mechanics.MultiBody.Frames.to_Q(mechanics.b3.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[2] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real mechanics.b3.body.Q_start[3] = Modelica.Mechanics.MultiBody.Frames.to_Q(mechanics.b3.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[3] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real mechanics.b3.body.Q_start[4] = Modelica.Mechanics.MultiBody.Frames.to_Q(mechanics.b3.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[4] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real mechanics.b3.body.phi_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if mechanics.b3.body.sequence_start[1] == mechanics.b3.body.sequence_angleStates[1] and mechanics.b3.body.sequence_start[2] == mechanics.b3.body.sequence_angleStates[2] and mechanics.b3.body.sequence_start[3] == mechanics.b3.body.sequence_angleStates[3] then mechanics.b3.body.angles_start[1] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(mechanics.b3.body.R_start,{mechanics.b3.body.sequence_angleStates[1],mechanics.b3.body.sequence_angleStates[2],mechanics.b3.body.sequence_angleStates[3]},0.0)[1] \"Potential angle states at initial time\";
//   protected parameter Real mechanics.b3.body.phi_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if mechanics.b3.body.sequence_start[1] == mechanics.b3.body.sequence_angleStates[1] and mechanics.b3.body.sequence_start[2] == mechanics.b3.body.sequence_angleStates[2] and mechanics.b3.body.sequence_start[3] == mechanics.b3.body.sequence_angleStates[3] then mechanics.b3.body.angles_start[2] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(mechanics.b3.body.R_start,{mechanics.b3.body.sequence_angleStates[1],mechanics.b3.body.sequence_angleStates[2],mechanics.b3.body.sequence_angleStates[3]},0.0)[2] \"Potential angle states at initial time\";
//   protected parameter Real mechanics.b3.body.phi_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if mechanics.b3.body.sequence_start[1] == mechanics.b3.body.sequence_angleStates[1] and mechanics.b3.body.sequence_start[2] == mechanics.b3.body.sequence_angleStates[2] and mechanics.b3.body.sequence_start[3] == mechanics.b3.body.sequence_angleStates[3] then mechanics.b3.body.angles_start[3] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(mechanics.b3.body.R_start,{mechanics.b3.body.sequence_angleStates[1],mechanics.b3.body.sequence_angleStates[2],mechanics.b3.body.sequence_angleStates[3]},0.0)[3] \"Potential angle states at initial time\";
//   parameter String mechanics.b3.shape1.shapeType = mechanics.b3.shapeType \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real mechanics.b3.shape1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b3.shape1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b3.shape1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b3.shape1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b3.shape1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b3.shape1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b3.shape1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b3.shape1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b3.shape1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b3.shape1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.b3.shape1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.b3.shape1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.b3.shape1.r[1](quantity = \"Length\", unit = \"m\") = mechanics.b3.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.b3.shape1.r[2](quantity = \"Length\", unit = \"m\") = mechanics.b3.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.b3.shape1.r[3](quantity = \"Length\", unit = \"m\") = mechanics.b3.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.b3.shape1.r_shape[1](quantity = \"Length\", unit = \"m\") = mechanics.b3.r_shape[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.b3.shape1.r_shape[2](quantity = \"Length\", unit = \"m\") = mechanics.b3.r_shape[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.b3.shape1.r_shape[3](quantity = \"Length\", unit = \"m\") = mechanics.b3.r_shape[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.b3.shape1.lengthDirection[1](unit = \"1\") = mechanics.b3.lengthDirection[1] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.b3.shape1.lengthDirection[2](unit = \"1\") = mechanics.b3.lengthDirection[2] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.b3.shape1.lengthDirection[3](unit = \"1\") = mechanics.b3.lengthDirection[3] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.b3.shape1.widthDirection[1](unit = \"1\") = mechanics.b3.widthDirection[1] \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.b3.shape1.widthDirection[2](unit = \"1\") = mechanics.b3.widthDirection[2] \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.b3.shape1.widthDirection[3](unit = \"1\") = mechanics.b3.widthDirection[3] \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.b3.shape1.length(quantity = \"Length\", unit = \"m\") = mechanics.b3.length \"Length of visual object\";
//   input Real mechanics.b3.shape1.width(quantity = \"Length\", unit = \"m\") = mechanics.b3.width \"Width of visual object\";
//   input Real mechanics.b3.shape1.height(quantity = \"Length\", unit = \"m\") = mechanics.b3.height \"Height of visual object\";
//   input Real mechanics.b3.shape1.extra = mechanics.b3.extra \"Additional size data for some of the shape types\";
//   input Real mechanics.b3.shape1.color[1] = Real(mechanics.b3.color[1]) \"Color of shape\";
//   input Real mechanics.b3.shape1.color[2] = Real(mechanics.b3.color[2]) \"Color of shape\";
//   input Real mechanics.b3.shape1.color[3] = Real(mechanics.b3.color[3]) \"Color of shape\";
//   input Real mechanics.b3.shape1.specularCoefficient = mechanics.b3.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real mechanics.b3.shape1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({mechanics.b3.shape1.lengthDirection[1],mechanics.b3.shape1.lengthDirection[2],mechanics.b3.shape1.lengthDirection[3]});
//   protected Real mechanics.b3.shape1.e_x[1](unit = \"1\") = if noEvent(mechanics.b3.shape1.abs_n_x < 1e-10) then 1.0 else mechanics.b3.shape1.lengthDirection[1] / mechanics.b3.shape1.abs_n_x;
//   protected Real mechanics.b3.shape1.e_x[2](unit = \"1\") = if noEvent(mechanics.b3.shape1.abs_n_x < 1e-10) then 0.0 else mechanics.b3.shape1.lengthDirection[2] / mechanics.b3.shape1.abs_n_x;
//   protected Real mechanics.b3.shape1.e_x[3](unit = \"1\") = if noEvent(mechanics.b3.shape1.abs_n_x < 1e-10) then 0.0 else mechanics.b3.shape1.lengthDirection[3] / mechanics.b3.shape1.abs_n_x;
//   protected Real mechanics.b3.shape1.n_z_aux[1](unit = \"1\") = mechanics.b3.shape1.e_x[2] * mechanics.b3.shape1.widthDirection[3] - mechanics.b3.shape1.e_x[3] * mechanics.b3.shape1.widthDirection[2];
//   protected Real mechanics.b3.shape1.n_z_aux[2](unit = \"1\") = mechanics.b3.shape1.e_x[3] * mechanics.b3.shape1.widthDirection[1] - mechanics.b3.shape1.e_x[1] * mechanics.b3.shape1.widthDirection[3];
//   protected Real mechanics.b3.shape1.n_z_aux[3](unit = \"1\") = mechanics.b3.shape1.e_x[1] * mechanics.b3.shape1.widthDirection[2] - mechanics.b3.shape1.e_x[2] * mechanics.b3.shape1.widthDirection[1];
//   protected Real mechanics.b3.shape1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.b3.shape1.e_x[1],mechanics.b3.shape1.e_x[2],mechanics.b3.shape1.e_x[3]},if noEvent(mechanics.b3.shape1.n_z_aux[1] ^ 2.0 + (mechanics.b3.shape1.n_z_aux[2] ^ 2.0 + mechanics.b3.shape1.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.b3.shape1.widthDirection[1],mechanics.b3.shape1.widthDirection[2],mechanics.b3.shape1.widthDirection[3]} else if noEvent(abs(mechanics.b3.shape1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.b3.shape1.e_x[1],mechanics.b3.shape1.e_x[2],mechanics.b3.shape1.e_x[3]})[1];
//   protected Real mechanics.b3.shape1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.b3.shape1.e_x[1],mechanics.b3.shape1.e_x[2],mechanics.b3.shape1.e_x[3]},if noEvent(mechanics.b3.shape1.n_z_aux[1] ^ 2.0 + (mechanics.b3.shape1.n_z_aux[2] ^ 2.0 + mechanics.b3.shape1.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.b3.shape1.widthDirection[1],mechanics.b3.shape1.widthDirection[2],mechanics.b3.shape1.widthDirection[3]} else if noEvent(abs(mechanics.b3.shape1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.b3.shape1.e_x[1],mechanics.b3.shape1.e_x[2],mechanics.b3.shape1.e_x[3]})[2];
//   protected Real mechanics.b3.shape1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.b3.shape1.e_x[1],mechanics.b3.shape1.e_x[2],mechanics.b3.shape1.e_x[3]},if noEvent(mechanics.b3.shape1.n_z_aux[1] ^ 2.0 + (mechanics.b3.shape1.n_z_aux[2] ^ 2.0 + mechanics.b3.shape1.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.b3.shape1.widthDirection[1],mechanics.b3.shape1.widthDirection[2],mechanics.b3.shape1.widthDirection[3]} else if noEvent(abs(mechanics.b3.shape1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.b3.shape1.e_x[1],mechanics.b3.shape1.e_x[2],mechanics.b3.shape1.e_x[3]})[3];
//   protected output Real mechanics.b3.shape1.Form;
//   output Real mechanics.b3.shape1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b3.shape1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b3.shape1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b3.shape1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b3.shape1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b3.shape1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b3.shape1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real mechanics.b3.shape1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real mechanics.b3.shape1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real mechanics.b3.shape1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.b3.shape1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.b3.shape1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.b3.shape1.Material;
//   protected output Real mechanics.b3.shape1.Extra;
//   parameter Real mechanics.b3.lengthDirection[1](unit = \"1\") = 1.0 \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b3.lengthDirection[2](unit = \"1\") = 0.0 \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b3.lengthDirection[3](unit = \"1\") = 0.0 \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b3.length(quantity = \"Length\", unit = \"m\") = 0.15 \" Length of shape\";
//   parameter Real mechanics.b3.width(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.15 \" Width of shape\";
//   parameter Real mechanics.b3.height(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.15 \" Height of shape.\";
//   parameter Real mechanics.b3.sphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 2.0 * mechanics.b3.width \" Diameter of sphere\";
//   Real mechanics.b4.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b4.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b4.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b4.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b4.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b4.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b4.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b4.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b4.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b4.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b4.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b4.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b4.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b4.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b4.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b4.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b4.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b4.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b4.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b4.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b4.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b4.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b4.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b4.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean mechanics.b4.animation = mechanics.animation \"= true, if animation shall be enabled (show shape between frame_a and frame_b and optionally a sphere at the center of mass)\";
//   parameter Boolean mechanics.b4.animateSphere = false \"= true, if mass shall be animated as sphere provided animation=true\";
//   parameter Real mechanics.b4.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b4.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.186 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b4.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b4.r_CM[1](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b4.r_CM[2](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b4.r_CM[3](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b4.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 1.0) = 28.7 \"Mass of rigid body\";
//   parameter Real mechanics.b4.I_11(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 1.67 \" (1,1) element of inertia tensor\";
//   parameter Real mechanics.b4.I_22(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.081 \" (2,2) element of inertia tensor\";
//   parameter Real mechanics.b4.I_33(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 1.67 \" (3,3) element of inertia tensor\";
//   parameter Real mechanics.b4.I_21(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (2,1) element of inertia tensor\";
//   parameter Real mechanics.b4.I_31(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (3,1) element of inertia tensor\";
//   parameter Real mechanics.b4.I_32(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (3,2) element of inertia tensor\";
//   Real mechanics.b4.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b4.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b4.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b4.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b4.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b4.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b4.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real mechanics.b4.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real mechanics.b4.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean mechanics.b4.angles_fixed = false \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b4.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real mechanics.b4.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real mechanics.b4.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer mechanics.b4.sequence_start[1](min = 1, max = 3) = 1 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer mechanics.b4.sequence_start[2](min = 1, max = 3) = 2 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer mechanics.b4.sequence_start[3](min = 1, max = 3) = 3 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean mechanics.b4.w_0_fixed = false \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b4.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real mechanics.b4.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real mechanics.b4.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean mechanics.b4.z_0_fixed = false \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b4.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b4.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b4.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter String mechanics.b4.shapeType = \"4\" \" Type of shape\";
//   parameter Real mechanics.b4.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b4.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b4.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b4.widthDirection[1](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b4.widthDirection[2](unit = \"1\") = 1.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b4.widthDirection[3](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b4.extra = 0.0 \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer mechanics.b4.color[1](min = 0, max = 255) = 255 \" Color of shape\";
//   input Integer mechanics.b4.color[2](min = 0, max = 255) = 178 \" Color of shape\";
//   input Integer mechanics.b4.color[3](min = 0, max = 255) = 0 \" Color of shape\";
//   input Integer mechanics.b4.sphereColor[1](min = 0, max = 255) = mechanics.b4.color[1] \" Color of sphere of mass\";
//   input Integer mechanics.b4.sphereColor[2](min = 0, max = 255) = mechanics.b4.color[2] \" Color of sphere of mass\";
//   input Integer mechanics.b4.sphereColor[3](min = 0, max = 255) = mechanics.b4.color[3] \" Color of sphere of mass\";
//   input Real mechanics.b4.specularCoefficient = mechanics.world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean mechanics.b4.enforceStates = false \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean mechanics.b4.useQuaternions = true \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer mechanics.b4.sequence_angleStates[1](min = 1, max = 3) = 1 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer mechanics.b4.sequence_angleStates[2](min = 1, max = 3) = 2 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer mechanics.b4.sequence_angleStates[3](min = 1, max = 3) = 3 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   Real mechanics.b4.frameTranslation.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b4.frameTranslation.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b4.frameTranslation.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b4.frameTranslation.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frameTranslation.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frameTranslation.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frameTranslation.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frameTranslation.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frameTranslation.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frameTranslation.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frameTranslation.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frameTranslation.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frameTranslation.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b4.frameTranslation.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b4.frameTranslation.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b4.frameTranslation.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b4.frameTranslation.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b4.frameTranslation.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b4.frameTranslation.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b4.frameTranslation.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b4.frameTranslation.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b4.frameTranslation.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b4.frameTranslation.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b4.frameTranslation.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b4.frameTranslation.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frameTranslation.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frameTranslation.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frameTranslation.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frameTranslation.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frameTranslation.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frameTranslation.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frameTranslation.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frameTranslation.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.frameTranslation.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b4.frameTranslation.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b4.frameTranslation.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b4.frameTranslation.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b4.frameTranslation.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b4.frameTranslation.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b4.frameTranslation.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b4.frameTranslation.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b4.frameTranslation.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean mechanics.b4.frameTranslation.animation = false \"= true, if animation shall be enabled\";
//   parameter Real mechanics.b4.frameTranslation.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b4.r[1] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b4.frameTranslation.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b4.r[2] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b4.frameTranslation.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b4.r[3] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter String mechanics.b4.frameTranslation.shapeType = \"cylinder\" \" Type of shape\";
//   parameter Real mechanics.b4.frameTranslation.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b4.frameTranslation.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b4.frameTranslation.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b4.frameTranslation.widthDirection[1](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b4.frameTranslation.widthDirection[2](unit = \"1\") = 1.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b4.frameTranslation.widthDirection[3](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b4.frameTranslation.extra = 0.0 \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer mechanics.b4.frameTranslation.color[1](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer mechanics.b4.frameTranslation.color[2](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer mechanics.b4.frameTranslation.color[3](min = 0, max = 255) = 155 \" Color of shape\";
//   input Real mechanics.b4.frameTranslation.specularCoefficient = mechanics.world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Real mechanics.b4.frameTranslation.lengthDirection[1](unit = \"1\") = mechanics.b4.frameTranslation.r[1] - mechanics.b4.frameTranslation.r_shape[1] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b4.frameTranslation.lengthDirection[2](unit = \"1\") = mechanics.b4.frameTranslation.r[2] - mechanics.b4.frameTranslation.r_shape[2] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b4.frameTranslation.lengthDirection[3](unit = \"1\") = mechanics.b4.frameTranslation.r[3] - mechanics.b4.frameTranslation.r_shape[3] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b4.frameTranslation.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({mechanics.b4.frameTranslation.r[1] - mechanics.b4.frameTranslation.r_shape[1],mechanics.b4.frameTranslation.r[2] - mechanics.b4.frameTranslation.r_shape[2],mechanics.b4.frameTranslation.r[3] - mechanics.b4.frameTranslation.r_shape[3]}) \" Length of shape\";
//   parameter Real mechanics.b4.frameTranslation.width(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.b4.frameTranslation.length / mechanics.world.defaultWidthFraction \" Width of shape\";
//   parameter Real mechanics.b4.frameTranslation.height(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.b4.frameTranslation.width \" Height of shape.\";
//   Real mechanics.b4.body.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b4.body.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b4.body.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b4.body.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.body.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.body.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.body.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.body.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.body.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.body.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.body.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.body.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b4.body.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b4.body.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b4.body.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b4.body.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b4.body.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b4.body.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b4.body.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b4.body.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b4.body.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean mechanics.b4.body.animation = false \"= true, if animation shall be enabled (show cylinder and sphere)\";
//   parameter Real mechanics.b4.body.r_CM[1](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b4.r_CM[1] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b4.body.r_CM[2](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b4.r_CM[2] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b4.body.r_CM[3](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b4.r_CM[3] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b4.body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 1.0) = mechanics.b4.m \"Mass of rigid body\";
//   parameter Real mechanics.b4.body.I_11(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = mechanics.b4.I_11 \" (1,1) element of inertia tensor\";
//   parameter Real mechanics.b4.body.I_22(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = mechanics.b4.I_22 \" (2,2) element of inertia tensor\";
//   parameter Real mechanics.b4.body.I_33(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = mechanics.b4.I_33 \" (3,3) element of inertia tensor\";
//   parameter Real mechanics.b4.body.I_21(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = mechanics.b4.I_21 \" (2,1) element of inertia tensor\";
//   parameter Real mechanics.b4.body.I_31(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = mechanics.b4.I_31 \" (3,1) element of inertia tensor\";
//   parameter Real mechanics.b4.body.I_32(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = mechanics.b4.I_32 \" (3,2) element of inertia tensor\";
//   Real mechanics.b4.body.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b4.body.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b4.body.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b4.body.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b4.body.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b4.body.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b4.body.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real mechanics.b4.body.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real mechanics.b4.body.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean mechanics.b4.body.angles_fixed = mechanics.b4.angles_fixed \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b4.body.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = mechanics.b4.angles_start[1] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real mechanics.b4.body.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = mechanics.b4.angles_start[2] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real mechanics.b4.body.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = mechanics.b4.angles_start[3] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer mechanics.b4.body.sequence_start[1](min = 1, max = 3) = mechanics.b4.sequence_start[1] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer mechanics.b4.body.sequence_start[2](min = 1, max = 3) = mechanics.b4.sequence_start[2] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer mechanics.b4.body.sequence_start[3](min = 1, max = 3) = mechanics.b4.sequence_start[3] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean mechanics.b4.body.w_0_fixed = mechanics.b4.w_0_fixed \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b4.body.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = mechanics.b4.w_0_start[1] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real mechanics.b4.body.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = mechanics.b4.w_0_start[2] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real mechanics.b4.body.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = mechanics.b4.w_0_start[3] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean mechanics.b4.body.z_0_fixed = mechanics.b4.z_0_fixed \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b4.body.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = mechanics.b4.z_0_start[1] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b4.body.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = mechanics.b4.z_0_start[2] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b4.body.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = mechanics.b4.z_0_start[3] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b4.body.sphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.world.defaultBodyDiameter \"Diameter of sphere\";
//   input Integer mechanics.b4.body.sphereColor[1](min = 0, max = 255) = 0 \"Color of sphere\";
//   input Integer mechanics.b4.body.sphereColor[2](min = 0, max = 255) = 128 \"Color of sphere\";
//   input Integer mechanics.b4.body.sphereColor[3](min = 0, max = 255) = 255 \"Color of sphere\";
//   input Integer mechanics.b4.body.cylinderColor[1](min = 0, max = 255) = mechanics.b4.body.sphereColor[1] \"Color of cylinder\";
//   input Integer mechanics.b4.body.cylinderColor[2](min = 0, max = 255) = mechanics.b4.body.sphereColor[2] \"Color of cylinder\";
//   input Integer mechanics.b4.body.cylinderColor[3](min = 0, max = 255) = mechanics.b4.body.sphereColor[3] \"Color of cylinder\";
//   input Real mechanics.b4.body.specularCoefficient = mechanics.world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean mechanics.b4.body.enforceStates = mechanics.b4.enforceStates \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean mechanics.b4.body.useQuaternions = mechanics.b4.useQuaternions \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer mechanics.b4.body.sequence_angleStates[1](min = 1, max = 3) = mechanics.b4.sequence_angleStates[1] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer mechanics.b4.body.sequence_angleStates[2](min = 1, max = 3) = mechanics.b4.sequence_angleStates[2] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer mechanics.b4.body.sequence_angleStates[3](min = 1, max = 3) = mechanics.b4.sequence_angleStates[3] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   Real mechanics.b4.body.w_a[1](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b4.body.R_start,{mechanics.b4.body.w_0_start[1],mechanics.b4.body.w_0_start[2],mechanics.b4.body.w_0_start[3]})[1], fixed = mechanics.b4.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real mechanics.b4.body.w_a[2](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b4.body.R_start,{mechanics.b4.body.w_0_start[1],mechanics.b4.body.w_0_start[2],mechanics.b4.body.w_0_start[3]})[2], fixed = mechanics.b4.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real mechanics.b4.body.w_a[3](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b4.body.R_start,{mechanics.b4.body.w_0_start[1],mechanics.b4.body.w_0_start[2],mechanics.b4.body.w_0_start[3]})[3], fixed = mechanics.b4.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real mechanics.b4.body.z_a[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b4.body.R_start,{mechanics.b4.body.z_0_start[1],mechanics.b4.body.z_0_start[2],mechanics.b4.body.z_0_start[3]})[1], fixed = mechanics.b4.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real mechanics.b4.body.z_a[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b4.body.R_start,{mechanics.b4.body.z_0_start[1],mechanics.b4.body.z_0_start[2],mechanics.b4.body.z_0_start[3]})[2], fixed = mechanics.b4.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real mechanics.b4.body.z_a[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b4.body.R_start,{mechanics.b4.body.z_0_start[1],mechanics.b4.body.z_0_start[2],mechanics.b4.body.z_0_start[3]})[3], fixed = mechanics.b4.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real mechanics.b4.body.g_0[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real mechanics.b4.body.g_0[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real mechanics.b4.body.g_0[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   protected Real mechanics.b4.body.Q[1](start = mechanics.b4.body.Q_start[1], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real mechanics.b4.body.Q[2](start = mechanics.b4.body.Q_start[2], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real mechanics.b4.body.Q[3](start = mechanics.b4.body.Q_start[3], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real mechanics.b4.body.Q[4](start = mechanics.b4.body.Q_start[4], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real mechanics.b4.body.phi[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = mechanics.b4.body.phi_start[1], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real mechanics.b4.body.phi[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = mechanics.b4.body.phi_start[2], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real mechanics.b4.body.phi[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = mechanics.b4.body.phi_start[3], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real mechanics.b4.body.phi_d[1](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real mechanics.b4.body.phi_d[2](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real mechanics.b4.body.phi_d[3](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real mechanics.b4.body.phi_dd[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real mechanics.b4.body.phi_dd[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real mechanics.b4.body.phi_dd[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   final parameter Real mechanics.b4.body.I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b4.body.I_11 \"inertia tensor\";
//   final parameter Real mechanics.b4.body.I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b4.body.I_21 \"inertia tensor\";
//   final parameter Real mechanics.b4.body.I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b4.body.I_31 \"inertia tensor\";
//   final parameter Real mechanics.b4.body.I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b4.body.I_21 \"inertia tensor\";
//   final parameter Real mechanics.b4.body.I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b4.body.I_22 \"inertia tensor\";
//   final parameter Real mechanics.b4.body.I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b4.body.I_32 \"inertia tensor\";
//   final parameter Real mechanics.b4.body.I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b4.body.I_31 \"inertia tensor\";
//   final parameter Real mechanics.b4.body.I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b4.body.I_32 \"inertia tensor\";
//   final parameter Real mechanics.b4.body.I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b4.body.I_33 \"inertia tensor\";
//   final parameter Real mechanics.b4.body.R_start.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b4.body.R_start.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b4.body.R_start.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b4.body.R_start.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b4.body.R_start.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b4.body.R_start.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b4.body.R_start.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b4.body.R_start.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b4.body.R_start.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b4.body.R_start.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   final parameter Real mechanics.b4.body.R_start.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   final parameter Real mechanics.b4.body.R_start.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real mechanics.b4.body.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.b4.body.sphereDiameter / 3.0 \"Diameter of cylinder\";
//   final parameter Real mechanics.b4.body.z_a_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b4.body.R_start,{mechanics.b4.body.z_0_start[1],mechanics.b4.body.z_0_start[2],mechanics.b4.body.z_0_start[3]})[1] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   final parameter Real mechanics.b4.body.z_a_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b4.body.R_start,{mechanics.b4.body.z_0_start[1],mechanics.b4.body.z_0_start[2],mechanics.b4.body.z_0_start[3]})[2] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   final parameter Real mechanics.b4.body.z_a_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b4.body.R_start,{mechanics.b4.body.z_0_start[1],mechanics.b4.body.z_0_start[2],mechanics.b4.body.z_0_start[3]})[3] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   protected parameter Real mechanics.b4.body.Q_start[1] = Modelica.Mechanics.MultiBody.Frames.to_Q(mechanics.b4.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[1] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real mechanics.b4.body.Q_start[2] = Modelica.Mechanics.MultiBody.Frames.to_Q(mechanics.b4.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[2] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real mechanics.b4.body.Q_start[3] = Modelica.Mechanics.MultiBody.Frames.to_Q(mechanics.b4.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[3] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real mechanics.b4.body.Q_start[4] = Modelica.Mechanics.MultiBody.Frames.to_Q(mechanics.b4.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[4] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real mechanics.b4.body.phi_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if mechanics.b4.body.sequence_start[1] == mechanics.b4.body.sequence_angleStates[1] and mechanics.b4.body.sequence_start[2] == mechanics.b4.body.sequence_angleStates[2] and mechanics.b4.body.sequence_start[3] == mechanics.b4.body.sequence_angleStates[3] then mechanics.b4.body.angles_start[1] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(mechanics.b4.body.R_start,{mechanics.b4.body.sequence_angleStates[1],mechanics.b4.body.sequence_angleStates[2],mechanics.b4.body.sequence_angleStates[3]},0.0)[1] \"Potential angle states at initial time\";
//   protected parameter Real mechanics.b4.body.phi_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if mechanics.b4.body.sequence_start[1] == mechanics.b4.body.sequence_angleStates[1] and mechanics.b4.body.sequence_start[2] == mechanics.b4.body.sequence_angleStates[2] and mechanics.b4.body.sequence_start[3] == mechanics.b4.body.sequence_angleStates[3] then mechanics.b4.body.angles_start[2] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(mechanics.b4.body.R_start,{mechanics.b4.body.sequence_angleStates[1],mechanics.b4.body.sequence_angleStates[2],mechanics.b4.body.sequence_angleStates[3]},0.0)[2] \"Potential angle states at initial time\";
//   protected parameter Real mechanics.b4.body.phi_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if mechanics.b4.body.sequence_start[1] == mechanics.b4.body.sequence_angleStates[1] and mechanics.b4.body.sequence_start[2] == mechanics.b4.body.sequence_angleStates[2] and mechanics.b4.body.sequence_start[3] == mechanics.b4.body.sequence_angleStates[3] then mechanics.b4.body.angles_start[3] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(mechanics.b4.body.R_start,{mechanics.b4.body.sequence_angleStates[1],mechanics.b4.body.sequence_angleStates[2],mechanics.b4.body.sequence_angleStates[3]},0.0)[3] \"Potential angle states at initial time\";
//   parameter String mechanics.b4.shape1.shapeType = mechanics.b4.shapeType \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real mechanics.b4.shape1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b4.shape1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b4.shape1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b4.shape1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b4.shape1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b4.shape1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b4.shape1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b4.shape1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b4.shape1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b4.shape1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.b4.shape1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.b4.shape1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.b4.shape1.r[1](quantity = \"Length\", unit = \"m\") = mechanics.b4.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.b4.shape1.r[2](quantity = \"Length\", unit = \"m\") = mechanics.b4.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.b4.shape1.r[3](quantity = \"Length\", unit = \"m\") = mechanics.b4.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.b4.shape1.r_shape[1](quantity = \"Length\", unit = \"m\") = mechanics.b4.r_shape[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.b4.shape1.r_shape[2](quantity = \"Length\", unit = \"m\") = mechanics.b4.r_shape[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.b4.shape1.r_shape[3](quantity = \"Length\", unit = \"m\") = mechanics.b4.r_shape[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.b4.shape1.lengthDirection[1](unit = \"1\") = mechanics.b4.lengthDirection[1] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.b4.shape1.lengthDirection[2](unit = \"1\") = mechanics.b4.lengthDirection[2] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.b4.shape1.lengthDirection[3](unit = \"1\") = mechanics.b4.lengthDirection[3] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.b4.shape1.widthDirection[1](unit = \"1\") = mechanics.b4.widthDirection[1] \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.b4.shape1.widthDirection[2](unit = \"1\") = mechanics.b4.widthDirection[2] \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.b4.shape1.widthDirection[3](unit = \"1\") = mechanics.b4.widthDirection[3] \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.b4.shape1.length(quantity = \"Length\", unit = \"m\") = mechanics.b4.length \"Length of visual object\";
//   input Real mechanics.b4.shape1.width(quantity = \"Length\", unit = \"m\") = mechanics.b4.width \"Width of visual object\";
//   input Real mechanics.b4.shape1.height(quantity = \"Length\", unit = \"m\") = mechanics.b4.height \"Height of visual object\";
//   input Real mechanics.b4.shape1.extra = mechanics.b4.extra \"Additional size data for some of the shape types\";
//   input Real mechanics.b4.shape1.color[1] = Real(mechanics.b4.color[1]) \"Color of shape\";
//   input Real mechanics.b4.shape1.color[2] = Real(mechanics.b4.color[2]) \"Color of shape\";
//   input Real mechanics.b4.shape1.color[3] = Real(mechanics.b4.color[3]) \"Color of shape\";
//   input Real mechanics.b4.shape1.specularCoefficient = mechanics.b4.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real mechanics.b4.shape1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({mechanics.b4.shape1.lengthDirection[1],mechanics.b4.shape1.lengthDirection[2],mechanics.b4.shape1.lengthDirection[3]});
//   protected Real mechanics.b4.shape1.e_x[1](unit = \"1\") = if noEvent(mechanics.b4.shape1.abs_n_x < 1e-10) then 1.0 else mechanics.b4.shape1.lengthDirection[1] / mechanics.b4.shape1.abs_n_x;
//   protected Real mechanics.b4.shape1.e_x[2](unit = \"1\") = if noEvent(mechanics.b4.shape1.abs_n_x < 1e-10) then 0.0 else mechanics.b4.shape1.lengthDirection[2] / mechanics.b4.shape1.abs_n_x;
//   protected Real mechanics.b4.shape1.e_x[3](unit = \"1\") = if noEvent(mechanics.b4.shape1.abs_n_x < 1e-10) then 0.0 else mechanics.b4.shape1.lengthDirection[3] / mechanics.b4.shape1.abs_n_x;
//   protected Real mechanics.b4.shape1.n_z_aux[1](unit = \"1\") = mechanics.b4.shape1.e_x[2] * mechanics.b4.shape1.widthDirection[3] - mechanics.b4.shape1.e_x[3] * mechanics.b4.shape1.widthDirection[2];
//   protected Real mechanics.b4.shape1.n_z_aux[2](unit = \"1\") = mechanics.b4.shape1.e_x[3] * mechanics.b4.shape1.widthDirection[1] - mechanics.b4.shape1.e_x[1] * mechanics.b4.shape1.widthDirection[3];
//   protected Real mechanics.b4.shape1.n_z_aux[3](unit = \"1\") = mechanics.b4.shape1.e_x[1] * mechanics.b4.shape1.widthDirection[2] - mechanics.b4.shape1.e_x[2] * mechanics.b4.shape1.widthDirection[1];
//   protected Real mechanics.b4.shape1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.b4.shape1.e_x[1],mechanics.b4.shape1.e_x[2],mechanics.b4.shape1.e_x[3]},if noEvent(mechanics.b4.shape1.n_z_aux[1] ^ 2.0 + (mechanics.b4.shape1.n_z_aux[2] ^ 2.0 + mechanics.b4.shape1.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.b4.shape1.widthDirection[1],mechanics.b4.shape1.widthDirection[2],mechanics.b4.shape1.widthDirection[3]} else if noEvent(abs(mechanics.b4.shape1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.b4.shape1.e_x[1],mechanics.b4.shape1.e_x[2],mechanics.b4.shape1.e_x[3]})[1];
//   protected Real mechanics.b4.shape1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.b4.shape1.e_x[1],mechanics.b4.shape1.e_x[2],mechanics.b4.shape1.e_x[3]},if noEvent(mechanics.b4.shape1.n_z_aux[1] ^ 2.0 + (mechanics.b4.shape1.n_z_aux[2] ^ 2.0 + mechanics.b4.shape1.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.b4.shape1.widthDirection[1],mechanics.b4.shape1.widthDirection[2],mechanics.b4.shape1.widthDirection[3]} else if noEvent(abs(mechanics.b4.shape1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.b4.shape1.e_x[1],mechanics.b4.shape1.e_x[2],mechanics.b4.shape1.e_x[3]})[2];
//   protected Real mechanics.b4.shape1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.b4.shape1.e_x[1],mechanics.b4.shape1.e_x[2],mechanics.b4.shape1.e_x[3]},if noEvent(mechanics.b4.shape1.n_z_aux[1] ^ 2.0 + (mechanics.b4.shape1.n_z_aux[2] ^ 2.0 + mechanics.b4.shape1.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.b4.shape1.widthDirection[1],mechanics.b4.shape1.widthDirection[2],mechanics.b4.shape1.widthDirection[3]} else if noEvent(abs(mechanics.b4.shape1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.b4.shape1.e_x[1],mechanics.b4.shape1.e_x[2],mechanics.b4.shape1.e_x[3]})[3];
//   protected output Real mechanics.b4.shape1.Form;
//   output Real mechanics.b4.shape1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b4.shape1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b4.shape1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b4.shape1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b4.shape1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b4.shape1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b4.shape1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real mechanics.b4.shape1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real mechanics.b4.shape1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real mechanics.b4.shape1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.b4.shape1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.b4.shape1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.b4.shape1.Material;
//   protected output Real mechanics.b4.shape1.Extra;
//   parameter Real mechanics.b4.lengthDirection[1](unit = \"1\") = 1.0 \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b4.lengthDirection[2](unit = \"1\") = 0.0 \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b4.lengthDirection[3](unit = \"1\") = 0.0 \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b4.length(quantity = \"Length\", unit = \"m\") = 0.73 \" Length of shape\";
//   parameter Real mechanics.b4.width(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.1 \" Width of shape\";
//   parameter Real mechanics.b4.height(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.1 \" Height of shape.\";
//   parameter Real mechanics.b4.sphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 2.0 * mechanics.b4.width \" Diameter of sphere\";
//   Real mechanics.b5.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b5.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b5.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b5.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b5.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b5.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b5.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b5.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b5.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b5.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b5.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b5.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b5.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b5.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b5.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b5.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b5.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b5.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b5.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b5.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b5.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b5.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b5.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b5.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean mechanics.b5.animation = mechanics.animation \"= true, if animation shall be enabled (show shape between frame_a and frame_b and optionally a sphere at the center of mass)\";
//   parameter Boolean mechanics.b5.animateSphere = false \"= true, if mass shall be animated as sphere provided animation=true\";
//   parameter Real mechanics.b5.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b5.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.125 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b5.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b5.r_CM[1](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b5.r_CM[2](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b5.r_CM[3](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b5.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 1.0) = 5.2 \"Mass of rigid body\";
//   parameter Real mechanics.b5.I_11(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 1.25 \" (1,1) element of inertia tensor\";
//   parameter Real mechanics.b5.I_22(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.81 \" (2,2) element of inertia tensor\";
//   parameter Real mechanics.b5.I_33(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 1.53 \" (3,3) element of inertia tensor\";
//   parameter Real mechanics.b5.I_21(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (2,1) element of inertia tensor\";
//   parameter Real mechanics.b5.I_31(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (3,1) element of inertia tensor\";
//   parameter Real mechanics.b5.I_32(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (3,2) element of inertia tensor\";
//   Real mechanics.b5.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b5.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b5.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b5.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b5.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b5.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b5.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real mechanics.b5.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real mechanics.b5.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean mechanics.b5.angles_fixed = false \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b5.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real mechanics.b5.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real mechanics.b5.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer mechanics.b5.sequence_start[1](min = 1, max = 3) = 1 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer mechanics.b5.sequence_start[2](min = 1, max = 3) = 2 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer mechanics.b5.sequence_start[3](min = 1, max = 3) = 3 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean mechanics.b5.w_0_fixed = false \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b5.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real mechanics.b5.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real mechanics.b5.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean mechanics.b5.z_0_fixed = false \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b5.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b5.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b5.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter String mechanics.b5.shapeType = \"5\" \" Type of shape\";
//   parameter Real mechanics.b5.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b5.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b5.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b5.widthDirection[1](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b5.widthDirection[2](unit = \"1\") = 1.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b5.widthDirection[3](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b5.extra = 0.0 \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer mechanics.b5.color[1](min = 0, max = 255) = 0 \" Color of shape\";
//   input Integer mechanics.b5.color[2](min = 0, max = 255) = 0 \" Color of shape\";
//   input Integer mechanics.b5.color[3](min = 0, max = 255) = 255 \" Color of shape\";
//   input Integer mechanics.b5.sphereColor[1](min = 0, max = 255) = mechanics.b5.color[1] \" Color of sphere of mass\";
//   input Integer mechanics.b5.sphereColor[2](min = 0, max = 255) = mechanics.b5.color[2] \" Color of sphere of mass\";
//   input Integer mechanics.b5.sphereColor[3](min = 0, max = 255) = mechanics.b5.color[3] \" Color of sphere of mass\";
//   input Real mechanics.b5.specularCoefficient = mechanics.world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean mechanics.b5.enforceStates = false \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean mechanics.b5.useQuaternions = true \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer mechanics.b5.sequence_angleStates[1](min = 1, max = 3) = 1 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer mechanics.b5.sequence_angleStates[2](min = 1, max = 3) = 2 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer mechanics.b5.sequence_angleStates[3](min = 1, max = 3) = 3 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   Real mechanics.b5.frameTranslation.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b5.frameTranslation.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b5.frameTranslation.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b5.frameTranslation.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frameTranslation.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frameTranslation.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frameTranslation.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frameTranslation.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frameTranslation.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frameTranslation.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frameTranslation.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frameTranslation.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frameTranslation.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b5.frameTranslation.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b5.frameTranslation.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b5.frameTranslation.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b5.frameTranslation.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b5.frameTranslation.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b5.frameTranslation.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b5.frameTranslation.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b5.frameTranslation.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b5.frameTranslation.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b5.frameTranslation.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b5.frameTranslation.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b5.frameTranslation.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frameTranslation.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frameTranslation.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frameTranslation.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frameTranslation.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frameTranslation.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frameTranslation.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frameTranslation.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frameTranslation.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.frameTranslation.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b5.frameTranslation.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b5.frameTranslation.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b5.frameTranslation.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b5.frameTranslation.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b5.frameTranslation.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b5.frameTranslation.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b5.frameTranslation.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b5.frameTranslation.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean mechanics.b5.frameTranslation.animation = false \"= true, if animation shall be enabled\";
//   parameter Real mechanics.b5.frameTranslation.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b5.r[1] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b5.frameTranslation.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b5.r[2] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b5.frameTranslation.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b5.r[3] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter String mechanics.b5.frameTranslation.shapeType = \"cylinder\" \" Type of shape\";
//   parameter Real mechanics.b5.frameTranslation.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b5.frameTranslation.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b5.frameTranslation.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b5.frameTranslation.widthDirection[1](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b5.frameTranslation.widthDirection[2](unit = \"1\") = 1.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b5.frameTranslation.widthDirection[3](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b5.frameTranslation.extra = 0.0 \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer mechanics.b5.frameTranslation.color[1](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer mechanics.b5.frameTranslation.color[2](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer mechanics.b5.frameTranslation.color[3](min = 0, max = 255) = 155 \" Color of shape\";
//   input Real mechanics.b5.frameTranslation.specularCoefficient = mechanics.world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Real mechanics.b5.frameTranslation.lengthDirection[1](unit = \"1\") = mechanics.b5.frameTranslation.r[1] - mechanics.b5.frameTranslation.r_shape[1] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b5.frameTranslation.lengthDirection[2](unit = \"1\") = mechanics.b5.frameTranslation.r[2] - mechanics.b5.frameTranslation.r_shape[2] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b5.frameTranslation.lengthDirection[3](unit = \"1\") = mechanics.b5.frameTranslation.r[3] - mechanics.b5.frameTranslation.r_shape[3] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b5.frameTranslation.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({mechanics.b5.frameTranslation.r[1] - mechanics.b5.frameTranslation.r_shape[1],mechanics.b5.frameTranslation.r[2] - mechanics.b5.frameTranslation.r_shape[2],mechanics.b5.frameTranslation.r[3] - mechanics.b5.frameTranslation.r_shape[3]}) \" Length of shape\";
//   parameter Real mechanics.b5.frameTranslation.width(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.b5.frameTranslation.length / mechanics.world.defaultWidthFraction \" Width of shape\";
//   parameter Real mechanics.b5.frameTranslation.height(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.b5.frameTranslation.width \" Height of shape.\";
//   Real mechanics.b5.body.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b5.body.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b5.body.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b5.body.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.body.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.body.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.body.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.body.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.body.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.body.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.body.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.body.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b5.body.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b5.body.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b5.body.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b5.body.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b5.body.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b5.body.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b5.body.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b5.body.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b5.body.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean mechanics.b5.body.animation = false \"= true, if animation shall be enabled (show cylinder and sphere)\";
//   parameter Real mechanics.b5.body.r_CM[1](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b5.r_CM[1] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b5.body.r_CM[2](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b5.r_CM[2] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b5.body.r_CM[3](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b5.r_CM[3] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b5.body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 1.0) = mechanics.b5.m \"Mass of rigid body\";
//   parameter Real mechanics.b5.body.I_11(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = mechanics.b5.I_11 \" (1,1) element of inertia tensor\";
//   parameter Real mechanics.b5.body.I_22(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = mechanics.b5.I_22 \" (2,2) element of inertia tensor\";
//   parameter Real mechanics.b5.body.I_33(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = mechanics.b5.I_33 \" (3,3) element of inertia tensor\";
//   parameter Real mechanics.b5.body.I_21(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = mechanics.b5.I_21 \" (2,1) element of inertia tensor\";
//   parameter Real mechanics.b5.body.I_31(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = mechanics.b5.I_31 \" (3,1) element of inertia tensor\";
//   parameter Real mechanics.b5.body.I_32(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = mechanics.b5.I_32 \" (3,2) element of inertia tensor\";
//   Real mechanics.b5.body.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b5.body.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b5.body.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b5.body.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b5.body.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b5.body.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b5.body.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real mechanics.b5.body.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real mechanics.b5.body.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean mechanics.b5.body.angles_fixed = mechanics.b5.angles_fixed \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b5.body.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = mechanics.b5.angles_start[1] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real mechanics.b5.body.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = mechanics.b5.angles_start[2] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real mechanics.b5.body.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = mechanics.b5.angles_start[3] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer mechanics.b5.body.sequence_start[1](min = 1, max = 3) = mechanics.b5.sequence_start[1] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer mechanics.b5.body.sequence_start[2](min = 1, max = 3) = mechanics.b5.sequence_start[2] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer mechanics.b5.body.sequence_start[3](min = 1, max = 3) = mechanics.b5.sequence_start[3] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean mechanics.b5.body.w_0_fixed = mechanics.b5.w_0_fixed \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b5.body.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = mechanics.b5.w_0_start[1] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real mechanics.b5.body.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = mechanics.b5.w_0_start[2] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real mechanics.b5.body.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = mechanics.b5.w_0_start[3] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean mechanics.b5.body.z_0_fixed = mechanics.b5.z_0_fixed \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b5.body.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = mechanics.b5.z_0_start[1] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b5.body.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = mechanics.b5.z_0_start[2] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b5.body.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = mechanics.b5.z_0_start[3] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b5.body.sphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.world.defaultBodyDiameter \"Diameter of sphere\";
//   input Integer mechanics.b5.body.sphereColor[1](min = 0, max = 255) = 0 \"Color of sphere\";
//   input Integer mechanics.b5.body.sphereColor[2](min = 0, max = 255) = 128 \"Color of sphere\";
//   input Integer mechanics.b5.body.sphereColor[3](min = 0, max = 255) = 255 \"Color of sphere\";
//   input Integer mechanics.b5.body.cylinderColor[1](min = 0, max = 255) = mechanics.b5.body.sphereColor[1] \"Color of cylinder\";
//   input Integer mechanics.b5.body.cylinderColor[2](min = 0, max = 255) = mechanics.b5.body.sphereColor[2] \"Color of cylinder\";
//   input Integer mechanics.b5.body.cylinderColor[3](min = 0, max = 255) = mechanics.b5.body.sphereColor[3] \"Color of cylinder\";
//   input Real mechanics.b5.body.specularCoefficient = mechanics.world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean mechanics.b5.body.enforceStates = mechanics.b5.enforceStates \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean mechanics.b5.body.useQuaternions = mechanics.b5.useQuaternions \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer mechanics.b5.body.sequence_angleStates[1](min = 1, max = 3) = mechanics.b5.sequence_angleStates[1] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer mechanics.b5.body.sequence_angleStates[2](min = 1, max = 3) = mechanics.b5.sequence_angleStates[2] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer mechanics.b5.body.sequence_angleStates[3](min = 1, max = 3) = mechanics.b5.sequence_angleStates[3] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   Real mechanics.b5.body.w_a[1](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b5.body.R_start,{mechanics.b5.body.w_0_start[1],mechanics.b5.body.w_0_start[2],mechanics.b5.body.w_0_start[3]})[1], fixed = mechanics.b5.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real mechanics.b5.body.w_a[2](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b5.body.R_start,{mechanics.b5.body.w_0_start[1],mechanics.b5.body.w_0_start[2],mechanics.b5.body.w_0_start[3]})[2], fixed = mechanics.b5.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real mechanics.b5.body.w_a[3](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b5.body.R_start,{mechanics.b5.body.w_0_start[1],mechanics.b5.body.w_0_start[2],mechanics.b5.body.w_0_start[3]})[3], fixed = mechanics.b5.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real mechanics.b5.body.z_a[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b5.body.R_start,{mechanics.b5.body.z_0_start[1],mechanics.b5.body.z_0_start[2],mechanics.b5.body.z_0_start[3]})[1], fixed = mechanics.b5.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real mechanics.b5.body.z_a[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b5.body.R_start,{mechanics.b5.body.z_0_start[1],mechanics.b5.body.z_0_start[2],mechanics.b5.body.z_0_start[3]})[2], fixed = mechanics.b5.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real mechanics.b5.body.z_a[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b5.body.R_start,{mechanics.b5.body.z_0_start[1],mechanics.b5.body.z_0_start[2],mechanics.b5.body.z_0_start[3]})[3], fixed = mechanics.b5.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real mechanics.b5.body.g_0[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real mechanics.b5.body.g_0[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real mechanics.b5.body.g_0[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   protected Real mechanics.b5.body.Q[1](start = mechanics.b5.body.Q_start[1], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real mechanics.b5.body.Q[2](start = mechanics.b5.body.Q_start[2], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real mechanics.b5.body.Q[3](start = mechanics.b5.body.Q_start[3], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real mechanics.b5.body.Q[4](start = mechanics.b5.body.Q_start[4], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real mechanics.b5.body.phi[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = mechanics.b5.body.phi_start[1], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real mechanics.b5.body.phi[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = mechanics.b5.body.phi_start[2], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real mechanics.b5.body.phi[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = mechanics.b5.body.phi_start[3], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real mechanics.b5.body.phi_d[1](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real mechanics.b5.body.phi_d[2](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real mechanics.b5.body.phi_d[3](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real mechanics.b5.body.phi_dd[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real mechanics.b5.body.phi_dd[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real mechanics.b5.body.phi_dd[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   final parameter Real mechanics.b5.body.I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b5.body.I_11 \"inertia tensor\";
//   final parameter Real mechanics.b5.body.I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b5.body.I_21 \"inertia tensor\";
//   final parameter Real mechanics.b5.body.I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b5.body.I_31 \"inertia tensor\";
//   final parameter Real mechanics.b5.body.I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b5.body.I_21 \"inertia tensor\";
//   final parameter Real mechanics.b5.body.I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b5.body.I_22 \"inertia tensor\";
//   final parameter Real mechanics.b5.body.I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b5.body.I_32 \"inertia tensor\";
//   final parameter Real mechanics.b5.body.I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b5.body.I_31 \"inertia tensor\";
//   final parameter Real mechanics.b5.body.I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b5.body.I_32 \"inertia tensor\";
//   final parameter Real mechanics.b5.body.I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b5.body.I_33 \"inertia tensor\";
//   final parameter Real mechanics.b5.body.R_start.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b5.body.R_start.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b5.body.R_start.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b5.body.R_start.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b5.body.R_start.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b5.body.R_start.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b5.body.R_start.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b5.body.R_start.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b5.body.R_start.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b5.body.R_start.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   final parameter Real mechanics.b5.body.R_start.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   final parameter Real mechanics.b5.body.R_start.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real mechanics.b5.body.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.b5.body.sphereDiameter / 3.0 \"Diameter of cylinder\";
//   final parameter Real mechanics.b5.body.z_a_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b5.body.R_start,{mechanics.b5.body.z_0_start[1],mechanics.b5.body.z_0_start[2],mechanics.b5.body.z_0_start[3]})[1] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   final parameter Real mechanics.b5.body.z_a_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b5.body.R_start,{mechanics.b5.body.z_0_start[1],mechanics.b5.body.z_0_start[2],mechanics.b5.body.z_0_start[3]})[2] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   final parameter Real mechanics.b5.body.z_a_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b5.body.R_start,{mechanics.b5.body.z_0_start[1],mechanics.b5.body.z_0_start[2],mechanics.b5.body.z_0_start[3]})[3] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   protected parameter Real mechanics.b5.body.Q_start[1] = Modelica.Mechanics.MultiBody.Frames.to_Q(mechanics.b5.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[1] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real mechanics.b5.body.Q_start[2] = Modelica.Mechanics.MultiBody.Frames.to_Q(mechanics.b5.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[2] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real mechanics.b5.body.Q_start[3] = Modelica.Mechanics.MultiBody.Frames.to_Q(mechanics.b5.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[3] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real mechanics.b5.body.Q_start[4] = Modelica.Mechanics.MultiBody.Frames.to_Q(mechanics.b5.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[4] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real mechanics.b5.body.phi_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if mechanics.b5.body.sequence_start[1] == mechanics.b5.body.sequence_angleStates[1] and mechanics.b5.body.sequence_start[2] == mechanics.b5.body.sequence_angleStates[2] and mechanics.b5.body.sequence_start[3] == mechanics.b5.body.sequence_angleStates[3] then mechanics.b5.body.angles_start[1] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(mechanics.b5.body.R_start,{mechanics.b5.body.sequence_angleStates[1],mechanics.b5.body.sequence_angleStates[2],mechanics.b5.body.sequence_angleStates[3]},0.0)[1] \"Potential angle states at initial time\";
//   protected parameter Real mechanics.b5.body.phi_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if mechanics.b5.body.sequence_start[1] == mechanics.b5.body.sequence_angleStates[1] and mechanics.b5.body.sequence_start[2] == mechanics.b5.body.sequence_angleStates[2] and mechanics.b5.body.sequence_start[3] == mechanics.b5.body.sequence_angleStates[3] then mechanics.b5.body.angles_start[2] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(mechanics.b5.body.R_start,{mechanics.b5.body.sequence_angleStates[1],mechanics.b5.body.sequence_angleStates[2],mechanics.b5.body.sequence_angleStates[3]},0.0)[2] \"Potential angle states at initial time\";
//   protected parameter Real mechanics.b5.body.phi_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if mechanics.b5.body.sequence_start[1] == mechanics.b5.body.sequence_angleStates[1] and mechanics.b5.body.sequence_start[2] == mechanics.b5.body.sequence_angleStates[2] and mechanics.b5.body.sequence_start[3] == mechanics.b5.body.sequence_angleStates[3] then mechanics.b5.body.angles_start[3] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(mechanics.b5.body.R_start,{mechanics.b5.body.sequence_angleStates[1],mechanics.b5.body.sequence_angleStates[2],mechanics.b5.body.sequence_angleStates[3]},0.0)[3] \"Potential angle states at initial time\";
//   parameter String mechanics.b5.shape1.shapeType = mechanics.b5.shapeType \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real mechanics.b5.shape1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b5.shape1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b5.shape1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b5.shape1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b5.shape1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b5.shape1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b5.shape1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b5.shape1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b5.shape1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b5.shape1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.b5.shape1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.b5.shape1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.b5.shape1.r[1](quantity = \"Length\", unit = \"m\") = mechanics.b5.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.b5.shape1.r[2](quantity = \"Length\", unit = \"m\") = mechanics.b5.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.b5.shape1.r[3](quantity = \"Length\", unit = \"m\") = mechanics.b5.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.b5.shape1.r_shape[1](quantity = \"Length\", unit = \"m\") = mechanics.b5.r_shape[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.b5.shape1.r_shape[2](quantity = \"Length\", unit = \"m\") = mechanics.b5.r_shape[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.b5.shape1.r_shape[3](quantity = \"Length\", unit = \"m\") = mechanics.b5.r_shape[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.b5.shape1.lengthDirection[1](unit = \"1\") = mechanics.b5.lengthDirection[1] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.b5.shape1.lengthDirection[2](unit = \"1\") = mechanics.b5.lengthDirection[2] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.b5.shape1.lengthDirection[3](unit = \"1\") = mechanics.b5.lengthDirection[3] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.b5.shape1.widthDirection[1](unit = \"1\") = mechanics.b5.widthDirection[1] \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.b5.shape1.widthDirection[2](unit = \"1\") = mechanics.b5.widthDirection[2] \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.b5.shape1.widthDirection[3](unit = \"1\") = mechanics.b5.widthDirection[3] \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.b5.shape1.length(quantity = \"Length\", unit = \"m\") = mechanics.b5.length \"Length of visual object\";
//   input Real mechanics.b5.shape1.width(quantity = \"Length\", unit = \"m\") = mechanics.b5.width \"Width of visual object\";
//   input Real mechanics.b5.shape1.height(quantity = \"Length\", unit = \"m\") = mechanics.b5.height \"Height of visual object\";
//   input Real mechanics.b5.shape1.extra = mechanics.b5.extra \"Additional size data for some of the shape types\";
//   input Real mechanics.b5.shape1.color[1] = Real(mechanics.b5.color[1]) \"Color of shape\";
//   input Real mechanics.b5.shape1.color[2] = Real(mechanics.b5.color[2]) \"Color of shape\";
//   input Real mechanics.b5.shape1.color[3] = Real(mechanics.b5.color[3]) \"Color of shape\";
//   input Real mechanics.b5.shape1.specularCoefficient = mechanics.b5.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real mechanics.b5.shape1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({mechanics.b5.shape1.lengthDirection[1],mechanics.b5.shape1.lengthDirection[2],mechanics.b5.shape1.lengthDirection[3]});
//   protected Real mechanics.b5.shape1.e_x[1](unit = \"1\") = if noEvent(mechanics.b5.shape1.abs_n_x < 1e-10) then 1.0 else mechanics.b5.shape1.lengthDirection[1] / mechanics.b5.shape1.abs_n_x;
//   protected Real mechanics.b5.shape1.e_x[2](unit = \"1\") = if noEvent(mechanics.b5.shape1.abs_n_x < 1e-10) then 0.0 else mechanics.b5.shape1.lengthDirection[2] / mechanics.b5.shape1.abs_n_x;
//   protected Real mechanics.b5.shape1.e_x[3](unit = \"1\") = if noEvent(mechanics.b5.shape1.abs_n_x < 1e-10) then 0.0 else mechanics.b5.shape1.lengthDirection[3] / mechanics.b5.shape1.abs_n_x;
//   protected Real mechanics.b5.shape1.n_z_aux[1](unit = \"1\") = mechanics.b5.shape1.e_x[2] * mechanics.b5.shape1.widthDirection[3] - mechanics.b5.shape1.e_x[3] * mechanics.b5.shape1.widthDirection[2];
//   protected Real mechanics.b5.shape1.n_z_aux[2](unit = \"1\") = mechanics.b5.shape1.e_x[3] * mechanics.b5.shape1.widthDirection[1] - mechanics.b5.shape1.e_x[1] * mechanics.b5.shape1.widthDirection[3];
//   protected Real mechanics.b5.shape1.n_z_aux[3](unit = \"1\") = mechanics.b5.shape1.e_x[1] * mechanics.b5.shape1.widthDirection[2] - mechanics.b5.shape1.e_x[2] * mechanics.b5.shape1.widthDirection[1];
//   protected Real mechanics.b5.shape1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.b5.shape1.e_x[1],mechanics.b5.shape1.e_x[2],mechanics.b5.shape1.e_x[3]},if noEvent(mechanics.b5.shape1.n_z_aux[1] ^ 2.0 + (mechanics.b5.shape1.n_z_aux[2] ^ 2.0 + mechanics.b5.shape1.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.b5.shape1.widthDirection[1],mechanics.b5.shape1.widthDirection[2],mechanics.b5.shape1.widthDirection[3]} else if noEvent(abs(mechanics.b5.shape1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.b5.shape1.e_x[1],mechanics.b5.shape1.e_x[2],mechanics.b5.shape1.e_x[3]})[1];
//   protected Real mechanics.b5.shape1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.b5.shape1.e_x[1],mechanics.b5.shape1.e_x[2],mechanics.b5.shape1.e_x[3]},if noEvent(mechanics.b5.shape1.n_z_aux[1] ^ 2.0 + (mechanics.b5.shape1.n_z_aux[2] ^ 2.0 + mechanics.b5.shape1.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.b5.shape1.widthDirection[1],mechanics.b5.shape1.widthDirection[2],mechanics.b5.shape1.widthDirection[3]} else if noEvent(abs(mechanics.b5.shape1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.b5.shape1.e_x[1],mechanics.b5.shape1.e_x[2],mechanics.b5.shape1.e_x[3]})[2];
//   protected Real mechanics.b5.shape1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.b5.shape1.e_x[1],mechanics.b5.shape1.e_x[2],mechanics.b5.shape1.e_x[3]},if noEvent(mechanics.b5.shape1.n_z_aux[1] ^ 2.0 + (mechanics.b5.shape1.n_z_aux[2] ^ 2.0 + mechanics.b5.shape1.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.b5.shape1.widthDirection[1],mechanics.b5.shape1.widthDirection[2],mechanics.b5.shape1.widthDirection[3]} else if noEvent(abs(mechanics.b5.shape1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.b5.shape1.e_x[1],mechanics.b5.shape1.e_x[2],mechanics.b5.shape1.e_x[3]})[3];
//   protected output Real mechanics.b5.shape1.Form;
//   output Real mechanics.b5.shape1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b5.shape1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b5.shape1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b5.shape1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b5.shape1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b5.shape1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b5.shape1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real mechanics.b5.shape1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real mechanics.b5.shape1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real mechanics.b5.shape1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.b5.shape1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.b5.shape1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.b5.shape1.Material;
//   protected output Real mechanics.b5.shape1.Extra;
//   parameter Real mechanics.b5.lengthDirection[1](unit = \"1\") = 1.0 \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b5.lengthDirection[2](unit = \"1\") = 0.0 \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b5.lengthDirection[3](unit = \"1\") = 0.0 \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b5.length(quantity = \"Length\", unit = \"m\") = 0.225 \" Length of shape\";
//   parameter Real mechanics.b5.width(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.075 \" Width of shape\";
//   parameter Real mechanics.b5.height(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.1 \" Height of shape.\";
//   parameter Real mechanics.b5.sphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 2.0 * mechanics.b5.width \" Diameter of sphere\";
//   Real mechanics.b6.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b6.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b6.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b6.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b6.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b6.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b6.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b6.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b6.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b6.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b6.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b6.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b6.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b6.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b6.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b6.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b6.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b6.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b6.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b6.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b6.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b6.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b6.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b6.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean mechanics.b6.animation = mechanics.animation \"= true, if animation shall be enabled (show shape between frame_a and frame_b and optionally a sphere at the center of mass)\";
//   parameter Boolean mechanics.b6.animateSphere = false \"= true, if mass shall be animated as sphere provided animation=true\";
//   parameter Real mechanics.b6.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b6.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b6.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b6.r_CM[1](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.05 \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b6.r_CM[2](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.05 \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b6.r_CM[3](quantity = \"Length\", unit = \"m\", start = 0.0) = 0.05 \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b6.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 1.0) = 0.5 \"Mass of rigid body\";
//   parameter Real mechanics.b6.I_11(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.001 \" (1,1) element of inertia tensor\";
//   parameter Real mechanics.b6.I_22(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.001 \" (2,2) element of inertia tensor\";
//   parameter Real mechanics.b6.I_33(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.001 \" (3,3) element of inertia tensor\";
//   parameter Real mechanics.b6.I_21(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (2,1) element of inertia tensor\";
//   parameter Real mechanics.b6.I_31(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (3,1) element of inertia tensor\";
//   parameter Real mechanics.b6.I_32(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (3,2) element of inertia tensor\";
//   Real mechanics.b6.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b6.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b6.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b6.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b6.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b6.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b6.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real mechanics.b6.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real mechanics.b6.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean mechanics.b6.angles_fixed = false \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b6.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real mechanics.b6.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real mechanics.b6.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer mechanics.b6.sequence_start[1](min = 1, max = 3) = 1 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer mechanics.b6.sequence_start[2](min = 1, max = 3) = 2 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer mechanics.b6.sequence_start[3](min = 1, max = 3) = 3 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean mechanics.b6.w_0_fixed = false \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b6.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real mechanics.b6.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real mechanics.b6.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean mechanics.b6.z_0_fixed = false \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b6.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b6.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b6.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter String mechanics.b6.shapeType = \"6\" \" Type of shape\";
//   parameter Real mechanics.b6.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b6.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b6.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b6.widthDirection[1](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b6.widthDirection[2](unit = \"1\") = 1.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b6.widthDirection[3](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b6.extra = 0.0 \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer mechanics.b6.color[1](min = 0, max = 255) = 0 \" Color of shape\";
//   input Integer mechanics.b6.color[2](min = 0, max = 255) = 0 \" Color of shape\";
//   input Integer mechanics.b6.color[3](min = 0, max = 255) = 255 \" Color of shape\";
//   input Integer mechanics.b6.sphereColor[1](min = 0, max = 255) = mechanics.b6.color[1] \" Color of sphere of mass\";
//   input Integer mechanics.b6.sphereColor[2](min = 0, max = 255) = mechanics.b6.color[2] \" Color of sphere of mass\";
//   input Integer mechanics.b6.sphereColor[3](min = 0, max = 255) = mechanics.b6.color[3] \" Color of sphere of mass\";
//   input Real mechanics.b6.specularCoefficient = mechanics.world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean mechanics.b6.enforceStates = false \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean mechanics.b6.useQuaternions = true \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer mechanics.b6.sequence_angleStates[1](min = 1, max = 3) = 1 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer mechanics.b6.sequence_angleStates[2](min = 1, max = 3) = 2 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer mechanics.b6.sequence_angleStates[3](min = 1, max = 3) = 3 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   Real mechanics.b6.frameTranslation.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b6.frameTranslation.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b6.frameTranslation.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b6.frameTranslation.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frameTranslation.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frameTranslation.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frameTranslation.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frameTranslation.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frameTranslation.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frameTranslation.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frameTranslation.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frameTranslation.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frameTranslation.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b6.frameTranslation.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b6.frameTranslation.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b6.frameTranslation.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b6.frameTranslation.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b6.frameTranslation.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b6.frameTranslation.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b6.frameTranslation.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b6.frameTranslation.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b6.frameTranslation.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b6.frameTranslation.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b6.frameTranslation.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b6.frameTranslation.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frameTranslation.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frameTranslation.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frameTranslation.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frameTranslation.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frameTranslation.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frameTranslation.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frameTranslation.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frameTranslation.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.frameTranslation.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b6.frameTranslation.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b6.frameTranslation.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b6.frameTranslation.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b6.frameTranslation.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b6.frameTranslation.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b6.frameTranslation.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b6.frameTranslation.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b6.frameTranslation.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean mechanics.b6.frameTranslation.animation = false \"= true, if animation shall be enabled\";
//   parameter Real mechanics.b6.frameTranslation.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b6.r[1] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b6.frameTranslation.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b6.r[2] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.b6.frameTranslation.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b6.r[3] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter String mechanics.b6.frameTranslation.shapeType = \"cylinder\" \" Type of shape\";
//   parameter Real mechanics.b6.frameTranslation.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b6.frameTranslation.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b6.frameTranslation.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.b6.frameTranslation.widthDirection[1](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b6.frameTranslation.widthDirection[2](unit = \"1\") = 1.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b6.frameTranslation.widthDirection[3](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b6.frameTranslation.extra = 0.0 \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer mechanics.b6.frameTranslation.color[1](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer mechanics.b6.frameTranslation.color[2](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer mechanics.b6.frameTranslation.color[3](min = 0, max = 255) = 155 \" Color of shape\";
//   input Real mechanics.b6.frameTranslation.specularCoefficient = mechanics.world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Real mechanics.b6.frameTranslation.lengthDirection[1](unit = \"1\") = mechanics.b6.frameTranslation.r[1] - mechanics.b6.frameTranslation.r_shape[1] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b6.frameTranslation.lengthDirection[2](unit = \"1\") = mechanics.b6.frameTranslation.r[2] - mechanics.b6.frameTranslation.r_shape[2] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b6.frameTranslation.lengthDirection[3](unit = \"1\") = mechanics.b6.frameTranslation.r[3] - mechanics.b6.frameTranslation.r_shape[3] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b6.frameTranslation.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({mechanics.b6.frameTranslation.r[1] - mechanics.b6.frameTranslation.r_shape[1],mechanics.b6.frameTranslation.r[2] - mechanics.b6.frameTranslation.r_shape[2],mechanics.b6.frameTranslation.r[3] - mechanics.b6.frameTranslation.r_shape[3]}) \" Length of shape\";
//   parameter Real mechanics.b6.frameTranslation.width(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.b6.frameTranslation.length / mechanics.world.defaultWidthFraction \" Width of shape\";
//   parameter Real mechanics.b6.frameTranslation.height(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.b6.frameTranslation.width \" Height of shape.\";
//   Real mechanics.b6.body.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b6.body.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b6.body.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.b6.body.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.body.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.body.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.body.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.body.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.body.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.body.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.body.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.body.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.b6.body.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b6.body.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b6.body.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.b6.body.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b6.body.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b6.body.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.b6.body.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b6.body.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.b6.body.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean mechanics.b6.body.animation = false \"= true, if animation shall be enabled (show cylinder and sphere)\";
//   parameter Real mechanics.b6.body.r_CM[1](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b6.r_CM[1] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b6.body.r_CM[2](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b6.r_CM[2] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b6.body.r_CM[3](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.b6.r_CM[3] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.b6.body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 1.0) = mechanics.b6.m \"Mass of rigid body\";
//   parameter Real mechanics.b6.body.I_11(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = mechanics.b6.I_11 \" (1,1) element of inertia tensor\";
//   parameter Real mechanics.b6.body.I_22(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = mechanics.b6.I_22 \" (2,2) element of inertia tensor\";
//   parameter Real mechanics.b6.body.I_33(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = mechanics.b6.I_33 \" (3,3) element of inertia tensor\";
//   parameter Real mechanics.b6.body.I_21(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = mechanics.b6.I_21 \" (2,1) element of inertia tensor\";
//   parameter Real mechanics.b6.body.I_31(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = mechanics.b6.I_31 \" (3,1) element of inertia tensor\";
//   parameter Real mechanics.b6.body.I_32(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = mechanics.b6.I_32 \" (3,2) element of inertia tensor\";
//   Real mechanics.b6.body.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b6.body.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b6.body.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.b6.body.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b6.body.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b6.body.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.b6.body.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real mechanics.b6.body.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real mechanics.b6.body.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean mechanics.b6.body.angles_fixed = mechanics.b6.angles_fixed \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b6.body.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = mechanics.b6.angles_start[1] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real mechanics.b6.body.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = mechanics.b6.angles_start[2] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real mechanics.b6.body.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = mechanics.b6.angles_start[3] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer mechanics.b6.body.sequence_start[1](min = 1, max = 3) = mechanics.b6.sequence_start[1] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer mechanics.b6.body.sequence_start[2](min = 1, max = 3) = mechanics.b6.sequence_start[2] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer mechanics.b6.body.sequence_start[3](min = 1, max = 3) = mechanics.b6.sequence_start[3] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean mechanics.b6.body.w_0_fixed = mechanics.b6.w_0_fixed \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b6.body.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = mechanics.b6.w_0_start[1] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real mechanics.b6.body.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = mechanics.b6.w_0_start[2] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real mechanics.b6.body.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = mechanics.b6.w_0_start[3] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean mechanics.b6.body.z_0_fixed = mechanics.b6.z_0_fixed \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real mechanics.b6.body.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = mechanics.b6.z_0_start[1] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b6.body.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = mechanics.b6.z_0_start[2] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b6.body.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = mechanics.b6.z_0_start[3] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.b6.body.sphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.world.defaultBodyDiameter \"Diameter of sphere\";
//   input Integer mechanics.b6.body.sphereColor[1](min = 0, max = 255) = 0 \"Color of sphere\";
//   input Integer mechanics.b6.body.sphereColor[2](min = 0, max = 255) = 128 \"Color of sphere\";
//   input Integer mechanics.b6.body.sphereColor[3](min = 0, max = 255) = 255 \"Color of sphere\";
//   input Integer mechanics.b6.body.cylinderColor[1](min = 0, max = 255) = mechanics.b6.body.sphereColor[1] \"Color of cylinder\";
//   input Integer mechanics.b6.body.cylinderColor[2](min = 0, max = 255) = mechanics.b6.body.sphereColor[2] \"Color of cylinder\";
//   input Integer mechanics.b6.body.cylinderColor[3](min = 0, max = 255) = mechanics.b6.body.sphereColor[3] \"Color of cylinder\";
//   input Real mechanics.b6.body.specularCoefficient = mechanics.world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean mechanics.b6.body.enforceStates = mechanics.b6.enforceStates \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean mechanics.b6.body.useQuaternions = mechanics.b6.useQuaternions \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer mechanics.b6.body.sequence_angleStates[1](min = 1, max = 3) = mechanics.b6.sequence_angleStates[1] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer mechanics.b6.body.sequence_angleStates[2](min = 1, max = 3) = mechanics.b6.sequence_angleStates[2] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer mechanics.b6.body.sequence_angleStates[3](min = 1, max = 3) = mechanics.b6.sequence_angleStates[3] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   Real mechanics.b6.body.w_a[1](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b6.body.R_start,{mechanics.b6.body.w_0_start[1],mechanics.b6.body.w_0_start[2],mechanics.b6.body.w_0_start[3]})[1], fixed = mechanics.b6.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real mechanics.b6.body.w_a[2](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b6.body.R_start,{mechanics.b6.body.w_0_start[1],mechanics.b6.body.w_0_start[2],mechanics.b6.body.w_0_start[3]})[2], fixed = mechanics.b6.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real mechanics.b6.body.w_a[3](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b6.body.R_start,{mechanics.b6.body.w_0_start[1],mechanics.b6.body.w_0_start[2],mechanics.b6.body.w_0_start[3]})[3], fixed = mechanics.b6.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real mechanics.b6.body.z_a[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b6.body.R_start,{mechanics.b6.body.z_0_start[1],mechanics.b6.body.z_0_start[2],mechanics.b6.body.z_0_start[3]})[1], fixed = mechanics.b6.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real mechanics.b6.body.z_a[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b6.body.R_start,{mechanics.b6.body.z_0_start[1],mechanics.b6.body.z_0_start[2],mechanics.b6.body.z_0_start[3]})[2], fixed = mechanics.b6.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real mechanics.b6.body.z_a[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b6.body.R_start,{mechanics.b6.body.z_0_start[1],mechanics.b6.body.z_0_start[2],mechanics.b6.body.z_0_start[3]})[3], fixed = mechanics.b6.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real mechanics.b6.body.g_0[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real mechanics.b6.body.g_0[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real mechanics.b6.body.g_0[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   protected Real mechanics.b6.body.Q[1](start = mechanics.b6.body.Q_start[1], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real mechanics.b6.body.Q[2](start = mechanics.b6.body.Q_start[2], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real mechanics.b6.body.Q[3](start = mechanics.b6.body.Q_start[3], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real mechanics.b6.body.Q[4](start = mechanics.b6.body.Q_start[4], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real mechanics.b6.body.phi[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = mechanics.b6.body.phi_start[1], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real mechanics.b6.body.phi[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = mechanics.b6.body.phi_start[2], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real mechanics.b6.body.phi[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = mechanics.b6.body.phi_start[3], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real mechanics.b6.body.phi_d[1](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real mechanics.b6.body.phi_d[2](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real mechanics.b6.body.phi_d[3](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real mechanics.b6.body.phi_dd[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real mechanics.b6.body.phi_dd[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real mechanics.b6.body.phi_dd[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   final parameter Real mechanics.b6.body.I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b6.body.I_11 \"inertia tensor\";
//   final parameter Real mechanics.b6.body.I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b6.body.I_21 \"inertia tensor\";
//   final parameter Real mechanics.b6.body.I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b6.body.I_31 \"inertia tensor\";
//   final parameter Real mechanics.b6.body.I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b6.body.I_21 \"inertia tensor\";
//   final parameter Real mechanics.b6.body.I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b6.body.I_22 \"inertia tensor\";
//   final parameter Real mechanics.b6.body.I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b6.body.I_32 \"inertia tensor\";
//   final parameter Real mechanics.b6.body.I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b6.body.I_31 \"inertia tensor\";
//   final parameter Real mechanics.b6.body.I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b6.body.I_32 \"inertia tensor\";
//   final parameter Real mechanics.b6.body.I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.b6.body.I_33 \"inertia tensor\";
//   final parameter Real mechanics.b6.body.R_start.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b6.body.R_start.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b6.body.R_start.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b6.body.R_start.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b6.body.R_start.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b6.body.R_start.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b6.body.R_start.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b6.body.R_start.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b6.body.R_start.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.b6.body.R_start.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   final parameter Real mechanics.b6.body.R_start.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   final parameter Real mechanics.b6.body.R_start.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real mechanics.b6.body.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.b6.body.sphereDiameter / 3.0 \"Diameter of cylinder\";
//   final parameter Real mechanics.b6.body.z_a_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b6.body.R_start,{mechanics.b6.body.z_0_start[1],mechanics.b6.body.z_0_start[2],mechanics.b6.body.z_0_start[3]})[1] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   final parameter Real mechanics.b6.body.z_a_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b6.body.R_start,{mechanics.b6.body.z_0_start[1],mechanics.b6.body.z_0_start[2],mechanics.b6.body.z_0_start[3]})[2] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   final parameter Real mechanics.b6.body.z_a_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b6.body.R_start,{mechanics.b6.body.z_0_start[1],mechanics.b6.body.z_0_start[2],mechanics.b6.body.z_0_start[3]})[3] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   protected parameter Real mechanics.b6.body.Q_start[1] = Modelica.Mechanics.MultiBody.Frames.to_Q(mechanics.b6.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[1] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real mechanics.b6.body.Q_start[2] = Modelica.Mechanics.MultiBody.Frames.to_Q(mechanics.b6.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[2] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real mechanics.b6.body.Q_start[3] = Modelica.Mechanics.MultiBody.Frames.to_Q(mechanics.b6.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[3] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real mechanics.b6.body.Q_start[4] = Modelica.Mechanics.MultiBody.Frames.to_Q(mechanics.b6.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[4] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real mechanics.b6.body.phi_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if mechanics.b6.body.sequence_start[1] == mechanics.b6.body.sequence_angleStates[1] and mechanics.b6.body.sequence_start[2] == mechanics.b6.body.sequence_angleStates[2] and mechanics.b6.body.sequence_start[3] == mechanics.b6.body.sequence_angleStates[3] then mechanics.b6.body.angles_start[1] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(mechanics.b6.body.R_start,{mechanics.b6.body.sequence_angleStates[1],mechanics.b6.body.sequence_angleStates[2],mechanics.b6.body.sequence_angleStates[3]},0.0)[1] \"Potential angle states at initial time\";
//   protected parameter Real mechanics.b6.body.phi_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if mechanics.b6.body.sequence_start[1] == mechanics.b6.body.sequence_angleStates[1] and mechanics.b6.body.sequence_start[2] == mechanics.b6.body.sequence_angleStates[2] and mechanics.b6.body.sequence_start[3] == mechanics.b6.body.sequence_angleStates[3] then mechanics.b6.body.angles_start[2] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(mechanics.b6.body.R_start,{mechanics.b6.body.sequence_angleStates[1],mechanics.b6.body.sequence_angleStates[2],mechanics.b6.body.sequence_angleStates[3]},0.0)[2] \"Potential angle states at initial time\";
//   protected parameter Real mechanics.b6.body.phi_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if mechanics.b6.body.sequence_start[1] == mechanics.b6.body.sequence_angleStates[1] and mechanics.b6.body.sequence_start[2] == mechanics.b6.body.sequence_angleStates[2] and mechanics.b6.body.sequence_start[3] == mechanics.b6.body.sequence_angleStates[3] then mechanics.b6.body.angles_start[3] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(mechanics.b6.body.R_start,{mechanics.b6.body.sequence_angleStates[1],mechanics.b6.body.sequence_angleStates[2],mechanics.b6.body.sequence_angleStates[3]},0.0)[3] \"Potential angle states at initial time\";
//   parameter String mechanics.b6.shape1.shapeType = mechanics.b6.shapeType \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real mechanics.b6.shape1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b6.shape1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b6.shape1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b6.shape1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b6.shape1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b6.shape1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b6.shape1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b6.shape1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b6.shape1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.b6.shape1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.b6.shape1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.b6.shape1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.b6.shape1.r[1](quantity = \"Length\", unit = \"m\") = mechanics.b6.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.b6.shape1.r[2](quantity = \"Length\", unit = \"m\") = mechanics.b6.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.b6.shape1.r[3](quantity = \"Length\", unit = \"m\") = mechanics.b6.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.b6.shape1.r_shape[1](quantity = \"Length\", unit = \"m\") = mechanics.b6.r_shape[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.b6.shape1.r_shape[2](quantity = \"Length\", unit = \"m\") = mechanics.b6.r_shape[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.b6.shape1.r_shape[3](quantity = \"Length\", unit = \"m\") = mechanics.b6.r_shape[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.b6.shape1.lengthDirection[1](unit = \"1\") = mechanics.b6.lengthDirection[1] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.b6.shape1.lengthDirection[2](unit = \"1\") = mechanics.b6.lengthDirection[2] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.b6.shape1.lengthDirection[3](unit = \"1\") = mechanics.b6.lengthDirection[3] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.b6.shape1.widthDirection[1](unit = \"1\") = mechanics.b6.widthDirection[1] \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.b6.shape1.widthDirection[2](unit = \"1\") = mechanics.b6.widthDirection[2] \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.b6.shape1.widthDirection[3](unit = \"1\") = mechanics.b6.widthDirection[3] \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.b6.shape1.length(quantity = \"Length\", unit = \"m\") = mechanics.b6.length \"Length of visual object\";
//   input Real mechanics.b6.shape1.width(quantity = \"Length\", unit = \"m\") = mechanics.b6.width \"Width of visual object\";
//   input Real mechanics.b6.shape1.height(quantity = \"Length\", unit = \"m\") = mechanics.b6.height \"Height of visual object\";
//   input Real mechanics.b6.shape1.extra = mechanics.b6.extra \"Additional size data for some of the shape types\";
//   input Real mechanics.b6.shape1.color[1] = Real(mechanics.b6.color[1]) \"Color of shape\";
//   input Real mechanics.b6.shape1.color[2] = Real(mechanics.b6.color[2]) \"Color of shape\";
//   input Real mechanics.b6.shape1.color[3] = Real(mechanics.b6.color[3]) \"Color of shape\";
//   input Real mechanics.b6.shape1.specularCoefficient = mechanics.b6.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real mechanics.b6.shape1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({mechanics.b6.shape1.lengthDirection[1],mechanics.b6.shape1.lengthDirection[2],mechanics.b6.shape1.lengthDirection[3]});
//   protected Real mechanics.b6.shape1.e_x[1](unit = \"1\") = if noEvent(mechanics.b6.shape1.abs_n_x < 1e-10) then 1.0 else mechanics.b6.shape1.lengthDirection[1] / mechanics.b6.shape1.abs_n_x;
//   protected Real mechanics.b6.shape1.e_x[2](unit = \"1\") = if noEvent(mechanics.b6.shape1.abs_n_x < 1e-10) then 0.0 else mechanics.b6.shape1.lengthDirection[2] / mechanics.b6.shape1.abs_n_x;
//   protected Real mechanics.b6.shape1.e_x[3](unit = \"1\") = if noEvent(mechanics.b6.shape1.abs_n_x < 1e-10) then 0.0 else mechanics.b6.shape1.lengthDirection[3] / mechanics.b6.shape1.abs_n_x;
//   protected Real mechanics.b6.shape1.n_z_aux[1](unit = \"1\") = mechanics.b6.shape1.e_x[2] * mechanics.b6.shape1.widthDirection[3] - mechanics.b6.shape1.e_x[3] * mechanics.b6.shape1.widthDirection[2];
//   protected Real mechanics.b6.shape1.n_z_aux[2](unit = \"1\") = mechanics.b6.shape1.e_x[3] * mechanics.b6.shape1.widthDirection[1] - mechanics.b6.shape1.e_x[1] * mechanics.b6.shape1.widthDirection[3];
//   protected Real mechanics.b6.shape1.n_z_aux[3](unit = \"1\") = mechanics.b6.shape1.e_x[1] * mechanics.b6.shape1.widthDirection[2] - mechanics.b6.shape1.e_x[2] * mechanics.b6.shape1.widthDirection[1];
//   protected Real mechanics.b6.shape1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.b6.shape1.e_x[1],mechanics.b6.shape1.e_x[2],mechanics.b6.shape1.e_x[3]},if noEvent(mechanics.b6.shape1.n_z_aux[1] ^ 2.0 + (mechanics.b6.shape1.n_z_aux[2] ^ 2.0 + mechanics.b6.shape1.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.b6.shape1.widthDirection[1],mechanics.b6.shape1.widthDirection[2],mechanics.b6.shape1.widthDirection[3]} else if noEvent(abs(mechanics.b6.shape1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.b6.shape1.e_x[1],mechanics.b6.shape1.e_x[2],mechanics.b6.shape1.e_x[3]})[1];
//   protected Real mechanics.b6.shape1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.b6.shape1.e_x[1],mechanics.b6.shape1.e_x[2],mechanics.b6.shape1.e_x[3]},if noEvent(mechanics.b6.shape1.n_z_aux[1] ^ 2.0 + (mechanics.b6.shape1.n_z_aux[2] ^ 2.0 + mechanics.b6.shape1.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.b6.shape1.widthDirection[1],mechanics.b6.shape1.widthDirection[2],mechanics.b6.shape1.widthDirection[3]} else if noEvent(abs(mechanics.b6.shape1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.b6.shape1.e_x[1],mechanics.b6.shape1.e_x[2],mechanics.b6.shape1.e_x[3]})[2];
//   protected Real mechanics.b6.shape1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.b6.shape1.e_x[1],mechanics.b6.shape1.e_x[2],mechanics.b6.shape1.e_x[3]},if noEvent(mechanics.b6.shape1.n_z_aux[1] ^ 2.0 + (mechanics.b6.shape1.n_z_aux[2] ^ 2.0 + mechanics.b6.shape1.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.b6.shape1.widthDirection[1],mechanics.b6.shape1.widthDirection[2],mechanics.b6.shape1.widthDirection[3]} else if noEvent(abs(mechanics.b6.shape1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.b6.shape1.e_x[1],mechanics.b6.shape1.e_x[2],mechanics.b6.shape1.e_x[3]})[3];
//   protected output Real mechanics.b6.shape1.Form;
//   output Real mechanics.b6.shape1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b6.shape1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b6.shape1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b6.shape1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b6.shape1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b6.shape1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.b6.shape1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real mechanics.b6.shape1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real mechanics.b6.shape1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real mechanics.b6.shape1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.b6.shape1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.b6.shape1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.b6.shape1.Material;
//   protected output Real mechanics.b6.shape1.Extra;
//   parameter Real mechanics.b6.lengthDirection[1](unit = \"1\") = 1.0 \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b6.lengthDirection[2](unit = \"1\") = 0.0 \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b6.lengthDirection[3](unit = \"1\") = 0.0 \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.b6.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({mechanics.b6.r[1] - mechanics.b6.r_shape[1],mechanics.b6.r[2] - mechanics.b6.r_shape[2],mechanics.b6.r[3] - mechanics.b6.r_shape[3]}) \" Length of shape\";
//   parameter Real mechanics.b6.width(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.b6.length / mechanics.world.defaultWidthFraction \" Width of shape\";
//   parameter Real mechanics.b6.height(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.b6.width \" Height of shape.\";
//   parameter Real mechanics.b6.sphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 2.0 * mechanics.b6.width \" Diameter of sphere\";
//   Real mechanics.load.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.load.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.load.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.load.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.load.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.load.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.load.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.load.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.load.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.load.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.load.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.load.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.load.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.load.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.load.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.load.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.load.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.load.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.load.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.load.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.load.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.load.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.load.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.load.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean mechanics.load.animation = mechanics.animation \"= true, if animation shall be enabled (show shape between frame_a and frame_b and optionally a sphere at the center of mass)\";
//   parameter Boolean mechanics.load.animateSphere = true \"= true, if mass shall be animated as sphere provided animation=true\";
//   parameter Real mechanics.load.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.load.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.load.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.load.r_CM[1](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.rLoad[1] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.load.r_CM[2](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.rLoad[2] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.load.r_CM[3](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.rLoad[3] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.load.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 1.0) = mechanics.mLoad \"Mass of rigid body\";
//   parameter Real mechanics.load.I_11(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.001 \" (1,1) element of inertia tensor\";
//   parameter Real mechanics.load.I_22(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.001 \" (2,2) element of inertia tensor\";
//   parameter Real mechanics.load.I_33(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.001 \" (3,3) element of inertia tensor\";
//   parameter Real mechanics.load.I_21(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (2,1) element of inertia tensor\";
//   parameter Real mechanics.load.I_31(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (3,1) element of inertia tensor\";
//   parameter Real mechanics.load.I_32(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = 0.0 \" (3,2) element of inertia tensor\";
//   Real mechanics.load.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.load.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.load.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.load.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.load.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.load.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.load.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real mechanics.load.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real mechanics.load.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean mechanics.load.angles_fixed = false \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real mechanics.load.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real mechanics.load.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real mechanics.load.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer mechanics.load.sequence_start[1](min = 1, max = 3) = 1 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer mechanics.load.sequence_start[2](min = 1, max = 3) = 2 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer mechanics.load.sequence_start[3](min = 1, max = 3) = 3 \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean mechanics.load.w_0_fixed = false \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real mechanics.load.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real mechanics.load.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real mechanics.load.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean mechanics.load.z_0_fixed = false \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real mechanics.load.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.load.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.load.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 0.0 \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter String mechanics.load.shapeType = \"cylinder\" \" Type of shape\";
//   parameter Real mechanics.load.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.load.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.load.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.load.widthDirection[1](unit = \"1\") = 1.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.load.widthDirection[2](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.load.widthDirection[3](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.load.extra = 0.0 \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer mechanics.load.color[1](min = 0, max = 255) = 255 \" Color of shape\";
//   input Integer mechanics.load.color[2](min = 0, max = 255) = 0 \" Color of shape\";
//   input Integer mechanics.load.color[3](min = 0, max = 255) = 0 \" Color of shape\";
//   input Integer mechanics.load.sphereColor[1](min = 0, max = 255) = mechanics.load.color[1] \" Color of sphere of mass\";
//   input Integer mechanics.load.sphereColor[2](min = 0, max = 255) = mechanics.load.color[2] \" Color of sphere of mass\";
//   input Integer mechanics.load.sphereColor[3](min = 0, max = 255) = mechanics.load.color[3] \" Color of sphere of mass\";
//   input Real mechanics.load.specularCoefficient = mechanics.world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean mechanics.load.enforceStates = false \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean mechanics.load.useQuaternions = true \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer mechanics.load.sequence_angleStates[1](min = 1, max = 3) = 1 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer mechanics.load.sequence_angleStates[2](min = 1, max = 3) = 2 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer mechanics.load.sequence_angleStates[3](min = 1, max = 3) = 3 \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   Real mechanics.load.frameTranslation.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.load.frameTranslation.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.load.frameTranslation.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.load.frameTranslation.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frameTranslation.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frameTranslation.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frameTranslation.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frameTranslation.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frameTranslation.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frameTranslation.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frameTranslation.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frameTranslation.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frameTranslation.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.load.frameTranslation.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.load.frameTranslation.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.load.frameTranslation.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.load.frameTranslation.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.load.frameTranslation.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.load.frameTranslation.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.load.frameTranslation.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.load.frameTranslation.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.load.frameTranslation.frame_b.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.load.frameTranslation.frame_b.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.load.frameTranslation.frame_b.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.load.frameTranslation.frame_b.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frameTranslation.frame_b.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frameTranslation.frame_b.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frameTranslation.frame_b.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frameTranslation.frame_b.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frameTranslation.frame_b.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frameTranslation.frame_b.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frameTranslation.frame_b.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frameTranslation.frame_b.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.frameTranslation.frame_b.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.load.frameTranslation.frame_b.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.load.frameTranslation.frame_b.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.load.frameTranslation.frame_b.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.load.frameTranslation.frame_b.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.load.frameTranslation.frame_b.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.load.frameTranslation.frame_b.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.load.frameTranslation.frame_b.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.load.frameTranslation.frame_b.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean mechanics.load.frameTranslation.animation = false \"= true, if animation shall be enabled\";
//   parameter Real mechanics.load.frameTranslation.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.load.r[1] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.load.frameTranslation.r[2](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.load.r[2] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter Real mechanics.load.frameTranslation.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.load.r[3] \"Vector from frame_a to frame_b resolved in frame_a\";
//   parameter String mechanics.load.frameTranslation.shapeType = \"cylinder\" \" Type of shape\";
//   parameter Real mechanics.load.frameTranslation.r_shape[1](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.load.frameTranslation.r_shape[2](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.load.frameTranslation.r_shape[3](quantity = \"Length\", unit = \"m\") = 0.0 \" Vector from frame_a to shape origin, resolved in frame_a\";
//   parameter Real mechanics.load.frameTranslation.widthDirection[1](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.load.frameTranslation.widthDirection[2](unit = \"1\") = 1.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.load.frameTranslation.widthDirection[3](unit = \"1\") = 0.0 \" Vector in width direction of shape, resolved in frame_a\";
//   parameter Real mechanics.load.frameTranslation.extra = 0.0 \" Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).\";
//   input Integer mechanics.load.frameTranslation.color[1](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer mechanics.load.frameTranslation.color[2](min = 0, max = 255) = 155 \" Color of shape\";
//   input Integer mechanics.load.frameTranslation.color[3](min = 0, max = 255) = 155 \" Color of shape\";
//   input Real mechanics.load.frameTranslation.specularCoefficient = mechanics.world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Real mechanics.load.frameTranslation.lengthDirection[1](unit = \"1\") = mechanics.load.frameTranslation.r[1] - mechanics.load.frameTranslation.r_shape[1] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.load.frameTranslation.lengthDirection[2](unit = \"1\") = mechanics.load.frameTranslation.r[2] - mechanics.load.frameTranslation.r_shape[2] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.load.frameTranslation.lengthDirection[3](unit = \"1\") = mechanics.load.frameTranslation.r[3] - mechanics.load.frameTranslation.r_shape[3] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.load.frameTranslation.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({mechanics.load.frameTranslation.r[1] - mechanics.load.frameTranslation.r_shape[1],mechanics.load.frameTranslation.r[2] - mechanics.load.frameTranslation.r_shape[2],mechanics.load.frameTranslation.r[3] - mechanics.load.frameTranslation.r_shape[3]}) \" Length of shape\";
//   parameter Real mechanics.load.frameTranslation.width(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.load.frameTranslation.length / mechanics.world.defaultWidthFraction \" Width of shape\";
//   parameter Real mechanics.load.frameTranslation.height(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.load.frameTranslation.width \" Height of shape.\";
//   Real mechanics.load.body.frame_a.r_0[1](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.load.body.frame_a.r_0[2](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.load.body.frame_a.r_0[3](quantity = \"Length\", unit = \"m\") \"Position vector from world frame to the connector frame origin, resolved in world frame\";
//   Real mechanics.load.body.frame_a.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.body.frame_a.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.body.frame_a.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.body.frame_a.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.body.frame_a.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.body.frame_a.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.body.frame_a.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.body.frame_a.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.body.frame_a.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   Real mechanics.load.body.frame_a.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.load.body.frame_a.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.load.body.frame_a.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   Real mechanics.load.body.frame_a.f[1](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.load.body.frame_a.f[2](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.load.body.frame_a.f[3](quantity = \"Force\", unit = \"N\") \"Cut-force resolved in connector frame\";
//   Real mechanics.load.body.frame_a.t[1](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.load.body.frame_a.t[2](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   Real mechanics.load.body.frame_a.t[3](quantity = \"Torque\", unit = \"N.m\") \"Cut-torque resolved in connector frame\";
//   parameter Boolean mechanics.load.body.animation = false \"= true, if animation shall be enabled (show cylinder and sphere)\";
//   parameter Real mechanics.load.body.r_CM[1](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.load.r_CM[1] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.load.body.r_CM[2](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.load.r_CM[2] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.load.body.r_CM[3](quantity = \"Length\", unit = \"m\", start = 0.0) = mechanics.load.r_CM[3] \"Vector from frame_a to center of mass, resolved in frame_a\";
//   parameter Real mechanics.load.body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 1.0) = mechanics.load.m \"Mass of rigid body\";
//   parameter Real mechanics.load.body.I_11(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = mechanics.load.I_11 \" (1,1) element of inertia tensor\";
//   parameter Real mechanics.load.body.I_22(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = mechanics.load.I_22 \" (2,2) element of inertia tensor\";
//   parameter Real mechanics.load.body.I_33(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = mechanics.load.I_33 \" (3,3) element of inertia tensor\";
//   parameter Real mechanics.load.body.I_21(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = mechanics.load.I_21 \" (2,1) element of inertia tensor\";
//   parameter Real mechanics.load.body.I_31(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = mechanics.load.I_31 \" (3,1) element of inertia tensor\";
//   parameter Real mechanics.load.body.I_32(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = -1e+60) = mechanics.load.I_32 \" (3,2) element of inertia tensor\";
//   Real mechanics.load.body.r_0[1](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.load.body.r_0[2](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.load.body.r_0[3](quantity = \"Length\", unit = \"m\", start = 0.0, StateSelect = StateSelect.avoid) \"Position vector from origin of world frame to origin of frame_a\";
//   Real mechanics.load.body.v_0[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.load.body.v_0[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.load.body.v_0[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0, StateSelect = StateSelect.avoid) \"Absolute velocity of frame_a, resolved in world frame (= der(r_0))\";
//   Real mechanics.load.body.a_0[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real mechanics.load.body.a_0[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   Real mechanics.load.body.a_0[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 0.0) \"Absolute acceleration of frame_a resolved in world frame (= der(v_0))\";
//   parameter Boolean mechanics.load.body.angles_fixed = mechanics.load.angles_fixed \"= true, if angles_start are used as initial values, else as guess values\";
//   parameter Real mechanics.load.body.angles_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = mechanics.load.angles_start[1] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real mechanics.load.body.angles_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = mechanics.load.angles_start[2] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Real mechanics.load.body.angles_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = mechanics.load.angles_start[3] \"Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b\";
//   parameter Integer mechanics.load.body.sequence_start[1](min = 1, max = 3) = mechanics.load.sequence_start[1] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer mechanics.load.body.sequence_start[2](min = 1, max = 3) = mechanics.load.sequence_start[2] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Integer mechanics.load.body.sequence_start[3](min = 1, max = 3) = mechanics.load.sequence_start[3] \"Sequence of rotations to rotate frame_a into frame_b at initial time\";
//   parameter Boolean mechanics.load.body.w_0_fixed = mechanics.load.w_0_fixed \"= true, if w_0_start are used as initial values, else as guess values\";
//   parameter Real mechanics.load.body.w_0_start[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = mechanics.load.w_0_start[1] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real mechanics.load.body.w_0_start[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = mechanics.load.w_0_start[2] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Real mechanics.load.body.w_0_start[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = mechanics.load.w_0_start[3] \"Initial or guess values of angular velocity of frame_a resolved in world frame\";
//   parameter Boolean mechanics.load.body.z_0_fixed = mechanics.load.z_0_fixed \"= true, if z_0_start are used as initial values, else as guess values\";
//   parameter Real mechanics.load.body.z_0_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = mechanics.load.z_0_start[1] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.load.body.z_0_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = mechanics.load.z_0_start[2] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.load.body.z_0_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = mechanics.load.z_0_start[3] \"Initial values of angular acceleration z_0 = der(w_0)\";
//   parameter Real mechanics.load.body.sphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.world.defaultBodyDiameter \"Diameter of sphere\";
//   input Integer mechanics.load.body.sphereColor[1](min = 0, max = 255) = 0 \"Color of sphere\";
//   input Integer mechanics.load.body.sphereColor[2](min = 0, max = 255) = 128 \"Color of sphere\";
//   input Integer mechanics.load.body.sphereColor[3](min = 0, max = 255) = 255 \"Color of sphere\";
//   input Integer mechanics.load.body.cylinderColor[1](min = 0, max = 255) = mechanics.load.body.sphereColor[1] \"Color of cylinder\";
//   input Integer mechanics.load.body.cylinderColor[2](min = 0, max = 255) = mechanics.load.body.sphereColor[2] \"Color of cylinder\";
//   input Integer mechanics.load.body.cylinderColor[3](min = 0, max = 255) = mechanics.load.body.sphereColor[3] \"Color of cylinder\";
//   input Real mechanics.load.body.specularCoefficient = mechanics.world.defaultSpecularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   parameter Boolean mechanics.load.body.enforceStates = mechanics.load.enforceStates \" = true, if absolute variables of body object shall be used as states (StateSelect.always)\";
//   parameter Boolean mechanics.load.body.useQuaternions = mechanics.load.useQuaternions \" = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states\";
//   parameter Integer mechanics.load.body.sequence_angleStates[1](min = 1, max = 3) = mechanics.load.sequence_angleStates[1] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer mechanics.load.body.sequence_angleStates[2](min = 1, max = 3) = mechanics.load.sequence_angleStates[2] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   parameter Integer mechanics.load.body.sequence_angleStates[3](min = 1, max = 3) = mechanics.load.sequence_angleStates[3] \" Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states\";
//   Real mechanics.load.body.w_a[1](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.load.body.R_start,{mechanics.load.body.w_0_start[1],mechanics.load.body.w_0_start[2],mechanics.load.body.w_0_start[3]})[1], fixed = mechanics.load.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real mechanics.load.body.w_a[2](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.load.body.R_start,{mechanics.load.body.w_0_start[1],mechanics.load.body.w_0_start[2],mechanics.load.body.w_0_start[3]})[2], fixed = mechanics.load.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real mechanics.load.body.w_a[3](quantity = \"AngularVelocity\", unit = \"rad/s\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.load.body.R_start,{mechanics.load.body.w_0_start[1],mechanics.load.body.w_0_start[2],mechanics.load.body.w_0_start[3]})[3], fixed = mechanics.load.body.w_0_fixed, StateSelect = StateSelect.avoid) \"Absolute angular velocity of frame_a resolved in frame_a\";
//   Real mechanics.load.body.z_a[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.load.body.R_start,{mechanics.load.body.z_0_start[1],mechanics.load.body.z_0_start[2],mechanics.load.body.z_0_start[3]})[1], fixed = mechanics.load.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real mechanics.load.body.z_a[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.load.body.R_start,{mechanics.load.body.z_0_start[1],mechanics.load.body.z_0_start[2],mechanics.load.body.z_0_start[3]})[2], fixed = mechanics.load.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real mechanics.load.body.z_a[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.load.body.R_start,{mechanics.load.body.z_0_start[1],mechanics.load.body.z_0_start[2],mechanics.load.body.z_0_start[3]})[3], fixed = mechanics.load.body.z_0_fixed) \"Absolute angular acceleration of frame_a resolved in frame_a\";
//   Real mechanics.load.body.g_0[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real mechanics.load.body.g_0[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   Real mechanics.load.body.g_0[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Gravity acceleration resolved in world frame\";
//   protected Real mechanics.load.body.Q[1](start = mechanics.load.body.Q_start[1], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real mechanics.load.body.Q[2](start = mechanics.load.body.Q_start[2], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real mechanics.load.body.Q[3](start = mechanics.load.body.Q_start[3], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real mechanics.load.body.Q[4](start = mechanics.load.body.Q_start[4], StateSelect = StateSelect.avoid) \"Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)\";
//   protected Real mechanics.load.body.phi[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = mechanics.load.body.phi_start[1], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real mechanics.load.body.phi[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = mechanics.load.body.phi_start[2], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real mechanics.load.body.phi[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = mechanics.load.body.phi_start[3], StateSelect = StateSelect.avoid) \"Dummy or 3 angles to rotate world frame into frame_a of body\";
//   protected Real mechanics.load.body.phi_d[1](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real mechanics.load.body.phi_d[2](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real mechanics.load.body.phi_d[3](quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.avoid) \"= der(phi)\";
//   protected Real mechanics.load.body.phi_dd[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real mechanics.load.body.phi_dd[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   protected Real mechanics.load.body.phi_dd[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"= der(phi_d)\";
//   final parameter Real mechanics.load.body.I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.load.body.I_11 \"inertia tensor\";
//   final parameter Real mechanics.load.body.I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.load.body.I_21 \"inertia tensor\";
//   final parameter Real mechanics.load.body.I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.load.body.I_31 \"inertia tensor\";
//   final parameter Real mechanics.load.body.I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.load.body.I_21 \"inertia tensor\";
//   final parameter Real mechanics.load.body.I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.load.body.I_22 \"inertia tensor\";
//   final parameter Real mechanics.load.body.I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.load.body.I_32 \"inertia tensor\";
//   final parameter Real mechanics.load.body.I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.load.body.I_31 \"inertia tensor\";
//   final parameter Real mechanics.load.body.I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.load.body.I_32 \"inertia tensor\";
//   final parameter Real mechanics.load.body.I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\") = mechanics.load.body.I_33 \"inertia tensor\";
//   final parameter Real mechanics.load.body.R_start.T[1,1] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.load.body.R_start.T[1,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.load.body.R_start.T[1,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.load.body.R_start.T[2,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.load.body.R_start.T[2,2] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.load.body.R_start.T[2,3] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.load.body.R_start.T[3,1] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.load.body.R_start.T[3,2] = 0.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.load.body.R_start.T[3,3] = 1.0 \"Transformation matrix from world frame to local frame\";
//   final parameter Real mechanics.load.body.R_start.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   final parameter Real mechanics.load.body.R_start.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   final parameter Real mechanics.load.body.R_start.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"Absolute angular velocity of local frame, resolved in local frame\";
//   parameter Real mechanics.load.body.cylinderDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = mechanics.load.body.sphereDiameter / 3.0 \"Diameter of cylinder\";
//   final parameter Real mechanics.load.body.z_a_start[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.load.body.R_start,{mechanics.load.body.z_0_start[1],mechanics.load.body.z_0_start[2],mechanics.load.body.z_0_start[3]})[1] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   final parameter Real mechanics.load.body.z_a_start[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.load.body.R_start,{mechanics.load.body.z_0_start[1],mechanics.load.body.z_0_start[2],mechanics.load.body.z_0_start[3]})[2] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   final parameter Real mechanics.load.body.z_a_start[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.load.body.R_start,{mechanics.load.body.z_0_start[1],mechanics.load.body.z_0_start[2],mechanics.load.body.z_0_start[3]})[3] \"Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a\";
//   protected parameter Real mechanics.load.body.Q_start[1] = Modelica.Mechanics.MultiBody.Frames.to_Q(mechanics.load.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[1] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real mechanics.load.body.Q_start[2] = Modelica.Mechanics.MultiBody.Frames.to_Q(mechanics.load.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[2] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real mechanics.load.body.Q_start[3] = Modelica.Mechanics.MultiBody.Frames.to_Q(mechanics.load.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[3] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real mechanics.load.body.Q_start[4] = Modelica.Mechanics.MultiBody.Frames.to_Q(mechanics.load.body.R_start,Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation())[4] \"Quaternion orientation object from world frame to frame_a at initial time\";
//   protected parameter Real mechanics.load.body.phi_start[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if mechanics.load.body.sequence_start[1] == mechanics.load.body.sequence_angleStates[1] and mechanics.load.body.sequence_start[2] == mechanics.load.body.sequence_angleStates[2] and mechanics.load.body.sequence_start[3] == mechanics.load.body.sequence_angleStates[3] then mechanics.load.body.angles_start[1] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(mechanics.load.body.R_start,{mechanics.load.body.sequence_angleStates[1],mechanics.load.body.sequence_angleStates[2],mechanics.load.body.sequence_angleStates[3]},0.0)[1] \"Potential angle states at initial time\";
//   protected parameter Real mechanics.load.body.phi_start[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if mechanics.load.body.sequence_start[1] == mechanics.load.body.sequence_angleStates[1] and mechanics.load.body.sequence_start[2] == mechanics.load.body.sequence_angleStates[2] and mechanics.load.body.sequence_start[3] == mechanics.load.body.sequence_angleStates[3] then mechanics.load.body.angles_start[2] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(mechanics.load.body.R_start,{mechanics.load.body.sequence_angleStates[1],mechanics.load.body.sequence_angleStates[2],mechanics.load.body.sequence_angleStates[3]},0.0)[2] \"Potential angle states at initial time\";
//   protected parameter Real mechanics.load.body.phi_start[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = if mechanics.load.body.sequence_start[1] == mechanics.load.body.sequence_angleStates[1] and mechanics.load.body.sequence_start[2] == mechanics.load.body.sequence_angleStates[2] and mechanics.load.body.sequence_start[3] == mechanics.load.body.sequence_angleStates[3] then mechanics.load.body.angles_start[3] else Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles(mechanics.load.body.R_start,{mechanics.load.body.sequence_angleStates[1],mechanics.load.body.sequence_angleStates[2],mechanics.load.body.sequence_angleStates[3]},0.0)[3] \"Potential angle states at initial time\";
//   parameter String mechanics.load.shape1.shapeType = mechanics.load.shapeType \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real mechanics.load.shape1.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.load.shape1.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.load.shape1.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.load.shape1.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.load.shape1.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.load.shape1.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.load.shape1.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.load.shape1.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.load.shape1.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.load.shape1.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.load.shape1.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.load.shape1.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.load.shape1.r[1](quantity = \"Length\", unit = \"m\") = mechanics.load.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.load.shape1.r[2](quantity = \"Length\", unit = \"m\") = mechanics.load.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.load.shape1.r[3](quantity = \"Length\", unit = \"m\") = mechanics.load.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.load.shape1.r_shape[1](quantity = \"Length\", unit = \"m\") = mechanics.load.r_shape[1] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.load.shape1.r_shape[2](quantity = \"Length\", unit = \"m\") = mechanics.load.r_shape[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.load.shape1.r_shape[3](quantity = \"Length\", unit = \"m\") = mechanics.load.r_shape[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.load.shape1.lengthDirection[1](unit = \"1\") = mechanics.load.lengthDirection[1] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.load.shape1.lengthDirection[2](unit = \"1\") = mechanics.load.lengthDirection[2] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.load.shape1.lengthDirection[3](unit = \"1\") = mechanics.load.lengthDirection[3] \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.load.shape1.widthDirection[1](unit = \"1\") = mechanics.load.widthDirection[1] \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.load.shape1.widthDirection[2](unit = \"1\") = mechanics.load.widthDirection[2] \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.load.shape1.widthDirection[3](unit = \"1\") = mechanics.load.widthDirection[3] \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.load.shape1.length(quantity = \"Length\", unit = \"m\") = mechanics.load.length \"Length of visual object\";
//   input Real mechanics.load.shape1.width(quantity = \"Length\", unit = \"m\") = mechanics.load.width \"Width of visual object\";
//   input Real mechanics.load.shape1.height(quantity = \"Length\", unit = \"m\") = mechanics.load.height \"Height of visual object\";
//   input Real mechanics.load.shape1.extra = mechanics.load.extra \"Additional size data for some of the shape types\";
//   input Real mechanics.load.shape1.color[1] = Real(mechanics.load.color[1]) \"Color of shape\";
//   input Real mechanics.load.shape1.color[2] = Real(mechanics.load.color[2]) \"Color of shape\";
//   input Real mechanics.load.shape1.color[3] = Real(mechanics.load.color[3]) \"Color of shape\";
//   input Real mechanics.load.shape1.specularCoefficient = mechanics.load.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real mechanics.load.shape1.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({mechanics.load.shape1.lengthDirection[1],mechanics.load.shape1.lengthDirection[2],mechanics.load.shape1.lengthDirection[3]});
//   protected Real mechanics.load.shape1.e_x[1](unit = \"1\") = if noEvent(mechanics.load.shape1.abs_n_x < 1e-10) then 1.0 else mechanics.load.shape1.lengthDirection[1] / mechanics.load.shape1.abs_n_x;
//   protected Real mechanics.load.shape1.e_x[2](unit = \"1\") = if noEvent(mechanics.load.shape1.abs_n_x < 1e-10) then 0.0 else mechanics.load.shape1.lengthDirection[2] / mechanics.load.shape1.abs_n_x;
//   protected Real mechanics.load.shape1.e_x[3](unit = \"1\") = if noEvent(mechanics.load.shape1.abs_n_x < 1e-10) then 0.0 else mechanics.load.shape1.lengthDirection[3] / mechanics.load.shape1.abs_n_x;
//   protected Real mechanics.load.shape1.n_z_aux[1](unit = \"1\") = mechanics.load.shape1.e_x[2] * mechanics.load.shape1.widthDirection[3] - mechanics.load.shape1.e_x[3] * mechanics.load.shape1.widthDirection[2];
//   protected Real mechanics.load.shape1.n_z_aux[2](unit = \"1\") = mechanics.load.shape1.e_x[3] * mechanics.load.shape1.widthDirection[1] - mechanics.load.shape1.e_x[1] * mechanics.load.shape1.widthDirection[3];
//   protected Real mechanics.load.shape1.n_z_aux[3](unit = \"1\") = mechanics.load.shape1.e_x[1] * mechanics.load.shape1.widthDirection[2] - mechanics.load.shape1.e_x[2] * mechanics.load.shape1.widthDirection[1];
//   protected Real mechanics.load.shape1.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.load.shape1.e_x[1],mechanics.load.shape1.e_x[2],mechanics.load.shape1.e_x[3]},if noEvent(mechanics.load.shape1.n_z_aux[1] ^ 2.0 + (mechanics.load.shape1.n_z_aux[2] ^ 2.0 + mechanics.load.shape1.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.load.shape1.widthDirection[1],mechanics.load.shape1.widthDirection[2],mechanics.load.shape1.widthDirection[3]} else if noEvent(abs(mechanics.load.shape1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.load.shape1.e_x[1],mechanics.load.shape1.e_x[2],mechanics.load.shape1.e_x[3]})[1];
//   protected Real mechanics.load.shape1.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.load.shape1.e_x[1],mechanics.load.shape1.e_x[2],mechanics.load.shape1.e_x[3]},if noEvent(mechanics.load.shape1.n_z_aux[1] ^ 2.0 + (mechanics.load.shape1.n_z_aux[2] ^ 2.0 + mechanics.load.shape1.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.load.shape1.widthDirection[1],mechanics.load.shape1.widthDirection[2],mechanics.load.shape1.widthDirection[3]} else if noEvent(abs(mechanics.load.shape1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.load.shape1.e_x[1],mechanics.load.shape1.e_x[2],mechanics.load.shape1.e_x[3]})[2];
//   protected Real mechanics.load.shape1.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.load.shape1.e_x[1],mechanics.load.shape1.e_x[2],mechanics.load.shape1.e_x[3]},if noEvent(mechanics.load.shape1.n_z_aux[1] ^ 2.0 + (mechanics.load.shape1.n_z_aux[2] ^ 2.0 + mechanics.load.shape1.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.load.shape1.widthDirection[1],mechanics.load.shape1.widthDirection[2],mechanics.load.shape1.widthDirection[3]} else if noEvent(abs(mechanics.load.shape1.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.load.shape1.e_x[1],mechanics.load.shape1.e_x[2],mechanics.load.shape1.e_x[3]})[3];
//   protected output Real mechanics.load.shape1.Form;
//   output Real mechanics.load.shape1.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.load.shape1.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.load.shape1.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.load.shape1.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.load.shape1.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.load.shape1.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.load.shape1.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real mechanics.load.shape1.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real mechanics.load.shape1.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real mechanics.load.shape1.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.load.shape1.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.load.shape1.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.load.shape1.Material;
//   protected output Real mechanics.load.shape1.Extra;
//   parameter String mechanics.load.shape2.shapeType = \"sphere\" \"Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring)\";
//   input Real mechanics.load.shape2.R.T[1,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.load.shape2.R.T[1,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.load.shape2.R.T[1,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.load.shape2.R.T[2,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.load.shape2.R.T[2,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.load.shape2.R.T[2,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.load.shape2.R.T[3,1] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.load.shape2.R.T[3,2] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.load.shape2.R.T[3,3] \"Transformation matrix from world frame to local frame\";
//   input Real mechanics.load.shape2.R.w[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.load.shape2.R.w[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.load.shape2.R.w[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of local frame, resolved in local frame\";
//   input Real mechanics.load.shape2.r[1](quantity = \"Length\", unit = \"m\") = mechanics.load.frame_a.r_0[1] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.load.shape2.r[2](quantity = \"Length\", unit = \"m\") = mechanics.load.frame_a.r_0[2] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.load.shape2.r[3](quantity = \"Length\", unit = \"m\") = mechanics.load.frame_a.r_0[3] \"Position vector from origin of world frame to origin of object frame, resolved in world frame\";
//   input Real mechanics.load.shape2.r_shape[1](quantity = \"Length\", unit = \"m\") = mechanics.load.r_CM[1] - mechanics.load.sphereDiameter / 2.0 \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.load.shape2.r_shape[2](quantity = \"Length\", unit = \"m\") = mechanics.load.r_CM[2] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.load.shape2.r_shape[3](quantity = \"Length\", unit = \"m\") = mechanics.load.r_CM[3] \"Position vector from origin of object frame to shape origin, resolved in object frame\";
//   input Real mechanics.load.shape2.lengthDirection[1](unit = \"1\") = 1.0 \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.load.shape2.lengthDirection[2](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.load.shape2.lengthDirection[3](unit = \"1\") = 0.0 \"Vector in length direction, resolved in object frame\";
//   input Real mechanics.load.shape2.widthDirection[1](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.load.shape2.widthDirection[2](unit = \"1\") = 1.0 \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.load.shape2.widthDirection[3](unit = \"1\") = 0.0 \"Vector in width direction, resolved in object frame\";
//   input Real mechanics.load.shape2.length(quantity = \"Length\", unit = \"m\") = mechanics.load.sphereDiameter \"Length of visual object\";
//   input Real mechanics.load.shape2.width(quantity = \"Length\", unit = \"m\") = mechanics.load.sphereDiameter \"Width of visual object\";
//   input Real mechanics.load.shape2.height(quantity = \"Length\", unit = \"m\") = mechanics.load.sphereDiameter \"Height of visual object\";
//   input Real mechanics.load.shape2.extra = 0.0 \"Additional size data for some of the shape types\";
//   input Real mechanics.load.shape2.color[1] = Real(mechanics.load.sphereColor[1]) \"Color of shape\";
//   input Real mechanics.load.shape2.color[2] = Real(mechanics.load.sphereColor[2]) \"Color of shape\";
//   input Real mechanics.load.shape2.color[3] = Real(mechanics.load.sphereColor[3]) \"Color of shape\";
//   input Real mechanics.load.shape2.specularCoefficient = mechanics.load.specularCoefficient \"Reflection of ambient light (= 0: light is completely absorbed)\";
//   protected Real mechanics.load.shape2.abs_n_x(unit = \"1\") = Modelica.Math.Vectors.length({mechanics.load.shape2.lengthDirection[1],mechanics.load.shape2.lengthDirection[2],mechanics.load.shape2.lengthDirection[3]});
//   protected Real mechanics.load.shape2.e_x[1](unit = \"1\") = if noEvent(mechanics.load.shape2.abs_n_x < 1e-10) then 1.0 else mechanics.load.shape2.lengthDirection[1] / mechanics.load.shape2.abs_n_x;
//   protected Real mechanics.load.shape2.e_x[2](unit = \"1\") = if noEvent(mechanics.load.shape2.abs_n_x < 1e-10) then 0.0 else mechanics.load.shape2.lengthDirection[2] / mechanics.load.shape2.abs_n_x;
//   protected Real mechanics.load.shape2.e_x[3](unit = \"1\") = if noEvent(mechanics.load.shape2.abs_n_x < 1e-10) then 0.0 else mechanics.load.shape2.lengthDirection[3] / mechanics.load.shape2.abs_n_x;
//   protected Real mechanics.load.shape2.n_z_aux[1](unit = \"1\") = mechanics.load.shape2.e_x[2] * mechanics.load.shape2.widthDirection[3] - mechanics.load.shape2.e_x[3] * mechanics.load.shape2.widthDirection[2];
//   protected Real mechanics.load.shape2.n_z_aux[2](unit = \"1\") = mechanics.load.shape2.e_x[3] * mechanics.load.shape2.widthDirection[1] - mechanics.load.shape2.e_x[1] * mechanics.load.shape2.widthDirection[3];
//   protected Real mechanics.load.shape2.n_z_aux[3](unit = \"1\") = mechanics.load.shape2.e_x[1] * mechanics.load.shape2.widthDirection[2] - mechanics.load.shape2.e_x[2] * mechanics.load.shape2.widthDirection[1];
//   protected Real mechanics.load.shape2.e_y[1](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.load.shape2.e_x[1],mechanics.load.shape2.e_x[2],mechanics.load.shape2.e_x[3]},if noEvent(mechanics.load.shape2.n_z_aux[1] ^ 2.0 + (mechanics.load.shape2.n_z_aux[2] ^ 2.0 + mechanics.load.shape2.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.load.shape2.widthDirection[1],mechanics.load.shape2.widthDirection[2],mechanics.load.shape2.widthDirection[3]} else if noEvent(abs(mechanics.load.shape2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.load.shape2.e_x[1],mechanics.load.shape2.e_x[2],mechanics.load.shape2.e_x[3]})[1];
//   protected Real mechanics.load.shape2.e_y[2](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.load.shape2.e_x[1],mechanics.load.shape2.e_x[2],mechanics.load.shape2.e_x[3]},if noEvent(mechanics.load.shape2.n_z_aux[1] ^ 2.0 + (mechanics.load.shape2.n_z_aux[2] ^ 2.0 + mechanics.load.shape2.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.load.shape2.widthDirection[1],mechanics.load.shape2.widthDirection[2],mechanics.load.shape2.widthDirection[3]} else if noEvent(abs(mechanics.load.shape2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.load.shape2.e_x[1],mechanics.load.shape2.e_x[2],mechanics.load.shape2.e_x[3]})[2];
//   protected Real mechanics.load.shape2.e_y[3](unit = \"1\") = cross(Modelica.Math.Vectors.normalize(cross({mechanics.load.shape2.e_x[1],mechanics.load.shape2.e_x[2],mechanics.load.shape2.e_x[3]},if noEvent(mechanics.load.shape2.n_z_aux[1] ^ 2.0 + (mechanics.load.shape2.n_z_aux[2] ^ 2.0 + mechanics.load.shape2.n_z_aux[3] ^ 2.0) > 1e-06) then {mechanics.load.shape2.widthDirection[1],mechanics.load.shape2.widthDirection[2],mechanics.load.shape2.widthDirection[3]} else if noEvent(abs(mechanics.load.shape2.e_x[1]) > 1e-06) then {0.0,1.0,0.0} else {1.0,0.0,0.0}),1e-13),{mechanics.load.shape2.e_x[1],mechanics.load.shape2.e_x[2],mechanics.load.shape2.e_x[3]})[3];
//   protected output Real mechanics.load.shape2.Form;
//   output Real mechanics.load.shape2.rxvisobj[1](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.load.shape2.rxvisobj[2](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.load.shape2.rxvisobj[3](unit = \"1\") \"x-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.load.shape2.ryvisobj[1](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.load.shape2.ryvisobj[2](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.load.shape2.ryvisobj[3](unit = \"1\") \"y-axis unit vector of shape, resolved in world frame\";
//   output Real mechanics.load.shape2.rvisobj[1](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real mechanics.load.shape2.rvisobj[2](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   output Real mechanics.load.shape2.rvisobj[3](quantity = \"Length\", unit = \"m\") \"position vector from world frame to shape frame, resolved in world frame\";
//   protected output Real mechanics.load.shape2.size[1](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.load.shape2.size[2](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.load.shape2.size[3](quantity = \"Length\", unit = \"m\") \"{length,width,height} of shape\";
//   protected output Real mechanics.load.shape2.Material;
//   protected output Real mechanics.load.shape2.Extra;
//   parameter Real mechanics.load.lengthDirection[1](unit = \"1\") = mechanics.rLoad[1] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.load.lengthDirection[2](unit = \"1\") = mechanics.rLoad[2] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.load.lengthDirection[3](unit = \"1\") = mechanics.rLoad[3] \" Vector in length direction of shape, resolved in frame_a\";
//   parameter Real mechanics.load.length(quantity = \"Length\", unit = \"m\") = Modelica.Math.Vectors.length({mechanics.rLoad[1],mechanics.rLoad[2],mechanics.rLoad[3]}) \" Length of shape\";
//   parameter Real mechanics.load.width(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.05 \" Width of shape\";
//   parameter Real mechanics.load.height(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.05 \" Height of shape.\";
//   parameter Real mechanics.load.sphereDiameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 2.0 * mechanics.load.width \" Diameter of sphere\";
//   parameter Integer pathPlanning.naxis = 6 \"number of driven axis\";
//   parameter Real pathPlanning.startTime(quantity = \"Time\", unit = \"s\") = refStartTime \"Start time of movement\";
//   parameter Real pathPlanning.swingTime(quantity = \"Time\", unit = \"s\") = refSwingTime \"Additional time after reference motion is in rest before simulation is stopped\";
//   parameter Real pathPlanning.path.q_begin[1] = pathPlanning.angleBeg[1] \"Start position\";
//   parameter Real pathPlanning.path.q_begin[2] = pathPlanning.angleBeg[2] \"Start position\";
//   parameter Real pathPlanning.path.q_begin[3] = pathPlanning.angleBeg[3] \"Start position\";
//   parameter Real pathPlanning.path.q_begin[4] = pathPlanning.angleBeg[4] \"Start position\";
//   parameter Real pathPlanning.path.q_begin[5] = pathPlanning.angleBeg[5] \"Start position\";
//   parameter Real pathPlanning.path.q_begin[6] = pathPlanning.angleBeg[6] \"Start position\";
//   parameter Real pathPlanning.path.q_end[1] = pathPlanning.angleEnd[1] \"End position\";
//   parameter Real pathPlanning.path.q_end[2] = pathPlanning.angleEnd[2] \"End position\";
//   parameter Real pathPlanning.path.q_end[3] = pathPlanning.angleEnd[3] \"End position\";
//   parameter Real pathPlanning.path.q_end[4] = pathPlanning.angleEnd[4] \"End position\";
//   parameter Real pathPlanning.path.q_end[5] = pathPlanning.angleEnd[5] \"End position\";
//   parameter Real pathPlanning.path.q_end[6] = pathPlanning.angleEnd[6] \"End position\";
//   parameter Real pathPlanning.path.qd_max[1](min = 1e-60) = pathPlanning.speedMax[1] \"Maximum velocities der(q)\";
//   parameter Real pathPlanning.path.qd_max[2](min = 1e-60) = pathPlanning.speedMax[2] \"Maximum velocities der(q)\";
//   parameter Real pathPlanning.path.qd_max[3](min = 1e-60) = pathPlanning.speedMax[3] \"Maximum velocities der(q)\";
//   parameter Real pathPlanning.path.qd_max[4](min = 1e-60) = pathPlanning.speedMax[4] \"Maximum velocities der(q)\";
//   parameter Real pathPlanning.path.qd_max[5](min = 1e-60) = pathPlanning.speedMax[5] \"Maximum velocities der(q)\";
//   parameter Real pathPlanning.path.qd_max[6](min = 1e-60) = pathPlanning.speedMax[6] \"Maximum velocities der(q)\";
//   parameter Real pathPlanning.path.qdd_max[1](min = 1e-60) = pathPlanning.accMax[1] \"Maximum accelerations der(qd)\";
//   parameter Real pathPlanning.path.qdd_max[2](min = 1e-60) = pathPlanning.accMax[2] \"Maximum accelerations der(qd)\";
//   parameter Real pathPlanning.path.qdd_max[3](min = 1e-60) = pathPlanning.accMax[3] \"Maximum accelerations der(qd)\";
//   parameter Real pathPlanning.path.qdd_max[4](min = 1e-60) = pathPlanning.accMax[4] \"Maximum accelerations der(qd)\";
//   parameter Real pathPlanning.path.qdd_max[5](min = 1e-60) = pathPlanning.accMax[5] \"Maximum accelerations der(qd)\";
//   parameter Real pathPlanning.path.qdd_max[6](min = 1e-60) = pathPlanning.accMax[6] \"Maximum accelerations der(qd)\";
//   parameter Real pathPlanning.path.startTime(quantity = \"Time\", unit = \"s\") = pathPlanning.startTime \"Time instant at which movement starts\";
//   output Real pathPlanning.path.endTime(quantity = \"Time\", unit = \"s\") \"Time instant at which movement stops\";
//   output Real pathPlanning.path.q[1] \"Reference position of path planning\";
//   output Real pathPlanning.path.q[2] \"Reference position of path planning\";
//   output Real pathPlanning.path.q[3] \"Reference position of path planning\";
//   output Real pathPlanning.path.q[4] \"Reference position of path planning\";
//   output Real pathPlanning.path.q[5] \"Reference position of path planning\";
//   output Real pathPlanning.path.q[6] \"Reference position of path planning\";
//   output Real pathPlanning.path.qd[1] \"Reference speed of path planning\";
//   output Real pathPlanning.path.qd[2] \"Reference speed of path planning\";
//   output Real pathPlanning.path.qd[3] \"Reference speed of path planning\";
//   output Real pathPlanning.path.qd[4] \"Reference speed of path planning\";
//   output Real pathPlanning.path.qd[5] \"Reference speed of path planning\";
//   output Real pathPlanning.path.qd[6] \"Reference speed of path planning\";
//   output Real pathPlanning.path.qdd[1] \"Reference acceleration of path planning\";
//   output Real pathPlanning.path.qdd[2] \"Reference acceleration of path planning\";
//   output Real pathPlanning.path.qdd[3] \"Reference acceleration of path planning\";
//   output Real pathPlanning.path.qdd[4] \"Reference acceleration of path planning\";
//   output Real pathPlanning.path.qdd[5] \"Reference acceleration of path planning\";
//   output Real pathPlanning.path.qdd[6] \"Reference acceleration of path planning\";
//   output Boolean pathPlanning.path.moving[1] \"= true, if end position not yet reached; = false, if end position reached or axis is completely at rest\";
//   output Boolean pathPlanning.path.moving[2] \"= true, if end position not yet reached; = false, if end position reached or axis is completely at rest\";
//   output Boolean pathPlanning.path.moving[3] \"= true, if end position not yet reached; = false, if end position reached or axis is completely at rest\";
//   output Boolean pathPlanning.path.moving[4] \"= true, if end position not yet reached; = false, if end position reached or axis is completely at rest\";
//   output Boolean pathPlanning.path.moving[5] \"= true, if end position not yet reached; = false, if end position reached or axis is completely at rest\";
//   output Boolean pathPlanning.path.moving[6] \"= true, if end position not yet reached; = false, if end position reached or axis is completely at rest\";
//   protected constant Real pathPlanning.path.eps = 1e-14;
//   protected Boolean pathPlanning.path.motion_ref;
//   protected Real pathPlanning.path.sd_max_inv;
//   protected Real pathPlanning.path.sdd_max_inv;
//   protected Real pathPlanning.path.sd_max;
//   protected Real pathPlanning.path.sdd_max;
//   protected Real pathPlanning.path.sdd;
//   protected Real pathPlanning.path.aux1[1];
//   protected Real pathPlanning.path.aux1[2];
//   protected Real pathPlanning.path.aux1[3];
//   protected Real pathPlanning.path.aux1[4];
//   protected Real pathPlanning.path.aux1[5];
//   protected Real pathPlanning.path.aux1[6];
//   protected Real pathPlanning.path.aux2[1];
//   protected Real pathPlanning.path.aux2[2];
//   protected Real pathPlanning.path.aux2[3];
//   protected Real pathPlanning.path.aux2[4];
//   protected Real pathPlanning.path.aux2[5];
//   protected Real pathPlanning.path.aux2[6];
//   protected Real pathPlanning.path.Ta1(quantity = \"Time\", unit = \"s\");
//   protected Real pathPlanning.path.Ta2(quantity = \"Time\", unit = \"s\");
//   protected Real pathPlanning.path.Tv(quantity = \"Time\", unit = \"s\");
//   protected Real pathPlanning.path.Te(quantity = \"Time\", unit = \"s\");
//   protected Boolean pathPlanning.path.noWphase;
//   protected Real pathPlanning.path.Ta1s(quantity = \"Time\", unit = \"s\");
//   protected Real pathPlanning.path.Ta2s(quantity = \"Time\", unit = \"s\");
//   protected Real pathPlanning.path.Tvs(quantity = \"Time\", unit = \"s\");
//   protected Real pathPlanning.path.Tes(quantity = \"Time\", unit = \"s\");
//   protected Real pathPlanning.path.sd_max2;
//   protected Real pathPlanning.path.s1;
//   protected Real pathPlanning.path.s2;
//   protected Real pathPlanning.path.s3;
//   protected Real pathPlanning.path.s;
//   protected Real pathPlanning.path.sd;
//   protected Real pathPlanning.path.r_s;
//   protected Real pathPlanning.path.r_sd;
//   protected Real pathPlanning.path.r_sdd;
//   final parameter Integer pathPlanning.path.nout = 6 \"Number of output signals (= dimension of q, qd, qdd, moving)\";
//   protected parameter Real pathPlanning.path.p_q_begin[1] = pathPlanning.path.q_begin[1];
//   protected parameter Real pathPlanning.path.p_q_begin[2] = pathPlanning.path.q_begin[2];
//   protected parameter Real pathPlanning.path.p_q_begin[3] = pathPlanning.path.q_begin[3];
//   protected parameter Real pathPlanning.path.p_q_begin[4] = pathPlanning.path.q_begin[4];
//   protected parameter Real pathPlanning.path.p_q_begin[5] = pathPlanning.path.q_begin[5];
//   protected parameter Real pathPlanning.path.p_q_begin[6] = pathPlanning.path.q_begin[6];
//   protected parameter Real pathPlanning.path.p_q_end[1] = pathPlanning.path.q_end[1];
//   protected parameter Real pathPlanning.path.p_q_end[2] = pathPlanning.path.q_end[2];
//   protected parameter Real pathPlanning.path.p_q_end[3] = pathPlanning.path.q_end[3];
//   protected parameter Real pathPlanning.path.p_q_end[4] = pathPlanning.path.q_end[4];
//   protected parameter Real pathPlanning.path.p_q_end[5] = pathPlanning.path.q_end[5];
//   protected parameter Real pathPlanning.path.p_q_end[6] = pathPlanning.path.q_end[6];
//   protected parameter Real pathPlanning.path.p_qd_max[1] = pathPlanning.path.qd_max[1];
//   protected parameter Real pathPlanning.path.p_qd_max[2] = pathPlanning.path.qd_max[2];
//   protected parameter Real pathPlanning.path.p_qd_max[3] = pathPlanning.path.qd_max[3];
//   protected parameter Real pathPlanning.path.p_qd_max[4] = pathPlanning.path.qd_max[4];
//   protected parameter Real pathPlanning.path.p_qd_max[5] = pathPlanning.path.qd_max[5];
//   protected parameter Real pathPlanning.path.p_qd_max[6] = pathPlanning.path.qd_max[6];
//   protected parameter Real pathPlanning.path.p_qdd_max[1] = pathPlanning.path.qdd_max[1];
//   protected parameter Real pathPlanning.path.p_qdd_max[2] = pathPlanning.path.qdd_max[2];
//   protected parameter Real pathPlanning.path.p_qdd_max[3] = pathPlanning.path.qdd_max[3];
//   protected parameter Real pathPlanning.path.p_qdd_max[4] = pathPlanning.path.qdd_max[4];
//   protected parameter Real pathPlanning.path.p_qdd_max[5] = pathPlanning.path.qdd_max[5];
//   protected parameter Real pathPlanning.path.p_qdd_max[6] = pathPlanning.path.qdd_max[6];
//   protected parameter Real pathPlanning.path.p_deltaq[1] = pathPlanning.path.p_q_end[1] - pathPlanning.path.p_q_begin[1];
//   protected parameter Real pathPlanning.path.p_deltaq[2] = pathPlanning.path.p_q_end[2] - pathPlanning.path.p_q_begin[2];
//   protected parameter Real pathPlanning.path.p_deltaq[3] = pathPlanning.path.p_q_end[3] - pathPlanning.path.p_q_begin[3];
//   protected parameter Real pathPlanning.path.p_deltaq[4] = pathPlanning.path.p_q_end[4] - pathPlanning.path.p_q_begin[4];
//   protected parameter Real pathPlanning.path.p_deltaq[5] = pathPlanning.path.p_q_end[5] - pathPlanning.path.p_q_begin[5];
//   protected parameter Real pathPlanning.path.p_deltaq[6] = pathPlanning.path.p_q_end[6] - pathPlanning.path.p_q_begin[6];
//   parameter Integer pathPlanning.pathToAxis1.nAxis = pathPlanning.naxis \"Number of driven axis\";
//   parameter Integer pathPlanning.pathToAxis1.axisUsed = 1 \"Map path planning of axisUsed to axisControlBus\";
//   input Real pathPlanning.pathToAxis1.q[1];
//   input Real pathPlanning.pathToAxis1.q[2];
//   input Real pathPlanning.pathToAxis1.q[3];
//   input Real pathPlanning.pathToAxis1.q[4];
//   input Real pathPlanning.pathToAxis1.q[5];
//   input Real pathPlanning.pathToAxis1.q[6];
//   input Real pathPlanning.pathToAxis1.qd[1];
//   input Real pathPlanning.pathToAxis1.qd[2];
//   input Real pathPlanning.pathToAxis1.qd[3];
//   input Real pathPlanning.pathToAxis1.qd[4];
//   input Real pathPlanning.pathToAxis1.qd[5];
//   input Real pathPlanning.pathToAxis1.qd[6];
//   input Real pathPlanning.pathToAxis1.qdd[1];
//   input Real pathPlanning.pathToAxis1.qdd[2];
//   input Real pathPlanning.pathToAxis1.qdd[3];
//   input Real pathPlanning.pathToAxis1.qdd[4];
//   input Real pathPlanning.pathToAxis1.qdd[5];
//   input Real pathPlanning.pathToAxis1.qdd[6];
//   input Real pathPlanning.pathToAxis1.q_axisUsed.u \"Input signal\";
//   output Real pathPlanning.pathToAxis1.q_axisUsed.y \"Output signal\";
//   input Real pathPlanning.pathToAxis1.qd_axisUsed.u \"Input signal\";
//   output Real pathPlanning.pathToAxis1.qd_axisUsed.y \"Output signal\";
//   input Real pathPlanning.pathToAxis1.qdd_axisUsed.u \"Input signal\";
//   output Real pathPlanning.pathToAxis1.qdd_axisUsed.y \"Output signal\";
//   input Boolean pathPlanning.pathToAxis1.moving[1];
//   input Boolean pathPlanning.pathToAxis1.moving[2];
//   input Boolean pathPlanning.pathToAxis1.moving[3];
//   input Boolean pathPlanning.pathToAxis1.moving[4];
//   input Boolean pathPlanning.pathToAxis1.moving[5];
//   input Boolean pathPlanning.pathToAxis1.moving[6];
//   input Boolean pathPlanning.pathToAxis1.motion_ref_axisUsed.u \"Input signal\";
//   output Boolean pathPlanning.pathToAxis1.motion_ref_axisUsed.y \"Output signal\";
//   Boolean pathPlanning.pathToAxis1.axisControlBus.motion_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.pathToAxis1.axisControlBus.acceleration_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.pathToAxis1.axisControlBus.speed_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.pathToAxis1.axisControlBus.angle_ref \"virtual variable in expandable connector\";
//   parameter Integer pathPlanning.pathToAxis2.nAxis = pathPlanning.naxis \"Number of driven axis\";
//   parameter Integer pathPlanning.pathToAxis2.axisUsed = 2 \"Map path planning of axisUsed to axisControlBus\";
//   input Real pathPlanning.pathToAxis2.q[1];
//   input Real pathPlanning.pathToAxis2.q[2];
//   input Real pathPlanning.pathToAxis2.q[3];
//   input Real pathPlanning.pathToAxis2.q[4];
//   input Real pathPlanning.pathToAxis2.q[5];
//   input Real pathPlanning.pathToAxis2.q[6];
//   input Real pathPlanning.pathToAxis2.qd[1];
//   input Real pathPlanning.pathToAxis2.qd[2];
//   input Real pathPlanning.pathToAxis2.qd[3];
//   input Real pathPlanning.pathToAxis2.qd[4];
//   input Real pathPlanning.pathToAxis2.qd[5];
//   input Real pathPlanning.pathToAxis2.qd[6];
//   input Real pathPlanning.pathToAxis2.qdd[1];
//   input Real pathPlanning.pathToAxis2.qdd[2];
//   input Real pathPlanning.pathToAxis2.qdd[3];
//   input Real pathPlanning.pathToAxis2.qdd[4];
//   input Real pathPlanning.pathToAxis2.qdd[5];
//   input Real pathPlanning.pathToAxis2.qdd[6];
//   input Real pathPlanning.pathToAxis2.q_axisUsed.u \"Input signal\";
//   output Real pathPlanning.pathToAxis2.q_axisUsed.y \"Output signal\";
//   input Real pathPlanning.pathToAxis2.qd_axisUsed.u \"Input signal\";
//   output Real pathPlanning.pathToAxis2.qd_axisUsed.y \"Output signal\";
//   input Real pathPlanning.pathToAxis2.qdd_axisUsed.u \"Input signal\";
//   output Real pathPlanning.pathToAxis2.qdd_axisUsed.y \"Output signal\";
//   input Boolean pathPlanning.pathToAxis2.moving[1];
//   input Boolean pathPlanning.pathToAxis2.moving[2];
//   input Boolean pathPlanning.pathToAxis2.moving[3];
//   input Boolean pathPlanning.pathToAxis2.moving[4];
//   input Boolean pathPlanning.pathToAxis2.moving[5];
//   input Boolean pathPlanning.pathToAxis2.moving[6];
//   input Boolean pathPlanning.pathToAxis2.motion_ref_axisUsed.u \"Input signal\";
//   output Boolean pathPlanning.pathToAxis2.motion_ref_axisUsed.y \"Output signal\";
//   Boolean pathPlanning.pathToAxis2.axisControlBus.motion_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.pathToAxis2.axisControlBus.acceleration_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.pathToAxis2.axisControlBus.speed_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.pathToAxis2.axisControlBus.angle_ref \"virtual variable in expandable connector\";
//   parameter Integer pathPlanning.pathToAxis3.nAxis = pathPlanning.naxis \"Number of driven axis\";
//   parameter Integer pathPlanning.pathToAxis3.axisUsed = 3 \"Map path planning of axisUsed to axisControlBus\";
//   input Real pathPlanning.pathToAxis3.q[1];
//   input Real pathPlanning.pathToAxis3.q[2];
//   input Real pathPlanning.pathToAxis3.q[3];
//   input Real pathPlanning.pathToAxis3.q[4];
//   input Real pathPlanning.pathToAxis3.q[5];
//   input Real pathPlanning.pathToAxis3.q[6];
//   input Real pathPlanning.pathToAxis3.qd[1];
//   input Real pathPlanning.pathToAxis3.qd[2];
//   input Real pathPlanning.pathToAxis3.qd[3];
//   input Real pathPlanning.pathToAxis3.qd[4];
//   input Real pathPlanning.pathToAxis3.qd[5];
//   input Real pathPlanning.pathToAxis3.qd[6];
//   input Real pathPlanning.pathToAxis3.qdd[1];
//   input Real pathPlanning.pathToAxis3.qdd[2];
//   input Real pathPlanning.pathToAxis3.qdd[3];
//   input Real pathPlanning.pathToAxis3.qdd[4];
//   input Real pathPlanning.pathToAxis3.qdd[5];
//   input Real pathPlanning.pathToAxis3.qdd[6];
//   input Real pathPlanning.pathToAxis3.q_axisUsed.u \"Input signal\";
//   output Real pathPlanning.pathToAxis3.q_axisUsed.y \"Output signal\";
//   input Real pathPlanning.pathToAxis3.qd_axisUsed.u \"Input signal\";
//   output Real pathPlanning.pathToAxis3.qd_axisUsed.y \"Output signal\";
//   input Real pathPlanning.pathToAxis3.qdd_axisUsed.u \"Input signal\";
//   output Real pathPlanning.pathToAxis3.qdd_axisUsed.y \"Output signal\";
//   input Boolean pathPlanning.pathToAxis3.moving[1];
//   input Boolean pathPlanning.pathToAxis3.moving[2];
//   input Boolean pathPlanning.pathToAxis3.moving[3];
//   input Boolean pathPlanning.pathToAxis3.moving[4];
//   input Boolean pathPlanning.pathToAxis3.moving[5];
//   input Boolean pathPlanning.pathToAxis3.moving[6];
//   input Boolean pathPlanning.pathToAxis3.motion_ref_axisUsed.u \"Input signal\";
//   output Boolean pathPlanning.pathToAxis3.motion_ref_axisUsed.y \"Output signal\";
//   Boolean pathPlanning.pathToAxis3.axisControlBus.motion_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.pathToAxis3.axisControlBus.acceleration_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.pathToAxis3.axisControlBus.speed_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.pathToAxis3.axisControlBus.angle_ref \"virtual variable in expandable connector\";
//   parameter Integer pathPlanning.pathToAxis4.nAxis = pathPlanning.naxis \"Number of driven axis\";
//   parameter Integer pathPlanning.pathToAxis4.axisUsed = 4 \"Map path planning of axisUsed to axisControlBus\";
//   input Real pathPlanning.pathToAxis4.q[1];
//   input Real pathPlanning.pathToAxis4.q[2];
//   input Real pathPlanning.pathToAxis4.q[3];
//   input Real pathPlanning.pathToAxis4.q[4];
//   input Real pathPlanning.pathToAxis4.q[5];
//   input Real pathPlanning.pathToAxis4.q[6];
//   input Real pathPlanning.pathToAxis4.qd[1];
//   input Real pathPlanning.pathToAxis4.qd[2];
//   input Real pathPlanning.pathToAxis4.qd[3];
//   input Real pathPlanning.pathToAxis4.qd[4];
//   input Real pathPlanning.pathToAxis4.qd[5];
//   input Real pathPlanning.pathToAxis4.qd[6];
//   input Real pathPlanning.pathToAxis4.qdd[1];
//   input Real pathPlanning.pathToAxis4.qdd[2];
//   input Real pathPlanning.pathToAxis4.qdd[3];
//   input Real pathPlanning.pathToAxis4.qdd[4];
//   input Real pathPlanning.pathToAxis4.qdd[5];
//   input Real pathPlanning.pathToAxis4.qdd[6];
//   input Real pathPlanning.pathToAxis4.q_axisUsed.u \"Input signal\";
//   output Real pathPlanning.pathToAxis4.q_axisUsed.y \"Output signal\";
//   input Real pathPlanning.pathToAxis4.qd_axisUsed.u \"Input signal\";
//   output Real pathPlanning.pathToAxis4.qd_axisUsed.y \"Output signal\";
//   input Real pathPlanning.pathToAxis4.qdd_axisUsed.u \"Input signal\";
//   output Real pathPlanning.pathToAxis4.qdd_axisUsed.y \"Output signal\";
//   input Boolean pathPlanning.pathToAxis4.moving[1];
//   input Boolean pathPlanning.pathToAxis4.moving[2];
//   input Boolean pathPlanning.pathToAxis4.moving[3];
//   input Boolean pathPlanning.pathToAxis4.moving[4];
//   input Boolean pathPlanning.pathToAxis4.moving[5];
//   input Boolean pathPlanning.pathToAxis4.moving[6];
//   input Boolean pathPlanning.pathToAxis4.motion_ref_axisUsed.u \"Input signal\";
//   output Boolean pathPlanning.pathToAxis4.motion_ref_axisUsed.y \"Output signal\";
//   Boolean pathPlanning.pathToAxis4.axisControlBus.motion_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.pathToAxis4.axisControlBus.acceleration_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.pathToAxis4.axisControlBus.speed_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.pathToAxis4.axisControlBus.angle_ref \"virtual variable in expandable connector\";
//   parameter Integer pathPlanning.pathToAxis5.nAxis = pathPlanning.naxis \"Number of driven axis\";
//   parameter Integer pathPlanning.pathToAxis5.axisUsed = 5 \"Map path planning of axisUsed to axisControlBus\";
//   input Real pathPlanning.pathToAxis5.q[1];
//   input Real pathPlanning.pathToAxis5.q[2];
//   input Real pathPlanning.pathToAxis5.q[3];
//   input Real pathPlanning.pathToAxis5.q[4];
//   input Real pathPlanning.pathToAxis5.q[5];
//   input Real pathPlanning.pathToAxis5.q[6];
//   input Real pathPlanning.pathToAxis5.qd[1];
//   input Real pathPlanning.pathToAxis5.qd[2];
//   input Real pathPlanning.pathToAxis5.qd[3];
//   input Real pathPlanning.pathToAxis5.qd[4];
//   input Real pathPlanning.pathToAxis5.qd[5];
//   input Real pathPlanning.pathToAxis5.qd[6];
//   input Real pathPlanning.pathToAxis5.qdd[1];
//   input Real pathPlanning.pathToAxis5.qdd[2];
//   input Real pathPlanning.pathToAxis5.qdd[3];
//   input Real pathPlanning.pathToAxis5.qdd[4];
//   input Real pathPlanning.pathToAxis5.qdd[5];
//   input Real pathPlanning.pathToAxis5.qdd[6];
//   input Real pathPlanning.pathToAxis5.q_axisUsed.u \"Input signal\";
//   output Real pathPlanning.pathToAxis5.q_axisUsed.y \"Output signal\";
//   input Real pathPlanning.pathToAxis5.qd_axisUsed.u \"Input signal\";
//   output Real pathPlanning.pathToAxis5.qd_axisUsed.y \"Output signal\";
//   input Real pathPlanning.pathToAxis5.qdd_axisUsed.u \"Input signal\";
//   output Real pathPlanning.pathToAxis5.qdd_axisUsed.y \"Output signal\";
//   input Boolean pathPlanning.pathToAxis5.moving[1];
//   input Boolean pathPlanning.pathToAxis5.moving[2];
//   input Boolean pathPlanning.pathToAxis5.moving[3];
//   input Boolean pathPlanning.pathToAxis5.moving[4];
//   input Boolean pathPlanning.pathToAxis5.moving[5];
//   input Boolean pathPlanning.pathToAxis5.moving[6];
//   input Boolean pathPlanning.pathToAxis5.motion_ref_axisUsed.u \"Input signal\";
//   output Boolean pathPlanning.pathToAxis5.motion_ref_axisUsed.y \"Output signal\";
//   Boolean pathPlanning.pathToAxis5.axisControlBus.motion_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.pathToAxis5.axisControlBus.acceleration_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.pathToAxis5.axisControlBus.speed_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.pathToAxis5.axisControlBus.angle_ref \"virtual variable in expandable connector\";
//   parameter Integer pathPlanning.pathToAxis6.nAxis = pathPlanning.naxis \"Number of driven axis\";
//   parameter Integer pathPlanning.pathToAxis6.axisUsed = 6 \"Map path planning of axisUsed to axisControlBus\";
//   input Real pathPlanning.pathToAxis6.q[1];
//   input Real pathPlanning.pathToAxis6.q[2];
//   input Real pathPlanning.pathToAxis6.q[3];
//   input Real pathPlanning.pathToAxis6.q[4];
//   input Real pathPlanning.pathToAxis6.q[5];
//   input Real pathPlanning.pathToAxis6.q[6];
//   input Real pathPlanning.pathToAxis6.qd[1];
//   input Real pathPlanning.pathToAxis6.qd[2];
//   input Real pathPlanning.pathToAxis6.qd[3];
//   input Real pathPlanning.pathToAxis6.qd[4];
//   input Real pathPlanning.pathToAxis6.qd[5];
//   input Real pathPlanning.pathToAxis6.qd[6];
//   input Real pathPlanning.pathToAxis6.qdd[1];
//   input Real pathPlanning.pathToAxis6.qdd[2];
//   input Real pathPlanning.pathToAxis6.qdd[3];
//   input Real pathPlanning.pathToAxis6.qdd[4];
//   input Real pathPlanning.pathToAxis6.qdd[5];
//   input Real pathPlanning.pathToAxis6.qdd[6];
//   input Real pathPlanning.pathToAxis6.q_axisUsed.u \"Input signal\";
//   output Real pathPlanning.pathToAxis6.q_axisUsed.y \"Output signal\";
//   input Real pathPlanning.pathToAxis6.qd_axisUsed.u \"Input signal\";
//   output Real pathPlanning.pathToAxis6.qd_axisUsed.y \"Output signal\";
//   input Real pathPlanning.pathToAxis6.qdd_axisUsed.u \"Input signal\";
//   output Real pathPlanning.pathToAxis6.qdd_axisUsed.y \"Output signal\";
//   input Boolean pathPlanning.pathToAxis6.moving[1];
//   input Boolean pathPlanning.pathToAxis6.moving[2];
//   input Boolean pathPlanning.pathToAxis6.moving[3];
//   input Boolean pathPlanning.pathToAxis6.moving[4];
//   input Boolean pathPlanning.pathToAxis6.moving[5];
//   input Boolean pathPlanning.pathToAxis6.moving[6];
//   input Boolean pathPlanning.pathToAxis6.motion_ref_axisUsed.u \"Input signal\";
//   output Boolean pathPlanning.pathToAxis6.motion_ref_axisUsed.y \"Output signal\";
//   Boolean pathPlanning.pathToAxis6.axisControlBus.motion_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.pathToAxis6.axisControlBus.acceleration_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.pathToAxis6.axisControlBus.speed_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.pathToAxis6.axisControlBus.angle_ref \"virtual variable in expandable connector\";
//   output Boolean pathPlanning.terminateSimulation.condition = time >= pathPlanning.path.endTime + pathPlanning.swingTime \"Terminate simulation when condition becomes true\";
//   parameter String pathPlanning.terminateSimulation.terminationText = \"... End condition reached\" \"Text that will be displayed when simulation is terminated\";
//   parameter Real pathPlanning.angleBegDeg[1](unit = \"deg\") = startAngle1 \"Start angles\";
//   parameter Real pathPlanning.angleBegDeg[2](unit = \"deg\") = startAngle2 \"Start angles\";
//   parameter Real pathPlanning.angleBegDeg[3](unit = \"deg\") = startAngle3 \"Start angles\";
//   parameter Real pathPlanning.angleBegDeg[4](unit = \"deg\") = startAngle4 \"Start angles\";
//   parameter Real pathPlanning.angleBegDeg[5](unit = \"deg\") = startAngle5 \"Start angles\";
//   parameter Real pathPlanning.angleBegDeg[6](unit = \"deg\") = startAngle6 \"Start angles\";
//   parameter Real pathPlanning.angleEndDeg[1](unit = \"deg\") = endAngle1 \"End angles\";
//   parameter Real pathPlanning.angleEndDeg[2](unit = \"deg\") = endAngle2 \"End angles\";
//   parameter Real pathPlanning.angleEndDeg[3](unit = \"deg\") = endAngle3 \"End angles\";
//   parameter Real pathPlanning.angleEndDeg[4](unit = \"deg\") = endAngle4 \"End angles\";
//   parameter Real pathPlanning.angleEndDeg[5](unit = \"deg\") = endAngle5 \"End angles\";
//   parameter Real pathPlanning.angleEndDeg[6](unit = \"deg\") = endAngle6 \"End angles\";
//   parameter Real pathPlanning.speedMax[1](quantity = \"AngularVelocity\", unit = \"rad/s\") = refSpeedMax[1] \"Maximum axis speed\";
//   parameter Real pathPlanning.speedMax[2](quantity = \"AngularVelocity\", unit = \"rad/s\") = refSpeedMax[2] \"Maximum axis speed\";
//   parameter Real pathPlanning.speedMax[3](quantity = \"AngularVelocity\", unit = \"rad/s\") = refSpeedMax[3] \"Maximum axis speed\";
//   parameter Real pathPlanning.speedMax[4](quantity = \"AngularVelocity\", unit = \"rad/s\") = refSpeedMax[4] \"Maximum axis speed\";
//   parameter Real pathPlanning.speedMax[5](quantity = \"AngularVelocity\", unit = \"rad/s\") = refSpeedMax[5] \"Maximum axis speed\";
//   parameter Real pathPlanning.speedMax[6](quantity = \"AngularVelocity\", unit = \"rad/s\") = refSpeedMax[6] \"Maximum axis speed\";
//   parameter Real pathPlanning.accMax[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = refAccMax[1] \"Maximum axis acceleration\";
//   parameter Real pathPlanning.accMax[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = refAccMax[2] \"Maximum axis acceleration\";
//   parameter Real pathPlanning.accMax[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = refAccMax[3] \"Maximum axis acceleration\";
//   parameter Real pathPlanning.accMax[4](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = refAccMax[4] \"Maximum axis acceleration\";
//   parameter Real pathPlanning.accMax[5](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = refAccMax[5] \"Maximum axis acceleration\";
//   parameter Real pathPlanning.accMax[6](quantity = \"AngularAcceleration\", unit = \"rad/s2\") = refAccMax[6] \"Maximum axis acceleration\";
//   final parameter Real pathPlanning.angleBeg[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.SIunits.Conversions.from_deg(pathPlanning.angleBegDeg[1]) \"Start angles\";
//   final parameter Real pathPlanning.angleBeg[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.SIunits.Conversions.from_deg(pathPlanning.angleBegDeg[2]) \"Start angles\";
//   final parameter Real pathPlanning.angleBeg[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.SIunits.Conversions.from_deg(pathPlanning.angleBegDeg[3]) \"Start angles\";
//   final parameter Real pathPlanning.angleBeg[4](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.SIunits.Conversions.from_deg(pathPlanning.angleBegDeg[4]) \"Start angles\";
//   final parameter Real pathPlanning.angleBeg[5](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.SIunits.Conversions.from_deg(pathPlanning.angleBegDeg[5]) \"Start angles\";
//   final parameter Real pathPlanning.angleBeg[6](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.SIunits.Conversions.from_deg(pathPlanning.angleBegDeg[6]) \"Start angles\";
//   final parameter Real pathPlanning.angleEnd[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.SIunits.Conversions.from_deg(pathPlanning.angleEndDeg[1]) \"End angles\";
//   final parameter Real pathPlanning.angleEnd[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.SIunits.Conversions.from_deg(pathPlanning.angleEndDeg[2]) \"End angles\";
//   final parameter Real pathPlanning.angleEnd[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.SIunits.Conversions.from_deg(pathPlanning.angleEndDeg[3]) \"End angles\";
//   final parameter Real pathPlanning.angleEnd[4](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.SIunits.Conversions.from_deg(pathPlanning.angleEndDeg[4]) \"End angles\";
//   final parameter Real pathPlanning.angleEnd[5](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.SIunits.Conversions.from_deg(pathPlanning.angleEndDeg[5]) \"End angles\";
//   final parameter Real pathPlanning.angleEnd[6](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.SIunits.Conversions.from_deg(pathPlanning.angleEndDeg[6]) \"End angles\";
//   Boolean pathPlanning.controlBus.axisControlBus1.motion_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus1.acceleration_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus1.angle_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus1.speed_ref \"virtual variable in expandable connector\";
//   Boolean pathPlanning.controlBus.axisControlBus2.motion_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus2.acceleration_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus2.angle_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus2.speed_ref \"virtual variable in expandable connector\";
//   Boolean pathPlanning.controlBus.axisControlBus3.motion_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus3.acceleration_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus3.angle_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus3.speed_ref \"virtual variable in expandable connector\";
//   Boolean pathPlanning.controlBus.axisControlBus4.motion_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus4.acceleration_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus4.angle_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus4.speed_ref \"virtual variable in expandable connector\";
//   Boolean pathPlanning.controlBus.axisControlBus5.motion_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus5.acceleration_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus5.angle_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus5.speed_ref \"virtual variable in expandable connector\";
//   Boolean pathPlanning.controlBus.axisControlBus6.motion_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus6.acceleration_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus6.angle_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus6.speed_ref \"virtual variable in expandable connector\";
//   parameter Real axis1.kp = kp1 \"Gain of position controller\";
//   parameter Real axis1.ks = ks1 \"Gain of speed controller\";
//   parameter Real axis1.Ts(quantity = \"Time\", unit = \"s\") = Ts1 \"Time constant of integrator of speed controller\";
//   parameter Real axis1.k = 1.1616 \"Gain of motor\";
//   parameter Real axis1.w = 4590.0 \"Time constant of motor\";
//   parameter Real axis1.D = 0.6 \"Damping constant of motor\";
//   parameter Real axis1.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.0013 \"Moment of inertia of motor\";
//   parameter Real axis1.ratio = -105.0 \"Gear ratio\";
//   parameter Real axis1.Rv0(quantity = \"Torque\", unit = \"N.m\") = 0.4 \"Viscous friction torque at zero velocity in [Nm]\";
//   parameter Real axis1.Rv1(unit = \"N.m.s/rad\") = 0.0008125 \"Viscous friction coefficient in [Nms/rad]\";
//   parameter Real axis1.peak = 1.0 \"Maximum static friction torque is peak*Rv0 (peak >= 1)\";
//   Real axis1.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis1.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis1.gear.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis1.gear.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis1.gear.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis1.gear.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real axis1.gear.i = axis1.ratio \"gear ratio\";
//   parameter Real axis1.gear.c(unit = \"N.m/rad\") = axis1.c \"Spring constant\";
//   parameter Real axis1.gear.d(unit = \"N.m.s/rad\") = axis1.cd \"Damper constant\";
//   parameter Real axis1.gear.Rv0(quantity = \"Torque\", unit = \"N.m\") = axis1.Rv0 \"Viscous friction torque at zero velocity\";
//   parameter Real axis1.gear.Rv1(unit = \"N.m.s/rad\") = axis1.Rv1 \"Viscous friction coefficient (R=Rv0+Rv1*abs(qd))\";
//   parameter Real axis1.gear.peak = axis1.peak \"Maximum static friction torque is peak*Rv0 (peak >= 1)\";
//   Real axis1.gear.a_rel(quantity = \"AngularAcceleration\", unit = \"rad/s2\") = der(axis1.gear.spring.w_rel) \"Relative angular acceleration of spring\";
//   constant Real axis1.gear.unitAngularVelocity(quantity = \"AngularVelocity\", unit = \"rad/s\") = 1.0;
//   constant Real axis1.gear.unitTorque(quantity = \"Torque\", unit = \"N.m\") = 1.0;
//   parameter Boolean axis1.gear.gear.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real axis1.gear.gear.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis1.gear.gear.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis1.gear.gear.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis1.gear.gear.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real axis1.gear.gear.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   parameter Real axis1.gear.gear.ratio(start = 1.0) = axis1.gear.i \"Transmission ratio (flange_a.phi/flange_b.phi)\";
//   Real axis1.gear.gear.phi_a(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle between left shaft flange and support\";
//   Real axis1.gear.gear.phi_b(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle between right shaft flange and support\";
//   Real axis1.gear.spring.phi_rel(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, nominal = axis1.gear.spring.phi_nominal, StateSelect = StateSelect.prefer) \"Relative rotation angle (= flange_b.phi - flange_a.phi)\";
//   Real axis1.gear.spring.w_rel(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, StateSelect = StateSelect.prefer) \"Relative angular velocity (= der(phi_rel))\";
//   Real axis1.gear.spring.a_rel(quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = 0.0) \"Relative angular acceleration (= der(w_rel))\";
//   Real axis1.gear.spring.tau(quantity = \"Torque\", unit = \"N.m\") \"Torque between flanges (= flange_b.tau)\";
//   Real axis1.gear.spring.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis1.gear.spring.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis1.gear.spring.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis1.gear.spring.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real axis1.gear.spring.phi_nominal(quantity = \"Angle\", unit = \"rad\", displayUnit = \"rad\") = 0.0001 \"Nominal value of phi_rel (used for scaling)\";
//   parameter enumeration(never, avoid, default, prefer, always) axis1.gear.spring.stateSelect = StateSelect.prefer \"Priority to use phi_rel and w_rel as states\";
//   parameter Real axis1.gear.spring.c(quantity = \"RotationalSpringConstant\", unit = \"N.m/rad\", min = 0.0, start = 100000.0) = axis1.gear.c \"Spring constant\";
//   parameter Real axis1.gear.spring.d(quantity = \"RotationalDampingConstant\", unit = \"N.m.s/rad\", min = 0.0, start = 0.0) = axis1.gear.d \"Damping constant\";
//   parameter Real axis1.gear.spring.phi_rel0(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Unstretched spring angle\";
//   parameter Boolean axis1.gear.bearingFriction.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real axis1.gear.bearingFriction.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis1.gear.bearingFriction.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis1.gear.bearingFriction.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis1.gear.bearingFriction.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real axis1.gear.bearingFriction.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   parameter Real axis1.gear.bearingFriction.w_small(quantity = \"AngularVelocity\", unit = \"rad/s\") = 10000000000.0 \"Relative angular velocity near to zero if jumps due to a reinit(..) of the velocity can occur (set to low value only if such impulses can occur)\";
//   Real axis1.gear.bearingFriction.w_relfric(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Relative angular velocity between frictional surfaces\";
//   Real axis1.gear.bearingFriction.a_relfric(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration between frictional surfaces\";
//   Real axis1.gear.bearingFriction.tau0(quantity = \"Torque\", unit = \"N.m\") \"Friction torque for w=0 and forward sliding\";
//   Real axis1.gear.bearingFriction.tau0_max(quantity = \"Torque\", unit = \"N.m\") \"Maximum friction torque for w=0 and locked\";
//   Boolean axis1.gear.bearingFriction.free \"true, if frictional element is not active\";
//   Real axis1.gear.bearingFriction.sa(unit = \"1\") \"Path parameter of friction characteristic tau = f(a_relfric)\";
//   Boolean axis1.gear.bearingFriction.startForward(start = false, fixed = true) \"true, if w_rel=0 and start of forward sliding\";
//   Boolean axis1.gear.bearingFriction.startBackward(start = false, fixed = true) \"true, if w_rel=0 and start of backward sliding\";
//   Boolean axis1.gear.bearingFriction.locked(start = false) \"true, if w_rel=0 and not sliding\";
//   constant Integer axis1.gear.bearingFriction.Unknown = 3 \"Value of mode is not known\";
//   constant Integer axis1.gear.bearingFriction.Free = 2 \"Element is not active\";
//   constant Integer axis1.gear.bearingFriction.Forward = 1 \"w_rel > 0 (forward sliding)\";
//   constant Integer axis1.gear.bearingFriction.Stuck = 0 \"w_rel = 0 (forward sliding, locked or backward sliding)\";
//   constant Integer axis1.gear.bearingFriction.Backward = -1 \"w_rel < 0 (backward sliding)\";
//   Integer axis1.gear.bearingFriction.mode(min = -1, max = 3, start = 3, fixed = true);
//   protected constant Real axis1.gear.bearingFriction.unitAngularAcceleration(quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 1.0;
//   protected constant Real axis1.gear.bearingFriction.unitTorque(quantity = \"Torque\", unit = \"N.m\") = 1.0;
//   parameter Real axis1.gear.bearingFriction.tau_pos[1,1] = 0.0 \"[w,tau] Positive sliding friction characteristic (w>=0)\";
//   parameter Real axis1.gear.bearingFriction.tau_pos[1,2] = axis1.gear.Rv0 \"[w,tau] Positive sliding friction characteristic (w>=0)\";
//   parameter Real axis1.gear.bearingFriction.tau_pos[2,1] = 1.0 \"[w,tau] Positive sliding friction characteristic (w>=0)\";
//   parameter Real axis1.gear.bearingFriction.tau_pos[2,2] = axis1.gear.Rv0 + axis1.gear.Rv1 \"[w,tau] Positive sliding friction characteristic (w>=0)\";
//   parameter Real axis1.gear.bearingFriction.peak(min = 1.0) = 1.0 \"peak*tau_pos[1,2] = Maximum friction torque for w==0\";
//   Real axis1.gear.bearingFriction.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle between shaft flanges (flange_a, flange_b) and support\";
//   Real axis1.gear.bearingFriction.tau(quantity = \"Torque\", unit = \"N.m\") \"Friction torque\";
//   Real axis1.gear.bearingFriction.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of flange_a and flange_b\";
//   Real axis1.gear.bearingFriction.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of flange_a and flange_b\";
//   parameter Real axis1.motor.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = axis1.J \"Moment of inertia of motor\";
//   parameter Real axis1.motor.k = axis1.k \"Gain of motor\";
//   parameter Real axis1.motor.w = axis1.w \"Time constant of motor\";
//   parameter Real axis1.motor.D = axis1.D \"Damping constant of motor\";
//   parameter Real axis1.motor.w_max(quantity = \"AngularVelocity\", unit = \"rad/s\") = 315.0 \"Maximum speed of motor\";
//   parameter Real axis1.motor.i_max(quantity = \"ElectricCurrent\", unit = \"A\") = 9.0 \"Maximum current of motor\";
//   Real axis1.motor.flange_motor.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis1.motor.flange_motor.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis1.motor.Vs.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.Vs.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis1.motor.Vs.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.Vs.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   input Real axis1.motor.Vs.v \"Voltage between pin p and n (= p.v - n.v) as input signal\";
//   Real axis1.motor.Vs.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis1.motor.diff.v1(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the left port\";
//   Real axis1.motor.diff.v2(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the right port\";
//   Real axis1.motor.diff.i1(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the left port\";
//   Real axis1.motor.diff.i2(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the right port\";
//   Real axis1.motor.diff.p1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.diff.p1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis1.motor.diff.n1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.diff.n1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis1.motor.diff.p2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.diff.p2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis1.motor.diff.n2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.diff.n2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis1.motor.power.v1(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the left port\";
//   Real axis1.motor.power.v2(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the right port\";
//   Real axis1.motor.power.i1(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the left port\";
//   Real axis1.motor.power.i2(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the right port\";
//   Real axis1.motor.power.p1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.power.p1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis1.motor.power.n1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.power.n1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis1.motor.power.p2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.power.p2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis1.motor.power.n2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.power.n2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis1.motor.emf.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   parameter Real axis1.motor.emf.k(quantity = \"ElectricalTorqueConstant\", unit = \"N.m/A\", start = 1.0) = axis1.motor.k \"Transformation coefficient\";
//   Real axis1.motor.emf.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins\";
//   Real axis1.motor.emf.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from positive to negative pin\";
//   Real axis1.motor.emf.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle of shaft flange with respect to support (= flange.phi - support.phi)\";
//   Real axis1.motor.emf.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity of flange relative to support\";
//   Real axis1.motor.emf.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.emf.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis1.motor.emf.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.emf.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis1.motor.emf.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis1.motor.emf.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real axis1.motor.emf.internalSupport.tau(quantity = \"Torque\", unit = \"N.m\") = -axis1.motor.emf.flange.tau \"External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau)\";
//   Real axis1.motor.emf.internalSupport.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"External support angle (= flange.phi)\";
//   Real axis1.motor.emf.internalSupport.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis1.motor.emf.internalSupport.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real axis1.motor.emf.fixed.phi0(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Fixed offset angle of housing\";
//   Real axis1.motor.emf.fixed.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis1.motor.emf.fixed.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis1.motor.La.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis1.motor.La.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis1.motor.La.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.La.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis1.motor.La.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.La.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real axis1.motor.La.L(quantity = \"Inductance\", unit = \"H\", start = 1.0) = 250.0 / (axis1.motor.w * axis1.motor.D * 2.0) \"Inductance\";
//   Real axis1.motor.Ra.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis1.motor.Ra.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis1.motor.Ra.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.Ra.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis1.motor.Ra.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.Ra.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis1.motor.Ra.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis1.motor.Ra.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis1.motor.Ra.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis1.motor.Ra.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis1.motor.Ra.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis1.motor.Ra.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 250.0 \"Resistance at temperature T_ref\";
//   parameter Real axis1.motor.Ra.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis1.motor.Ra.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis1.motor.Ra.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis1.motor.Rd2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis1.motor.Rd2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis1.motor.Rd2.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.Rd2.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis1.motor.Rd2.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.Rd2.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis1.motor.Rd2.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis1.motor.Rd2.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis1.motor.Rd2.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis1.motor.Rd2.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis1.motor.Rd2.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis1.motor.Rd2.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 100.0 \"Resistance at temperature T_ref\";
//   parameter Real axis1.motor.Rd2.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis1.motor.Rd2.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis1.motor.Rd2.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis1.motor.C.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis1.motor.C.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis1.motor.C.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.C.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis1.motor.C.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.C.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real axis1.motor.C.C(quantity = \"Capacitance\", unit = \"F\", min = 0.0, start = 1.0) = (0.004 * axis1.motor.D) / axis1.motor.w \"Capacitance\";
//   Real axis1.motor.OpI.v1(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the left port\";
//   Real axis1.motor.OpI.v2(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the right port\";
//   Real axis1.motor.OpI.i1(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the left port\";
//   Real axis1.motor.OpI.i2(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the right port\";
//   Real axis1.motor.OpI.p1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.OpI.p1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis1.motor.OpI.n1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.OpI.n1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis1.motor.OpI.p2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.OpI.p2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis1.motor.OpI.n2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.OpI.n2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis1.motor.Rd1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis1.motor.Rd1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis1.motor.Rd1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.Rd1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis1.motor.Rd1.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.Rd1.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis1.motor.Rd1.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis1.motor.Rd1.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis1.motor.Rd1.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis1.motor.Rd1.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis1.motor.Rd1.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis1.motor.Rd1.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 100.0 \"Resistance at temperature T_ref\";
//   parameter Real axis1.motor.Rd1.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis1.motor.Rd1.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis1.motor.Rd1.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis1.motor.Ri.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis1.motor.Ri.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis1.motor.Ri.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.Ri.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis1.motor.Ri.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.Ri.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis1.motor.Ri.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis1.motor.Ri.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis1.motor.Ri.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis1.motor.Ri.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis1.motor.Ri.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis1.motor.Ri.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 10.0 \"Resistance at temperature T_ref\";
//   parameter Real axis1.motor.Ri.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis1.motor.Ri.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis1.motor.Ri.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis1.motor.Rp1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis1.motor.Rp1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis1.motor.Rp1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.Rp1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis1.motor.Rp1.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.Rp1.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis1.motor.Rp1.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis1.motor.Rp1.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis1.motor.Rp1.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis1.motor.Rp1.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis1.motor.Rp1.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis1.motor.Rp1.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 200.0 \"Resistance at temperature T_ref\";
//   parameter Real axis1.motor.Rp1.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis1.motor.Rp1.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis1.motor.Rp1.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis1.motor.Rp2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis1.motor.Rp2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis1.motor.Rp2.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.Rp2.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis1.motor.Rp2.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.Rp2.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis1.motor.Rp2.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis1.motor.Rp2.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis1.motor.Rp2.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis1.motor.Rp2.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis1.motor.Rp2.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis1.motor.Rp2.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 50.0 \"Resistance at temperature T_ref\";
//   parameter Real axis1.motor.Rp2.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis1.motor.Rp2.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis1.motor.Rp2.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis1.motor.Rd4.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis1.motor.Rd4.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis1.motor.Rd4.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.Rd4.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis1.motor.Rd4.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.Rd4.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis1.motor.Rd4.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis1.motor.Rd4.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis1.motor.Rd4.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis1.motor.Rd4.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis1.motor.Rd4.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis1.motor.Rd4.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 100.0 \"Resistance at temperature T_ref\";
//   parameter Real axis1.motor.Rd4.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis1.motor.Rd4.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis1.motor.Rd4.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis1.motor.hall2.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.hall2.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis1.motor.hall2.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.hall2.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   input Real axis1.motor.hall2.v \"Voltage between pin p and n (= p.v - n.v) as input signal\";
//   Real axis1.motor.hall2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis1.motor.Rd3.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis1.motor.Rd3.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis1.motor.Rd3.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.Rd3.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis1.motor.Rd3.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.Rd3.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis1.motor.Rd3.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis1.motor.Rd3.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis1.motor.Rd3.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis1.motor.Rd3.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis1.motor.Rd3.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis1.motor.Rd3.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 100.0 \"Resistance at temperature T_ref\";
//   parameter Real axis1.motor.Rd3.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis1.motor.Rd3.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis1.motor.Rd3.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis1.motor.g1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.g1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis1.motor.g2.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.g2.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis1.motor.g3.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.g3.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis1.motor.hall1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.hall1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis1.motor.hall1.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.hall1.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   output Real axis1.motor.hall1.i \"current in the branch from p to n as output signal\";
//   Real axis1.motor.g4.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.g4.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis1.motor.g5.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis1.motor.g5.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis1.motor.phi.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis1.motor.phi.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real axis1.motor.phi.phi \"Absolute angle of flange\";
//   Real axis1.motor.speed.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis1.motor.speed.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real axis1.motor.speed.w \"Absolute angular velocity of flange\";
//   Real axis1.motor.Jmotor.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis1.motor.Jmotor.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis1.motor.Jmotor.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis1.motor.Jmotor.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real axis1.motor.Jmotor.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = axis1.motor.J \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) axis1.motor.Jmotor.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real axis1.motor.Jmotor.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real axis1.motor.Jmotor.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
//   Real axis1.motor.Jmotor.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   parameter Real axis1.motor.convert1.k(start = 1.0) = 1.0 \"Gain value multiplied with input signal\";
//   input Real axis1.motor.convert1.u \"Input signal connector\";
//   output Real axis1.motor.convert1.y \"Output signal connector\";
//   parameter Real axis1.motor.convert2.k(start = 1.0) = 1.0 \"Gain value multiplied with input signal\";
//   input Real axis1.motor.convert2.u \"Input signal connector\";
//   output Real axis1.motor.convert2.y \"Output signal connector\";
//   Real axis1.motor.axisControlBus.motorAngle \"virtual variable in expandable connector\";
//   Real axis1.motor.axisControlBus.motorSpeed \"virtual variable in expandable connector\";
//   Real axis1.motor.axisControlBus.current \"virtual variable in expandable connector\";
//   Real axis1.motor.axisControlBus.current_ref \"virtual variable in expandable connector\";
//   parameter Real axis1.controller.kp = axis1.kp \"Gain of position controller\";
//   parameter Real axis1.controller.ks = axis1.ks \"Gain of speed controller\";
//   parameter Real axis1.controller.Ts(quantity = \"Time\", unit = \"s\") = axis1.Ts \"Time constant of integrator of speed controller\";
//   parameter Real axis1.controller.ratio = axis1.ratio \"Gear ratio of gearbox\";
//   parameter Real axis1.controller.gain1.k(start = 1.0) = axis1.controller.ratio \"Gain value multiplied with input signal\";
//   input Real axis1.controller.gain1.u \"Input signal connector\";
//   output Real axis1.controller.gain1.y \"Output signal connector\";
//   input Real axis1.controller.PI.u \"Connector of Real input signal\";
//   output Real axis1.controller.PI.y \"Connector of Real output signal\";
//   parameter Real axis1.controller.PI.k = axis1.controller.ks \"Gain\";
//   parameter Real axis1.controller.PI.T(quantity = \"Time\", unit = \"s\", min = 1e-60, start = 1.0) = axis1.controller.Ts \"Time Constant (T>0 required)\";
//   parameter enumeration(NoInit, SteadyState, InitialState, InitialOutput) axis1.controller.PI.initType = Modelica.Blocks.Types.Init.NoInit \"Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)\";
//   parameter Real axis1.controller.PI.x_start = 0.0 \"Initial or guess value of state\";
//   parameter Real axis1.controller.PI.y_start = 0.0 \"Initial value of output\";
//   output Real axis1.controller.PI.x(start = axis1.controller.PI.x_start) \"State of block\";
//   input Real axis1.controller.feedback1.u1;
//   input Real axis1.controller.feedback1.u2;
//   output Real axis1.controller.feedback1.y;
//   parameter Real axis1.controller.P.k(start = 1.0) = axis1.controller.kp \"Gain value multiplied with input signal\";
//   input Real axis1.controller.P.u \"Input signal connector\";
//   output Real axis1.controller.P.y \"Output signal connector\";
//   parameter Real axis1.controller.add3.k1 = 1.0 \"Gain of upper input\";
//   parameter Real axis1.controller.add3.k2 = 1.0 \"Gain of middle input\";
//   parameter Real axis1.controller.add3.k3 = -1.0 \"Gain of lower input\";
//   input Real axis1.controller.add3.u1 \"Connector 1 of Real input signals\";
//   input Real axis1.controller.add3.u2 \"Connector 2 of Real input signals\";
//   input Real axis1.controller.add3.u3 \"Connector 3 of Real input signals\";
//   output Real axis1.controller.add3.y \"Connector of Real output signals\";
//   parameter Real axis1.controller.gain2.k(start = 1.0) = axis1.controller.ratio \"Gain value multiplied with input signal\";
//   input Real axis1.controller.gain2.u \"Input signal connector\";
//   output Real axis1.controller.gain2.y \"Output signal connector\";
//   Real axis1.controller.axisControlBus.speed_ref \"virtual variable in expandable connector\";
//   Real axis1.controller.axisControlBus.angle_ref \"virtual variable in expandable connector\";
//   output Real axis1.controller.axisControlBus.motorAngle \"virtual variable in expandable connector\";
//   output Real axis1.controller.axisControlBus.motorSpeed \"virtual variable in expandable connector\";
//   Real axis1.controller.axisControlBus.current_ref \"virtual variable in expandable connector\";
//   Real axis1.angleSensor.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis1.angleSensor.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real axis1.angleSensor.phi \"Absolute angle of flange\";
//   Real axis1.speedSensor.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis1.speedSensor.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real axis1.speedSensor.w \"Absolute angular velocity of flange\";
//   Real axis1.accSensor.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis1.accSensor.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis1.accSensor.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of flange\";
//   output Real axis1.accSensor.a \"Absolute angular acceleration of flange\";
//   parameter Boolean axis1.initializeFlange.use_phi_start = true \"= true, if initial angle is defined by input phi_start, otherwise not initialized\";
//   parameter Boolean axis1.initializeFlange.use_w_start = true \"= true, if initial speed is defined by input w_start, otherwise not initialized\";
//   parameter Boolean axis1.initializeFlange.use_a_start = true \"= true, if initial angular acceleration is defined by input a_start, otherwise not initialized\";
//   parameter enumeration(never, avoid, default, prefer, always) axis1.initializeFlange.stateSelect = StateSelect.prefer \"Priority to use flange angle and speed as states\";
//   Real axis1.initializeFlange.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis1.initializeFlange.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis1.initializeFlange.phi_flange(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) = axis1.initializeFlange.flange.phi \"Flange angle\";
//   Real axis1.initializeFlange.w_flange(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) = der(axis1.initializeFlange.phi_flange) \"= der(phi_flange)\";
//   Real axis1.initializeFlange.set_flange_tau.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis1.initializeFlange.set_flange_tau.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real axis1.initializeFlange.phi_start \"Initial angle of flange\";
//   input Real axis1.initializeFlange.set_phi_start.phi_start \"Start angle\";
//   Real axis1.initializeFlange.set_phi_start.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis1.initializeFlange.set_phi_start.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real axis1.initializeFlange.w_start \"Initial speed of flange\";
//   input Real axis1.initializeFlange.set_w_start.w_start \"Start angular velocity\";
//   Real axis1.initializeFlange.set_w_start.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis1.initializeFlange.set_w_start.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real axis1.initializeFlange.a_start \"Initial angular acceleration of flange\";
//   input Real axis1.initializeFlange.set_a_start.a_start \"Start angular acceleration\";
//   Real axis1.initializeFlange.set_a_start.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.avoid) \"Absolute rotation angle of flange\";
//   Real axis1.initializeFlange.set_a_start.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis1.initializeFlange.set_a_start.w(quantity = \"AngularVelocity\", unit = \"rad/s\") = der(axis1.initializeFlange.set_a_start.flange.phi);
//   output Real axis1.const.y \"Connector of Real output signal\";
//   parameter Real axis1.const.k(start = 1.0) = 0.0 \"Constant output value\";
//   parameter Real axis1.c(unit = \"N.m/rad\") = 43.0 \"Spring constant\";
//   parameter Real axis1.cd(unit = \"N.m.s/rad\") = 0.005 \"Damper constant\";
//   Real axis1.axisControlBus.angle \"virtual variable in expandable connector\";
//   Real axis1.axisControlBus.speed \"virtual variable in expandable connector\";
//   Real axis1.axisControlBus.acceleration \"virtual variable in expandable connector\";
//   Real axis1.axisControlBus.angle_ref \"virtual variable in expandable connector\";
//   Real axis1.axisControlBus.speed_ref \"virtual variable in expandable connector\";
//   Real axis1.axisControlBus.motorSpeed \"virtual variable in expandable connector\";
//   Real axis1.axisControlBus.current_ref \"virtual variable in expandable connector\";
//   Real axis1.axisControlBus.current \"virtual variable in expandable connector\";
//   Real axis1.axisControlBus.motorAngle \"virtual variable in expandable connector\";
//   Real axis1.motor.axisControlBus.angle \"virtual variable in expandable connector\";
//   Real axis1.motor.axisControlBus.acceleration \"virtual variable in expandable connector\";
//   Real axis1.motor.axisControlBus.speed \"virtual variable in expandable connector\";
//   Real axis1.motor.axisControlBus.angle_ref \"virtual variable in expandable connector\";
//   Real axis1.motor.axisControlBus.speed_ref \"virtual variable in expandable connector\";
//   Real axis1.controller.axisControlBus.angle \"virtual variable in expandable connector\";
//   Real axis1.controller.axisControlBus.acceleration \"virtual variable in expandable connector\";
//   Real axis1.controller.axisControlBus.current \"virtual variable in expandable connector\";
//   Real axis1.controller.axisControlBus.speed \"virtual variable in expandable connector\";
//   parameter Real axis2.kp = kp2 \"Gain of position controller\";
//   parameter Real axis2.ks = ks2 \"Gain of speed controller\";
//   parameter Real axis2.Ts(quantity = \"Time\", unit = \"s\") = Ts2 \"Time constant of integrator of speed controller\";
//   parameter Real axis2.k = 1.1616 \"Gain of motor\";
//   parameter Real axis2.w = 5500.0 \"Time constant of motor\";
//   parameter Real axis2.D = 0.6 \"Damping constant of motor\";
//   parameter Real axis2.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.0013 \"Moment of inertia of motor\";
//   parameter Real axis2.ratio = 210.0 \"Gear ratio\";
//   parameter Real axis2.Rv0(quantity = \"Torque\", unit = \"N.m\") = 0.5 \"Viscous friction torque at zero velocity in [Nm]\";
//   parameter Real axis2.Rv1(unit = \"N.m.s/rad\") = 0.000769230769230769 \"Viscous friction coefficient in [Nms/rad]\";
//   parameter Real axis2.peak = 1.0 \"Maximum static friction torque is peak*Rv0 (peak >= 1)\";
//   Real axis2.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis2.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis2.gear.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis2.gear.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis2.gear.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis2.gear.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real axis2.gear.i = axis2.ratio \"gear ratio\";
//   parameter Real axis2.gear.c(unit = \"N.m/rad\") = axis2.c \"Spring constant\";
//   parameter Real axis2.gear.d(unit = \"N.m.s/rad\") = axis2.cd \"Damper constant\";
//   parameter Real axis2.gear.Rv0(quantity = \"Torque\", unit = \"N.m\") = axis2.Rv0 \"Viscous friction torque at zero velocity\";
//   parameter Real axis2.gear.Rv1(unit = \"N.m.s/rad\") = axis2.Rv1 \"Viscous friction coefficient (R=Rv0+Rv1*abs(qd))\";
//   parameter Real axis2.gear.peak = axis2.peak \"Maximum static friction torque is peak*Rv0 (peak >= 1)\";
//   Real axis2.gear.a_rel(quantity = \"AngularAcceleration\", unit = \"rad/s2\") = der(axis2.gear.spring.w_rel) \"Relative angular acceleration of spring\";
//   constant Real axis2.gear.unitAngularVelocity(quantity = \"AngularVelocity\", unit = \"rad/s\") = 1.0;
//   constant Real axis2.gear.unitTorque(quantity = \"Torque\", unit = \"N.m\") = 1.0;
//   parameter Boolean axis2.gear.gear.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real axis2.gear.gear.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis2.gear.gear.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis2.gear.gear.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis2.gear.gear.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real axis2.gear.gear.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   parameter Real axis2.gear.gear.ratio(start = 1.0) = axis2.gear.i \"Transmission ratio (flange_a.phi/flange_b.phi)\";
//   Real axis2.gear.gear.phi_a(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle between left shaft flange and support\";
//   Real axis2.gear.gear.phi_b(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle between right shaft flange and support\";
//   Real axis2.gear.spring.phi_rel(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, nominal = axis2.gear.spring.phi_nominal, StateSelect = StateSelect.prefer) \"Relative rotation angle (= flange_b.phi - flange_a.phi)\";
//   Real axis2.gear.spring.w_rel(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, StateSelect = StateSelect.prefer) \"Relative angular velocity (= der(phi_rel))\";
//   Real axis2.gear.spring.a_rel(quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = 0.0) \"Relative angular acceleration (= der(w_rel))\";
//   Real axis2.gear.spring.tau(quantity = \"Torque\", unit = \"N.m\") \"Torque between flanges (= flange_b.tau)\";
//   Real axis2.gear.spring.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis2.gear.spring.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis2.gear.spring.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis2.gear.spring.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real axis2.gear.spring.phi_nominal(quantity = \"Angle\", unit = \"rad\", displayUnit = \"rad\") = 0.0001 \"Nominal value of phi_rel (used for scaling)\";
//   parameter enumeration(never, avoid, default, prefer, always) axis2.gear.spring.stateSelect = StateSelect.prefer \"Priority to use phi_rel and w_rel as states\";
//   parameter Real axis2.gear.spring.c(quantity = \"RotationalSpringConstant\", unit = \"N.m/rad\", min = 0.0, start = 100000.0) = axis2.gear.c \"Spring constant\";
//   parameter Real axis2.gear.spring.d(quantity = \"RotationalDampingConstant\", unit = \"N.m.s/rad\", min = 0.0, start = 0.0) = axis2.gear.d \"Damping constant\";
//   parameter Real axis2.gear.spring.phi_rel0(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Unstretched spring angle\";
//   parameter Boolean axis2.gear.bearingFriction.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real axis2.gear.bearingFriction.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis2.gear.bearingFriction.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis2.gear.bearingFriction.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis2.gear.bearingFriction.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real axis2.gear.bearingFriction.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   parameter Real axis2.gear.bearingFriction.w_small(quantity = \"AngularVelocity\", unit = \"rad/s\") = 10000000000.0 \"Relative angular velocity near to zero if jumps due to a reinit(..) of the velocity can occur (set to low value only if such impulses can occur)\";
//   Real axis2.gear.bearingFriction.w_relfric(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Relative angular velocity between frictional surfaces\";
//   Real axis2.gear.bearingFriction.a_relfric(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration between frictional surfaces\";
//   Real axis2.gear.bearingFriction.tau0(quantity = \"Torque\", unit = \"N.m\") \"Friction torque for w=0 and forward sliding\";
//   Real axis2.gear.bearingFriction.tau0_max(quantity = \"Torque\", unit = \"N.m\") \"Maximum friction torque for w=0 and locked\";
//   Boolean axis2.gear.bearingFriction.free \"true, if frictional element is not active\";
//   Real axis2.gear.bearingFriction.sa(unit = \"1\") \"Path parameter of friction characteristic tau = f(a_relfric)\";
//   Boolean axis2.gear.bearingFriction.startForward(start = false, fixed = true) \"true, if w_rel=0 and start of forward sliding\";
//   Boolean axis2.gear.bearingFriction.startBackward(start = false, fixed = true) \"true, if w_rel=0 and start of backward sliding\";
//   Boolean axis2.gear.bearingFriction.locked(start = false) \"true, if w_rel=0 and not sliding\";
//   constant Integer axis2.gear.bearingFriction.Unknown = 3 \"Value of mode is not known\";
//   constant Integer axis2.gear.bearingFriction.Free = 2 \"Element is not active\";
//   constant Integer axis2.gear.bearingFriction.Forward = 1 \"w_rel > 0 (forward sliding)\";
//   constant Integer axis2.gear.bearingFriction.Stuck = 0 \"w_rel = 0 (forward sliding, locked or backward sliding)\";
//   constant Integer axis2.gear.bearingFriction.Backward = -1 \"w_rel < 0 (backward sliding)\";
//   Integer axis2.gear.bearingFriction.mode(min = -1, max = 3, start = 3, fixed = true);
//   protected constant Real axis2.gear.bearingFriction.unitAngularAcceleration(quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 1.0;
//   protected constant Real axis2.gear.bearingFriction.unitTorque(quantity = \"Torque\", unit = \"N.m\") = 1.0;
//   parameter Real axis2.gear.bearingFriction.tau_pos[1,1] = 0.0 \"[w,tau] Positive sliding friction characteristic (w>=0)\";
//   parameter Real axis2.gear.bearingFriction.tau_pos[1,2] = axis2.gear.Rv0 \"[w,tau] Positive sliding friction characteristic (w>=0)\";
//   parameter Real axis2.gear.bearingFriction.tau_pos[2,1] = 1.0 \"[w,tau] Positive sliding friction characteristic (w>=0)\";
//   parameter Real axis2.gear.bearingFriction.tau_pos[2,2] = axis2.gear.Rv0 + axis2.gear.Rv1 \"[w,tau] Positive sliding friction characteristic (w>=0)\";
//   parameter Real axis2.gear.bearingFriction.peak(min = 1.0) = 1.0 \"peak*tau_pos[1,2] = Maximum friction torque for w==0\";
//   Real axis2.gear.bearingFriction.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle between shaft flanges (flange_a, flange_b) and support\";
//   Real axis2.gear.bearingFriction.tau(quantity = \"Torque\", unit = \"N.m\") \"Friction torque\";
//   Real axis2.gear.bearingFriction.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of flange_a and flange_b\";
//   Real axis2.gear.bearingFriction.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of flange_a and flange_b\";
//   parameter Real axis2.motor.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = axis2.J \"Moment of inertia of motor\";
//   parameter Real axis2.motor.k = axis2.k \"Gain of motor\";
//   parameter Real axis2.motor.w = axis2.w \"Time constant of motor\";
//   parameter Real axis2.motor.D = axis2.D \"Damping constant of motor\";
//   parameter Real axis2.motor.w_max(quantity = \"AngularVelocity\", unit = \"rad/s\") = 315.0 \"Maximum speed of motor\";
//   parameter Real axis2.motor.i_max(quantity = \"ElectricCurrent\", unit = \"A\") = 9.0 \"Maximum current of motor\";
//   Real axis2.motor.flange_motor.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis2.motor.flange_motor.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis2.motor.Vs.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.Vs.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis2.motor.Vs.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.Vs.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   input Real axis2.motor.Vs.v \"Voltage between pin p and n (= p.v - n.v) as input signal\";
//   Real axis2.motor.Vs.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis2.motor.diff.v1(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the left port\";
//   Real axis2.motor.diff.v2(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the right port\";
//   Real axis2.motor.diff.i1(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the left port\";
//   Real axis2.motor.diff.i2(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the right port\";
//   Real axis2.motor.diff.p1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.diff.p1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis2.motor.diff.n1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.diff.n1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis2.motor.diff.p2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.diff.p2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis2.motor.diff.n2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.diff.n2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis2.motor.power.v1(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the left port\";
//   Real axis2.motor.power.v2(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the right port\";
//   Real axis2.motor.power.i1(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the left port\";
//   Real axis2.motor.power.i2(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the right port\";
//   Real axis2.motor.power.p1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.power.p1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis2.motor.power.n1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.power.n1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis2.motor.power.p2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.power.p2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis2.motor.power.n2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.power.n2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis2.motor.emf.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   parameter Real axis2.motor.emf.k(quantity = \"ElectricalTorqueConstant\", unit = \"N.m/A\", start = 1.0) = axis2.motor.k \"Transformation coefficient\";
//   Real axis2.motor.emf.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins\";
//   Real axis2.motor.emf.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from positive to negative pin\";
//   Real axis2.motor.emf.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle of shaft flange with respect to support (= flange.phi - support.phi)\";
//   Real axis2.motor.emf.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity of flange relative to support\";
//   Real axis2.motor.emf.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.emf.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis2.motor.emf.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.emf.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis2.motor.emf.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis2.motor.emf.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real axis2.motor.emf.internalSupport.tau(quantity = \"Torque\", unit = \"N.m\") = -axis2.motor.emf.flange.tau \"External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau)\";
//   Real axis2.motor.emf.internalSupport.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"External support angle (= flange.phi)\";
//   Real axis2.motor.emf.internalSupport.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis2.motor.emf.internalSupport.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real axis2.motor.emf.fixed.phi0(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Fixed offset angle of housing\";
//   Real axis2.motor.emf.fixed.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis2.motor.emf.fixed.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis2.motor.La.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis2.motor.La.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis2.motor.La.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.La.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis2.motor.La.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.La.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real axis2.motor.La.L(quantity = \"Inductance\", unit = \"H\", start = 1.0) = 250.0 / (axis2.motor.w * axis2.motor.D * 2.0) \"Inductance\";
//   Real axis2.motor.Ra.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis2.motor.Ra.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis2.motor.Ra.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.Ra.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis2.motor.Ra.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.Ra.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis2.motor.Ra.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis2.motor.Ra.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis2.motor.Ra.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis2.motor.Ra.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis2.motor.Ra.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis2.motor.Ra.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 250.0 \"Resistance at temperature T_ref\";
//   parameter Real axis2.motor.Ra.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis2.motor.Ra.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis2.motor.Ra.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis2.motor.Rd2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis2.motor.Rd2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis2.motor.Rd2.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.Rd2.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis2.motor.Rd2.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.Rd2.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis2.motor.Rd2.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis2.motor.Rd2.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis2.motor.Rd2.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis2.motor.Rd2.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis2.motor.Rd2.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis2.motor.Rd2.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 100.0 \"Resistance at temperature T_ref\";
//   parameter Real axis2.motor.Rd2.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis2.motor.Rd2.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis2.motor.Rd2.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis2.motor.C.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis2.motor.C.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis2.motor.C.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.C.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis2.motor.C.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.C.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real axis2.motor.C.C(quantity = \"Capacitance\", unit = \"F\", min = 0.0, start = 1.0) = (0.004 * axis2.motor.D) / axis2.motor.w \"Capacitance\";
//   Real axis2.motor.OpI.v1(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the left port\";
//   Real axis2.motor.OpI.v2(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the right port\";
//   Real axis2.motor.OpI.i1(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the left port\";
//   Real axis2.motor.OpI.i2(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the right port\";
//   Real axis2.motor.OpI.p1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.OpI.p1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis2.motor.OpI.n1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.OpI.n1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis2.motor.OpI.p2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.OpI.p2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis2.motor.OpI.n2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.OpI.n2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis2.motor.Rd1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis2.motor.Rd1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis2.motor.Rd1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.Rd1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis2.motor.Rd1.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.Rd1.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis2.motor.Rd1.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis2.motor.Rd1.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis2.motor.Rd1.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis2.motor.Rd1.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis2.motor.Rd1.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis2.motor.Rd1.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 100.0 \"Resistance at temperature T_ref\";
//   parameter Real axis2.motor.Rd1.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis2.motor.Rd1.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis2.motor.Rd1.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis2.motor.Ri.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis2.motor.Ri.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis2.motor.Ri.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.Ri.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis2.motor.Ri.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.Ri.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis2.motor.Ri.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis2.motor.Ri.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis2.motor.Ri.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis2.motor.Ri.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis2.motor.Ri.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis2.motor.Ri.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 10.0 \"Resistance at temperature T_ref\";
//   parameter Real axis2.motor.Ri.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis2.motor.Ri.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis2.motor.Ri.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis2.motor.Rp1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis2.motor.Rp1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis2.motor.Rp1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.Rp1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis2.motor.Rp1.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.Rp1.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis2.motor.Rp1.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis2.motor.Rp1.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis2.motor.Rp1.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis2.motor.Rp1.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis2.motor.Rp1.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis2.motor.Rp1.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 200.0 \"Resistance at temperature T_ref\";
//   parameter Real axis2.motor.Rp1.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis2.motor.Rp1.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis2.motor.Rp1.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis2.motor.Rp2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis2.motor.Rp2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis2.motor.Rp2.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.Rp2.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis2.motor.Rp2.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.Rp2.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis2.motor.Rp2.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis2.motor.Rp2.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis2.motor.Rp2.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis2.motor.Rp2.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis2.motor.Rp2.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis2.motor.Rp2.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 50.0 \"Resistance at temperature T_ref\";
//   parameter Real axis2.motor.Rp2.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis2.motor.Rp2.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis2.motor.Rp2.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis2.motor.Rd4.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis2.motor.Rd4.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis2.motor.Rd4.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.Rd4.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis2.motor.Rd4.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.Rd4.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis2.motor.Rd4.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis2.motor.Rd4.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis2.motor.Rd4.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis2.motor.Rd4.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis2.motor.Rd4.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis2.motor.Rd4.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 100.0 \"Resistance at temperature T_ref\";
//   parameter Real axis2.motor.Rd4.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis2.motor.Rd4.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis2.motor.Rd4.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis2.motor.hall2.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.hall2.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis2.motor.hall2.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.hall2.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   input Real axis2.motor.hall2.v \"Voltage between pin p and n (= p.v - n.v) as input signal\";
//   Real axis2.motor.hall2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis2.motor.Rd3.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis2.motor.Rd3.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis2.motor.Rd3.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.Rd3.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis2.motor.Rd3.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.Rd3.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis2.motor.Rd3.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis2.motor.Rd3.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis2.motor.Rd3.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis2.motor.Rd3.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis2.motor.Rd3.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis2.motor.Rd3.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 100.0 \"Resistance at temperature T_ref\";
//   parameter Real axis2.motor.Rd3.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis2.motor.Rd3.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis2.motor.Rd3.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis2.motor.g1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.g1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis2.motor.g2.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.g2.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis2.motor.g3.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.g3.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis2.motor.hall1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.hall1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis2.motor.hall1.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.hall1.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   output Real axis2.motor.hall1.i \"current in the branch from p to n as output signal\";
//   Real axis2.motor.g4.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.g4.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis2.motor.g5.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis2.motor.g5.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis2.motor.phi.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis2.motor.phi.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real axis2.motor.phi.phi \"Absolute angle of flange\";
//   Real axis2.motor.speed.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis2.motor.speed.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real axis2.motor.speed.w \"Absolute angular velocity of flange\";
//   Real axis2.motor.Jmotor.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis2.motor.Jmotor.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis2.motor.Jmotor.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis2.motor.Jmotor.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real axis2.motor.Jmotor.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = axis2.motor.J \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) axis2.motor.Jmotor.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real axis2.motor.Jmotor.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real axis2.motor.Jmotor.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
//   Real axis2.motor.Jmotor.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   parameter Real axis2.motor.convert1.k(start = 1.0) = 1.0 \"Gain value multiplied with input signal\";
//   input Real axis2.motor.convert1.u \"Input signal connector\";
//   output Real axis2.motor.convert1.y \"Output signal connector\";
//   parameter Real axis2.motor.convert2.k(start = 1.0) = 1.0 \"Gain value multiplied with input signal\";
//   input Real axis2.motor.convert2.u \"Input signal connector\";
//   output Real axis2.motor.convert2.y \"Output signal connector\";
//   Real axis2.motor.axisControlBus.motorAngle \"virtual variable in expandable connector\";
//   Real axis2.motor.axisControlBus.motorSpeed \"virtual variable in expandable connector\";
//   Real axis2.motor.axisControlBus.current \"virtual variable in expandable connector\";
//   Real axis2.motor.axisControlBus.current_ref \"virtual variable in expandable connector\";
//   parameter Real axis2.controller.kp = axis2.kp \"Gain of position controller\";
//   parameter Real axis2.controller.ks = axis2.ks \"Gain of speed controller\";
//   parameter Real axis2.controller.Ts(quantity = \"Time\", unit = \"s\") = axis2.Ts \"Time constant of integrator of speed controller\";
//   parameter Real axis2.controller.ratio = axis2.ratio \"Gear ratio of gearbox\";
//   parameter Real axis2.controller.gain1.k(start = 1.0) = axis2.controller.ratio \"Gain value multiplied with input signal\";
//   input Real axis2.controller.gain1.u \"Input signal connector\";
//   output Real axis2.controller.gain1.y \"Output signal connector\";
//   input Real axis2.controller.PI.u \"Connector of Real input signal\";
//   output Real axis2.controller.PI.y \"Connector of Real output signal\";
//   parameter Real axis2.controller.PI.k = axis2.controller.ks \"Gain\";
//   parameter Real axis2.controller.PI.T(quantity = \"Time\", unit = \"s\", min = 1e-60, start = 1.0) = axis2.controller.Ts \"Time Constant (T>0 required)\";
//   parameter enumeration(NoInit, SteadyState, InitialState, InitialOutput) axis2.controller.PI.initType = Modelica.Blocks.Types.Init.NoInit \"Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)\";
//   parameter Real axis2.controller.PI.x_start = 0.0 \"Initial or guess value of state\";
//   parameter Real axis2.controller.PI.y_start = 0.0 \"Initial value of output\";
//   output Real axis2.controller.PI.x(start = axis2.controller.PI.x_start) \"State of block\";
//   input Real axis2.controller.feedback1.u1;
//   input Real axis2.controller.feedback1.u2;
//   output Real axis2.controller.feedback1.y;
//   parameter Real axis2.controller.P.k(start = 1.0) = axis2.controller.kp \"Gain value multiplied with input signal\";
//   input Real axis2.controller.P.u \"Input signal connector\";
//   output Real axis2.controller.P.y \"Output signal connector\";
//   parameter Real axis2.controller.add3.k1 = 1.0 \"Gain of upper input\";
//   parameter Real axis2.controller.add3.k2 = 1.0 \"Gain of middle input\";
//   parameter Real axis2.controller.add3.k3 = -1.0 \"Gain of lower input\";
//   input Real axis2.controller.add3.u1 \"Connector 1 of Real input signals\";
//   input Real axis2.controller.add3.u2 \"Connector 2 of Real input signals\";
//   input Real axis2.controller.add3.u3 \"Connector 3 of Real input signals\";
//   output Real axis2.controller.add3.y \"Connector of Real output signals\";
//   parameter Real axis2.controller.gain2.k(start = 1.0) = axis2.controller.ratio \"Gain value multiplied with input signal\";
//   input Real axis2.controller.gain2.u \"Input signal connector\";
//   output Real axis2.controller.gain2.y \"Output signal connector\";
//   Real axis2.controller.axisControlBus.speed_ref \"virtual variable in expandable connector\";
//   Real axis2.controller.axisControlBus.angle_ref \"virtual variable in expandable connector\";
//   output Real axis2.controller.axisControlBus.motorAngle \"virtual variable in expandable connector\";
//   output Real axis2.controller.axisControlBus.motorSpeed \"virtual variable in expandable connector\";
//   Real axis2.controller.axisControlBus.current_ref \"virtual variable in expandable connector\";
//   Real axis2.angleSensor.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis2.angleSensor.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real axis2.angleSensor.phi \"Absolute angle of flange\";
//   Real axis2.speedSensor.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis2.speedSensor.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real axis2.speedSensor.w \"Absolute angular velocity of flange\";
//   Real axis2.accSensor.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis2.accSensor.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis2.accSensor.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of flange\";
//   output Real axis2.accSensor.a \"Absolute angular acceleration of flange\";
//   parameter Boolean axis2.initializeFlange.use_phi_start = true \"= true, if initial angle is defined by input phi_start, otherwise not initialized\";
//   parameter Boolean axis2.initializeFlange.use_w_start = true \"= true, if initial speed is defined by input w_start, otherwise not initialized\";
//   parameter Boolean axis2.initializeFlange.use_a_start = true \"= true, if initial angular acceleration is defined by input a_start, otherwise not initialized\";
//   parameter enumeration(never, avoid, default, prefer, always) axis2.initializeFlange.stateSelect = StateSelect.prefer \"Priority to use flange angle and speed as states\";
//   Real axis2.initializeFlange.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis2.initializeFlange.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis2.initializeFlange.phi_flange(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) = axis2.initializeFlange.flange.phi \"Flange angle\";
//   Real axis2.initializeFlange.w_flange(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) = der(axis2.initializeFlange.phi_flange) \"= der(phi_flange)\";
//   Real axis2.initializeFlange.set_flange_tau.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis2.initializeFlange.set_flange_tau.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real axis2.initializeFlange.phi_start \"Initial angle of flange\";
//   input Real axis2.initializeFlange.set_phi_start.phi_start \"Start angle\";
//   Real axis2.initializeFlange.set_phi_start.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis2.initializeFlange.set_phi_start.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real axis2.initializeFlange.w_start \"Initial speed of flange\";
//   input Real axis2.initializeFlange.set_w_start.w_start \"Start angular velocity\";
//   Real axis2.initializeFlange.set_w_start.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis2.initializeFlange.set_w_start.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real axis2.initializeFlange.a_start \"Initial angular acceleration of flange\";
//   input Real axis2.initializeFlange.set_a_start.a_start \"Start angular acceleration\";
//   Real axis2.initializeFlange.set_a_start.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.avoid) \"Absolute rotation angle of flange\";
//   Real axis2.initializeFlange.set_a_start.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis2.initializeFlange.set_a_start.w(quantity = \"AngularVelocity\", unit = \"rad/s\") = der(axis2.initializeFlange.set_a_start.flange.phi);
//   output Real axis2.const.y \"Connector of Real output signal\";
//   parameter Real axis2.const.k(start = 1.0) = 0.0 \"Constant output value\";
//   parameter Real axis2.c(unit = \"N.m/rad\") = 8.0 \"Spring constant\";
//   parameter Real axis2.cd(unit = \"N.m.s/rad\") = 0.01 \"Damper constant\";
//   Real axis2.axisControlBus.angle \"virtual variable in expandable connector\";
//   Real axis2.axisControlBus.speed \"virtual variable in expandable connector\";
//   Real axis2.axisControlBus.acceleration \"virtual variable in expandable connector\";
//   Real axis2.axisControlBus.angle_ref \"virtual variable in expandable connector\";
//   Real axis2.axisControlBus.speed_ref \"virtual variable in expandable connector\";
//   Real axis2.axisControlBus.motorSpeed \"virtual variable in expandable connector\";
//   Real axis2.axisControlBus.current_ref \"virtual variable in expandable connector\";
//   Real axis2.axisControlBus.current \"virtual variable in expandable connector\";
//   Real axis2.axisControlBus.motorAngle \"virtual variable in expandable connector\";
//   Real axis2.motor.axisControlBus.angle \"virtual variable in expandable connector\";
//   Real axis2.motor.axisControlBus.acceleration \"virtual variable in expandable connector\";
//   Real axis2.motor.axisControlBus.speed \"virtual variable in expandable connector\";
//   Real axis2.motor.axisControlBus.angle_ref \"virtual variable in expandable connector\";
//   Real axis2.motor.axisControlBus.speed_ref \"virtual variable in expandable connector\";
//   Real axis2.controller.axisControlBus.angle \"virtual variable in expandable connector\";
//   Real axis2.controller.axisControlBus.acceleration \"virtual variable in expandable connector\";
//   Real axis2.controller.axisControlBus.current \"virtual variable in expandable connector\";
//   Real axis2.controller.axisControlBus.speed \"virtual variable in expandable connector\";
//   parameter Real axis3.kp = kp3 \"Gain of position controller\";
//   parameter Real axis3.ks = ks3 \"Gain of speed controller\";
//   parameter Real axis3.Ts(quantity = \"Time\", unit = \"s\") = Ts3 \"Time constant of integrator of speed controller\";
//   parameter Real axis3.k = 1.1616 \"Gain of motor\";
//   parameter Real axis3.w = 5500.0 \"Time constant of motor\";
//   parameter Real axis3.D = 0.6 \"Damping constant of motor\";
//   parameter Real axis3.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.0013 \"Moment of inertia of motor\";
//   parameter Real axis3.ratio = 60.0 \"Gear ratio\";
//   parameter Real axis3.Rv0(quantity = \"Torque\", unit = \"N.m\") = 0.7 \"Viscous friction torque at zero velocity in [Nm]\";
//   parameter Real axis3.Rv1(unit = \"N.m.s/rad\") = 0.00153846153846154 \"Viscous friction coefficient in [Nms/rad]\";
//   parameter Real axis3.peak = 1.0 \"Maximum static friction torque is peak*Rv0 (peak >= 1)\";
//   Real axis3.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis3.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis3.gear.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis3.gear.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis3.gear.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis3.gear.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real axis3.gear.i = axis3.ratio \"gear ratio\";
//   parameter Real axis3.gear.c(unit = \"N.m/rad\") = axis3.c \"Spring constant\";
//   parameter Real axis3.gear.d(unit = \"N.m.s/rad\") = axis3.cd \"Damper constant\";
//   parameter Real axis3.gear.Rv0(quantity = \"Torque\", unit = \"N.m\") = axis3.Rv0 \"Viscous friction torque at zero velocity\";
//   parameter Real axis3.gear.Rv1(unit = \"N.m.s/rad\") = axis3.Rv1 \"Viscous friction coefficient (R=Rv0+Rv1*abs(qd))\";
//   parameter Real axis3.gear.peak = axis3.peak \"Maximum static friction torque is peak*Rv0 (peak >= 1)\";
//   Real axis3.gear.a_rel(quantity = \"AngularAcceleration\", unit = \"rad/s2\") = der(axis3.gear.spring.w_rel) \"Relative angular acceleration of spring\";
//   constant Real axis3.gear.unitAngularVelocity(quantity = \"AngularVelocity\", unit = \"rad/s\") = 1.0;
//   constant Real axis3.gear.unitTorque(quantity = \"Torque\", unit = \"N.m\") = 1.0;
//   parameter Boolean axis3.gear.gear.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real axis3.gear.gear.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis3.gear.gear.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis3.gear.gear.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis3.gear.gear.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real axis3.gear.gear.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   parameter Real axis3.gear.gear.ratio(start = 1.0) = axis3.gear.i \"Transmission ratio (flange_a.phi/flange_b.phi)\";
//   Real axis3.gear.gear.phi_a(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle between left shaft flange and support\";
//   Real axis3.gear.gear.phi_b(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle between right shaft flange and support\";
//   Real axis3.gear.spring.phi_rel(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, nominal = axis3.gear.spring.phi_nominal, StateSelect = StateSelect.prefer) \"Relative rotation angle (= flange_b.phi - flange_a.phi)\";
//   Real axis3.gear.spring.w_rel(quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0, StateSelect = StateSelect.prefer) \"Relative angular velocity (= der(phi_rel))\";
//   Real axis3.gear.spring.a_rel(quantity = \"AngularAcceleration\", unit = \"rad/s2\", start = 0.0) \"Relative angular acceleration (= der(w_rel))\";
//   Real axis3.gear.spring.tau(quantity = \"Torque\", unit = \"N.m\") \"Torque between flanges (= flange_b.tau)\";
//   Real axis3.gear.spring.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis3.gear.spring.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis3.gear.spring.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis3.gear.spring.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real axis3.gear.spring.phi_nominal(quantity = \"Angle\", unit = \"rad\", displayUnit = \"rad\") = 0.0001 \"Nominal value of phi_rel (used for scaling)\";
//   parameter enumeration(never, avoid, default, prefer, always) axis3.gear.spring.stateSelect = StateSelect.prefer \"Priority to use phi_rel and w_rel as states\";
//   parameter Real axis3.gear.spring.c(quantity = \"RotationalSpringConstant\", unit = \"N.m/rad\", min = 0.0, start = 100000.0) = axis3.gear.c \"Spring constant\";
//   parameter Real axis3.gear.spring.d(quantity = \"RotationalDampingConstant\", unit = \"N.m.s/rad\", min = 0.0, start = 0.0) = axis3.gear.d \"Damping constant\";
//   parameter Real axis3.gear.spring.phi_rel0(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Unstretched spring angle\";
//   parameter Boolean axis3.gear.bearingFriction.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real axis3.gear.bearingFriction.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis3.gear.bearingFriction.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis3.gear.bearingFriction.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis3.gear.bearingFriction.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real axis3.gear.bearingFriction.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   parameter Real axis3.gear.bearingFriction.w_small(quantity = \"AngularVelocity\", unit = \"rad/s\") = 10000000000.0 \"Relative angular velocity near to zero if jumps due to a reinit(..) of the velocity can occur (set to low value only if such impulses can occur)\";
//   Real axis3.gear.bearingFriction.w_relfric(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Relative angular velocity between frictional surfaces\";
//   Real axis3.gear.bearingFriction.a_relfric(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration between frictional surfaces\";
//   Real axis3.gear.bearingFriction.tau0(quantity = \"Torque\", unit = \"N.m\") \"Friction torque for w=0 and forward sliding\";
//   Real axis3.gear.bearingFriction.tau0_max(quantity = \"Torque\", unit = \"N.m\") \"Maximum friction torque for w=0 and locked\";
//   Boolean axis3.gear.bearingFriction.free \"true, if frictional element is not active\";
//   Real axis3.gear.bearingFriction.sa(unit = \"1\") \"Path parameter of friction characteristic tau = f(a_relfric)\";
//   Boolean axis3.gear.bearingFriction.startForward(start = false, fixed = true) \"true, if w_rel=0 and start of forward sliding\";
//   Boolean axis3.gear.bearingFriction.startBackward(start = false, fixed = true) \"true, if w_rel=0 and start of backward sliding\";
//   Boolean axis3.gear.bearingFriction.locked(start = false) \"true, if w_rel=0 and not sliding\";
//   constant Integer axis3.gear.bearingFriction.Unknown = 3 \"Value of mode is not known\";
//   constant Integer axis3.gear.bearingFriction.Free = 2 \"Element is not active\";
//   constant Integer axis3.gear.bearingFriction.Forward = 1 \"w_rel > 0 (forward sliding)\";
//   constant Integer axis3.gear.bearingFriction.Stuck = 0 \"w_rel = 0 (forward sliding, locked or backward sliding)\";
//   constant Integer axis3.gear.bearingFriction.Backward = -1 \"w_rel < 0 (backward sliding)\";
//   Integer axis3.gear.bearingFriction.mode(min = -1, max = 3, start = 3, fixed = true);
//   protected constant Real axis3.gear.bearingFriction.unitAngularAcceleration(quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 1.0;
//   protected constant Real axis3.gear.bearingFriction.unitTorque(quantity = \"Torque\", unit = \"N.m\") = 1.0;
//   parameter Real axis3.gear.bearingFriction.tau_pos[1,1] = 0.0 \"[w,tau] Positive sliding friction characteristic (w>=0)\";
//   parameter Real axis3.gear.bearingFriction.tau_pos[1,2] = axis3.gear.Rv0 \"[w,tau] Positive sliding friction characteristic (w>=0)\";
//   parameter Real axis3.gear.bearingFriction.tau_pos[2,1] = 1.0 \"[w,tau] Positive sliding friction characteristic (w>=0)\";
//   parameter Real axis3.gear.bearingFriction.tau_pos[2,2] = axis3.gear.Rv0 + axis3.gear.Rv1 \"[w,tau] Positive sliding friction characteristic (w>=0)\";
//   parameter Real axis3.gear.bearingFriction.peak(min = 1.0) = 1.0 \"peak*tau_pos[1,2] = Maximum friction torque for w==0\";
//   Real axis3.gear.bearingFriction.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle between shaft flanges (flange_a, flange_b) and support\";
//   Real axis3.gear.bearingFriction.tau(quantity = \"Torque\", unit = \"N.m\") \"Friction torque\";
//   Real axis3.gear.bearingFriction.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of flange_a and flange_b\";
//   Real axis3.gear.bearingFriction.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of flange_a and flange_b\";
//   parameter Real axis3.motor.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = axis3.J \"Moment of inertia of motor\";
//   parameter Real axis3.motor.k = axis3.k \"Gain of motor\";
//   parameter Real axis3.motor.w = axis3.w \"Time constant of motor\";
//   parameter Real axis3.motor.D = axis3.D \"Damping constant of motor\";
//   parameter Real axis3.motor.w_max(quantity = \"AngularVelocity\", unit = \"rad/s\") = 315.0 \"Maximum speed of motor\";
//   parameter Real axis3.motor.i_max(quantity = \"ElectricCurrent\", unit = \"A\") = 9.0 \"Maximum current of motor\";
//   Real axis3.motor.flange_motor.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis3.motor.flange_motor.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis3.motor.Vs.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.Vs.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis3.motor.Vs.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.Vs.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   input Real axis3.motor.Vs.v \"Voltage between pin p and n (= p.v - n.v) as input signal\";
//   Real axis3.motor.Vs.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis3.motor.diff.v1(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the left port\";
//   Real axis3.motor.diff.v2(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the right port\";
//   Real axis3.motor.diff.i1(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the left port\";
//   Real axis3.motor.diff.i2(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the right port\";
//   Real axis3.motor.diff.p1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.diff.p1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis3.motor.diff.n1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.diff.n1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis3.motor.diff.p2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.diff.p2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis3.motor.diff.n2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.diff.n2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis3.motor.power.v1(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the left port\";
//   Real axis3.motor.power.v2(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the right port\";
//   Real axis3.motor.power.i1(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the left port\";
//   Real axis3.motor.power.i2(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the right port\";
//   Real axis3.motor.power.p1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.power.p1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis3.motor.power.n1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.power.n1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis3.motor.power.p2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.power.p2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis3.motor.power.n2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.power.n2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis3.motor.emf.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   parameter Real axis3.motor.emf.k(quantity = \"ElectricalTorqueConstant\", unit = \"N.m/A\", start = 1.0) = axis3.motor.k \"Transformation coefficient\";
//   Real axis3.motor.emf.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins\";
//   Real axis3.motor.emf.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from positive to negative pin\";
//   Real axis3.motor.emf.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle of shaft flange with respect to support (= flange.phi - support.phi)\";
//   Real axis3.motor.emf.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity of flange relative to support\";
//   Real axis3.motor.emf.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.emf.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis3.motor.emf.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.emf.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis3.motor.emf.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis3.motor.emf.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real axis3.motor.emf.internalSupport.tau(quantity = \"Torque\", unit = \"N.m\") = -axis3.motor.emf.flange.tau \"External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau)\";
//   Real axis3.motor.emf.internalSupport.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"External support angle (= flange.phi)\";
//   Real axis3.motor.emf.internalSupport.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis3.motor.emf.internalSupport.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real axis3.motor.emf.fixed.phi0(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Fixed offset angle of housing\";
//   Real axis3.motor.emf.fixed.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis3.motor.emf.fixed.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis3.motor.La.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis3.motor.La.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis3.motor.La.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.La.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis3.motor.La.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.La.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real axis3.motor.La.L(quantity = \"Inductance\", unit = \"H\", start = 1.0) = 250.0 / (axis3.motor.w * axis3.motor.D * 2.0) \"Inductance\";
//   Real axis3.motor.Ra.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis3.motor.Ra.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis3.motor.Ra.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.Ra.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis3.motor.Ra.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.Ra.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis3.motor.Ra.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis3.motor.Ra.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis3.motor.Ra.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis3.motor.Ra.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis3.motor.Ra.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis3.motor.Ra.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 250.0 \"Resistance at temperature T_ref\";
//   parameter Real axis3.motor.Ra.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis3.motor.Ra.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis3.motor.Ra.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis3.motor.Rd2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis3.motor.Rd2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis3.motor.Rd2.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.Rd2.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis3.motor.Rd2.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.Rd2.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis3.motor.Rd2.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis3.motor.Rd2.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis3.motor.Rd2.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis3.motor.Rd2.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis3.motor.Rd2.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis3.motor.Rd2.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 100.0 \"Resistance at temperature T_ref\";
//   parameter Real axis3.motor.Rd2.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis3.motor.Rd2.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis3.motor.Rd2.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis3.motor.C.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis3.motor.C.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis3.motor.C.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.C.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis3.motor.C.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.C.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real axis3.motor.C.C(quantity = \"Capacitance\", unit = \"F\", min = 0.0, start = 1.0) = (0.004 * axis3.motor.D) / axis3.motor.w \"Capacitance\";
//   Real axis3.motor.OpI.v1(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the left port\";
//   Real axis3.motor.OpI.v2(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the right port\";
//   Real axis3.motor.OpI.i1(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the left port\";
//   Real axis3.motor.OpI.i2(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the right port\";
//   Real axis3.motor.OpI.p1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.OpI.p1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis3.motor.OpI.n1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.OpI.n1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis3.motor.OpI.p2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.OpI.p2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis3.motor.OpI.n2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.OpI.n2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis3.motor.Rd1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis3.motor.Rd1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis3.motor.Rd1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.Rd1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis3.motor.Rd1.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.Rd1.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis3.motor.Rd1.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis3.motor.Rd1.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis3.motor.Rd1.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis3.motor.Rd1.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis3.motor.Rd1.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis3.motor.Rd1.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 100.0 \"Resistance at temperature T_ref\";
//   parameter Real axis3.motor.Rd1.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis3.motor.Rd1.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis3.motor.Rd1.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis3.motor.Ri.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis3.motor.Ri.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis3.motor.Ri.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.Ri.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis3.motor.Ri.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.Ri.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis3.motor.Ri.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis3.motor.Ri.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis3.motor.Ri.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis3.motor.Ri.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis3.motor.Ri.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis3.motor.Ri.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 10.0 \"Resistance at temperature T_ref\";
//   parameter Real axis3.motor.Ri.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis3.motor.Ri.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis3.motor.Ri.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis3.motor.Rp1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis3.motor.Rp1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis3.motor.Rp1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.Rp1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis3.motor.Rp1.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.Rp1.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis3.motor.Rp1.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis3.motor.Rp1.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis3.motor.Rp1.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis3.motor.Rp1.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis3.motor.Rp1.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis3.motor.Rp1.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 200.0 \"Resistance at temperature T_ref\";
//   parameter Real axis3.motor.Rp1.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis3.motor.Rp1.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis3.motor.Rp1.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis3.motor.Rp2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis3.motor.Rp2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis3.motor.Rp2.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.Rp2.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis3.motor.Rp2.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.Rp2.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis3.motor.Rp2.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis3.motor.Rp2.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis3.motor.Rp2.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis3.motor.Rp2.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis3.motor.Rp2.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis3.motor.Rp2.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 50.0 \"Resistance at temperature T_ref\";
//   parameter Real axis3.motor.Rp2.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis3.motor.Rp2.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis3.motor.Rp2.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis3.motor.Rd4.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis3.motor.Rd4.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis3.motor.Rd4.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.Rd4.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis3.motor.Rd4.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.Rd4.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis3.motor.Rd4.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis3.motor.Rd4.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis3.motor.Rd4.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis3.motor.Rd4.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis3.motor.Rd4.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis3.motor.Rd4.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 100.0 \"Resistance at temperature T_ref\";
//   parameter Real axis3.motor.Rd4.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis3.motor.Rd4.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis3.motor.Rd4.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis3.motor.hall2.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.hall2.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis3.motor.hall2.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.hall2.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   input Real axis3.motor.hall2.v \"Voltage between pin p and n (= p.v - n.v) as input signal\";
//   Real axis3.motor.hall2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis3.motor.Rd3.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis3.motor.Rd3.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis3.motor.Rd3.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.Rd3.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis3.motor.Rd3.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.Rd3.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis3.motor.Rd3.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis3.motor.Rd3.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis3.motor.Rd3.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis3.motor.Rd3.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis3.motor.Rd3.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis3.motor.Rd3.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 100.0 \"Resistance at temperature T_ref\";
//   parameter Real axis3.motor.Rd3.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis3.motor.Rd3.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis3.motor.Rd3.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis3.motor.g1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.g1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis3.motor.g2.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.g2.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis3.motor.g3.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.g3.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis3.motor.hall1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.hall1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis3.motor.hall1.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.hall1.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   output Real axis3.motor.hall1.i \"current in the branch from p to n as output signal\";
//   Real axis3.motor.g4.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.g4.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis3.motor.g5.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis3.motor.g5.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis3.motor.phi.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis3.motor.phi.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real axis3.motor.phi.phi \"Absolute angle of flange\";
//   Real axis3.motor.speed.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis3.motor.speed.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real axis3.motor.speed.w \"Absolute angular velocity of flange\";
//   Real axis3.motor.Jmotor.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis3.motor.Jmotor.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis3.motor.Jmotor.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis3.motor.Jmotor.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real axis3.motor.Jmotor.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = axis3.motor.J \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) axis3.motor.Jmotor.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real axis3.motor.Jmotor.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real axis3.motor.Jmotor.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
//   Real axis3.motor.Jmotor.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   parameter Real axis3.motor.convert1.k(start = 1.0) = 1.0 \"Gain value multiplied with input signal\";
//   input Real axis3.motor.convert1.u \"Input signal connector\";
//   output Real axis3.motor.convert1.y \"Output signal connector\";
//   parameter Real axis3.motor.convert2.k(start = 1.0) = 1.0 \"Gain value multiplied with input signal\";
//   input Real axis3.motor.convert2.u \"Input signal connector\";
//   output Real axis3.motor.convert2.y \"Output signal connector\";
//   Real axis3.motor.axisControlBus.motorAngle \"virtual variable in expandable connector\";
//   Real axis3.motor.axisControlBus.motorSpeed \"virtual variable in expandable connector\";
//   Real axis3.motor.axisControlBus.current \"virtual variable in expandable connector\";
//   Real axis3.motor.axisControlBus.current_ref \"virtual variable in expandable connector\";
//   parameter Real axis3.controller.kp = axis3.kp \"Gain of position controller\";
//   parameter Real axis3.controller.ks = axis3.ks \"Gain of speed controller\";
//   parameter Real axis3.controller.Ts(quantity = \"Time\", unit = \"s\") = axis3.Ts \"Time constant of integrator of speed controller\";
//   parameter Real axis3.controller.ratio = axis3.ratio \"Gear ratio of gearbox\";
//   parameter Real axis3.controller.gain1.k(start = 1.0) = axis3.controller.ratio \"Gain value multiplied with input signal\";
//   input Real axis3.controller.gain1.u \"Input signal connector\";
//   output Real axis3.controller.gain1.y \"Output signal connector\";
//   input Real axis3.controller.PI.u \"Connector of Real input signal\";
//   output Real axis3.controller.PI.y \"Connector of Real output signal\";
//   parameter Real axis3.controller.PI.k = axis3.controller.ks \"Gain\";
//   parameter Real axis3.controller.PI.T(quantity = \"Time\", unit = \"s\", min = 1e-60, start = 1.0) = axis3.controller.Ts \"Time Constant (T>0 required)\";
//   parameter enumeration(NoInit, SteadyState, InitialState, InitialOutput) axis3.controller.PI.initType = Modelica.Blocks.Types.Init.NoInit \"Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)\";
//   parameter Real axis3.controller.PI.x_start = 0.0 \"Initial or guess value of state\";
//   parameter Real axis3.controller.PI.y_start = 0.0 \"Initial value of output\";
//   output Real axis3.controller.PI.x(start = axis3.controller.PI.x_start) \"State of block\";
//   input Real axis3.controller.feedback1.u1;
//   input Real axis3.controller.feedback1.u2;
//   output Real axis3.controller.feedback1.y;
//   parameter Real axis3.controller.P.k(start = 1.0) = axis3.controller.kp \"Gain value multiplied with input signal\";
//   input Real axis3.controller.P.u \"Input signal connector\";
//   output Real axis3.controller.P.y \"Output signal connector\";
//   parameter Real axis3.controller.add3.k1 = 1.0 \"Gain of upper input\";
//   parameter Real axis3.controller.add3.k2 = 1.0 \"Gain of middle input\";
//   parameter Real axis3.controller.add3.k3 = -1.0 \"Gain of lower input\";
//   input Real axis3.controller.add3.u1 \"Connector 1 of Real input signals\";
//   input Real axis3.controller.add3.u2 \"Connector 2 of Real input signals\";
//   input Real axis3.controller.add3.u3 \"Connector 3 of Real input signals\";
//   output Real axis3.controller.add3.y \"Connector of Real output signals\";
//   parameter Real axis3.controller.gain2.k(start = 1.0) = axis3.controller.ratio \"Gain value multiplied with input signal\";
//   input Real axis3.controller.gain2.u \"Input signal connector\";
//   output Real axis3.controller.gain2.y \"Output signal connector\";
//   Real axis3.controller.axisControlBus.speed_ref \"virtual variable in expandable connector\";
//   Real axis3.controller.axisControlBus.angle_ref \"virtual variable in expandable connector\";
//   output Real axis3.controller.axisControlBus.motorAngle \"virtual variable in expandable connector\";
//   output Real axis3.controller.axisControlBus.motorSpeed \"virtual variable in expandable connector\";
//   Real axis3.controller.axisControlBus.current_ref \"virtual variable in expandable connector\";
//   Real axis3.angleSensor.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis3.angleSensor.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real axis3.angleSensor.phi \"Absolute angle of flange\";
//   Real axis3.speedSensor.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis3.speedSensor.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real axis3.speedSensor.w \"Absolute angular velocity of flange\";
//   Real axis3.accSensor.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis3.accSensor.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis3.accSensor.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of flange\";
//   output Real axis3.accSensor.a \"Absolute angular acceleration of flange\";
//   parameter Boolean axis3.initializeFlange.use_phi_start = true \"= true, if initial angle is defined by input phi_start, otherwise not initialized\";
//   parameter Boolean axis3.initializeFlange.use_w_start = true \"= true, if initial speed is defined by input w_start, otherwise not initialized\";
//   parameter Boolean axis3.initializeFlange.use_a_start = true \"= true, if initial angular acceleration is defined by input a_start, otherwise not initialized\";
//   parameter enumeration(never, avoid, default, prefer, always) axis3.initializeFlange.stateSelect = StateSelect.prefer \"Priority to use flange angle and speed as states\";
//   Real axis3.initializeFlange.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis3.initializeFlange.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis3.initializeFlange.phi_flange(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) = axis3.initializeFlange.flange.phi \"Flange angle\";
//   Real axis3.initializeFlange.w_flange(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) = der(axis3.initializeFlange.phi_flange) \"= der(phi_flange)\";
//   Real axis3.initializeFlange.set_flange_tau.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis3.initializeFlange.set_flange_tau.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real axis3.initializeFlange.phi_start \"Initial angle of flange\";
//   input Real axis3.initializeFlange.set_phi_start.phi_start \"Start angle\";
//   Real axis3.initializeFlange.set_phi_start.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis3.initializeFlange.set_phi_start.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real axis3.initializeFlange.w_start \"Initial speed of flange\";
//   input Real axis3.initializeFlange.set_w_start.w_start \"Start angular velocity\";
//   Real axis3.initializeFlange.set_w_start.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis3.initializeFlange.set_w_start.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real axis3.initializeFlange.a_start \"Initial angular acceleration of flange\";
//   input Real axis3.initializeFlange.set_a_start.a_start \"Start angular acceleration\";
//   Real axis3.initializeFlange.set_a_start.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.avoid) \"Absolute rotation angle of flange\";
//   Real axis3.initializeFlange.set_a_start.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis3.initializeFlange.set_a_start.w(quantity = \"AngularVelocity\", unit = \"rad/s\") = der(axis3.initializeFlange.set_a_start.flange.phi);
//   output Real axis3.const.y \"Connector of Real output signal\";
//   parameter Real axis3.const.k(start = 1.0) = 0.0 \"Constant output value\";
//   parameter Real axis3.c(unit = \"N.m/rad\") = 58.0 \"Spring constant\";
//   parameter Real axis3.cd(unit = \"N.m.s/rad\") = 0.04 \"Damper constant\";
//   Real axis3.axisControlBus.angle \"virtual variable in expandable connector\";
//   Real axis3.axisControlBus.speed \"virtual variable in expandable connector\";
//   Real axis3.axisControlBus.acceleration \"virtual variable in expandable connector\";
//   Real axis3.axisControlBus.angle_ref \"virtual variable in expandable connector\";
//   Real axis3.axisControlBus.speed_ref \"virtual variable in expandable connector\";
//   Real axis3.axisControlBus.motorSpeed \"virtual variable in expandable connector\";
//   Real axis3.axisControlBus.current_ref \"virtual variable in expandable connector\";
//   Real axis3.axisControlBus.current \"virtual variable in expandable connector\";
//   Real axis3.axisControlBus.motorAngle \"virtual variable in expandable connector\";
//   Real axis3.motor.axisControlBus.angle \"virtual variable in expandable connector\";
//   Real axis3.motor.axisControlBus.acceleration \"virtual variable in expandable connector\";
//   Real axis3.motor.axisControlBus.speed \"virtual variable in expandable connector\";
//   Real axis3.motor.axisControlBus.angle_ref \"virtual variable in expandable connector\";
//   Real axis3.motor.axisControlBus.speed_ref \"virtual variable in expandable connector\";
//   Real axis3.controller.axisControlBus.angle \"virtual variable in expandable connector\";
//   Real axis3.controller.axisControlBus.acceleration \"virtual variable in expandable connector\";
//   Real axis3.controller.axisControlBus.current \"virtual variable in expandable connector\";
//   Real axis3.controller.axisControlBus.speed \"virtual variable in expandable connector\";
//   parameter Real axis4.kp = kp4 \"Gain of position controller\";
//   parameter Real axis4.ks = ks4 \"Gain of speed controller\";
//   parameter Real axis4.Ts(quantity = \"Time\", unit = \"s\") = Ts4 \"Time constant of integrator of speed controller\";
//   parameter Real axis4.k = 0.2365 \"Gain of motor\";
//   parameter Real axis4.w = 6250.0 \"Time constant of motor\";
//   parameter Real axis4.D = 0.55 \"Damping constant of motor\";
//   parameter Real axis4.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.00016 \"Moment of inertia of motor\";
//   parameter Real axis4.ratio = -99.0 \"Gear ratio\";
//   parameter Real axis4.Rv0(quantity = \"Torque\", unit = \"N.m\") = 21.8 \"Viscous friction torque at zero velocity in [Nm]\";
//   parameter Real axis4.Rv1(unit = \"N.m.s/rad\") = 9.8 \"Viscous friction coefficient in [Nms/rad]\";
//   parameter Real axis4.peak = 1.22477064220183 \"Maximum static friction torque is peak*Rv0 (peak >= 1)\";
//   Real axis4.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis4.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis4.gear.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis4.gear.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis4.gear.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis4.gear.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real axis4.gear.i = axis4.ratio \"Gear ratio\";
//   parameter Real axis4.gear.Rv0(quantity = \"Torque\", unit = \"N.m\") = axis4.Rv0 \"Viscous friction torque at zero velocity\";
//   parameter Real axis4.gear.Rv1 = axis4.Rv1 \"Viscous friction coefficient in [Nms/rad] (R=Rv0+Rv1*abs(qd))\";
//   parameter Real axis4.gear.peak = axis4.peak \"Maximum static friction torque is peak*Rv0 (peak >= 1)\";
//   constant Real axis4.gear.unitAngularVelocity(quantity = \"AngularVelocity\", unit = \"rad/s\") = 1.0;
//   constant Real axis4.gear.unitTorque(quantity = \"Torque\", unit = \"N.m\") = 1.0;
//   parameter Boolean axis4.gear.gear.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real axis4.gear.gear.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis4.gear.gear.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis4.gear.gear.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis4.gear.gear.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real axis4.gear.gear.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   parameter Real axis4.gear.gear.ratio(start = 1.0) = axis4.gear.i \"Transmission ratio (flange_a.phi/flange_b.phi)\";
//   Real axis4.gear.gear.phi_a(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle between left shaft flange and support\";
//   Real axis4.gear.gear.phi_b(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle between right shaft flange and support\";
//   parameter Boolean axis4.gear.bearingFriction.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real axis4.gear.bearingFriction.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis4.gear.bearingFriction.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis4.gear.bearingFriction.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis4.gear.bearingFriction.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real axis4.gear.bearingFriction.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   parameter Real axis4.gear.bearingFriction.w_small(quantity = \"AngularVelocity\", unit = \"rad/s\") = 10000000000.0 \"Relative angular velocity near to zero if jumps due to a reinit(..) of the velocity can occur (set to low value only if such impulses can occur)\";
//   Real axis4.gear.bearingFriction.w_relfric(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Relative angular velocity between frictional surfaces\";
//   Real axis4.gear.bearingFriction.a_relfric(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration between frictional surfaces\";
//   Real axis4.gear.bearingFriction.tau0(quantity = \"Torque\", unit = \"N.m\") \"Friction torque for w=0 and forward sliding\";
//   Real axis4.gear.bearingFriction.tau0_max(quantity = \"Torque\", unit = \"N.m\") \"Maximum friction torque for w=0 and locked\";
//   Boolean axis4.gear.bearingFriction.free \"true, if frictional element is not active\";
//   Real axis4.gear.bearingFriction.sa(unit = \"1\") \"Path parameter of friction characteristic tau = f(a_relfric)\";
//   Boolean axis4.gear.bearingFriction.startForward(start = false, fixed = true) \"true, if w_rel=0 and start of forward sliding\";
//   Boolean axis4.gear.bearingFriction.startBackward(start = false, fixed = true) \"true, if w_rel=0 and start of backward sliding\";
//   Boolean axis4.gear.bearingFriction.locked(start = false) \"true, if w_rel=0 and not sliding\";
//   constant Integer axis4.gear.bearingFriction.Unknown = 3 \"Value of mode is not known\";
//   constant Integer axis4.gear.bearingFriction.Free = 2 \"Element is not active\";
//   constant Integer axis4.gear.bearingFriction.Forward = 1 \"w_rel > 0 (forward sliding)\";
//   constant Integer axis4.gear.bearingFriction.Stuck = 0 \"w_rel = 0 (forward sliding, locked or backward sliding)\";
//   constant Integer axis4.gear.bearingFriction.Backward = -1 \"w_rel < 0 (backward sliding)\";
//   Integer axis4.gear.bearingFriction.mode(min = -1, max = 3, start = 3, fixed = true);
//   protected constant Real axis4.gear.bearingFriction.unitAngularAcceleration(quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 1.0;
//   protected constant Real axis4.gear.bearingFriction.unitTorque(quantity = \"Torque\", unit = \"N.m\") = 1.0;
//   parameter Real axis4.gear.bearingFriction.tau_pos[1,1] = 0.0 \"[w,tau] Positive sliding friction characteristic (w>=0)\";
//   parameter Real axis4.gear.bearingFriction.tau_pos[1,2] = axis4.gear.Rv0 \"[w,tau] Positive sliding friction characteristic (w>=0)\";
//   parameter Real axis4.gear.bearingFriction.tau_pos[2,1] = 1.0 \"[w,tau] Positive sliding friction characteristic (w>=0)\";
//   parameter Real axis4.gear.bearingFriction.tau_pos[2,2] = axis4.gear.Rv0 + axis4.gear.Rv1 \"[w,tau] Positive sliding friction characteristic (w>=0)\";
//   parameter Real axis4.gear.bearingFriction.peak(min = 1.0) = axis4.gear.peak \"peak*tau_pos[1,2] = Maximum friction torque for w==0\";
//   Real axis4.gear.bearingFriction.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle between shaft flanges (flange_a, flange_b) and support\";
//   Real axis4.gear.bearingFriction.tau(quantity = \"Torque\", unit = \"N.m\") \"Friction torque\";
//   Real axis4.gear.bearingFriction.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of flange_a and flange_b\";
//   Real axis4.gear.bearingFriction.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of flange_a and flange_b\";
//   parameter Real axis4.motor.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = axis4.J \"Moment of inertia of motor\";
//   parameter Real axis4.motor.k = axis4.k \"Gain of motor\";
//   parameter Real axis4.motor.w = axis4.w \"Time constant of motor\";
//   parameter Real axis4.motor.D = axis4.D \"Damping constant of motor\";
//   parameter Real axis4.motor.w_max(quantity = \"AngularVelocity\", unit = \"rad/s\") = 315.0 \"Maximum speed of motor\";
//   parameter Real axis4.motor.i_max(quantity = \"ElectricCurrent\", unit = \"A\") = 9.0 \"Maximum current of motor\";
//   Real axis4.motor.flange_motor.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis4.motor.flange_motor.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis4.motor.Vs.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.Vs.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis4.motor.Vs.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.Vs.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   input Real axis4.motor.Vs.v \"Voltage between pin p and n (= p.v - n.v) as input signal\";
//   Real axis4.motor.Vs.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis4.motor.diff.v1(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the left port\";
//   Real axis4.motor.diff.v2(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the right port\";
//   Real axis4.motor.diff.i1(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the left port\";
//   Real axis4.motor.diff.i2(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the right port\";
//   Real axis4.motor.diff.p1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.diff.p1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis4.motor.diff.n1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.diff.n1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis4.motor.diff.p2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.diff.p2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis4.motor.diff.n2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.diff.n2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis4.motor.power.v1(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the left port\";
//   Real axis4.motor.power.v2(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the right port\";
//   Real axis4.motor.power.i1(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the left port\";
//   Real axis4.motor.power.i2(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the right port\";
//   Real axis4.motor.power.p1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.power.p1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis4.motor.power.n1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.power.n1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis4.motor.power.p2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.power.p2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis4.motor.power.n2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.power.n2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis4.motor.emf.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   parameter Real axis4.motor.emf.k(quantity = \"ElectricalTorqueConstant\", unit = \"N.m/A\", start = 1.0) = axis4.motor.k \"Transformation coefficient\";
//   Real axis4.motor.emf.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins\";
//   Real axis4.motor.emf.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from positive to negative pin\";
//   Real axis4.motor.emf.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle of shaft flange with respect to support (= flange.phi - support.phi)\";
//   Real axis4.motor.emf.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity of flange relative to support\";
//   Real axis4.motor.emf.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.emf.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis4.motor.emf.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.emf.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis4.motor.emf.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis4.motor.emf.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real axis4.motor.emf.internalSupport.tau(quantity = \"Torque\", unit = \"N.m\") = -axis4.motor.emf.flange.tau \"External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau)\";
//   Real axis4.motor.emf.internalSupport.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"External support angle (= flange.phi)\";
//   Real axis4.motor.emf.internalSupport.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis4.motor.emf.internalSupport.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real axis4.motor.emf.fixed.phi0(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Fixed offset angle of housing\";
//   Real axis4.motor.emf.fixed.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis4.motor.emf.fixed.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis4.motor.La.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis4.motor.La.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis4.motor.La.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.La.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis4.motor.La.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.La.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real axis4.motor.La.L(quantity = \"Inductance\", unit = \"H\", start = 1.0) = 250.0 / (axis4.motor.w * axis4.motor.D * 2.0) \"Inductance\";
//   Real axis4.motor.Ra.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis4.motor.Ra.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis4.motor.Ra.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.Ra.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis4.motor.Ra.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.Ra.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis4.motor.Ra.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis4.motor.Ra.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis4.motor.Ra.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis4.motor.Ra.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis4.motor.Ra.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis4.motor.Ra.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 250.0 \"Resistance at temperature T_ref\";
//   parameter Real axis4.motor.Ra.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis4.motor.Ra.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis4.motor.Ra.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis4.motor.Rd2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis4.motor.Rd2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis4.motor.Rd2.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.Rd2.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis4.motor.Rd2.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.Rd2.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis4.motor.Rd2.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis4.motor.Rd2.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis4.motor.Rd2.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis4.motor.Rd2.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis4.motor.Rd2.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis4.motor.Rd2.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 100.0 \"Resistance at temperature T_ref\";
//   parameter Real axis4.motor.Rd2.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis4.motor.Rd2.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis4.motor.Rd2.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis4.motor.C.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis4.motor.C.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis4.motor.C.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.C.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis4.motor.C.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.C.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real axis4.motor.C.C(quantity = \"Capacitance\", unit = \"F\", min = 0.0, start = 1.0) = (0.004 * axis4.motor.D) / axis4.motor.w \"Capacitance\";
//   Real axis4.motor.OpI.v1(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the left port\";
//   Real axis4.motor.OpI.v2(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the right port\";
//   Real axis4.motor.OpI.i1(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the left port\";
//   Real axis4.motor.OpI.i2(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the right port\";
//   Real axis4.motor.OpI.p1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.OpI.p1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis4.motor.OpI.n1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.OpI.n1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis4.motor.OpI.p2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.OpI.p2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis4.motor.OpI.n2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.OpI.n2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis4.motor.Rd1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis4.motor.Rd1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis4.motor.Rd1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.Rd1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis4.motor.Rd1.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.Rd1.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis4.motor.Rd1.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis4.motor.Rd1.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis4.motor.Rd1.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis4.motor.Rd1.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis4.motor.Rd1.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis4.motor.Rd1.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 100.0 \"Resistance at temperature T_ref\";
//   parameter Real axis4.motor.Rd1.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis4.motor.Rd1.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis4.motor.Rd1.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis4.motor.Ri.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis4.motor.Ri.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis4.motor.Ri.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.Ri.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis4.motor.Ri.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.Ri.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis4.motor.Ri.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis4.motor.Ri.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis4.motor.Ri.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis4.motor.Ri.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis4.motor.Ri.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis4.motor.Ri.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 10.0 \"Resistance at temperature T_ref\";
//   parameter Real axis4.motor.Ri.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis4.motor.Ri.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis4.motor.Ri.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis4.motor.Rp1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis4.motor.Rp1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis4.motor.Rp1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.Rp1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis4.motor.Rp1.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.Rp1.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis4.motor.Rp1.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis4.motor.Rp1.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis4.motor.Rp1.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis4.motor.Rp1.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis4.motor.Rp1.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis4.motor.Rp1.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 200.0 \"Resistance at temperature T_ref\";
//   parameter Real axis4.motor.Rp1.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis4.motor.Rp1.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis4.motor.Rp1.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis4.motor.Rp2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis4.motor.Rp2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis4.motor.Rp2.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.Rp2.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis4.motor.Rp2.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.Rp2.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis4.motor.Rp2.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis4.motor.Rp2.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis4.motor.Rp2.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis4.motor.Rp2.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis4.motor.Rp2.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis4.motor.Rp2.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 50.0 \"Resistance at temperature T_ref\";
//   parameter Real axis4.motor.Rp2.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis4.motor.Rp2.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis4.motor.Rp2.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis4.motor.Rd4.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis4.motor.Rd4.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis4.motor.Rd4.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.Rd4.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis4.motor.Rd4.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.Rd4.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis4.motor.Rd4.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis4.motor.Rd4.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis4.motor.Rd4.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis4.motor.Rd4.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis4.motor.Rd4.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis4.motor.Rd4.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 100.0 \"Resistance at temperature T_ref\";
//   parameter Real axis4.motor.Rd4.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis4.motor.Rd4.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis4.motor.Rd4.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis4.motor.hall2.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.hall2.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis4.motor.hall2.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.hall2.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   input Real axis4.motor.hall2.v \"Voltage between pin p and n (= p.v - n.v) as input signal\";
//   Real axis4.motor.hall2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis4.motor.Rd3.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis4.motor.Rd3.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis4.motor.Rd3.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.Rd3.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis4.motor.Rd3.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.Rd3.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis4.motor.Rd3.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis4.motor.Rd3.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis4.motor.Rd3.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis4.motor.Rd3.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis4.motor.Rd3.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis4.motor.Rd3.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 100.0 \"Resistance at temperature T_ref\";
//   parameter Real axis4.motor.Rd3.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis4.motor.Rd3.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis4.motor.Rd3.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis4.motor.g1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.g1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis4.motor.g2.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.g2.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis4.motor.g3.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.g3.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis4.motor.hall1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.hall1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis4.motor.hall1.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.hall1.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   output Real axis4.motor.hall1.i \"current in the branch from p to n as output signal\";
//   Real axis4.motor.g4.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.g4.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis4.motor.g5.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis4.motor.g5.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis4.motor.phi.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis4.motor.phi.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real axis4.motor.phi.phi \"Absolute angle of flange\";
//   Real axis4.motor.speed.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis4.motor.speed.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real axis4.motor.speed.w \"Absolute angular velocity of flange\";
//   Real axis4.motor.Jmotor.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis4.motor.Jmotor.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis4.motor.Jmotor.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis4.motor.Jmotor.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real axis4.motor.Jmotor.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = axis4.motor.J \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) axis4.motor.Jmotor.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real axis4.motor.Jmotor.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real axis4.motor.Jmotor.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
//   Real axis4.motor.Jmotor.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   parameter Real axis4.motor.convert1.k(start = 1.0) = 1.0 \"Gain value multiplied with input signal\";
//   input Real axis4.motor.convert1.u \"Input signal connector\";
//   output Real axis4.motor.convert1.y \"Output signal connector\";
//   parameter Real axis4.motor.convert2.k(start = 1.0) = 1.0 \"Gain value multiplied with input signal\";
//   input Real axis4.motor.convert2.u \"Input signal connector\";
//   output Real axis4.motor.convert2.y \"Output signal connector\";
//   Real axis4.motor.axisControlBus.motorAngle \"virtual variable in expandable connector\";
//   Real axis4.motor.axisControlBus.motorSpeed \"virtual variable in expandable connector\";
//   Real axis4.motor.axisControlBus.current \"virtual variable in expandable connector\";
//   Real axis4.motor.axisControlBus.current_ref \"virtual variable in expandable connector\";
//   parameter Real axis4.controller.kp = axis4.kp \"Gain of position controller\";
//   parameter Real axis4.controller.ks = axis4.ks \"Gain of speed controller\";
//   parameter Real axis4.controller.Ts(quantity = \"Time\", unit = \"s\") = axis4.Ts \"Time constant of integrator of speed controller\";
//   parameter Real axis4.controller.ratio = axis4.ratio \"Gear ratio of gearbox\";
//   parameter Real axis4.controller.gain1.k(start = 1.0) = axis4.controller.ratio \"Gain value multiplied with input signal\";
//   input Real axis4.controller.gain1.u \"Input signal connector\";
//   output Real axis4.controller.gain1.y \"Output signal connector\";
//   input Real axis4.controller.PI.u \"Connector of Real input signal\";
//   output Real axis4.controller.PI.y \"Connector of Real output signal\";
//   parameter Real axis4.controller.PI.k = axis4.controller.ks \"Gain\";
//   parameter Real axis4.controller.PI.T(quantity = \"Time\", unit = \"s\", min = 1e-60, start = 1.0) = axis4.controller.Ts \"Time Constant (T>0 required)\";
//   parameter enumeration(NoInit, SteadyState, InitialState, InitialOutput) axis4.controller.PI.initType = Modelica.Blocks.Types.Init.NoInit \"Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)\";
//   parameter Real axis4.controller.PI.x_start = 0.0 \"Initial or guess value of state\";
//   parameter Real axis4.controller.PI.y_start = 0.0 \"Initial value of output\";
//   output Real axis4.controller.PI.x(start = axis4.controller.PI.x_start) \"State of block\";
//   input Real axis4.controller.feedback1.u1;
//   input Real axis4.controller.feedback1.u2;
//   output Real axis4.controller.feedback1.y;
//   parameter Real axis4.controller.P.k(start = 1.0) = axis4.controller.kp \"Gain value multiplied with input signal\";
//   input Real axis4.controller.P.u \"Input signal connector\";
//   output Real axis4.controller.P.y \"Output signal connector\";
//   parameter Real axis4.controller.add3.k1 = 1.0 \"Gain of upper input\";
//   parameter Real axis4.controller.add3.k2 = 1.0 \"Gain of middle input\";
//   parameter Real axis4.controller.add3.k3 = -1.0 \"Gain of lower input\";
//   input Real axis4.controller.add3.u1 \"Connector 1 of Real input signals\";
//   input Real axis4.controller.add3.u2 \"Connector 2 of Real input signals\";
//   input Real axis4.controller.add3.u3 \"Connector 3 of Real input signals\";
//   output Real axis4.controller.add3.y \"Connector of Real output signals\";
//   parameter Real axis4.controller.gain2.k(start = 1.0) = axis4.controller.ratio \"Gain value multiplied with input signal\";
//   input Real axis4.controller.gain2.u \"Input signal connector\";
//   output Real axis4.controller.gain2.y \"Output signal connector\";
//   Real axis4.controller.axisControlBus.speed_ref \"virtual variable in expandable connector\";
//   Real axis4.controller.axisControlBus.angle_ref \"virtual variable in expandable connector\";
//   output Real axis4.controller.axisControlBus.motorAngle \"virtual variable in expandable connector\";
//   output Real axis4.controller.axisControlBus.motorSpeed \"virtual variable in expandable connector\";
//   Real axis4.controller.axisControlBus.current_ref \"virtual variable in expandable connector\";
//   Real axis4.angleSensor.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis4.angleSensor.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real axis4.angleSensor.phi \"Absolute angle of flange\";
//   Real axis4.speedSensor.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis4.speedSensor.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real axis4.speedSensor.w \"Absolute angular velocity of flange\";
//   Real axis4.accSensor.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis4.accSensor.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis4.accSensor.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of flange\";
//   output Real axis4.accSensor.a \"Absolute angular acceleration of flange\";
//   parameter Boolean axis4.initializeFlange.use_phi_start = true \"= true, if initial angle is defined by input phi_start, otherwise not initialized\";
//   parameter Boolean axis4.initializeFlange.use_w_start = true \"= true, if initial speed is defined by input w_start, otherwise not initialized\";
//   parameter Boolean axis4.initializeFlange.use_a_start = true \"= true, if initial angular acceleration is defined by input a_start, otherwise not initialized\";
//   parameter enumeration(never, avoid, default, prefer, always) axis4.initializeFlange.stateSelect = StateSelect.prefer \"Priority to use flange angle and speed as states\";
//   Real axis4.initializeFlange.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis4.initializeFlange.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis4.initializeFlange.phi_flange(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) = axis4.initializeFlange.flange.phi \"Flange angle\";
//   Real axis4.initializeFlange.w_flange(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) = der(axis4.initializeFlange.phi_flange) \"= der(phi_flange)\";
//   Real axis4.initializeFlange.set_flange_tau.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis4.initializeFlange.set_flange_tau.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real axis4.initializeFlange.phi_start \"Initial angle of flange\";
//   input Real axis4.initializeFlange.set_phi_start.phi_start \"Start angle\";
//   Real axis4.initializeFlange.set_phi_start.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis4.initializeFlange.set_phi_start.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real axis4.initializeFlange.w_start \"Initial speed of flange\";
//   input Real axis4.initializeFlange.set_w_start.w_start \"Start angular velocity\";
//   Real axis4.initializeFlange.set_w_start.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis4.initializeFlange.set_w_start.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real axis4.initializeFlange.a_start \"Initial angular acceleration of flange\";
//   input Real axis4.initializeFlange.set_a_start.a_start \"Start angular acceleration\";
//   Real axis4.initializeFlange.set_a_start.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.avoid) \"Absolute rotation angle of flange\";
//   Real axis4.initializeFlange.set_a_start.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis4.initializeFlange.set_a_start.w(quantity = \"AngularVelocity\", unit = \"rad/s\") = der(axis4.initializeFlange.set_a_start.flange.phi);
//   output Real axis4.const.y \"Connector of Real output signal\";
//   parameter Real axis4.const.k(start = 1.0) = 0.0 \"Constant output value\";
//   Real axis4.axisControlBus.angle \"virtual variable in expandable connector\";
//   Real axis4.axisControlBus.speed \"virtual variable in expandable connector\";
//   Real axis4.axisControlBus.acceleration \"virtual variable in expandable connector\";
//   Real axis4.axisControlBus.angle_ref \"virtual variable in expandable connector\";
//   Real axis4.axisControlBus.speed_ref \"virtual variable in expandable connector\";
//   Real axis4.axisControlBus.motorSpeed \"virtual variable in expandable connector\";
//   Real axis4.axisControlBus.current_ref \"virtual variable in expandable connector\";
//   Real axis4.axisControlBus.current \"virtual variable in expandable connector\";
//   Real axis4.axisControlBus.motorAngle \"virtual variable in expandable connector\";
//   Real axis4.motor.axisControlBus.angle \"virtual variable in expandable connector\";
//   Real axis4.motor.axisControlBus.acceleration \"virtual variable in expandable connector\";
//   Real axis4.motor.axisControlBus.speed \"virtual variable in expandable connector\";
//   Real axis4.motor.axisControlBus.angle_ref \"virtual variable in expandable connector\";
//   Real axis4.motor.axisControlBus.speed_ref \"virtual variable in expandable connector\";
//   Real axis4.controller.axisControlBus.angle \"virtual variable in expandable connector\";
//   Real axis4.controller.axisControlBus.acceleration \"virtual variable in expandable connector\";
//   Real axis4.controller.axisControlBus.current \"virtual variable in expandable connector\";
//   Real axis4.controller.axisControlBus.speed \"virtual variable in expandable connector\";
//   parameter Real axis5.kp = kp5 \"Gain of position controller\";
//   parameter Real axis5.ks = ks5 \"Gain of speed controller\";
//   parameter Real axis5.Ts(quantity = \"Time\", unit = \"s\") = Ts5 \"Time constant of integrator of speed controller\";
//   parameter Real axis5.k = 0.2608 \"Gain of motor\";
//   parameter Real axis5.w = 6250.0 \"Time constant of motor\";
//   parameter Real axis5.D = 0.55 \"Damping constant of motor\";
//   parameter Real axis5.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 0.00018 \"Moment of inertia of motor\";
//   parameter Real axis5.ratio = 79.2 \"Gear ratio\";
//   parameter Real axis5.Rv0(quantity = \"Torque\", unit = \"N.m\") = 30.1 \"Viscous friction torque at zero velocity in [Nm]\";
//   parameter Real axis5.Rv1(unit = \"N.m.s/rad\") = 0.03 \"Viscous friction coefficient in [Nms/rad]\";
//   parameter Real axis5.peak = 1.3156146179402 \"Maximum static friction torque is peak*Rv0 (peak >= 1)\";
//   Real axis5.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis5.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis5.gear.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis5.gear.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis5.gear.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis5.gear.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real axis5.gear.i = axis5.ratio \"Gear ratio\";
//   parameter Real axis5.gear.Rv0(quantity = \"Torque\", unit = \"N.m\") = axis5.Rv0 \"Viscous friction torque at zero velocity\";
//   parameter Real axis5.gear.Rv1 = axis5.Rv1 \"Viscous friction coefficient in [Nms/rad] (R=Rv0+Rv1*abs(qd))\";
//   parameter Real axis5.gear.peak = axis5.peak \"Maximum static friction torque is peak*Rv0 (peak >= 1)\";
//   constant Real axis5.gear.unitAngularVelocity(quantity = \"AngularVelocity\", unit = \"rad/s\") = 1.0;
//   constant Real axis5.gear.unitTorque(quantity = \"Torque\", unit = \"N.m\") = 1.0;
//   parameter Boolean axis5.gear.gear.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real axis5.gear.gear.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis5.gear.gear.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis5.gear.gear.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis5.gear.gear.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real axis5.gear.gear.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   parameter Real axis5.gear.gear.ratio(start = 1.0) = axis5.gear.i \"Transmission ratio (flange_a.phi/flange_b.phi)\";
//   Real axis5.gear.gear.phi_a(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle between left shaft flange and support\";
//   Real axis5.gear.gear.phi_b(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle between right shaft flange and support\";
//   parameter Boolean axis5.gear.bearingFriction.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real axis5.gear.bearingFriction.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis5.gear.bearingFriction.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis5.gear.bearingFriction.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis5.gear.bearingFriction.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real axis5.gear.bearingFriction.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   parameter Real axis5.gear.bearingFriction.w_small(quantity = \"AngularVelocity\", unit = \"rad/s\") = 10000000000.0 \"Relative angular velocity near to zero if jumps due to a reinit(..) of the velocity can occur (set to low value only if such impulses can occur)\";
//   Real axis5.gear.bearingFriction.w_relfric(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Relative angular velocity between frictional surfaces\";
//   Real axis5.gear.bearingFriction.a_relfric(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration between frictional surfaces\";
//   Real axis5.gear.bearingFriction.tau0(quantity = \"Torque\", unit = \"N.m\") \"Friction torque for w=0 and forward sliding\";
//   Real axis5.gear.bearingFriction.tau0_max(quantity = \"Torque\", unit = \"N.m\") \"Maximum friction torque for w=0 and locked\";
//   Boolean axis5.gear.bearingFriction.free \"true, if frictional element is not active\";
//   Real axis5.gear.bearingFriction.sa(unit = \"1\") \"Path parameter of friction characteristic tau = f(a_relfric)\";
//   Boolean axis5.gear.bearingFriction.startForward(start = false, fixed = true) \"true, if w_rel=0 and start of forward sliding\";
//   Boolean axis5.gear.bearingFriction.startBackward(start = false, fixed = true) \"true, if w_rel=0 and start of backward sliding\";
//   Boolean axis5.gear.bearingFriction.locked(start = false) \"true, if w_rel=0 and not sliding\";
//   constant Integer axis5.gear.bearingFriction.Unknown = 3 \"Value of mode is not known\";
//   constant Integer axis5.gear.bearingFriction.Free = 2 \"Element is not active\";
//   constant Integer axis5.gear.bearingFriction.Forward = 1 \"w_rel > 0 (forward sliding)\";
//   constant Integer axis5.gear.bearingFriction.Stuck = 0 \"w_rel = 0 (forward sliding, locked or backward sliding)\";
//   constant Integer axis5.gear.bearingFriction.Backward = -1 \"w_rel < 0 (backward sliding)\";
//   Integer axis5.gear.bearingFriction.mode(min = -1, max = 3, start = 3, fixed = true);
//   protected constant Real axis5.gear.bearingFriction.unitAngularAcceleration(quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 1.0;
//   protected constant Real axis5.gear.bearingFriction.unitTorque(quantity = \"Torque\", unit = \"N.m\") = 1.0;
//   parameter Real axis5.gear.bearingFriction.tau_pos[1,1] = 0.0 \"[w,tau] Positive sliding friction characteristic (w>=0)\";
//   parameter Real axis5.gear.bearingFriction.tau_pos[1,2] = axis5.gear.Rv0 \"[w,tau] Positive sliding friction characteristic (w>=0)\";
//   parameter Real axis5.gear.bearingFriction.tau_pos[2,1] = 1.0 \"[w,tau] Positive sliding friction characteristic (w>=0)\";
//   parameter Real axis5.gear.bearingFriction.tau_pos[2,2] = axis5.gear.Rv0 + axis5.gear.Rv1 \"[w,tau] Positive sliding friction characteristic (w>=0)\";
//   parameter Real axis5.gear.bearingFriction.peak(min = 1.0) = axis5.gear.peak \"peak*tau_pos[1,2] = Maximum friction torque for w==0\";
//   Real axis5.gear.bearingFriction.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle between shaft flanges (flange_a, flange_b) and support\";
//   Real axis5.gear.bearingFriction.tau(quantity = \"Torque\", unit = \"N.m\") \"Friction torque\";
//   Real axis5.gear.bearingFriction.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of flange_a and flange_b\";
//   Real axis5.gear.bearingFriction.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of flange_a and flange_b\";
//   parameter Real axis5.motor.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = axis5.J \"Moment of inertia of motor\";
//   parameter Real axis5.motor.k = axis5.k \"Gain of motor\";
//   parameter Real axis5.motor.w = axis5.w \"Time constant of motor\";
//   parameter Real axis5.motor.D = axis5.D \"Damping constant of motor\";
//   parameter Real axis5.motor.w_max(quantity = \"AngularVelocity\", unit = \"rad/s\") = 315.0 \"Maximum speed of motor\";
//   parameter Real axis5.motor.i_max(quantity = \"ElectricCurrent\", unit = \"A\") = 9.0 \"Maximum current of motor\";
//   Real axis5.motor.flange_motor.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis5.motor.flange_motor.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis5.motor.Vs.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.Vs.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis5.motor.Vs.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.Vs.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   input Real axis5.motor.Vs.v \"Voltage between pin p and n (= p.v - n.v) as input signal\";
//   Real axis5.motor.Vs.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis5.motor.diff.v1(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the left port\";
//   Real axis5.motor.diff.v2(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the right port\";
//   Real axis5.motor.diff.i1(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the left port\";
//   Real axis5.motor.diff.i2(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the right port\";
//   Real axis5.motor.diff.p1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.diff.p1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis5.motor.diff.n1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.diff.n1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis5.motor.diff.p2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.diff.p2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis5.motor.diff.n2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.diff.n2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis5.motor.power.v1(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the left port\";
//   Real axis5.motor.power.v2(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the right port\";
//   Real axis5.motor.power.i1(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the left port\";
//   Real axis5.motor.power.i2(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the right port\";
//   Real axis5.motor.power.p1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.power.p1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis5.motor.power.n1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.power.n1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis5.motor.power.p2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.power.p2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis5.motor.power.n2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.power.n2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis5.motor.emf.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   parameter Real axis5.motor.emf.k(quantity = \"ElectricalTorqueConstant\", unit = \"N.m/A\", start = 1.0) = axis5.motor.k \"Transformation coefficient\";
//   Real axis5.motor.emf.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins\";
//   Real axis5.motor.emf.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from positive to negative pin\";
//   Real axis5.motor.emf.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle of shaft flange with respect to support (= flange.phi - support.phi)\";
//   Real axis5.motor.emf.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity of flange relative to support\";
//   Real axis5.motor.emf.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.emf.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis5.motor.emf.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.emf.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis5.motor.emf.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis5.motor.emf.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real axis5.motor.emf.internalSupport.tau(quantity = \"Torque\", unit = \"N.m\") = -axis5.motor.emf.flange.tau \"External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau)\";
//   Real axis5.motor.emf.internalSupport.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"External support angle (= flange.phi)\";
//   Real axis5.motor.emf.internalSupport.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis5.motor.emf.internalSupport.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real axis5.motor.emf.fixed.phi0(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Fixed offset angle of housing\";
//   Real axis5.motor.emf.fixed.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis5.motor.emf.fixed.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis5.motor.La.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis5.motor.La.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis5.motor.La.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.La.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis5.motor.La.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.La.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real axis5.motor.La.L(quantity = \"Inductance\", unit = \"H\", start = 1.0) = 250.0 / (axis5.motor.w * axis5.motor.D * 2.0) \"Inductance\";
//   Real axis5.motor.Ra.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis5.motor.Ra.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis5.motor.Ra.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.Ra.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis5.motor.Ra.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.Ra.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis5.motor.Ra.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis5.motor.Ra.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis5.motor.Ra.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis5.motor.Ra.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis5.motor.Ra.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis5.motor.Ra.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 250.0 \"Resistance at temperature T_ref\";
//   parameter Real axis5.motor.Ra.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis5.motor.Ra.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis5.motor.Ra.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis5.motor.Rd2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis5.motor.Rd2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis5.motor.Rd2.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.Rd2.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis5.motor.Rd2.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.Rd2.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis5.motor.Rd2.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis5.motor.Rd2.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis5.motor.Rd2.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis5.motor.Rd2.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis5.motor.Rd2.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis5.motor.Rd2.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 100.0 \"Resistance at temperature T_ref\";
//   parameter Real axis5.motor.Rd2.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis5.motor.Rd2.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis5.motor.Rd2.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis5.motor.C.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis5.motor.C.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis5.motor.C.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.C.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis5.motor.C.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.C.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real axis5.motor.C.C(quantity = \"Capacitance\", unit = \"F\", min = 0.0, start = 1.0) = (0.004 * axis5.motor.D) / axis5.motor.w \"Capacitance\";
//   Real axis5.motor.OpI.v1(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the left port\";
//   Real axis5.motor.OpI.v2(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the right port\";
//   Real axis5.motor.OpI.i1(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the left port\";
//   Real axis5.motor.OpI.i2(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the right port\";
//   Real axis5.motor.OpI.p1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.OpI.p1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis5.motor.OpI.n1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.OpI.n1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis5.motor.OpI.p2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.OpI.p2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis5.motor.OpI.n2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.OpI.n2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis5.motor.Rd1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis5.motor.Rd1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis5.motor.Rd1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.Rd1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis5.motor.Rd1.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.Rd1.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis5.motor.Rd1.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis5.motor.Rd1.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis5.motor.Rd1.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis5.motor.Rd1.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis5.motor.Rd1.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis5.motor.Rd1.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 100.0 \"Resistance at temperature T_ref\";
//   parameter Real axis5.motor.Rd1.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis5.motor.Rd1.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis5.motor.Rd1.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis5.motor.Ri.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis5.motor.Ri.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis5.motor.Ri.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.Ri.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis5.motor.Ri.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.Ri.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis5.motor.Ri.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis5.motor.Ri.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis5.motor.Ri.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis5.motor.Ri.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis5.motor.Ri.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis5.motor.Ri.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 10.0 \"Resistance at temperature T_ref\";
//   parameter Real axis5.motor.Ri.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis5.motor.Ri.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis5.motor.Ri.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis5.motor.Rp1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis5.motor.Rp1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis5.motor.Rp1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.Rp1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis5.motor.Rp1.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.Rp1.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis5.motor.Rp1.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis5.motor.Rp1.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis5.motor.Rp1.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis5.motor.Rp1.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis5.motor.Rp1.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis5.motor.Rp1.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 200.0 \"Resistance at temperature T_ref\";
//   parameter Real axis5.motor.Rp1.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis5.motor.Rp1.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis5.motor.Rp1.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis5.motor.Rp2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis5.motor.Rp2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis5.motor.Rp2.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.Rp2.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis5.motor.Rp2.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.Rp2.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis5.motor.Rp2.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis5.motor.Rp2.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis5.motor.Rp2.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis5.motor.Rp2.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis5.motor.Rp2.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis5.motor.Rp2.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 50.0 \"Resistance at temperature T_ref\";
//   parameter Real axis5.motor.Rp2.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis5.motor.Rp2.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis5.motor.Rp2.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis5.motor.Rd4.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis5.motor.Rd4.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis5.motor.Rd4.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.Rd4.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis5.motor.Rd4.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.Rd4.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis5.motor.Rd4.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis5.motor.Rd4.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis5.motor.Rd4.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis5.motor.Rd4.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis5.motor.Rd4.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis5.motor.Rd4.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 100.0 \"Resistance at temperature T_ref\";
//   parameter Real axis5.motor.Rd4.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis5.motor.Rd4.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis5.motor.Rd4.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis5.motor.hall2.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.hall2.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis5.motor.hall2.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.hall2.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   input Real axis5.motor.hall2.v \"Voltage between pin p and n (= p.v - n.v) as input signal\";
//   Real axis5.motor.hall2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis5.motor.Rd3.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis5.motor.Rd3.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis5.motor.Rd3.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.Rd3.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis5.motor.Rd3.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.Rd3.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis5.motor.Rd3.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis5.motor.Rd3.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis5.motor.Rd3.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis5.motor.Rd3.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis5.motor.Rd3.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis5.motor.Rd3.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 100.0 \"Resistance at temperature T_ref\";
//   parameter Real axis5.motor.Rd3.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis5.motor.Rd3.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis5.motor.Rd3.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis5.motor.g1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.g1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis5.motor.g2.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.g2.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis5.motor.g3.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.g3.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis5.motor.hall1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.hall1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis5.motor.hall1.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.hall1.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   output Real axis5.motor.hall1.i \"current in the branch from p to n as output signal\";
//   Real axis5.motor.g4.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.g4.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis5.motor.g5.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis5.motor.g5.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis5.motor.phi.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis5.motor.phi.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real axis5.motor.phi.phi \"Absolute angle of flange\";
//   Real axis5.motor.speed.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis5.motor.speed.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real axis5.motor.speed.w \"Absolute angular velocity of flange\";
//   Real axis5.motor.Jmotor.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis5.motor.Jmotor.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis5.motor.Jmotor.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis5.motor.Jmotor.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real axis5.motor.Jmotor.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = axis5.motor.J \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) axis5.motor.Jmotor.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real axis5.motor.Jmotor.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real axis5.motor.Jmotor.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
//   Real axis5.motor.Jmotor.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   parameter Real axis5.motor.convert1.k(start = 1.0) = 1.0 \"Gain value multiplied with input signal\";
//   input Real axis5.motor.convert1.u \"Input signal connector\";
//   output Real axis5.motor.convert1.y \"Output signal connector\";
//   parameter Real axis5.motor.convert2.k(start = 1.0) = 1.0 \"Gain value multiplied with input signal\";
//   input Real axis5.motor.convert2.u \"Input signal connector\";
//   output Real axis5.motor.convert2.y \"Output signal connector\";
//   Real axis5.motor.axisControlBus.motorAngle \"virtual variable in expandable connector\";
//   Real axis5.motor.axisControlBus.motorSpeed \"virtual variable in expandable connector\";
//   Real axis5.motor.axisControlBus.current \"virtual variable in expandable connector\";
//   Real axis5.motor.axisControlBus.current_ref \"virtual variable in expandable connector\";
//   parameter Real axis5.controller.kp = axis5.kp \"Gain of position controller\";
//   parameter Real axis5.controller.ks = axis5.ks \"Gain of speed controller\";
//   parameter Real axis5.controller.Ts(quantity = \"Time\", unit = \"s\") = axis5.Ts \"Time constant of integrator of speed controller\";
//   parameter Real axis5.controller.ratio = axis5.ratio \"Gear ratio of gearbox\";
//   parameter Real axis5.controller.gain1.k(start = 1.0) = axis5.controller.ratio \"Gain value multiplied with input signal\";
//   input Real axis5.controller.gain1.u \"Input signal connector\";
//   output Real axis5.controller.gain1.y \"Output signal connector\";
//   input Real axis5.controller.PI.u \"Connector of Real input signal\";
//   output Real axis5.controller.PI.y \"Connector of Real output signal\";
//   parameter Real axis5.controller.PI.k = axis5.controller.ks \"Gain\";
//   parameter Real axis5.controller.PI.T(quantity = \"Time\", unit = \"s\", min = 1e-60, start = 1.0) = axis5.controller.Ts \"Time Constant (T>0 required)\";
//   parameter enumeration(NoInit, SteadyState, InitialState, InitialOutput) axis5.controller.PI.initType = Modelica.Blocks.Types.Init.NoInit \"Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)\";
//   parameter Real axis5.controller.PI.x_start = 0.0 \"Initial or guess value of state\";
//   parameter Real axis5.controller.PI.y_start = 0.0 \"Initial value of output\";
//   output Real axis5.controller.PI.x(start = axis5.controller.PI.x_start) \"State of block\";
//   input Real axis5.controller.feedback1.u1;
//   input Real axis5.controller.feedback1.u2;
//   output Real axis5.controller.feedback1.y;
//   parameter Real axis5.controller.P.k(start = 1.0) = axis5.controller.kp \"Gain value multiplied with input signal\";
//   input Real axis5.controller.P.u \"Input signal connector\";
//   output Real axis5.controller.P.y \"Output signal connector\";
//   parameter Real axis5.controller.add3.k1 = 1.0 \"Gain of upper input\";
//   parameter Real axis5.controller.add3.k2 = 1.0 \"Gain of middle input\";
//   parameter Real axis5.controller.add3.k3 = -1.0 \"Gain of lower input\";
//   input Real axis5.controller.add3.u1 \"Connector 1 of Real input signals\";
//   input Real axis5.controller.add3.u2 \"Connector 2 of Real input signals\";
//   input Real axis5.controller.add3.u3 \"Connector 3 of Real input signals\";
//   output Real axis5.controller.add3.y \"Connector of Real output signals\";
//   parameter Real axis5.controller.gain2.k(start = 1.0) = axis5.controller.ratio \"Gain value multiplied with input signal\";
//   input Real axis5.controller.gain2.u \"Input signal connector\";
//   output Real axis5.controller.gain2.y \"Output signal connector\";
//   Real axis5.controller.axisControlBus.speed_ref \"virtual variable in expandable connector\";
//   Real axis5.controller.axisControlBus.angle_ref \"virtual variable in expandable connector\";
//   output Real axis5.controller.axisControlBus.motorAngle \"virtual variable in expandable connector\";
//   output Real axis5.controller.axisControlBus.motorSpeed \"virtual variable in expandable connector\";
//   Real axis5.controller.axisControlBus.current_ref \"virtual variable in expandable connector\";
//   Real axis5.angleSensor.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis5.angleSensor.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real axis5.angleSensor.phi \"Absolute angle of flange\";
//   Real axis5.speedSensor.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis5.speedSensor.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real axis5.speedSensor.w \"Absolute angular velocity of flange\";
//   Real axis5.accSensor.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis5.accSensor.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis5.accSensor.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of flange\";
//   output Real axis5.accSensor.a \"Absolute angular acceleration of flange\";
//   parameter Boolean axis5.initializeFlange.use_phi_start = true \"= true, if initial angle is defined by input phi_start, otherwise not initialized\";
//   parameter Boolean axis5.initializeFlange.use_w_start = true \"= true, if initial speed is defined by input w_start, otherwise not initialized\";
//   parameter Boolean axis5.initializeFlange.use_a_start = true \"= true, if initial angular acceleration is defined by input a_start, otherwise not initialized\";
//   parameter enumeration(never, avoid, default, prefer, always) axis5.initializeFlange.stateSelect = StateSelect.prefer \"Priority to use flange angle and speed as states\";
//   Real axis5.initializeFlange.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis5.initializeFlange.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis5.initializeFlange.phi_flange(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) = axis5.initializeFlange.flange.phi \"Flange angle\";
//   Real axis5.initializeFlange.w_flange(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) = der(axis5.initializeFlange.phi_flange) \"= der(phi_flange)\";
//   Real axis5.initializeFlange.set_flange_tau.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis5.initializeFlange.set_flange_tau.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real axis5.initializeFlange.phi_start \"Initial angle of flange\";
//   input Real axis5.initializeFlange.set_phi_start.phi_start \"Start angle\";
//   Real axis5.initializeFlange.set_phi_start.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis5.initializeFlange.set_phi_start.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real axis5.initializeFlange.w_start \"Initial speed of flange\";
//   input Real axis5.initializeFlange.set_w_start.w_start \"Start angular velocity\";
//   Real axis5.initializeFlange.set_w_start.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis5.initializeFlange.set_w_start.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real axis5.initializeFlange.a_start \"Initial angular acceleration of flange\";
//   input Real axis5.initializeFlange.set_a_start.a_start \"Start angular acceleration\";
//   Real axis5.initializeFlange.set_a_start.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.avoid) \"Absolute rotation angle of flange\";
//   Real axis5.initializeFlange.set_a_start.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis5.initializeFlange.set_a_start.w(quantity = \"AngularVelocity\", unit = \"rad/s\") = der(axis5.initializeFlange.set_a_start.flange.phi);
//   output Real axis5.const.y \"Connector of Real output signal\";
//   parameter Real axis5.const.k(start = 1.0) = 0.0 \"Constant output value\";
//   Real axis5.axisControlBus.angle \"virtual variable in expandable connector\";
//   Real axis5.axisControlBus.speed \"virtual variable in expandable connector\";
//   Real axis5.axisControlBus.acceleration \"virtual variable in expandable connector\";
//   Real axis5.axisControlBus.angle_ref \"virtual variable in expandable connector\";
//   Real axis5.axisControlBus.speed_ref \"virtual variable in expandable connector\";
//   Real axis5.axisControlBus.motorSpeed \"virtual variable in expandable connector\";
//   Real axis5.axisControlBus.current_ref \"virtual variable in expandable connector\";
//   Real axis5.axisControlBus.current \"virtual variable in expandable connector\";
//   Real axis5.axisControlBus.motorAngle \"virtual variable in expandable connector\";
//   Real axis5.motor.axisControlBus.angle \"virtual variable in expandable connector\";
//   Real axis5.motor.axisControlBus.acceleration \"virtual variable in expandable connector\";
//   Real axis5.motor.axisControlBus.speed \"virtual variable in expandable connector\";
//   Real axis5.motor.axisControlBus.angle_ref \"virtual variable in expandable connector\";
//   Real axis5.motor.axisControlBus.speed_ref \"virtual variable in expandable connector\";
//   Real axis5.controller.axisControlBus.angle \"virtual variable in expandable connector\";
//   Real axis5.controller.axisControlBus.acceleration \"virtual variable in expandable connector\";
//   Real axis5.controller.axisControlBus.current \"virtual variable in expandable connector\";
//   Real axis5.controller.axisControlBus.speed \"virtual variable in expandable connector\";
//   parameter Real axis6.kp = kp6 \"Gain of position controller\";
//   parameter Real axis6.ks = ks6 \"Gain of speed controller\";
//   parameter Real axis6.Ts(quantity = \"Time\", unit = \"s\") = Ts6 \"Time constant of integrator of speed controller\";
//   parameter Real axis6.k = 0.0842 \"Gain of motor\";
//   parameter Real axis6.w = 7400.0 \"Time constant of motor\";
//   parameter Real axis6.D = 0.27 \"Damping constant of motor\";
//   parameter Real axis6.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = 4.3e-05 \"Moment of inertia of motor\";
//   parameter Real axis6.ratio = -99.0 \"Gear ratio\";
//   parameter Real axis6.Rv0(quantity = \"Torque\", unit = \"N.m\") = 10.9 \"Viscous friction torque at zero velocity in [Nm]\";
//   parameter Real axis6.Rv1(unit = \"N.m.s/rad\") = 3.92 \"Viscous friction coefficient in [Nms/rad]\";
//   parameter Real axis6.peak = 1.54128440366972 \"Maximum static friction torque is peak*Rv0 (peak >= 1)\";
//   Real axis6.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis6.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis6.gear.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis6.gear.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis6.gear.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis6.gear.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real axis6.gear.i = axis6.ratio \"Gear ratio\";
//   parameter Real axis6.gear.Rv0(quantity = \"Torque\", unit = \"N.m\") = axis6.Rv0 \"Viscous friction torque at zero velocity\";
//   parameter Real axis6.gear.Rv1 = axis6.Rv1 \"Viscous friction coefficient in [Nms/rad] (R=Rv0+Rv1*abs(qd))\";
//   parameter Real axis6.gear.peak = axis6.peak \"Maximum static friction torque is peak*Rv0 (peak >= 1)\";
//   constant Real axis6.gear.unitAngularVelocity(quantity = \"AngularVelocity\", unit = \"rad/s\") = 1.0;
//   constant Real axis6.gear.unitTorque(quantity = \"Torque\", unit = \"N.m\") = 1.0;
//   parameter Boolean axis6.gear.gear.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real axis6.gear.gear.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis6.gear.gear.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis6.gear.gear.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis6.gear.gear.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real axis6.gear.gear.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   parameter Real axis6.gear.gear.ratio(start = 1.0) = axis6.gear.i \"Transmission ratio (flange_a.phi/flange_b.phi)\";
//   Real axis6.gear.gear.phi_a(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle between left shaft flange and support\";
//   Real axis6.gear.gear.phi_b(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle between right shaft flange and support\";
//   parameter Boolean axis6.gear.bearingFriction.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real axis6.gear.bearingFriction.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis6.gear.bearingFriction.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis6.gear.bearingFriction.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis6.gear.bearingFriction.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real axis6.gear.bearingFriction.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   parameter Real axis6.gear.bearingFriction.w_small(quantity = \"AngularVelocity\", unit = \"rad/s\") = 10000000000.0 \"Relative angular velocity near to zero if jumps due to a reinit(..) of the velocity can occur (set to low value only if such impulses can occur)\";
//   Real axis6.gear.bearingFriction.w_relfric(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Relative angular velocity between frictional surfaces\";
//   Real axis6.gear.bearingFriction.a_relfric(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration between frictional surfaces\";
//   Real axis6.gear.bearingFriction.tau0(quantity = \"Torque\", unit = \"N.m\") \"Friction torque for w=0 and forward sliding\";
//   Real axis6.gear.bearingFriction.tau0_max(quantity = \"Torque\", unit = \"N.m\") \"Maximum friction torque for w=0 and locked\";
//   Boolean axis6.gear.bearingFriction.free \"true, if frictional element is not active\";
//   Real axis6.gear.bearingFriction.sa(unit = \"1\") \"Path parameter of friction characteristic tau = f(a_relfric)\";
//   Boolean axis6.gear.bearingFriction.startForward(start = false, fixed = true) \"true, if w_rel=0 and start of forward sliding\";
//   Boolean axis6.gear.bearingFriction.startBackward(start = false, fixed = true) \"true, if w_rel=0 and start of backward sliding\";
//   Boolean axis6.gear.bearingFriction.locked(start = false) \"true, if w_rel=0 and not sliding\";
//   constant Integer axis6.gear.bearingFriction.Unknown = 3 \"Value of mode is not known\";
//   constant Integer axis6.gear.bearingFriction.Free = 2 \"Element is not active\";
//   constant Integer axis6.gear.bearingFriction.Forward = 1 \"w_rel > 0 (forward sliding)\";
//   constant Integer axis6.gear.bearingFriction.Stuck = 0 \"w_rel = 0 (forward sliding, locked or backward sliding)\";
//   constant Integer axis6.gear.bearingFriction.Backward = -1 \"w_rel < 0 (backward sliding)\";
//   Integer axis6.gear.bearingFriction.mode(min = -1, max = 3, start = 3, fixed = true);
//   protected constant Real axis6.gear.bearingFriction.unitAngularAcceleration(quantity = \"AngularAcceleration\", unit = \"rad/s2\") = 1.0;
//   protected constant Real axis6.gear.bearingFriction.unitTorque(quantity = \"Torque\", unit = \"N.m\") = 1.0;
//   parameter Real axis6.gear.bearingFriction.tau_pos[1,1] = 0.0 \"[w,tau] Positive sliding friction characteristic (w>=0)\";
//   parameter Real axis6.gear.bearingFriction.tau_pos[1,2] = axis6.gear.Rv0 \"[w,tau] Positive sliding friction characteristic (w>=0)\";
//   parameter Real axis6.gear.bearingFriction.tau_pos[2,1] = 1.0 \"[w,tau] Positive sliding friction characteristic (w>=0)\";
//   parameter Real axis6.gear.bearingFriction.tau_pos[2,2] = axis6.gear.Rv0 + axis6.gear.Rv1 \"[w,tau] Positive sliding friction characteristic (w>=0)\";
//   parameter Real axis6.gear.bearingFriction.peak(min = 1.0) = axis6.gear.peak \"peak*tau_pos[1,2] = Maximum friction torque for w==0\";
//   Real axis6.gear.bearingFriction.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle between shaft flanges (flange_a, flange_b) and support\";
//   Real axis6.gear.bearingFriction.tau(quantity = \"Torque\", unit = \"N.m\") \"Friction torque\";
//   Real axis6.gear.bearingFriction.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of flange_a and flange_b\";
//   Real axis6.gear.bearingFriction.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of flange_a and flange_b\";
//   parameter Real axis6.motor.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0) = axis6.J \"Moment of inertia of motor\";
//   parameter Real axis6.motor.k = axis6.k \"Gain of motor\";
//   parameter Real axis6.motor.w = axis6.w \"Time constant of motor\";
//   parameter Real axis6.motor.D = axis6.D \"Damping constant of motor\";
//   parameter Real axis6.motor.w_max(quantity = \"AngularVelocity\", unit = \"rad/s\") = 315.0 \"Maximum speed of motor\";
//   parameter Real axis6.motor.i_max(quantity = \"ElectricCurrent\", unit = \"A\") = 9.0 \"Maximum current of motor\";
//   Real axis6.motor.flange_motor.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis6.motor.flange_motor.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis6.motor.Vs.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.Vs.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis6.motor.Vs.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.Vs.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   input Real axis6.motor.Vs.v \"Voltage between pin p and n (= p.v - n.v) as input signal\";
//   Real axis6.motor.Vs.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis6.motor.diff.v1(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the left port\";
//   Real axis6.motor.diff.v2(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the right port\";
//   Real axis6.motor.diff.i1(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the left port\";
//   Real axis6.motor.diff.i2(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the right port\";
//   Real axis6.motor.diff.p1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.diff.p1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis6.motor.diff.n1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.diff.n1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis6.motor.diff.p2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.diff.p2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis6.motor.diff.n2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.diff.n2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis6.motor.power.v1(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the left port\";
//   Real axis6.motor.power.v2(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the right port\";
//   Real axis6.motor.power.i1(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the left port\";
//   Real axis6.motor.power.i2(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the right port\";
//   Real axis6.motor.power.p1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.power.p1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis6.motor.power.n1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.power.n1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis6.motor.power.p2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.power.p2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis6.motor.power.n2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.power.n2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis6.motor.emf.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   parameter Real axis6.motor.emf.k(quantity = \"ElectricalTorqueConstant\", unit = \"N.m/A\", start = 1.0) = axis6.motor.k \"Transformation coefficient\";
//   Real axis6.motor.emf.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins\";
//   Real axis6.motor.emf.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from positive to negative pin\";
//   Real axis6.motor.emf.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle of shaft flange with respect to support (= flange.phi - support.phi)\";
//   Real axis6.motor.emf.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity of flange relative to support\";
//   Real axis6.motor.emf.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.emf.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis6.motor.emf.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.emf.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis6.motor.emf.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis6.motor.emf.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real axis6.motor.emf.internalSupport.tau(quantity = \"Torque\", unit = \"N.m\") = -axis6.motor.emf.flange.tau \"External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau)\";
//   Real axis6.motor.emf.internalSupport.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"External support angle (= flange.phi)\";
//   Real axis6.motor.emf.internalSupport.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis6.motor.emf.internalSupport.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real axis6.motor.emf.fixed.phi0(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Fixed offset angle of housing\";
//   Real axis6.motor.emf.fixed.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis6.motor.emf.fixed.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis6.motor.La.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis6.motor.La.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis6.motor.La.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.La.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis6.motor.La.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.La.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real axis6.motor.La.L(quantity = \"Inductance\", unit = \"H\", start = 1.0) = 250.0 / (axis6.motor.w * axis6.motor.D * 2.0) \"Inductance\";
//   Real axis6.motor.Ra.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis6.motor.Ra.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis6.motor.Ra.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.Ra.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis6.motor.Ra.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.Ra.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis6.motor.Ra.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis6.motor.Ra.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis6.motor.Ra.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis6.motor.Ra.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis6.motor.Ra.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis6.motor.Ra.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 250.0 \"Resistance at temperature T_ref\";
//   parameter Real axis6.motor.Ra.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis6.motor.Ra.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis6.motor.Ra.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis6.motor.Rd2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis6.motor.Rd2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis6.motor.Rd2.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.Rd2.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis6.motor.Rd2.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.Rd2.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis6.motor.Rd2.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis6.motor.Rd2.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis6.motor.Rd2.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis6.motor.Rd2.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis6.motor.Rd2.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis6.motor.Rd2.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 100.0 \"Resistance at temperature T_ref\";
//   parameter Real axis6.motor.Rd2.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis6.motor.Rd2.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis6.motor.Rd2.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis6.motor.C.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis6.motor.C.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis6.motor.C.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.C.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis6.motor.C.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.C.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real axis6.motor.C.C(quantity = \"Capacitance\", unit = \"F\", min = 0.0, start = 1.0) = (0.004 * axis6.motor.D) / axis6.motor.w \"Capacitance\";
//   Real axis6.motor.OpI.v1(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the left port\";
//   Real axis6.motor.OpI.v2(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the right port\";
//   Real axis6.motor.OpI.i1(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the left port\";
//   Real axis6.motor.OpI.i2(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the right port\";
//   Real axis6.motor.OpI.p1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.OpI.p1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis6.motor.OpI.n1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.OpI.n1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis6.motor.OpI.p2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.OpI.p2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis6.motor.OpI.n2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.OpI.n2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis6.motor.Rd1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis6.motor.Rd1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis6.motor.Rd1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.Rd1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis6.motor.Rd1.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.Rd1.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis6.motor.Rd1.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis6.motor.Rd1.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis6.motor.Rd1.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis6.motor.Rd1.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis6.motor.Rd1.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis6.motor.Rd1.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 100.0 \"Resistance at temperature T_ref\";
//   parameter Real axis6.motor.Rd1.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis6.motor.Rd1.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis6.motor.Rd1.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis6.motor.Ri.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis6.motor.Ri.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis6.motor.Ri.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.Ri.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis6.motor.Ri.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.Ri.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis6.motor.Ri.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis6.motor.Ri.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis6.motor.Ri.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis6.motor.Ri.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis6.motor.Ri.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis6.motor.Ri.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 10.0 \"Resistance at temperature T_ref\";
//   parameter Real axis6.motor.Ri.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis6.motor.Ri.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis6.motor.Ri.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis6.motor.Rp1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis6.motor.Rp1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis6.motor.Rp1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.Rp1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis6.motor.Rp1.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.Rp1.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis6.motor.Rp1.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis6.motor.Rp1.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis6.motor.Rp1.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis6.motor.Rp1.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis6.motor.Rp1.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis6.motor.Rp1.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 200.0 \"Resistance at temperature T_ref\";
//   parameter Real axis6.motor.Rp1.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis6.motor.Rp1.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis6.motor.Rp1.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis6.motor.Rp2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis6.motor.Rp2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis6.motor.Rp2.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.Rp2.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis6.motor.Rp2.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.Rp2.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis6.motor.Rp2.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis6.motor.Rp2.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis6.motor.Rp2.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis6.motor.Rp2.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis6.motor.Rp2.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis6.motor.Rp2.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 50.0 \"Resistance at temperature T_ref\";
//   parameter Real axis6.motor.Rp2.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis6.motor.Rp2.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis6.motor.Rp2.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis6.motor.Rd4.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis6.motor.Rd4.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis6.motor.Rd4.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.Rd4.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis6.motor.Rd4.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.Rd4.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis6.motor.Rd4.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis6.motor.Rd4.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis6.motor.Rd4.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis6.motor.Rd4.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis6.motor.Rd4.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis6.motor.Rd4.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 100.0 \"Resistance at temperature T_ref\";
//   parameter Real axis6.motor.Rd4.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis6.motor.Rd4.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis6.motor.Rd4.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis6.motor.hall2.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.hall2.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis6.motor.hall2.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.hall2.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   input Real axis6.motor.hall2.v \"Voltage between pin p and n (= p.v - n.v) as input signal\";
//   Real axis6.motor.hall2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis6.motor.Rd3.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real axis6.motor.Rd3.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real axis6.motor.Rd3.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.Rd3.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis6.motor.Rd3.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.Rd3.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean axis6.motor.Rd3.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real axis6.motor.Rd3.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = axis6.motor.Rd3.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real axis6.motor.Rd3.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real axis6.motor.Rd3.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real axis6.motor.Rd3.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = 100.0 \"Resistance at temperature T_ref\";
//   parameter Real axis6.motor.Rd3.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real axis6.motor.Rd3.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis6.motor.Rd3.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real axis6.motor.g1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.g1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis6.motor.g2.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.g2.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis6.motor.g3.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.g3.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis6.motor.hall1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.hall1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis6.motor.hall1.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.hall1.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   output Real axis6.motor.hall1.i \"current in the branch from p to n as output signal\";
//   Real axis6.motor.g4.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.g4.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis6.motor.g5.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real axis6.motor.g5.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real axis6.motor.phi.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis6.motor.phi.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real axis6.motor.phi.phi \"Absolute angle of flange\";
//   Real axis6.motor.speed.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis6.motor.speed.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real axis6.motor.speed.w \"Absolute angular velocity of flange\";
//   Real axis6.motor.Jmotor.flange_a.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis6.motor.Jmotor.flange_a.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis6.motor.Jmotor.flange_b.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis6.motor.Jmotor.flange_b.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real axis6.motor.Jmotor.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\", min = 0.0, start = 1.0) = axis6.motor.J \"Moment of inertia\";
//   parameter enumeration(never, avoid, default, prefer, always) axis6.motor.Jmotor.stateSelect = StateSelect.default \"Priority to use phi and w as states\";
//   Real axis6.motor.Jmotor.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.default) \"Absolute rotation angle of component\";
//   Real axis6.motor.Jmotor.w(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.default) \"Absolute angular velocity of component (= der(phi))\";
//   Real axis6.motor.Jmotor.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Absolute angular acceleration of component (= der(w))\";
//   parameter Real axis6.motor.convert1.k(start = 1.0) = 1.0 \"Gain value multiplied with input signal\";
//   input Real axis6.motor.convert1.u \"Input signal connector\";
//   output Real axis6.motor.convert1.y \"Output signal connector\";
//   parameter Real axis6.motor.convert2.k(start = 1.0) = 1.0 \"Gain value multiplied with input signal\";
//   input Real axis6.motor.convert2.u \"Input signal connector\";
//   output Real axis6.motor.convert2.y \"Output signal connector\";
//   Real axis6.motor.axisControlBus.motorAngle \"virtual variable in expandable connector\";
//   Real axis6.motor.axisControlBus.motorSpeed \"virtual variable in expandable connector\";
//   Real axis6.motor.axisControlBus.current \"virtual variable in expandable connector\";
//   Real axis6.motor.axisControlBus.current_ref \"virtual variable in expandable connector\";
//   parameter Real axis6.controller.kp = axis6.kp \"Gain of position controller\";
//   parameter Real axis6.controller.ks = axis6.ks \"Gain of speed controller\";
//   parameter Real axis6.controller.Ts(quantity = \"Time\", unit = \"s\") = axis6.Ts \"Time constant of integrator of speed controller\";
//   parameter Real axis6.controller.ratio = axis6.ratio \"Gear ratio of gearbox\";
//   parameter Real axis6.controller.gain1.k(start = 1.0) = axis6.controller.ratio \"Gain value multiplied with input signal\";
//   input Real axis6.controller.gain1.u \"Input signal connector\";
//   output Real axis6.controller.gain1.y \"Output signal connector\";
//   input Real axis6.controller.PI.u \"Connector of Real input signal\";
//   output Real axis6.controller.PI.y \"Connector of Real output signal\";
//   parameter Real axis6.controller.PI.k = axis6.controller.ks \"Gain\";
//   parameter Real axis6.controller.PI.T(quantity = \"Time\", unit = \"s\", min = 1e-60, start = 1.0) = axis6.controller.Ts \"Time Constant (T>0 required)\";
//   parameter enumeration(NoInit, SteadyState, InitialState, InitialOutput) axis6.controller.PI.initType = Modelica.Blocks.Types.Init.NoInit \"Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)\";
//   parameter Real axis6.controller.PI.x_start = 0.0 \"Initial or guess value of state\";
//   parameter Real axis6.controller.PI.y_start = 0.0 \"Initial value of output\";
//   output Real axis6.controller.PI.x(start = axis6.controller.PI.x_start) \"State of block\";
//   input Real axis6.controller.feedback1.u1;
//   input Real axis6.controller.feedback1.u2;
//   output Real axis6.controller.feedback1.y;
//   parameter Real axis6.controller.P.k(start = 1.0) = axis6.controller.kp \"Gain value multiplied with input signal\";
//   input Real axis6.controller.P.u \"Input signal connector\";
//   output Real axis6.controller.P.y \"Output signal connector\";
//   parameter Real axis6.controller.add3.k1 = 1.0 \"Gain of upper input\";
//   parameter Real axis6.controller.add3.k2 = 1.0 \"Gain of middle input\";
//   parameter Real axis6.controller.add3.k3 = -1.0 \"Gain of lower input\";
//   input Real axis6.controller.add3.u1 \"Connector 1 of Real input signals\";
//   input Real axis6.controller.add3.u2 \"Connector 2 of Real input signals\";
//   input Real axis6.controller.add3.u3 \"Connector 3 of Real input signals\";
//   output Real axis6.controller.add3.y \"Connector of Real output signals\";
//   parameter Real axis6.controller.gain2.k(start = 1.0) = axis6.controller.ratio \"Gain value multiplied with input signal\";
//   input Real axis6.controller.gain2.u \"Input signal connector\";
//   output Real axis6.controller.gain2.y \"Output signal connector\";
//   Real axis6.controller.axisControlBus.speed_ref \"virtual variable in expandable connector\";
//   Real axis6.controller.axisControlBus.angle_ref \"virtual variable in expandable connector\";
//   output Real axis6.controller.axisControlBus.motorAngle \"virtual variable in expandable connector\";
//   output Real axis6.controller.axisControlBus.motorSpeed \"virtual variable in expandable connector\";
//   Real axis6.controller.axisControlBus.current_ref \"virtual variable in expandable connector\";
//   Real axis6.angleSensor.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis6.angleSensor.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real axis6.angleSensor.phi \"Absolute angle of flange\";
//   Real axis6.speedSensor.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis6.speedSensor.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   output Real axis6.speedSensor.w \"Absolute angular velocity of flange\";
//   Real axis6.accSensor.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis6.accSensor.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis6.accSensor.w(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Absolute angular velocity of flange\";
//   output Real axis6.accSensor.a \"Absolute angular acceleration of flange\";
//   parameter Boolean axis6.initializeFlange.use_phi_start = true \"= true, if initial angle is defined by input phi_start, otherwise not initialized\";
//   parameter Boolean axis6.initializeFlange.use_w_start = true \"= true, if initial speed is defined by input w_start, otherwise not initialized\";
//   parameter Boolean axis6.initializeFlange.use_a_start = true \"= true, if initial angular acceleration is defined by input a_start, otherwise not initialized\";
//   parameter enumeration(never, avoid, default, prefer, always) axis6.initializeFlange.stateSelect = StateSelect.prefer \"Priority to use flange angle and speed as states\";
//   Real axis6.initializeFlange.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis6.initializeFlange.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis6.initializeFlange.phi_flange(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.prefer) = axis6.initializeFlange.flange.phi \"Flange angle\";
//   Real axis6.initializeFlange.w_flange(quantity = \"AngularVelocity\", unit = \"rad/s\", StateSelect = StateSelect.prefer) = der(axis6.initializeFlange.phi_flange) \"= der(phi_flange)\";
//   Real axis6.initializeFlange.set_flange_tau.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis6.initializeFlange.set_flange_tau.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real axis6.initializeFlange.phi_start \"Initial angle of flange\";
//   input Real axis6.initializeFlange.set_phi_start.phi_start \"Start angle\";
//   Real axis6.initializeFlange.set_phi_start.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis6.initializeFlange.set_phi_start.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real axis6.initializeFlange.w_start \"Initial speed of flange\";
//   input Real axis6.initializeFlange.set_w_start.w_start \"Start angular velocity\";
//   Real axis6.initializeFlange.set_w_start.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real axis6.initializeFlange.set_w_start.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   input Real axis6.initializeFlange.a_start \"Initial angular acceleration of flange\";
//   input Real axis6.initializeFlange.set_a_start.a_start \"Start angular acceleration\";
//   Real axis6.initializeFlange.set_a_start.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", StateSelect = StateSelect.avoid) \"Absolute rotation angle of flange\";
//   Real axis6.initializeFlange.set_a_start.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real axis6.initializeFlange.set_a_start.w(quantity = \"AngularVelocity\", unit = \"rad/s\") = der(axis6.initializeFlange.set_a_start.flange.phi);
//   output Real axis6.const.y \"Connector of Real output signal\";
//   parameter Real axis6.const.k(start = 1.0) = 0.0 \"Constant output value\";
//   Real axis6.axisControlBus.angle \"virtual variable in expandable connector\";
//   Real axis6.axisControlBus.speed \"virtual variable in expandable connector\";
//   Real axis6.axisControlBus.acceleration \"virtual variable in expandable connector\";
//   Real axis6.axisControlBus.angle_ref \"virtual variable in expandable connector\";
//   Real axis6.axisControlBus.speed_ref \"virtual variable in expandable connector\";
//   Real axis6.axisControlBus.motorSpeed \"virtual variable in expandable connector\";
//   Real axis6.axisControlBus.current_ref \"virtual variable in expandable connector\";
//   Real axis6.axisControlBus.current \"virtual variable in expandable connector\";
//   Real axis6.axisControlBus.motorAngle \"virtual variable in expandable connector\";
//   Real axis6.motor.axisControlBus.angle \"virtual variable in expandable connector\";
//   Real axis6.motor.axisControlBus.acceleration \"virtual variable in expandable connector\";
//   Real axis6.motor.axisControlBus.speed \"virtual variable in expandable connector\";
//   Real axis6.motor.axisControlBus.angle_ref \"virtual variable in expandable connector\";
//   Real axis6.motor.axisControlBus.speed_ref \"virtual variable in expandable connector\";
//   Real axis6.controller.axisControlBus.angle \"virtual variable in expandable connector\";
//   Real axis6.controller.axisControlBus.acceleration \"virtual variable in expandable connector\";
//   Real axis6.controller.axisControlBus.current \"virtual variable in expandable connector\";
//   Real axis6.controller.axisControlBus.speed \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus1.angle_ref \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus1.angle \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus1.acceleration \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus1.motorSpeed \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus1.current_ref \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus1.current \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus1.motorAngle \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus1.speed \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus1.speed_ref \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus2.angle_ref \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus2.angle \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus2.acceleration \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus2.motorSpeed \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus2.current_ref \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus2.current \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus2.motorAngle \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus2.speed \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus2.speed_ref \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus3.angle_ref \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus3.angle \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus3.acceleration \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus3.motorSpeed \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus3.current_ref \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus3.current \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus3.motorAngle \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus3.speed \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus3.speed_ref \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus4.angle_ref \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus4.angle \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus4.acceleration \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus4.motorSpeed \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus4.current_ref \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus4.current \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus4.motorAngle \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus4.speed \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus4.speed_ref \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus5.angle_ref \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus5.angle \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus5.acceleration \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus5.motorSpeed \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus5.current_ref \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus5.current \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus5.motorAngle \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus5.speed \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus5.speed_ref \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus6.angle_ref \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus6.angle \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus6.acceleration \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus6.motorSpeed \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus6.current_ref \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus6.current \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus6.motorAngle \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus6.speed \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus6.speed_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus4.speed \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus4.motorAngle \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus4.current \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus4.current_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus4.motorSpeed \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus4.acceleration \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus4.angle \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus4.acceleration_ref \"virtual variable in expandable connector\";
//   Boolean controlBus.axisControlBus4.motion_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus2.speed \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus2.motorAngle \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus2.current \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus2.current_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus2.motorSpeed \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus2.acceleration \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus2.angle \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus2.acceleration_ref \"virtual variable in expandable connector\";
//   Boolean controlBus.axisControlBus2.motion_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus1.speed \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus1.motorAngle \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus1.current \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus1.current_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus1.motorSpeed \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus1.acceleration \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus1.angle \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus1.acceleration_ref \"virtual variable in expandable connector\";
//   Boolean controlBus.axisControlBus1.motion_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus3.speed \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus3.motorAngle \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus3.current \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus3.current_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus3.motorSpeed \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus3.acceleration \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus3.angle \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus3.acceleration_ref \"virtual variable in expandable connector\";
//   Boolean controlBus.axisControlBus3.motion_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus5.speed \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus5.motorAngle \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus5.current \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus5.current_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus5.motorSpeed \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus5.acceleration \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus5.angle \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus5.acceleration_ref \"virtual variable in expandable connector\";
//   Boolean controlBus.axisControlBus5.motion_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus6.speed \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus6.motorAngle \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus6.current \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus6.current_ref \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus6.motorSpeed \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus6.acceleration \"virtual variable in expandable connector\";
//   Real pathPlanning.controlBus.axisControlBus6.angle \"virtual variable in expandable connector\";
//   Real controlBus.axisControlBus6.acceleration_ref \"virtual variable in expandable connector\";
//   Boolean controlBus.axisControlBus6.motion_ref \"virtual variable in expandable connector\";
// initial equation
//   axis1.gear.spring.w_rel = 0.0;
//   axis1.gear.a_rel = 0.0;
//   der(axis1.motor.C.v) = 0.0;
//   der(axis1.motor.La.i) = 0.0;
//   axis1.initializeFlange.set_phi_start.flange.phi = axis1.initializeFlange.set_phi_start.phi_start;
//   der(axis1.initializeFlange.set_w_start.flange.phi) = axis1.initializeFlange.set_w_start.w_start;
//   der(axis1.initializeFlange.set_a_start.w) = axis1.initializeFlange.set_a_start.a_start;
//   axis2.gear.spring.w_rel = 0.0;
//   axis2.gear.a_rel = 0.0;
//   der(axis2.motor.C.v) = 0.0;
//   der(axis2.motor.La.i) = 0.0;
//   axis2.initializeFlange.set_phi_start.flange.phi = axis2.initializeFlange.set_phi_start.phi_start;
//   der(axis2.initializeFlange.set_w_start.flange.phi) = axis2.initializeFlange.set_w_start.w_start;
//   der(axis2.initializeFlange.set_a_start.w) = axis2.initializeFlange.set_a_start.a_start;
//   axis3.gear.spring.w_rel = 0.0;
//   axis3.gear.a_rel = 0.0;
//   der(axis3.motor.C.v) = 0.0;
//   der(axis3.motor.La.i) = 0.0;
//   axis3.initializeFlange.set_phi_start.flange.phi = axis3.initializeFlange.set_phi_start.phi_start;
//   der(axis3.initializeFlange.set_w_start.flange.phi) = axis3.initializeFlange.set_w_start.w_start;
//   der(axis3.initializeFlange.set_a_start.w) = axis3.initializeFlange.set_a_start.a_start;
//   der(axis4.motor.C.v) = 0.0;
//   der(axis4.motor.La.i) = 0.0;
//   axis4.initializeFlange.set_phi_start.flange.phi = axis4.initializeFlange.set_phi_start.phi_start;
//   der(axis4.initializeFlange.set_w_start.flange.phi) = axis4.initializeFlange.set_w_start.w_start;
//   der(axis4.initializeFlange.set_a_start.w) = axis4.initializeFlange.set_a_start.a_start;
//   der(axis5.motor.C.v) = 0.0;
//   der(axis5.motor.La.i) = 0.0;
//   axis5.initializeFlange.set_phi_start.flange.phi = axis5.initializeFlange.set_phi_start.phi_start;
//   der(axis5.initializeFlange.set_w_start.flange.phi) = axis5.initializeFlange.set_w_start.w_start;
//   der(axis5.initializeFlange.set_a_start.w) = axis5.initializeFlange.set_a_start.a_start;
//   der(axis6.motor.C.v) = 0.0;
//   der(axis6.motor.La.i) = 0.0;
//   axis6.initializeFlange.set_phi_start.flange.phi = axis6.initializeFlange.set_phi_start.phi_start;
//   der(axis6.initializeFlange.set_w_start.flange.phi) = axis6.initializeFlange.set_w_start.w_start;
//   der(axis6.initializeFlange.set_a_start.w) = axis6.initializeFlange.set_a_start.a_start;
// equation
//   assert(Modelica.Math.Vectors.length({mechanics.world.n[1],mechanics.world.n[2],mechanics.world.n[3]}) > 1e-10,\"Parameter n of World object is wrong (lenght(n) > 0 required)\");
//   mechanics.world.frame_b.r_0[1] = 0.0;
//   mechanics.world.frame_b.r_0[2] = 0.0;
//   mechanics.world.frame_b.r_0[3] = 0.0;
//   mechanics.world.frame_b.R.w[3] = 0.0;
//   mechanics.world.frame_b.R.w[2] = 0.0;
//   mechanics.world.frame_b.R.w[1] = 0.0;
//   mechanics.world.frame_b.R.T[3,3] = 1.0;
//   mechanics.world.frame_b.R.T[3,2] = 0.0;
//   mechanics.world.frame_b.R.T[3,1] = 0.0;
//   mechanics.world.frame_b.R.T[2,3] = 0.0;
//   mechanics.world.frame_b.R.T[2,2] = 1.0;
//   mechanics.world.frame_b.R.T[2,1] = 0.0;
//   mechanics.world.frame_b.R.T[1,3] = 0.0;
//   mechanics.world.frame_b.R.T[1,2] = 0.0;
//   mechanics.world.frame_b.R.T[1,1] = 1.0;
//   mechanics.r1.fixed.flange.phi = mechanics.r1.fixed.phi0;
//   mechanics.r1.internalAxis.flange.tau = mechanics.r1.internalAxis.tau;
//   mechanics.r1.internalAxis.flange.phi = mechanics.r1.internalAxis.phi;
//   mechanics.r1.cylinder.R.T[1,1] = mechanics.r1.frame_a.R.T[1,1];
//   mechanics.r1.cylinder.R.T[1,2] = mechanics.r1.frame_a.R.T[1,2];
//   mechanics.r1.cylinder.R.T[1,3] = mechanics.r1.frame_a.R.T[1,3];
//   mechanics.r1.cylinder.R.T[2,1] = mechanics.r1.frame_a.R.T[2,1];
//   mechanics.r1.cylinder.R.T[2,2] = mechanics.r1.frame_a.R.T[2,2];
//   mechanics.r1.cylinder.R.T[2,3] = mechanics.r1.frame_a.R.T[2,3];
//   mechanics.r1.cylinder.R.T[3,1] = mechanics.r1.frame_a.R.T[3,1];
//   mechanics.r1.cylinder.R.T[3,2] = mechanics.r1.frame_a.R.T[3,2];
//   mechanics.r1.cylinder.R.T[3,3] = mechanics.r1.frame_a.R.T[3,3];
//   mechanics.r1.cylinder.R.w[1] = mechanics.r1.frame_a.R.w[1];
//   mechanics.r1.cylinder.R.w[2] = mechanics.r1.frame_a.R.w[2];
//   mechanics.r1.cylinder.R.w[3] = mechanics.r1.frame_a.R.w[3];
//   mechanics.r1.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(mechanics.r1.cylinder.shapeType);
//   mechanics.r1.cylinder.rxvisobj[1] = mechanics.r1.cylinder.R.T[1,1] * mechanics.r1.cylinder.e_x[1] + mechanics.r1.cylinder.R.T[2,1] * mechanics.r1.cylinder.e_x[2] + mechanics.r1.cylinder.R.T[3,1] * mechanics.r1.cylinder.e_x[3];
//   mechanics.r1.cylinder.rxvisobj[2] = mechanics.r1.cylinder.R.T[1,2] * mechanics.r1.cylinder.e_x[1] + mechanics.r1.cylinder.R.T[2,2] * mechanics.r1.cylinder.e_x[2] + mechanics.r1.cylinder.R.T[3,2] * mechanics.r1.cylinder.e_x[3];
//   mechanics.r1.cylinder.rxvisobj[3] = mechanics.r1.cylinder.R.T[1,3] * mechanics.r1.cylinder.e_x[1] + mechanics.r1.cylinder.R.T[2,3] * mechanics.r1.cylinder.e_x[2] + mechanics.r1.cylinder.R.T[3,3] * mechanics.r1.cylinder.e_x[3];
//   mechanics.r1.cylinder.ryvisobj[1] = mechanics.r1.cylinder.R.T[1,1] * mechanics.r1.cylinder.e_y[1] + mechanics.r1.cylinder.R.T[2,1] * mechanics.r1.cylinder.e_y[2] + mechanics.r1.cylinder.R.T[3,1] * mechanics.r1.cylinder.e_y[3];
//   mechanics.r1.cylinder.ryvisobj[2] = mechanics.r1.cylinder.R.T[1,2] * mechanics.r1.cylinder.e_y[1] + mechanics.r1.cylinder.R.T[2,2] * mechanics.r1.cylinder.e_y[2] + mechanics.r1.cylinder.R.T[3,2] * mechanics.r1.cylinder.e_y[3];
//   mechanics.r1.cylinder.ryvisobj[3] = mechanics.r1.cylinder.R.T[1,3] * mechanics.r1.cylinder.e_y[1] + mechanics.r1.cylinder.R.T[2,3] * mechanics.r1.cylinder.e_y[2] + mechanics.r1.cylinder.R.T[3,3] * mechanics.r1.cylinder.e_y[3];
//   mechanics.r1.cylinder.rvisobj = mechanics.r1.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{mechanics.r1.cylinder.R.T[1,1],mechanics.r1.cylinder.R.T[1,2],mechanics.r1.cylinder.R.T[1,3]},{mechanics.r1.cylinder.R.T[2,1],mechanics.r1.cylinder.R.T[2,2],mechanics.r1.cylinder.R.T[2,3]},{mechanics.r1.cylinder.R.T[3,1],mechanics.r1.cylinder.R.T[3,2],mechanics.r1.cylinder.R.T[3,3]}},{mechanics.r1.cylinder.r_shape[1],mechanics.r1.cylinder.r_shape[2],mechanics.r1.cylinder.r_shape[3]});
//   mechanics.r1.cylinder.size[1] = mechanics.r1.cylinder.length;
//   mechanics.r1.cylinder.size[2] = mechanics.r1.cylinder.width;
//   mechanics.r1.cylinder.size[3] = mechanics.r1.cylinder.height;
//   mechanics.r1.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(mechanics.r1.cylinder.color[1] / 255.0,mechanics.r1.cylinder.color[2] / 255.0,mechanics.r1.cylinder.color[3] / 255.0,mechanics.r1.cylinder.specularCoefficient);
//   mechanics.r1.cylinder.Extra = mechanics.r1.cylinder.extra;
//   assert(true,\"Connector frame_a of revolute joint is not connected\");
//   assert(true,\"Connector frame_b of revolute joint is not connected\");
//   mechanics.r1.angle = mechanics.r1.phi;
//   mechanics.r1.w = der(mechanics.r1.phi);
//   mechanics.r1.a = der(mechanics.r1.w);
//   mechanics.r1.frame_b.r_0[1] = mechanics.r1.frame_a.r_0[1];
//   mechanics.r1.frame_b.r_0[2] = mechanics.r1.frame_a.r_0[2];
//   mechanics.r1.frame_b.r_0[3] = mechanics.r1.frame_a.r_0[3];
//   mechanics.r1.R_rel = Modelica.Mechanics.MultiBody.Frames.planarRotation({mechanics.r1.e[1],mechanics.r1.e[2],mechanics.r1.e[3]},mechanics.r1.phi,mechanics.r1.w);
//   mechanics.r1.frame_b.R = Modelica.Mechanics.MultiBody.Frames.absoluteRotation(mechanics.r1.frame_a.R,mechanics.r1.R_rel);
//   mechanics.r1.frame_a.f = -Modelica.Mechanics.MultiBody.Frames.resolve1(mechanics.r1.R_rel,{mechanics.r1.frame_b.f[1],mechanics.r1.frame_b.f[2],mechanics.r1.frame_b.f[3]});
//   mechanics.r1.frame_a.t = -Modelica.Mechanics.MultiBody.Frames.resolve1(mechanics.r1.R_rel,{mechanics.r1.frame_b.t[1],mechanics.r1.frame_b.t[2],mechanics.r1.frame_b.t[3]});
//   mechanics.r1.tau = (-mechanics.r1.frame_b.t[1]) * mechanics.r1.e[1] + ((-mechanics.r1.frame_b.t[2]) * mechanics.r1.e[2] + (-mechanics.r1.frame_b.t[3]) * mechanics.r1.e[3]);
//   mechanics.r1.phi = mechanics.r1.internalAxis.phi;
//   mechanics.r2.fixed.flange.phi = mechanics.r2.fixed.phi0;
//   mechanics.r2.internalAxis.flange.tau = mechanics.r2.internalAxis.tau;
//   mechanics.r2.internalAxis.flange.phi = mechanics.r2.internalAxis.phi;
//   mechanics.r2.cylinder.R.T[1,1] = mechanics.r2.frame_a.R.T[1,1];
//   mechanics.r2.cylinder.R.T[1,2] = mechanics.r2.frame_a.R.T[1,2];
//   mechanics.r2.cylinder.R.T[1,3] = mechanics.r2.frame_a.R.T[1,3];
//   mechanics.r2.cylinder.R.T[2,1] = mechanics.r2.frame_a.R.T[2,1];
//   mechanics.r2.cylinder.R.T[2,2] = mechanics.r2.frame_a.R.T[2,2];
//   mechanics.r2.cylinder.R.T[2,3] = mechanics.r2.frame_a.R.T[2,3];
//   mechanics.r2.cylinder.R.T[3,1] = mechanics.r2.frame_a.R.T[3,1];
//   mechanics.r2.cylinder.R.T[3,2] = mechanics.r2.frame_a.R.T[3,2];
//   mechanics.r2.cylinder.R.T[3,3] = mechanics.r2.frame_a.R.T[3,3];
//   mechanics.r2.cylinder.R.w[1] = mechanics.r2.frame_a.R.w[1];
//   mechanics.r2.cylinder.R.w[2] = mechanics.r2.frame_a.R.w[2];
//   mechanics.r2.cylinder.R.w[3] = mechanics.r2.frame_a.R.w[3];
//   mechanics.r2.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(mechanics.r2.cylinder.shapeType);
//   mechanics.r2.cylinder.rxvisobj[1] = mechanics.r2.cylinder.R.T[1,1] * mechanics.r2.cylinder.e_x[1] + mechanics.r2.cylinder.R.T[2,1] * mechanics.r2.cylinder.e_x[2] + mechanics.r2.cylinder.R.T[3,1] * mechanics.r2.cylinder.e_x[3];
//   mechanics.r2.cylinder.rxvisobj[2] = mechanics.r2.cylinder.R.T[1,2] * mechanics.r2.cylinder.e_x[1] + mechanics.r2.cylinder.R.T[2,2] * mechanics.r2.cylinder.e_x[2] + mechanics.r2.cylinder.R.T[3,2] * mechanics.r2.cylinder.e_x[3];
//   mechanics.r2.cylinder.rxvisobj[3] = mechanics.r2.cylinder.R.T[1,3] * mechanics.r2.cylinder.e_x[1] + mechanics.r2.cylinder.R.T[2,3] * mechanics.r2.cylinder.e_x[2] + mechanics.r2.cylinder.R.T[3,3] * mechanics.r2.cylinder.e_x[3];
//   mechanics.r2.cylinder.ryvisobj[1] = mechanics.r2.cylinder.R.T[1,1] * mechanics.r2.cylinder.e_y[1] + mechanics.r2.cylinder.R.T[2,1] * mechanics.r2.cylinder.e_y[2] + mechanics.r2.cylinder.R.T[3,1] * mechanics.r2.cylinder.e_y[3];
//   mechanics.r2.cylinder.ryvisobj[2] = mechanics.r2.cylinder.R.T[1,2] * mechanics.r2.cylinder.e_y[1] + mechanics.r2.cylinder.R.T[2,2] * mechanics.r2.cylinder.e_y[2] + mechanics.r2.cylinder.R.T[3,2] * mechanics.r2.cylinder.e_y[3];
//   mechanics.r2.cylinder.ryvisobj[3] = mechanics.r2.cylinder.R.T[1,3] * mechanics.r2.cylinder.e_y[1] + mechanics.r2.cylinder.R.T[2,3] * mechanics.r2.cylinder.e_y[2] + mechanics.r2.cylinder.R.T[3,3] * mechanics.r2.cylinder.e_y[3];
//   mechanics.r2.cylinder.rvisobj = mechanics.r2.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{mechanics.r2.cylinder.R.T[1,1],mechanics.r2.cylinder.R.T[1,2],mechanics.r2.cylinder.R.T[1,3]},{mechanics.r2.cylinder.R.T[2,1],mechanics.r2.cylinder.R.T[2,2],mechanics.r2.cylinder.R.T[2,3]},{mechanics.r2.cylinder.R.T[3,1],mechanics.r2.cylinder.R.T[3,2],mechanics.r2.cylinder.R.T[3,3]}},{mechanics.r2.cylinder.r_shape[1],mechanics.r2.cylinder.r_shape[2],mechanics.r2.cylinder.r_shape[3]});
//   mechanics.r2.cylinder.size[1] = mechanics.r2.cylinder.length;
//   mechanics.r2.cylinder.size[2] = mechanics.r2.cylinder.width;
//   mechanics.r2.cylinder.size[3] = mechanics.r2.cylinder.height;
//   mechanics.r2.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(mechanics.r2.cylinder.color[1] / 255.0,mechanics.r2.cylinder.color[2] / 255.0,mechanics.r2.cylinder.color[3] / 255.0,mechanics.r2.cylinder.specularCoefficient);
//   mechanics.r2.cylinder.Extra = mechanics.r2.cylinder.extra;
//   assert(true,\"Connector frame_a of revolute joint is not connected\");
//   assert(true,\"Connector frame_b of revolute joint is not connected\");
//   mechanics.r2.angle = mechanics.r2.phi;
//   mechanics.r2.w = der(mechanics.r2.phi);
//   mechanics.r2.a = der(mechanics.r2.w);
//   mechanics.r2.frame_b.r_0[1] = mechanics.r2.frame_a.r_0[1];
//   mechanics.r2.frame_b.r_0[2] = mechanics.r2.frame_a.r_0[2];
//   mechanics.r2.frame_b.r_0[3] = mechanics.r2.frame_a.r_0[3];
//   mechanics.r2.R_rel = Modelica.Mechanics.MultiBody.Frames.planarRotation({mechanics.r2.e[1],mechanics.r2.e[2],mechanics.r2.e[3]},mechanics.r2.phi,mechanics.r2.w);
//   mechanics.r2.frame_b.R = Modelica.Mechanics.MultiBody.Frames.absoluteRotation(mechanics.r2.frame_a.R,mechanics.r2.R_rel);
//   mechanics.r2.frame_a.f = -Modelica.Mechanics.MultiBody.Frames.resolve1(mechanics.r2.R_rel,{mechanics.r2.frame_b.f[1],mechanics.r2.frame_b.f[2],mechanics.r2.frame_b.f[3]});
//   mechanics.r2.frame_a.t = -Modelica.Mechanics.MultiBody.Frames.resolve1(mechanics.r2.R_rel,{mechanics.r2.frame_b.t[1],mechanics.r2.frame_b.t[2],mechanics.r2.frame_b.t[3]});
//   mechanics.r2.tau = (-mechanics.r2.frame_b.t[1]) * mechanics.r2.e[1] + ((-mechanics.r2.frame_b.t[2]) * mechanics.r2.e[2] + (-mechanics.r2.frame_b.t[3]) * mechanics.r2.e[3]);
//   mechanics.r2.phi = mechanics.r2.internalAxis.phi;
//   mechanics.r3.fixed.flange.phi = mechanics.r3.fixed.phi0;
//   mechanics.r3.internalAxis.flange.tau = mechanics.r3.internalAxis.tau;
//   mechanics.r3.internalAxis.flange.phi = mechanics.r3.internalAxis.phi;
//   mechanics.r3.cylinder.R.T[1,1] = mechanics.r3.frame_a.R.T[1,1];
//   mechanics.r3.cylinder.R.T[1,2] = mechanics.r3.frame_a.R.T[1,2];
//   mechanics.r3.cylinder.R.T[1,3] = mechanics.r3.frame_a.R.T[1,3];
//   mechanics.r3.cylinder.R.T[2,1] = mechanics.r3.frame_a.R.T[2,1];
//   mechanics.r3.cylinder.R.T[2,2] = mechanics.r3.frame_a.R.T[2,2];
//   mechanics.r3.cylinder.R.T[2,3] = mechanics.r3.frame_a.R.T[2,3];
//   mechanics.r3.cylinder.R.T[3,1] = mechanics.r3.frame_a.R.T[3,1];
//   mechanics.r3.cylinder.R.T[3,2] = mechanics.r3.frame_a.R.T[3,2];
//   mechanics.r3.cylinder.R.T[3,3] = mechanics.r3.frame_a.R.T[3,3];
//   mechanics.r3.cylinder.R.w[1] = mechanics.r3.frame_a.R.w[1];
//   mechanics.r3.cylinder.R.w[2] = mechanics.r3.frame_a.R.w[2];
//   mechanics.r3.cylinder.R.w[3] = mechanics.r3.frame_a.R.w[3];
//   mechanics.r3.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(mechanics.r3.cylinder.shapeType);
//   mechanics.r3.cylinder.rxvisobj[1] = mechanics.r3.cylinder.R.T[1,1] * mechanics.r3.cylinder.e_x[1] + mechanics.r3.cylinder.R.T[2,1] * mechanics.r3.cylinder.e_x[2] + mechanics.r3.cylinder.R.T[3,1] * mechanics.r3.cylinder.e_x[3];
//   mechanics.r3.cylinder.rxvisobj[2] = mechanics.r3.cylinder.R.T[1,2] * mechanics.r3.cylinder.e_x[1] + mechanics.r3.cylinder.R.T[2,2] * mechanics.r3.cylinder.e_x[2] + mechanics.r3.cylinder.R.T[3,2] * mechanics.r3.cylinder.e_x[3];
//   mechanics.r3.cylinder.rxvisobj[3] = mechanics.r3.cylinder.R.T[1,3] * mechanics.r3.cylinder.e_x[1] + mechanics.r3.cylinder.R.T[2,3] * mechanics.r3.cylinder.e_x[2] + mechanics.r3.cylinder.R.T[3,3] * mechanics.r3.cylinder.e_x[3];
//   mechanics.r3.cylinder.ryvisobj[1] = mechanics.r3.cylinder.R.T[1,1] * mechanics.r3.cylinder.e_y[1] + mechanics.r3.cylinder.R.T[2,1] * mechanics.r3.cylinder.e_y[2] + mechanics.r3.cylinder.R.T[3,1] * mechanics.r3.cylinder.e_y[3];
//   mechanics.r3.cylinder.ryvisobj[2] = mechanics.r3.cylinder.R.T[1,2] * mechanics.r3.cylinder.e_y[1] + mechanics.r3.cylinder.R.T[2,2] * mechanics.r3.cylinder.e_y[2] + mechanics.r3.cylinder.R.T[3,2] * mechanics.r3.cylinder.e_y[3];
//   mechanics.r3.cylinder.ryvisobj[3] = mechanics.r3.cylinder.R.T[1,3] * mechanics.r3.cylinder.e_y[1] + mechanics.r3.cylinder.R.T[2,3] * mechanics.r3.cylinder.e_y[2] + mechanics.r3.cylinder.R.T[3,3] * mechanics.r3.cylinder.e_y[3];
//   mechanics.r3.cylinder.rvisobj = mechanics.r3.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{mechanics.r3.cylinder.R.T[1,1],mechanics.r3.cylinder.R.T[1,2],mechanics.r3.cylinder.R.T[1,3]},{mechanics.r3.cylinder.R.T[2,1],mechanics.r3.cylinder.R.T[2,2],mechanics.r3.cylinder.R.T[2,3]},{mechanics.r3.cylinder.R.T[3,1],mechanics.r3.cylinder.R.T[3,2],mechanics.r3.cylinder.R.T[3,3]}},{mechanics.r3.cylinder.r_shape[1],mechanics.r3.cylinder.r_shape[2],mechanics.r3.cylinder.r_shape[3]});
//   mechanics.r3.cylinder.size[1] = mechanics.r3.cylinder.length;
//   mechanics.r3.cylinder.size[2] = mechanics.r3.cylinder.width;
//   mechanics.r3.cylinder.size[3] = mechanics.r3.cylinder.height;
//   mechanics.r3.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(mechanics.r3.cylinder.color[1] / 255.0,mechanics.r3.cylinder.color[2] / 255.0,mechanics.r3.cylinder.color[3] / 255.0,mechanics.r3.cylinder.specularCoefficient);
//   mechanics.r3.cylinder.Extra = mechanics.r3.cylinder.extra;
//   assert(true,\"Connector frame_a of revolute joint is not connected\");
//   assert(true,\"Connector frame_b of revolute joint is not connected\");
//   mechanics.r3.angle = mechanics.r3.phi;
//   mechanics.r3.w = der(mechanics.r3.phi);
//   mechanics.r3.a = der(mechanics.r3.w);
//   mechanics.r3.frame_b.r_0[1] = mechanics.r3.frame_a.r_0[1];
//   mechanics.r3.frame_b.r_0[2] = mechanics.r3.frame_a.r_0[2];
//   mechanics.r3.frame_b.r_0[3] = mechanics.r3.frame_a.r_0[3];
//   mechanics.r3.R_rel = Modelica.Mechanics.MultiBody.Frames.planarRotation({mechanics.r3.e[1],mechanics.r3.e[2],mechanics.r3.e[3]},mechanics.r3.phi,mechanics.r3.w);
//   mechanics.r3.frame_b.R = Modelica.Mechanics.MultiBody.Frames.absoluteRotation(mechanics.r3.frame_a.R,mechanics.r3.R_rel);
//   mechanics.r3.frame_a.f = -Modelica.Mechanics.MultiBody.Frames.resolve1(mechanics.r3.R_rel,{mechanics.r3.frame_b.f[1],mechanics.r3.frame_b.f[2],mechanics.r3.frame_b.f[3]});
//   mechanics.r3.frame_a.t = -Modelica.Mechanics.MultiBody.Frames.resolve1(mechanics.r3.R_rel,{mechanics.r3.frame_b.t[1],mechanics.r3.frame_b.t[2],mechanics.r3.frame_b.t[3]});
//   mechanics.r3.tau = (-mechanics.r3.frame_b.t[1]) * mechanics.r3.e[1] + ((-mechanics.r3.frame_b.t[2]) * mechanics.r3.e[2] + (-mechanics.r3.frame_b.t[3]) * mechanics.r3.e[3]);
//   mechanics.r3.phi = mechanics.r3.internalAxis.phi;
//   mechanics.r4.fixed.flange.phi = mechanics.r4.fixed.phi0;
//   mechanics.r4.internalAxis.flange.tau = mechanics.r4.internalAxis.tau;
//   mechanics.r4.internalAxis.flange.phi = mechanics.r4.internalAxis.phi;
//   mechanics.r4.cylinder.R.T[1,1] = mechanics.r4.frame_a.R.T[1,1];
//   mechanics.r4.cylinder.R.T[1,2] = mechanics.r4.frame_a.R.T[1,2];
//   mechanics.r4.cylinder.R.T[1,3] = mechanics.r4.frame_a.R.T[1,3];
//   mechanics.r4.cylinder.R.T[2,1] = mechanics.r4.frame_a.R.T[2,1];
//   mechanics.r4.cylinder.R.T[2,2] = mechanics.r4.frame_a.R.T[2,2];
//   mechanics.r4.cylinder.R.T[2,3] = mechanics.r4.frame_a.R.T[2,3];
//   mechanics.r4.cylinder.R.T[3,1] = mechanics.r4.frame_a.R.T[3,1];
//   mechanics.r4.cylinder.R.T[3,2] = mechanics.r4.frame_a.R.T[3,2];
//   mechanics.r4.cylinder.R.T[3,3] = mechanics.r4.frame_a.R.T[3,3];
//   mechanics.r4.cylinder.R.w[1] = mechanics.r4.frame_a.R.w[1];
//   mechanics.r4.cylinder.R.w[2] = mechanics.r4.frame_a.R.w[2];
//   mechanics.r4.cylinder.R.w[3] = mechanics.r4.frame_a.R.w[3];
//   mechanics.r4.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(mechanics.r4.cylinder.shapeType);
//   mechanics.r4.cylinder.rxvisobj[1] = mechanics.r4.cylinder.R.T[1,1] * mechanics.r4.cylinder.e_x[1] + mechanics.r4.cylinder.R.T[2,1] * mechanics.r4.cylinder.e_x[2] + mechanics.r4.cylinder.R.T[3,1] * mechanics.r4.cylinder.e_x[3];
//   mechanics.r4.cylinder.rxvisobj[2] = mechanics.r4.cylinder.R.T[1,2] * mechanics.r4.cylinder.e_x[1] + mechanics.r4.cylinder.R.T[2,2] * mechanics.r4.cylinder.e_x[2] + mechanics.r4.cylinder.R.T[3,2] * mechanics.r4.cylinder.e_x[3];
//   mechanics.r4.cylinder.rxvisobj[3] = mechanics.r4.cylinder.R.T[1,3] * mechanics.r4.cylinder.e_x[1] + mechanics.r4.cylinder.R.T[2,3] * mechanics.r4.cylinder.e_x[2] + mechanics.r4.cylinder.R.T[3,3] * mechanics.r4.cylinder.e_x[3];
//   mechanics.r4.cylinder.ryvisobj[1] = mechanics.r4.cylinder.R.T[1,1] * mechanics.r4.cylinder.e_y[1] + mechanics.r4.cylinder.R.T[2,1] * mechanics.r4.cylinder.e_y[2] + mechanics.r4.cylinder.R.T[3,1] * mechanics.r4.cylinder.e_y[3];
//   mechanics.r4.cylinder.ryvisobj[2] = mechanics.r4.cylinder.R.T[1,2] * mechanics.r4.cylinder.e_y[1] + mechanics.r4.cylinder.R.T[2,2] * mechanics.r4.cylinder.e_y[2] + mechanics.r4.cylinder.R.T[3,2] * mechanics.r4.cylinder.e_y[3];
//   mechanics.r4.cylinder.ryvisobj[3] = mechanics.r4.cylinder.R.T[1,3] * mechanics.r4.cylinder.e_y[1] + mechanics.r4.cylinder.R.T[2,3] * mechanics.r4.cylinder.e_y[2] + mechanics.r4.cylinder.R.T[3,3] * mechanics.r4.cylinder.e_y[3];
//   mechanics.r4.cylinder.rvisobj = mechanics.r4.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{mechanics.r4.cylinder.R.T[1,1],mechanics.r4.cylinder.R.T[1,2],mechanics.r4.cylinder.R.T[1,3]},{mechanics.r4.cylinder.R.T[2,1],mechanics.r4.cylinder.R.T[2,2],mechanics.r4.cylinder.R.T[2,3]},{mechanics.r4.cylinder.R.T[3,1],mechanics.r4.cylinder.R.T[3,2],mechanics.r4.cylinder.R.T[3,3]}},{mechanics.r4.cylinder.r_shape[1],mechanics.r4.cylinder.r_shape[2],mechanics.r4.cylinder.r_shape[3]});
//   mechanics.r4.cylinder.size[1] = mechanics.r4.cylinder.length;
//   mechanics.r4.cylinder.size[2] = mechanics.r4.cylinder.width;
//   mechanics.r4.cylinder.size[3] = mechanics.r4.cylinder.height;
//   mechanics.r4.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(mechanics.r4.cylinder.color[1] / 255.0,mechanics.r4.cylinder.color[2] / 255.0,mechanics.r4.cylinder.color[3] / 255.0,mechanics.r4.cylinder.specularCoefficient);
//   mechanics.r4.cylinder.Extra = mechanics.r4.cylinder.extra;
//   assert(true,\"Connector frame_a of revolute joint is not connected\");
//   assert(true,\"Connector frame_b of revolute joint is not connected\");
//   mechanics.r4.angle = mechanics.r4.phi;
//   mechanics.r4.w = der(mechanics.r4.phi);
//   mechanics.r4.a = der(mechanics.r4.w);
//   mechanics.r4.frame_b.r_0[1] = mechanics.r4.frame_a.r_0[1];
//   mechanics.r4.frame_b.r_0[2] = mechanics.r4.frame_a.r_0[2];
//   mechanics.r4.frame_b.r_0[3] = mechanics.r4.frame_a.r_0[3];
//   mechanics.r4.R_rel = Modelica.Mechanics.MultiBody.Frames.planarRotation({mechanics.r4.e[1],mechanics.r4.e[2],mechanics.r4.e[3]},mechanics.r4.phi,mechanics.r4.w);
//   mechanics.r4.frame_b.R = Modelica.Mechanics.MultiBody.Frames.absoluteRotation(mechanics.r4.frame_a.R,mechanics.r4.R_rel);
//   mechanics.r4.frame_a.f = -Modelica.Mechanics.MultiBody.Frames.resolve1(mechanics.r4.R_rel,{mechanics.r4.frame_b.f[1],mechanics.r4.frame_b.f[2],mechanics.r4.frame_b.f[3]});
//   mechanics.r4.frame_a.t = -Modelica.Mechanics.MultiBody.Frames.resolve1(mechanics.r4.R_rel,{mechanics.r4.frame_b.t[1],mechanics.r4.frame_b.t[2],mechanics.r4.frame_b.t[3]});
//   mechanics.r4.tau = (-mechanics.r4.frame_b.t[1]) * mechanics.r4.e[1] + ((-mechanics.r4.frame_b.t[2]) * mechanics.r4.e[2] + (-mechanics.r4.frame_b.t[3]) * mechanics.r4.e[3]);
//   mechanics.r4.phi = mechanics.r4.internalAxis.phi;
//   mechanics.r5.fixed.flange.phi = mechanics.r5.fixed.phi0;
//   mechanics.r5.internalAxis.flange.tau = mechanics.r5.internalAxis.tau;
//   mechanics.r5.internalAxis.flange.phi = mechanics.r5.internalAxis.phi;
//   mechanics.r5.cylinder.R.T[1,1] = mechanics.r5.frame_a.R.T[1,1];
//   mechanics.r5.cylinder.R.T[1,2] = mechanics.r5.frame_a.R.T[1,2];
//   mechanics.r5.cylinder.R.T[1,3] = mechanics.r5.frame_a.R.T[1,3];
//   mechanics.r5.cylinder.R.T[2,1] = mechanics.r5.frame_a.R.T[2,1];
//   mechanics.r5.cylinder.R.T[2,2] = mechanics.r5.frame_a.R.T[2,2];
//   mechanics.r5.cylinder.R.T[2,3] = mechanics.r5.frame_a.R.T[2,3];
//   mechanics.r5.cylinder.R.T[3,1] = mechanics.r5.frame_a.R.T[3,1];
//   mechanics.r5.cylinder.R.T[3,2] = mechanics.r5.frame_a.R.T[3,2];
//   mechanics.r5.cylinder.R.T[3,3] = mechanics.r5.frame_a.R.T[3,3];
//   mechanics.r5.cylinder.R.w[1] = mechanics.r5.frame_a.R.w[1];
//   mechanics.r5.cylinder.R.w[2] = mechanics.r5.frame_a.R.w[2];
//   mechanics.r5.cylinder.R.w[3] = mechanics.r5.frame_a.R.w[3];
//   mechanics.r5.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(mechanics.r5.cylinder.shapeType);
//   mechanics.r5.cylinder.rxvisobj[1] = mechanics.r5.cylinder.R.T[1,1] * mechanics.r5.cylinder.e_x[1] + mechanics.r5.cylinder.R.T[2,1] * mechanics.r5.cylinder.e_x[2] + mechanics.r5.cylinder.R.T[3,1] * mechanics.r5.cylinder.e_x[3];
//   mechanics.r5.cylinder.rxvisobj[2] = mechanics.r5.cylinder.R.T[1,2] * mechanics.r5.cylinder.e_x[1] + mechanics.r5.cylinder.R.T[2,2] * mechanics.r5.cylinder.e_x[2] + mechanics.r5.cylinder.R.T[3,2] * mechanics.r5.cylinder.e_x[3];
//   mechanics.r5.cylinder.rxvisobj[3] = mechanics.r5.cylinder.R.T[1,3] * mechanics.r5.cylinder.e_x[1] + mechanics.r5.cylinder.R.T[2,3] * mechanics.r5.cylinder.e_x[2] + mechanics.r5.cylinder.R.T[3,3] * mechanics.r5.cylinder.e_x[3];
//   mechanics.r5.cylinder.ryvisobj[1] = mechanics.r5.cylinder.R.T[1,1] * mechanics.r5.cylinder.e_y[1] + mechanics.r5.cylinder.R.T[2,1] * mechanics.r5.cylinder.e_y[2] + mechanics.r5.cylinder.R.T[3,1] * mechanics.r5.cylinder.e_y[3];
//   mechanics.r5.cylinder.ryvisobj[2] = mechanics.r5.cylinder.R.T[1,2] * mechanics.r5.cylinder.e_y[1] + mechanics.r5.cylinder.R.T[2,2] * mechanics.r5.cylinder.e_y[2] + mechanics.r5.cylinder.R.T[3,2] * mechanics.r5.cylinder.e_y[3];
//   mechanics.r5.cylinder.ryvisobj[3] = mechanics.r5.cylinder.R.T[1,3] * mechanics.r5.cylinder.e_y[1] + mechanics.r5.cylinder.R.T[2,3] * mechanics.r5.cylinder.e_y[2] + mechanics.r5.cylinder.R.T[3,3] * mechanics.r5.cylinder.e_y[3];
//   mechanics.r5.cylinder.rvisobj = mechanics.r5.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{mechanics.r5.cylinder.R.T[1,1],mechanics.r5.cylinder.R.T[1,2],mechanics.r5.cylinder.R.T[1,3]},{mechanics.r5.cylinder.R.T[2,1],mechanics.r5.cylinder.R.T[2,2],mechanics.r5.cylinder.R.T[2,3]},{mechanics.r5.cylinder.R.T[3,1],mechanics.r5.cylinder.R.T[3,2],mechanics.r5.cylinder.R.T[3,3]}},{mechanics.r5.cylinder.r_shape[1],mechanics.r5.cylinder.r_shape[2],mechanics.r5.cylinder.r_shape[3]});
//   mechanics.r5.cylinder.size[1] = mechanics.r5.cylinder.length;
//   mechanics.r5.cylinder.size[2] = mechanics.r5.cylinder.width;
//   mechanics.r5.cylinder.size[3] = mechanics.r5.cylinder.height;
//   mechanics.r5.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(mechanics.r5.cylinder.color[1] / 255.0,mechanics.r5.cylinder.color[2] / 255.0,mechanics.r5.cylinder.color[3] / 255.0,mechanics.r5.cylinder.specularCoefficient);
//   mechanics.r5.cylinder.Extra = mechanics.r5.cylinder.extra;
//   assert(true,\"Connector frame_a of revolute joint is not connected\");
//   assert(true,\"Connector frame_b of revolute joint is not connected\");
//   mechanics.r5.angle = mechanics.r5.phi;
//   mechanics.r5.w = der(mechanics.r5.phi);
//   mechanics.r5.a = der(mechanics.r5.w);
//   mechanics.r5.frame_b.r_0[1] = mechanics.r5.frame_a.r_0[1];
//   mechanics.r5.frame_b.r_0[2] = mechanics.r5.frame_a.r_0[2];
//   mechanics.r5.frame_b.r_0[3] = mechanics.r5.frame_a.r_0[3];
//   mechanics.r5.R_rel = Modelica.Mechanics.MultiBody.Frames.planarRotation({mechanics.r5.e[1],mechanics.r5.e[2],mechanics.r5.e[3]},mechanics.r5.phi,mechanics.r5.w);
//   mechanics.r5.frame_b.R = Modelica.Mechanics.MultiBody.Frames.absoluteRotation(mechanics.r5.frame_a.R,mechanics.r5.R_rel);
//   mechanics.r5.frame_a.f = -Modelica.Mechanics.MultiBody.Frames.resolve1(mechanics.r5.R_rel,{mechanics.r5.frame_b.f[1],mechanics.r5.frame_b.f[2],mechanics.r5.frame_b.f[3]});
//   mechanics.r5.frame_a.t = -Modelica.Mechanics.MultiBody.Frames.resolve1(mechanics.r5.R_rel,{mechanics.r5.frame_b.t[1],mechanics.r5.frame_b.t[2],mechanics.r5.frame_b.t[3]});
//   mechanics.r5.tau = (-mechanics.r5.frame_b.t[1]) * mechanics.r5.e[1] + ((-mechanics.r5.frame_b.t[2]) * mechanics.r5.e[2] + (-mechanics.r5.frame_b.t[3]) * mechanics.r5.e[3]);
//   mechanics.r5.phi = mechanics.r5.internalAxis.phi;
//   mechanics.r6.fixed.flange.phi = mechanics.r6.fixed.phi0;
//   mechanics.r6.internalAxis.flange.tau = mechanics.r6.internalAxis.tau;
//   mechanics.r6.internalAxis.flange.phi = mechanics.r6.internalAxis.phi;
//   mechanics.r6.cylinder.R.T[1,1] = mechanics.r6.frame_a.R.T[1,1];
//   mechanics.r6.cylinder.R.T[1,2] = mechanics.r6.frame_a.R.T[1,2];
//   mechanics.r6.cylinder.R.T[1,3] = mechanics.r6.frame_a.R.T[1,3];
//   mechanics.r6.cylinder.R.T[2,1] = mechanics.r6.frame_a.R.T[2,1];
//   mechanics.r6.cylinder.R.T[2,2] = mechanics.r6.frame_a.R.T[2,2];
//   mechanics.r6.cylinder.R.T[2,3] = mechanics.r6.frame_a.R.T[2,3];
//   mechanics.r6.cylinder.R.T[3,1] = mechanics.r6.frame_a.R.T[3,1];
//   mechanics.r6.cylinder.R.T[3,2] = mechanics.r6.frame_a.R.T[3,2];
//   mechanics.r6.cylinder.R.T[3,3] = mechanics.r6.frame_a.R.T[3,3];
//   mechanics.r6.cylinder.R.w[1] = mechanics.r6.frame_a.R.w[1];
//   mechanics.r6.cylinder.R.w[2] = mechanics.r6.frame_a.R.w[2];
//   mechanics.r6.cylinder.R.w[3] = mechanics.r6.frame_a.R.w[3];
//   mechanics.r6.cylinder.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(mechanics.r6.cylinder.shapeType);
//   mechanics.r6.cylinder.rxvisobj[1] = mechanics.r6.cylinder.R.T[1,1] * mechanics.r6.cylinder.e_x[1] + mechanics.r6.cylinder.R.T[2,1] * mechanics.r6.cylinder.e_x[2] + mechanics.r6.cylinder.R.T[3,1] * mechanics.r6.cylinder.e_x[3];
//   mechanics.r6.cylinder.rxvisobj[2] = mechanics.r6.cylinder.R.T[1,2] * mechanics.r6.cylinder.e_x[1] + mechanics.r6.cylinder.R.T[2,2] * mechanics.r6.cylinder.e_x[2] + mechanics.r6.cylinder.R.T[3,2] * mechanics.r6.cylinder.e_x[3];
//   mechanics.r6.cylinder.rxvisobj[3] = mechanics.r6.cylinder.R.T[1,3] * mechanics.r6.cylinder.e_x[1] + mechanics.r6.cylinder.R.T[2,3] * mechanics.r6.cylinder.e_x[2] + mechanics.r6.cylinder.R.T[3,3] * mechanics.r6.cylinder.e_x[3];
//   mechanics.r6.cylinder.ryvisobj[1] = mechanics.r6.cylinder.R.T[1,1] * mechanics.r6.cylinder.e_y[1] + mechanics.r6.cylinder.R.T[2,1] * mechanics.r6.cylinder.e_y[2] + mechanics.r6.cylinder.R.T[3,1] * mechanics.r6.cylinder.e_y[3];
//   mechanics.r6.cylinder.ryvisobj[2] = mechanics.r6.cylinder.R.T[1,2] * mechanics.r6.cylinder.e_y[1] + mechanics.r6.cylinder.R.T[2,2] * mechanics.r6.cylinder.e_y[2] + mechanics.r6.cylinder.R.T[3,2] * mechanics.r6.cylinder.e_y[3];
//   mechanics.r6.cylinder.ryvisobj[3] = mechanics.r6.cylinder.R.T[1,3] * mechanics.r6.cylinder.e_y[1] + mechanics.r6.cylinder.R.T[2,3] * mechanics.r6.cylinder.e_y[2] + mechanics.r6.cylinder.R.T[3,3] * mechanics.r6.cylinder.e_y[3];
//   mechanics.r6.cylinder.rvisobj = mechanics.r6.cylinder.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{mechanics.r6.cylinder.R.T[1,1],mechanics.r6.cylinder.R.T[1,2],mechanics.r6.cylinder.R.T[1,3]},{mechanics.r6.cylinder.R.T[2,1],mechanics.r6.cylinder.R.T[2,2],mechanics.r6.cylinder.R.T[2,3]},{mechanics.r6.cylinder.R.T[3,1],mechanics.r6.cylinder.R.T[3,2],mechanics.r6.cylinder.R.T[3,3]}},{mechanics.r6.cylinder.r_shape[1],mechanics.r6.cylinder.r_shape[2],mechanics.r6.cylinder.r_shape[3]});
//   mechanics.r6.cylinder.size[1] = mechanics.r6.cylinder.length;
//   mechanics.r6.cylinder.size[2] = mechanics.r6.cylinder.width;
//   mechanics.r6.cylinder.size[3] = mechanics.r6.cylinder.height;
//   mechanics.r6.cylinder.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(mechanics.r6.cylinder.color[1] / 255.0,mechanics.r6.cylinder.color[2] / 255.0,mechanics.r6.cylinder.color[3] / 255.0,mechanics.r6.cylinder.specularCoefficient);
//   mechanics.r6.cylinder.Extra = mechanics.r6.cylinder.extra;
//   assert(true,\"Connector frame_a of revolute joint is not connected\");
//   assert(true,\"Connector frame_b of revolute joint is not connected\");
//   mechanics.r6.angle = mechanics.r6.phi;
//   mechanics.r6.w = der(mechanics.r6.phi);
//   mechanics.r6.a = der(mechanics.r6.w);
//   mechanics.r6.frame_b.r_0[1] = mechanics.r6.frame_a.r_0[1];
//   mechanics.r6.frame_b.r_0[2] = mechanics.r6.frame_a.r_0[2];
//   mechanics.r6.frame_b.r_0[3] = mechanics.r6.frame_a.r_0[3];
//   mechanics.r6.R_rel = Modelica.Mechanics.MultiBody.Frames.planarRotation({mechanics.r6.e[1],mechanics.r6.e[2],mechanics.r6.e[3]},mechanics.r6.phi,mechanics.r6.w);
//   mechanics.r6.frame_b.R = Modelica.Mechanics.MultiBody.Frames.absoluteRotation(mechanics.r6.frame_a.R,mechanics.r6.R_rel);
//   mechanics.r6.frame_a.f = -Modelica.Mechanics.MultiBody.Frames.resolve1(mechanics.r6.R_rel,{mechanics.r6.frame_b.f[1],mechanics.r6.frame_b.f[2],mechanics.r6.frame_b.f[3]});
//   mechanics.r6.frame_a.t = -Modelica.Mechanics.MultiBody.Frames.resolve1(mechanics.r6.R_rel,{mechanics.r6.frame_b.t[1],mechanics.r6.frame_b.t[2],mechanics.r6.frame_b.t[3]});
//   mechanics.r6.tau = (-mechanics.r6.frame_b.t[1]) * mechanics.r6.e[1] + ((-mechanics.r6.frame_b.t[2]) * mechanics.r6.e[2] + (-mechanics.r6.frame_b.t[3]) * mechanics.r6.e[3]);
//   mechanics.r6.phi = mechanics.r6.internalAxis.phi;
//   assert(true,\"Neither connector frame_a nor frame_b of FixedTranslation object is connected\");
//   mechanics.b0.frameTranslation.frame_b.r_0 = mechanics.b0.frameTranslation.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(mechanics.b0.frameTranslation.frame_a.R,{mechanics.b0.frameTranslation.r[1],mechanics.b0.frameTranslation.r[2],mechanics.b0.frameTranslation.r[3]});
//   mechanics.b0.frameTranslation.frame_b.R.T[1,1] = mechanics.b0.frameTranslation.frame_a.R.T[1,1];
//   mechanics.b0.frameTranslation.frame_b.R.T[1,2] = mechanics.b0.frameTranslation.frame_a.R.T[1,2];
//   mechanics.b0.frameTranslation.frame_b.R.T[1,3] = mechanics.b0.frameTranslation.frame_a.R.T[1,3];
//   mechanics.b0.frameTranslation.frame_b.R.T[2,1] = mechanics.b0.frameTranslation.frame_a.R.T[2,1];
//   mechanics.b0.frameTranslation.frame_b.R.T[2,2] = mechanics.b0.frameTranslation.frame_a.R.T[2,2];
//   mechanics.b0.frameTranslation.frame_b.R.T[2,3] = mechanics.b0.frameTranslation.frame_a.R.T[2,3];
//   mechanics.b0.frameTranslation.frame_b.R.T[3,1] = mechanics.b0.frameTranslation.frame_a.R.T[3,1];
//   mechanics.b0.frameTranslation.frame_b.R.T[3,2] = mechanics.b0.frameTranslation.frame_a.R.T[3,2];
//   mechanics.b0.frameTranslation.frame_b.R.T[3,3] = mechanics.b0.frameTranslation.frame_a.R.T[3,3];
//   mechanics.b0.frameTranslation.frame_b.R.w[1] = mechanics.b0.frameTranslation.frame_a.R.w[1];
//   mechanics.b0.frameTranslation.frame_b.R.w[2] = mechanics.b0.frameTranslation.frame_a.R.w[2];
//   mechanics.b0.frameTranslation.frame_b.R.w[3] = mechanics.b0.frameTranslation.frame_a.R.w[3];
//   0.0 = mechanics.b0.frameTranslation.frame_a.f[1] + mechanics.b0.frameTranslation.frame_b.f[1];
//   0.0 = mechanics.b0.frameTranslation.frame_a.f[2] + mechanics.b0.frameTranslation.frame_b.f[2];
//   0.0 = mechanics.b0.frameTranslation.frame_a.f[3] + mechanics.b0.frameTranslation.frame_b.f[3];
//   0.0 = mechanics.b0.frameTranslation.frame_a.t[1] + mechanics.b0.frameTranslation.frame_b.t[1] + (mechanics.b0.frameTranslation.r[2] * mechanics.b0.frameTranslation.frame_b.f[3] - mechanics.b0.frameTranslation.r[3] * mechanics.b0.frameTranslation.frame_b.f[2]);
//   0.0 = mechanics.b0.frameTranslation.frame_a.t[2] + mechanics.b0.frameTranslation.frame_b.t[2] + (mechanics.b0.frameTranslation.r[3] * mechanics.b0.frameTranslation.frame_b.f[1] - mechanics.b0.frameTranslation.r[1] * mechanics.b0.frameTranslation.frame_b.f[3]);
//   0.0 = mechanics.b0.frameTranslation.frame_a.t[3] + mechanics.b0.frameTranslation.frame_b.t[3] + (mechanics.b0.frameTranslation.r[1] * mechanics.b0.frameTranslation.frame_b.f[2] - mechanics.b0.frameTranslation.r[2] * mechanics.b0.frameTranslation.frame_b.f[1]);
//   mechanics.b0.body.r_0[1] = mechanics.b0.body.frame_a.r_0[1];
//   mechanics.b0.body.r_0[2] = mechanics.b0.body.frame_a.r_0[2];
//   mechanics.b0.body.r_0[3] = mechanics.b0.body.frame_a.r_0[3];
//   if true then
//   mechanics.b0.body.Q[1] = 0.0;
//   mechanics.b0.body.Q[2] = 0.0;
//   mechanics.b0.body.Q[3] = 0.0;
//   mechanics.b0.body.Q[4] = 1.0;
//   mechanics.b0.body.phi[1] = 0.0;
//   mechanics.b0.body.phi[2] = 0.0;
//   mechanics.b0.body.phi[3] = 0.0;
//   mechanics.b0.body.phi_d[1] = 0.0;
//   mechanics.b0.body.phi_d[2] = 0.0;
//   mechanics.b0.body.phi_d[3] = 0.0;
//   mechanics.b0.body.phi_dd[1] = 0.0;
//   mechanics.b0.body.phi_dd[2] = 0.0;
//   mechanics.b0.body.phi_dd[3] = 0.0;
//   elseif mechanics.b0.body.useQuaternions then
//   mechanics.b0.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.from_Q({mechanics.b0.body.Q[1],mechanics.b0.body.Q[2],mechanics.b0.body.Q[3],mechanics.b0.body.Q[4]},Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2({mechanics.b0.body.Q[1],mechanics.b0.body.Q[2],mechanics.b0.body.Q[3],mechanics.b0.body.Q[4]},{der(mechanics.b0.body.Q[1]),der(mechanics.b0.body.Q[2]),der(mechanics.b0.body.Q[3]),der(mechanics.b0.body.Q[4])}));
//   {0.0} = Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint({mechanics.b0.body.Q[1],mechanics.b0.body.Q[2],mechanics.b0.body.Q[3],mechanics.b0.body.Q[4]});
//   mechanics.b0.body.phi[1] = 0.0;
//   mechanics.b0.body.phi[2] = 0.0;
//   mechanics.b0.body.phi[3] = 0.0;
//   mechanics.b0.body.phi_d[1] = 0.0;
//   mechanics.b0.body.phi_d[2] = 0.0;
//   mechanics.b0.body.phi_d[3] = 0.0;
//   mechanics.b0.body.phi_dd[1] = 0.0;
//   mechanics.b0.body.phi_dd[2] = 0.0;
//   mechanics.b0.body.phi_dd[3] = 0.0;
//   else
//   mechanics.b0.body.phi_d[1] = der(mechanics.b0.body.phi[1]);
//   mechanics.b0.body.phi_d[2] = der(mechanics.b0.body.phi[2]);
//   mechanics.b0.body.phi_d[3] = der(mechanics.b0.body.phi[3]);
//   mechanics.b0.body.phi_dd[1] = der(mechanics.b0.body.phi_d[1]);
//   mechanics.b0.body.phi_dd[2] = der(mechanics.b0.body.phi_d[2]);
//   mechanics.b0.body.phi_dd[3] = der(mechanics.b0.body.phi_d[3]);
//   mechanics.b0.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.axesRotations({mechanics.b0.body.sequence_angleStates[1],mechanics.b0.body.sequence_angleStates[2],mechanics.b0.body.sequence_angleStates[3]},{mechanics.b0.body.phi[1],mechanics.b0.body.phi[2],mechanics.b0.body.phi[3]},{mechanics.b0.body.phi_d[1],mechanics.b0.body.phi_d[2],mechanics.b0.body.phi_d[3]});
//   mechanics.b0.body.Q[1] = 0.0;
//   mechanics.b0.body.Q[2] = 0.0;
//   mechanics.b0.body.Q[3] = 0.0;
//   mechanics.b0.body.Q[4] = 1.0;
//   end if;
//   mechanics.b0.body.g_0 = Modelica.Mechanics.MultiBody.Parts.Body.world__gravityAcceleration({mechanics.b0.body.frame_a.r_0[1],mechanics.b0.body.frame_a.r_0[2],mechanics.b0.body.frame_a.r_0[3]} + Modelica.Mechanics.MultiBody.Frames.resolve1(mechanics.b0.body.frame_a.R,{mechanics.b0.body.r_CM[1],mechanics.b0.body.r_CM[2],mechanics.b0.body.r_CM[3]}),mechanics.world.gravityType,mechanics.world.g * Modelica.Math.Vectors.normalize({mechanics.world.n[1],mechanics.world.n[2],mechanics.world.n[3]},1e-13),mechanics.world.mue);
//   mechanics.b0.body.v_0[1] = der(mechanics.b0.body.frame_a.r_0[1]);
//   mechanics.b0.body.v_0[2] = der(mechanics.b0.body.frame_a.r_0[2]);
//   mechanics.b0.body.v_0[3] = der(mechanics.b0.body.frame_a.r_0[3]);
//   mechanics.b0.body.a_0[1] = der(mechanics.b0.body.v_0[1]);
//   mechanics.b0.body.a_0[2] = der(mechanics.b0.body.v_0[2]);
//   mechanics.b0.body.a_0[3] = der(mechanics.b0.body.v_0[3]);
//   mechanics.b0.body.w_a = Modelica.Mechanics.MultiBody.Frames.angularVelocity2(mechanics.b0.body.frame_a.R);
//   mechanics.b0.body.z_a[1] = der(mechanics.b0.body.w_a[1]);
//   mechanics.b0.body.z_a[2] = der(mechanics.b0.body.w_a[2]);
//   mechanics.b0.body.z_a[3] = der(mechanics.b0.body.w_a[3]);
//   mechanics.b0.body.frame_a.f = mechanics.b0.body.m * (Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b0.body.frame_a.R,{mechanics.b0.body.a_0[1] - mechanics.b0.body.g_0[1],mechanics.b0.body.a_0[2] - mechanics.b0.body.g_0[2],mechanics.b0.body.a_0[3] - mechanics.b0.body.g_0[3]}) + {mechanics.b0.body.z_a[2] * mechanics.b0.body.r_CM[3] - mechanics.b0.body.z_a[3] * mechanics.b0.body.r_CM[2],mechanics.b0.body.z_a[3] * mechanics.b0.body.r_CM[1] - mechanics.b0.body.z_a[1] * mechanics.b0.body.r_CM[3],mechanics.b0.body.z_a[1] * mechanics.b0.body.r_CM[2] - mechanics.b0.body.z_a[2] * mechanics.b0.body.r_CM[1]} + {mechanics.b0.body.w_a[2] * (mechanics.b0.body.w_a[1] * mechanics.b0.body.r_CM[2] - mechanics.b0.body.w_a[2] * mechanics.b0.body.r_CM[1]) - mechanics.b0.body.w_a[3] * (mechanics.b0.body.w_a[3] * mechanics.b0.body.r_CM[1] - mechanics.b0.body.w_a[1] * mechanics.b0.body.r_CM[3]),mechanics.b0.body.w_a[3] * (mechanics.b0.body.w_a[2] * mechanics.b0.body.r_CM[3] - mechanics.b0.body.w_a[3] * mechanics.b0.body.r_CM[2]) - mechanics.b0.body.w_a[1] * (mechanics.b0.body.w_a[1] * mechanics.b0.body.r_CM[2] - mechanics.b0.body.w_a[2] * mechanics.b0.body.r_CM[1]),mechanics.b0.body.w_a[1] * (mechanics.b0.body.w_a[3] * mechanics.b0.body.r_CM[1] - mechanics.b0.body.w_a[1] * mechanics.b0.body.r_CM[3]) - mechanics.b0.body.w_a[2] * (mechanics.b0.body.w_a[2] * mechanics.b0.body.r_CM[3] - mechanics.b0.body.w_a[3] * mechanics.b0.body.r_CM[2])});
//   mechanics.b0.body.frame_a.t[1] = mechanics.b0.body.I[1,1] * mechanics.b0.body.z_a[1] + mechanics.b0.body.I[1,2] * mechanics.b0.body.z_a[2] + mechanics.b0.body.I[1,3] * mechanics.b0.body.z_a[3] + (mechanics.b0.body.w_a[2] * (mechanics.b0.body.I[3,1] * mechanics.b0.body.w_a[1] + mechanics.b0.body.I[3,2] * mechanics.b0.body.w_a[2] + mechanics.b0.body.I[3,3] * mechanics.b0.body.w_a[3]) - mechanics.b0.body.w_a[3] * (mechanics.b0.body.I[2,1] * mechanics.b0.body.w_a[1] + mechanics.b0.body.I[2,2] * mechanics.b0.body.w_a[2] + mechanics.b0.body.I[2,3] * mechanics.b0.body.w_a[3])) + (mechanics.b0.body.r_CM[2] * mechanics.b0.body.frame_a.f[3] - mechanics.b0.body.r_CM[3] * mechanics.b0.body.frame_a.f[2]);
//   mechanics.b0.body.frame_a.t[2] = mechanics.b0.body.I[2,1] * mechanics.b0.body.z_a[1] + mechanics.b0.body.I[2,2] * mechanics.b0.body.z_a[2] + mechanics.b0.body.I[2,3] * mechanics.b0.body.z_a[3] + (mechanics.b0.body.w_a[3] * (mechanics.b0.body.I[1,1] * mechanics.b0.body.w_a[1] + mechanics.b0.body.I[1,2] * mechanics.b0.body.w_a[2] + mechanics.b0.body.I[1,3] * mechanics.b0.body.w_a[3]) - mechanics.b0.body.w_a[1] * (mechanics.b0.body.I[3,1] * mechanics.b0.body.w_a[1] + mechanics.b0.body.I[3,2] * mechanics.b0.body.w_a[2] + mechanics.b0.body.I[3,3] * mechanics.b0.body.w_a[3])) + (mechanics.b0.body.r_CM[3] * mechanics.b0.body.frame_a.f[1] - mechanics.b0.body.r_CM[1] * mechanics.b0.body.frame_a.f[3]);
//   mechanics.b0.body.frame_a.t[3] = mechanics.b0.body.I[3,1] * mechanics.b0.body.z_a[1] + mechanics.b0.body.I[3,2] * mechanics.b0.body.z_a[2] + mechanics.b0.body.I[3,3] * mechanics.b0.body.z_a[3] + (mechanics.b0.body.w_a[1] * (mechanics.b0.body.I[2,1] * mechanics.b0.body.w_a[1] + mechanics.b0.body.I[2,2] * mechanics.b0.body.w_a[2] + mechanics.b0.body.I[2,3] * mechanics.b0.body.w_a[3]) - mechanics.b0.body.w_a[2] * (mechanics.b0.body.I[1,1] * mechanics.b0.body.w_a[1] + mechanics.b0.body.I[1,2] * mechanics.b0.body.w_a[2] + mechanics.b0.body.I[1,3] * mechanics.b0.body.w_a[3])) + (mechanics.b0.body.r_CM[1] * mechanics.b0.body.frame_a.f[2] - mechanics.b0.body.r_CM[2] * mechanics.b0.body.frame_a.f[1]);
//   mechanics.b0.shape1.R.T[1,1] = mechanics.b0.frame_a.R.T[1,1];
//   mechanics.b0.shape1.R.T[1,2] = mechanics.b0.frame_a.R.T[1,2];
//   mechanics.b0.shape1.R.T[1,3] = mechanics.b0.frame_a.R.T[1,3];
//   mechanics.b0.shape1.R.T[2,1] = mechanics.b0.frame_a.R.T[2,1];
//   mechanics.b0.shape1.R.T[2,2] = mechanics.b0.frame_a.R.T[2,2];
//   mechanics.b0.shape1.R.T[2,3] = mechanics.b0.frame_a.R.T[2,3];
//   mechanics.b0.shape1.R.T[3,1] = mechanics.b0.frame_a.R.T[3,1];
//   mechanics.b0.shape1.R.T[3,2] = mechanics.b0.frame_a.R.T[3,2];
//   mechanics.b0.shape1.R.T[3,3] = mechanics.b0.frame_a.R.T[3,3];
//   mechanics.b0.shape1.R.w[1] = mechanics.b0.frame_a.R.w[1];
//   mechanics.b0.shape1.R.w[2] = mechanics.b0.frame_a.R.w[2];
//   mechanics.b0.shape1.R.w[3] = mechanics.b0.frame_a.R.w[3];
//   mechanics.b0.shape1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(mechanics.b0.shape1.shapeType);
//   mechanics.b0.shape1.rxvisobj[1] = mechanics.b0.shape1.R.T[1,1] * mechanics.b0.shape1.e_x[1] + mechanics.b0.shape1.R.T[2,1] * mechanics.b0.shape1.e_x[2] + mechanics.b0.shape1.R.T[3,1] * mechanics.b0.shape1.e_x[3];
//   mechanics.b0.shape1.rxvisobj[2] = mechanics.b0.shape1.R.T[1,2] * mechanics.b0.shape1.e_x[1] + mechanics.b0.shape1.R.T[2,2] * mechanics.b0.shape1.e_x[2] + mechanics.b0.shape1.R.T[3,2] * mechanics.b0.shape1.e_x[3];
//   mechanics.b0.shape1.rxvisobj[3] = mechanics.b0.shape1.R.T[1,3] * mechanics.b0.shape1.e_x[1] + mechanics.b0.shape1.R.T[2,3] * mechanics.b0.shape1.e_x[2] + mechanics.b0.shape1.R.T[3,3] * mechanics.b0.shape1.e_x[3];
//   mechanics.b0.shape1.ryvisobj[1] = mechanics.b0.shape1.R.T[1,1] * mechanics.b0.shape1.e_y[1] + mechanics.b0.shape1.R.T[2,1] * mechanics.b0.shape1.e_y[2] + mechanics.b0.shape1.R.T[3,1] * mechanics.b0.shape1.e_y[3];
//   mechanics.b0.shape1.ryvisobj[2] = mechanics.b0.shape1.R.T[1,2] * mechanics.b0.shape1.e_y[1] + mechanics.b0.shape1.R.T[2,2] * mechanics.b0.shape1.e_y[2] + mechanics.b0.shape1.R.T[3,2] * mechanics.b0.shape1.e_y[3];
//   mechanics.b0.shape1.ryvisobj[3] = mechanics.b0.shape1.R.T[1,3] * mechanics.b0.shape1.e_y[1] + mechanics.b0.shape1.R.T[2,3] * mechanics.b0.shape1.e_y[2] + mechanics.b0.shape1.R.T[3,3] * mechanics.b0.shape1.e_y[3];
//   mechanics.b0.shape1.rvisobj = mechanics.b0.shape1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{mechanics.b0.shape1.R.T[1,1],mechanics.b0.shape1.R.T[1,2],mechanics.b0.shape1.R.T[1,3]},{mechanics.b0.shape1.R.T[2,1],mechanics.b0.shape1.R.T[2,2],mechanics.b0.shape1.R.T[2,3]},{mechanics.b0.shape1.R.T[3,1],mechanics.b0.shape1.R.T[3,2],mechanics.b0.shape1.R.T[3,3]}},{mechanics.b0.shape1.r_shape[1],mechanics.b0.shape1.r_shape[2],mechanics.b0.shape1.r_shape[3]});
//   mechanics.b0.shape1.size[1] = mechanics.b0.shape1.length;
//   mechanics.b0.shape1.size[2] = mechanics.b0.shape1.width;
//   mechanics.b0.shape1.size[3] = mechanics.b0.shape1.height;
//   mechanics.b0.shape1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(mechanics.b0.shape1.color[1] / 255.0,mechanics.b0.shape1.color[2] / 255.0,mechanics.b0.shape1.color[3] / 255.0,mechanics.b0.shape1.specularCoefficient);
//   mechanics.b0.shape1.Extra = mechanics.b0.shape1.extra;
//   mechanics.b0.r_0[1] = mechanics.b0.frame_a.r_0[1];
//   mechanics.b0.r_0[2] = mechanics.b0.frame_a.r_0[2];
//   mechanics.b0.r_0[3] = mechanics.b0.frame_a.r_0[3];
//   mechanics.b0.v_0[1] = der(mechanics.b0.r_0[1]);
//   mechanics.b0.v_0[2] = der(mechanics.b0.r_0[2]);
//   mechanics.b0.v_0[3] = der(mechanics.b0.r_0[3]);
//   mechanics.b0.a_0[1] = der(mechanics.b0.v_0[1]);
//   mechanics.b0.a_0[2] = der(mechanics.b0.v_0[2]);
//   mechanics.b0.a_0[3] = der(mechanics.b0.v_0[3]);
//   assert(true,\"Neither connector frame_a nor frame_b of FixedTranslation object is connected\");
//   mechanics.b1.frameTranslation.frame_b.r_0 = mechanics.b1.frameTranslation.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(mechanics.b1.frameTranslation.frame_a.R,{mechanics.b1.frameTranslation.r[1],mechanics.b1.frameTranslation.r[2],mechanics.b1.frameTranslation.r[3]});
//   mechanics.b1.frameTranslation.frame_b.R.T[1,1] = mechanics.b1.frameTranslation.frame_a.R.T[1,1];
//   mechanics.b1.frameTranslation.frame_b.R.T[1,2] = mechanics.b1.frameTranslation.frame_a.R.T[1,2];
//   mechanics.b1.frameTranslation.frame_b.R.T[1,3] = mechanics.b1.frameTranslation.frame_a.R.T[1,3];
//   mechanics.b1.frameTranslation.frame_b.R.T[2,1] = mechanics.b1.frameTranslation.frame_a.R.T[2,1];
//   mechanics.b1.frameTranslation.frame_b.R.T[2,2] = mechanics.b1.frameTranslation.frame_a.R.T[2,2];
//   mechanics.b1.frameTranslation.frame_b.R.T[2,3] = mechanics.b1.frameTranslation.frame_a.R.T[2,3];
//   mechanics.b1.frameTranslation.frame_b.R.T[3,1] = mechanics.b1.frameTranslation.frame_a.R.T[3,1];
//   mechanics.b1.frameTranslation.frame_b.R.T[3,2] = mechanics.b1.frameTranslation.frame_a.R.T[3,2];
//   mechanics.b1.frameTranslation.frame_b.R.T[3,3] = mechanics.b1.frameTranslation.frame_a.R.T[3,3];
//   mechanics.b1.frameTranslation.frame_b.R.w[1] = mechanics.b1.frameTranslation.frame_a.R.w[1];
//   mechanics.b1.frameTranslation.frame_b.R.w[2] = mechanics.b1.frameTranslation.frame_a.R.w[2];
//   mechanics.b1.frameTranslation.frame_b.R.w[3] = mechanics.b1.frameTranslation.frame_a.R.w[3];
//   0.0 = mechanics.b1.frameTranslation.frame_a.f[1] + mechanics.b1.frameTranslation.frame_b.f[1];
//   0.0 = mechanics.b1.frameTranslation.frame_a.f[2] + mechanics.b1.frameTranslation.frame_b.f[2];
//   0.0 = mechanics.b1.frameTranslation.frame_a.f[3] + mechanics.b1.frameTranslation.frame_b.f[3];
//   0.0 = mechanics.b1.frameTranslation.frame_a.t[1] + mechanics.b1.frameTranslation.frame_b.t[1] + (mechanics.b1.frameTranslation.r[2] * mechanics.b1.frameTranslation.frame_b.f[3] - mechanics.b1.frameTranslation.r[3] * mechanics.b1.frameTranslation.frame_b.f[2]);
//   0.0 = mechanics.b1.frameTranslation.frame_a.t[2] + mechanics.b1.frameTranslation.frame_b.t[2] + (mechanics.b1.frameTranslation.r[3] * mechanics.b1.frameTranslation.frame_b.f[1] - mechanics.b1.frameTranslation.r[1] * mechanics.b1.frameTranslation.frame_b.f[3]);
//   0.0 = mechanics.b1.frameTranslation.frame_a.t[3] + mechanics.b1.frameTranslation.frame_b.t[3] + (mechanics.b1.frameTranslation.r[1] * mechanics.b1.frameTranslation.frame_b.f[2] - mechanics.b1.frameTranslation.r[2] * mechanics.b1.frameTranslation.frame_b.f[1]);
//   mechanics.b1.body.r_0[1] = mechanics.b1.body.frame_a.r_0[1];
//   mechanics.b1.body.r_0[2] = mechanics.b1.body.frame_a.r_0[2];
//   mechanics.b1.body.r_0[3] = mechanics.b1.body.frame_a.r_0[3];
//   if true then
//   mechanics.b1.body.Q[1] = 0.0;
//   mechanics.b1.body.Q[2] = 0.0;
//   mechanics.b1.body.Q[3] = 0.0;
//   mechanics.b1.body.Q[4] = 1.0;
//   mechanics.b1.body.phi[1] = 0.0;
//   mechanics.b1.body.phi[2] = 0.0;
//   mechanics.b1.body.phi[3] = 0.0;
//   mechanics.b1.body.phi_d[1] = 0.0;
//   mechanics.b1.body.phi_d[2] = 0.0;
//   mechanics.b1.body.phi_d[3] = 0.0;
//   mechanics.b1.body.phi_dd[1] = 0.0;
//   mechanics.b1.body.phi_dd[2] = 0.0;
//   mechanics.b1.body.phi_dd[3] = 0.0;
//   elseif mechanics.b1.body.useQuaternions then
//   mechanics.b1.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.from_Q({mechanics.b1.body.Q[1],mechanics.b1.body.Q[2],mechanics.b1.body.Q[3],mechanics.b1.body.Q[4]},Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2({mechanics.b1.body.Q[1],mechanics.b1.body.Q[2],mechanics.b1.body.Q[3],mechanics.b1.body.Q[4]},{der(mechanics.b1.body.Q[1]),der(mechanics.b1.body.Q[2]),der(mechanics.b1.body.Q[3]),der(mechanics.b1.body.Q[4])}));
//   {0.0} = Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint({mechanics.b1.body.Q[1],mechanics.b1.body.Q[2],mechanics.b1.body.Q[3],mechanics.b1.body.Q[4]});
//   mechanics.b1.body.phi[1] = 0.0;
//   mechanics.b1.body.phi[2] = 0.0;
//   mechanics.b1.body.phi[3] = 0.0;
//   mechanics.b1.body.phi_d[1] = 0.0;
//   mechanics.b1.body.phi_d[2] = 0.0;
//   mechanics.b1.body.phi_d[3] = 0.0;
//   mechanics.b1.body.phi_dd[1] = 0.0;
//   mechanics.b1.body.phi_dd[2] = 0.0;
//   mechanics.b1.body.phi_dd[3] = 0.0;
//   else
//   mechanics.b1.body.phi_d[1] = der(mechanics.b1.body.phi[1]);
//   mechanics.b1.body.phi_d[2] = der(mechanics.b1.body.phi[2]);
//   mechanics.b1.body.phi_d[3] = der(mechanics.b1.body.phi[3]);
//   mechanics.b1.body.phi_dd[1] = der(mechanics.b1.body.phi_d[1]);
//   mechanics.b1.body.phi_dd[2] = der(mechanics.b1.body.phi_d[2]);
//   mechanics.b1.body.phi_dd[3] = der(mechanics.b1.body.phi_d[3]);
//   mechanics.b1.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.axesRotations({mechanics.b1.body.sequence_angleStates[1],mechanics.b1.body.sequence_angleStates[2],mechanics.b1.body.sequence_angleStates[3]},{mechanics.b1.body.phi[1],mechanics.b1.body.phi[2],mechanics.b1.body.phi[3]},{mechanics.b1.body.phi_d[1],mechanics.b1.body.phi_d[2],mechanics.b1.body.phi_d[3]});
//   mechanics.b1.body.Q[1] = 0.0;
//   mechanics.b1.body.Q[2] = 0.0;
//   mechanics.b1.body.Q[3] = 0.0;
//   mechanics.b1.body.Q[4] = 1.0;
//   end if;
//   mechanics.b1.body.g_0 = Modelica.Mechanics.MultiBody.Parts.Body.world__gravityAcceleration({mechanics.b1.body.frame_a.r_0[1],mechanics.b1.body.frame_a.r_0[2],mechanics.b1.body.frame_a.r_0[3]} + Modelica.Mechanics.MultiBody.Frames.resolve1(mechanics.b1.body.frame_a.R,{mechanics.b1.body.r_CM[1],mechanics.b1.body.r_CM[2],mechanics.b1.body.r_CM[3]}),mechanics.world.gravityType,mechanics.world.g * Modelica.Math.Vectors.normalize({mechanics.world.n[1],mechanics.world.n[2],mechanics.world.n[3]},1e-13),mechanics.world.mue);
//   mechanics.b1.body.v_0[1] = der(mechanics.b1.body.frame_a.r_0[1]);
//   mechanics.b1.body.v_0[2] = der(mechanics.b1.body.frame_a.r_0[2]);
//   mechanics.b1.body.v_0[3] = der(mechanics.b1.body.frame_a.r_0[3]);
//   mechanics.b1.body.a_0[1] = der(mechanics.b1.body.v_0[1]);
//   mechanics.b1.body.a_0[2] = der(mechanics.b1.body.v_0[2]);
//   mechanics.b1.body.a_0[3] = der(mechanics.b1.body.v_0[3]);
//   mechanics.b1.body.w_a = Modelica.Mechanics.MultiBody.Frames.angularVelocity2(mechanics.b1.body.frame_a.R);
//   mechanics.b1.body.z_a[1] = der(mechanics.b1.body.w_a[1]);
//   mechanics.b1.body.z_a[2] = der(mechanics.b1.body.w_a[2]);
//   mechanics.b1.body.z_a[3] = der(mechanics.b1.body.w_a[3]);
//   mechanics.b1.body.frame_a.f = mechanics.b1.body.m * (Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b1.body.frame_a.R,{mechanics.b1.body.a_0[1] - mechanics.b1.body.g_0[1],mechanics.b1.body.a_0[2] - mechanics.b1.body.g_0[2],mechanics.b1.body.a_0[3] - mechanics.b1.body.g_0[3]}) + {mechanics.b1.body.z_a[2] * mechanics.b1.body.r_CM[3] - mechanics.b1.body.z_a[3] * mechanics.b1.body.r_CM[2],mechanics.b1.body.z_a[3] * mechanics.b1.body.r_CM[1] - mechanics.b1.body.z_a[1] * mechanics.b1.body.r_CM[3],mechanics.b1.body.z_a[1] * mechanics.b1.body.r_CM[2] - mechanics.b1.body.z_a[2] * mechanics.b1.body.r_CM[1]} + {mechanics.b1.body.w_a[2] * (mechanics.b1.body.w_a[1] * mechanics.b1.body.r_CM[2] - mechanics.b1.body.w_a[2] * mechanics.b1.body.r_CM[1]) - mechanics.b1.body.w_a[3] * (mechanics.b1.body.w_a[3] * mechanics.b1.body.r_CM[1] - mechanics.b1.body.w_a[1] * mechanics.b1.body.r_CM[3]),mechanics.b1.body.w_a[3] * (mechanics.b1.body.w_a[2] * mechanics.b1.body.r_CM[3] - mechanics.b1.body.w_a[3] * mechanics.b1.body.r_CM[2]) - mechanics.b1.body.w_a[1] * (mechanics.b1.body.w_a[1] * mechanics.b1.body.r_CM[2] - mechanics.b1.body.w_a[2] * mechanics.b1.body.r_CM[1]),mechanics.b1.body.w_a[1] * (mechanics.b1.body.w_a[3] * mechanics.b1.body.r_CM[1] - mechanics.b1.body.w_a[1] * mechanics.b1.body.r_CM[3]) - mechanics.b1.body.w_a[2] * (mechanics.b1.body.w_a[2] * mechanics.b1.body.r_CM[3] - mechanics.b1.body.w_a[3] * mechanics.b1.body.r_CM[2])});
//   mechanics.b1.body.frame_a.t[1] = mechanics.b1.body.I[1,1] * mechanics.b1.body.z_a[1] + mechanics.b1.body.I[1,2] * mechanics.b1.body.z_a[2] + mechanics.b1.body.I[1,3] * mechanics.b1.body.z_a[3] + (mechanics.b1.body.w_a[2] * (mechanics.b1.body.I[3,1] * mechanics.b1.body.w_a[1] + mechanics.b1.body.I[3,2] * mechanics.b1.body.w_a[2] + mechanics.b1.body.I[3,3] * mechanics.b1.body.w_a[3]) - mechanics.b1.body.w_a[3] * (mechanics.b1.body.I[2,1] * mechanics.b1.body.w_a[1] + mechanics.b1.body.I[2,2] * mechanics.b1.body.w_a[2] + mechanics.b1.body.I[2,3] * mechanics.b1.body.w_a[3])) + (mechanics.b1.body.r_CM[2] * mechanics.b1.body.frame_a.f[3] - mechanics.b1.body.r_CM[3] * mechanics.b1.body.frame_a.f[2]);
//   mechanics.b1.body.frame_a.t[2] = mechanics.b1.body.I[2,1] * mechanics.b1.body.z_a[1] + mechanics.b1.body.I[2,2] * mechanics.b1.body.z_a[2] + mechanics.b1.body.I[2,3] * mechanics.b1.body.z_a[3] + (mechanics.b1.body.w_a[3] * (mechanics.b1.body.I[1,1] * mechanics.b1.body.w_a[1] + mechanics.b1.body.I[1,2] * mechanics.b1.body.w_a[2] + mechanics.b1.body.I[1,3] * mechanics.b1.body.w_a[3]) - mechanics.b1.body.w_a[1] * (mechanics.b1.body.I[3,1] * mechanics.b1.body.w_a[1] + mechanics.b1.body.I[3,2] * mechanics.b1.body.w_a[2] + mechanics.b1.body.I[3,3] * mechanics.b1.body.w_a[3])) + (mechanics.b1.body.r_CM[3] * mechanics.b1.body.frame_a.f[1] - mechanics.b1.body.r_CM[1] * mechanics.b1.body.frame_a.f[3]);
//   mechanics.b1.body.frame_a.t[3] = mechanics.b1.body.I[3,1] * mechanics.b1.body.z_a[1] + mechanics.b1.body.I[3,2] * mechanics.b1.body.z_a[2] + mechanics.b1.body.I[3,3] * mechanics.b1.body.z_a[3] + (mechanics.b1.body.w_a[1] * (mechanics.b1.body.I[2,1] * mechanics.b1.body.w_a[1] + mechanics.b1.body.I[2,2] * mechanics.b1.body.w_a[2] + mechanics.b1.body.I[2,3] * mechanics.b1.body.w_a[3]) - mechanics.b1.body.w_a[2] * (mechanics.b1.body.I[1,1] * mechanics.b1.body.w_a[1] + mechanics.b1.body.I[1,2] * mechanics.b1.body.w_a[2] + mechanics.b1.body.I[1,3] * mechanics.b1.body.w_a[3])) + (mechanics.b1.body.r_CM[1] * mechanics.b1.body.frame_a.f[2] - mechanics.b1.body.r_CM[2] * mechanics.b1.body.frame_a.f[1]);
//   mechanics.b1.shape1.R.T[1,1] = mechanics.b1.frame_a.R.T[1,1];
//   mechanics.b1.shape1.R.T[1,2] = mechanics.b1.frame_a.R.T[1,2];
//   mechanics.b1.shape1.R.T[1,3] = mechanics.b1.frame_a.R.T[1,3];
//   mechanics.b1.shape1.R.T[2,1] = mechanics.b1.frame_a.R.T[2,1];
//   mechanics.b1.shape1.R.T[2,2] = mechanics.b1.frame_a.R.T[2,2];
//   mechanics.b1.shape1.R.T[2,3] = mechanics.b1.frame_a.R.T[2,3];
//   mechanics.b1.shape1.R.T[3,1] = mechanics.b1.frame_a.R.T[3,1];
//   mechanics.b1.shape1.R.T[3,2] = mechanics.b1.frame_a.R.T[3,2];
//   mechanics.b1.shape1.R.T[3,3] = mechanics.b1.frame_a.R.T[3,3];
//   mechanics.b1.shape1.R.w[1] = mechanics.b1.frame_a.R.w[1];
//   mechanics.b1.shape1.R.w[2] = mechanics.b1.frame_a.R.w[2];
//   mechanics.b1.shape1.R.w[3] = mechanics.b1.frame_a.R.w[3];
//   mechanics.b1.shape1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(mechanics.b1.shape1.shapeType);
//   mechanics.b1.shape1.rxvisobj[1] = mechanics.b1.shape1.R.T[1,1] * mechanics.b1.shape1.e_x[1] + mechanics.b1.shape1.R.T[2,1] * mechanics.b1.shape1.e_x[2] + mechanics.b1.shape1.R.T[3,1] * mechanics.b1.shape1.e_x[3];
//   mechanics.b1.shape1.rxvisobj[2] = mechanics.b1.shape1.R.T[1,2] * mechanics.b1.shape1.e_x[1] + mechanics.b1.shape1.R.T[2,2] * mechanics.b1.shape1.e_x[2] + mechanics.b1.shape1.R.T[3,2] * mechanics.b1.shape1.e_x[3];
//   mechanics.b1.shape1.rxvisobj[3] = mechanics.b1.shape1.R.T[1,3] * mechanics.b1.shape1.e_x[1] + mechanics.b1.shape1.R.T[2,3] * mechanics.b1.shape1.e_x[2] + mechanics.b1.shape1.R.T[3,3] * mechanics.b1.shape1.e_x[3];
//   mechanics.b1.shape1.ryvisobj[1] = mechanics.b1.shape1.R.T[1,1] * mechanics.b1.shape1.e_y[1] + mechanics.b1.shape1.R.T[2,1] * mechanics.b1.shape1.e_y[2] + mechanics.b1.shape1.R.T[3,1] * mechanics.b1.shape1.e_y[3];
//   mechanics.b1.shape1.ryvisobj[2] = mechanics.b1.shape1.R.T[1,2] * mechanics.b1.shape1.e_y[1] + mechanics.b1.shape1.R.T[2,2] * mechanics.b1.shape1.e_y[2] + mechanics.b1.shape1.R.T[3,2] * mechanics.b1.shape1.e_y[3];
//   mechanics.b1.shape1.ryvisobj[3] = mechanics.b1.shape1.R.T[1,3] * mechanics.b1.shape1.e_y[1] + mechanics.b1.shape1.R.T[2,3] * mechanics.b1.shape1.e_y[2] + mechanics.b1.shape1.R.T[3,3] * mechanics.b1.shape1.e_y[3];
//   mechanics.b1.shape1.rvisobj = mechanics.b1.shape1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{mechanics.b1.shape1.R.T[1,1],mechanics.b1.shape1.R.T[1,2],mechanics.b1.shape1.R.T[1,3]},{mechanics.b1.shape1.R.T[2,1],mechanics.b1.shape1.R.T[2,2],mechanics.b1.shape1.R.T[2,3]},{mechanics.b1.shape1.R.T[3,1],mechanics.b1.shape1.R.T[3,2],mechanics.b1.shape1.R.T[3,3]}},{mechanics.b1.shape1.r_shape[1],mechanics.b1.shape1.r_shape[2],mechanics.b1.shape1.r_shape[3]});
//   mechanics.b1.shape1.size[1] = mechanics.b1.shape1.length;
//   mechanics.b1.shape1.size[2] = mechanics.b1.shape1.width;
//   mechanics.b1.shape1.size[3] = mechanics.b1.shape1.height;
//   mechanics.b1.shape1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(mechanics.b1.shape1.color[1] / 255.0,mechanics.b1.shape1.color[2] / 255.0,mechanics.b1.shape1.color[3] / 255.0,mechanics.b1.shape1.specularCoefficient);
//   mechanics.b1.shape1.Extra = mechanics.b1.shape1.extra;
//   mechanics.b1.r_0[1] = mechanics.b1.frame_a.r_0[1];
//   mechanics.b1.r_0[2] = mechanics.b1.frame_a.r_0[2];
//   mechanics.b1.r_0[3] = mechanics.b1.frame_a.r_0[3];
//   mechanics.b1.v_0[1] = der(mechanics.b1.r_0[1]);
//   mechanics.b1.v_0[2] = der(mechanics.b1.r_0[2]);
//   mechanics.b1.v_0[3] = der(mechanics.b1.r_0[3]);
//   mechanics.b1.a_0[1] = der(mechanics.b1.v_0[1]);
//   mechanics.b1.a_0[2] = der(mechanics.b1.v_0[2]);
//   mechanics.b1.a_0[3] = der(mechanics.b1.v_0[3]);
//   assert(true,\"Neither connector frame_a nor frame_b of FixedTranslation object is connected\");
//   mechanics.b2.frameTranslation.frame_b.r_0 = mechanics.b2.frameTranslation.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(mechanics.b2.frameTranslation.frame_a.R,{mechanics.b2.frameTranslation.r[1],mechanics.b2.frameTranslation.r[2],mechanics.b2.frameTranslation.r[3]});
//   mechanics.b2.frameTranslation.frame_b.R.T[1,1] = mechanics.b2.frameTranslation.frame_a.R.T[1,1];
//   mechanics.b2.frameTranslation.frame_b.R.T[1,2] = mechanics.b2.frameTranslation.frame_a.R.T[1,2];
//   mechanics.b2.frameTranslation.frame_b.R.T[1,3] = mechanics.b2.frameTranslation.frame_a.R.T[1,3];
//   mechanics.b2.frameTranslation.frame_b.R.T[2,1] = mechanics.b2.frameTranslation.frame_a.R.T[2,1];
//   mechanics.b2.frameTranslation.frame_b.R.T[2,2] = mechanics.b2.frameTranslation.frame_a.R.T[2,2];
//   mechanics.b2.frameTranslation.frame_b.R.T[2,3] = mechanics.b2.frameTranslation.frame_a.R.T[2,3];
//   mechanics.b2.frameTranslation.frame_b.R.T[3,1] = mechanics.b2.frameTranslation.frame_a.R.T[3,1];
//   mechanics.b2.frameTranslation.frame_b.R.T[3,2] = mechanics.b2.frameTranslation.frame_a.R.T[3,2];
//   mechanics.b2.frameTranslation.frame_b.R.T[3,3] = mechanics.b2.frameTranslation.frame_a.R.T[3,3];
//   mechanics.b2.frameTranslation.frame_b.R.w[1] = mechanics.b2.frameTranslation.frame_a.R.w[1];
//   mechanics.b2.frameTranslation.frame_b.R.w[2] = mechanics.b2.frameTranslation.frame_a.R.w[2];
//   mechanics.b2.frameTranslation.frame_b.R.w[3] = mechanics.b2.frameTranslation.frame_a.R.w[3];
//   0.0 = mechanics.b2.frameTranslation.frame_a.f[1] + mechanics.b2.frameTranslation.frame_b.f[1];
//   0.0 = mechanics.b2.frameTranslation.frame_a.f[2] + mechanics.b2.frameTranslation.frame_b.f[2];
//   0.0 = mechanics.b2.frameTranslation.frame_a.f[3] + mechanics.b2.frameTranslation.frame_b.f[3];
//   0.0 = mechanics.b2.frameTranslation.frame_a.t[1] + mechanics.b2.frameTranslation.frame_b.t[1] + (mechanics.b2.frameTranslation.r[2] * mechanics.b2.frameTranslation.frame_b.f[3] - mechanics.b2.frameTranslation.r[3] * mechanics.b2.frameTranslation.frame_b.f[2]);
//   0.0 = mechanics.b2.frameTranslation.frame_a.t[2] + mechanics.b2.frameTranslation.frame_b.t[2] + (mechanics.b2.frameTranslation.r[3] * mechanics.b2.frameTranslation.frame_b.f[1] - mechanics.b2.frameTranslation.r[1] * mechanics.b2.frameTranslation.frame_b.f[3]);
//   0.0 = mechanics.b2.frameTranslation.frame_a.t[3] + mechanics.b2.frameTranslation.frame_b.t[3] + (mechanics.b2.frameTranslation.r[1] * mechanics.b2.frameTranslation.frame_b.f[2] - mechanics.b2.frameTranslation.r[2] * mechanics.b2.frameTranslation.frame_b.f[1]);
//   mechanics.b2.body.r_0[1] = mechanics.b2.body.frame_a.r_0[1];
//   mechanics.b2.body.r_0[2] = mechanics.b2.body.frame_a.r_0[2];
//   mechanics.b2.body.r_0[3] = mechanics.b2.body.frame_a.r_0[3];
//   if true then
//   mechanics.b2.body.Q[1] = 0.0;
//   mechanics.b2.body.Q[2] = 0.0;
//   mechanics.b2.body.Q[3] = 0.0;
//   mechanics.b2.body.Q[4] = 1.0;
//   mechanics.b2.body.phi[1] = 0.0;
//   mechanics.b2.body.phi[2] = 0.0;
//   mechanics.b2.body.phi[3] = 0.0;
//   mechanics.b2.body.phi_d[1] = 0.0;
//   mechanics.b2.body.phi_d[2] = 0.0;
//   mechanics.b2.body.phi_d[3] = 0.0;
//   mechanics.b2.body.phi_dd[1] = 0.0;
//   mechanics.b2.body.phi_dd[2] = 0.0;
//   mechanics.b2.body.phi_dd[3] = 0.0;
//   elseif mechanics.b2.body.useQuaternions then
//   mechanics.b2.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.from_Q({mechanics.b2.body.Q[1],mechanics.b2.body.Q[2],mechanics.b2.body.Q[3],mechanics.b2.body.Q[4]},Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2({mechanics.b2.body.Q[1],mechanics.b2.body.Q[2],mechanics.b2.body.Q[3],mechanics.b2.body.Q[4]},{der(mechanics.b2.body.Q[1]),der(mechanics.b2.body.Q[2]),der(mechanics.b2.body.Q[3]),der(mechanics.b2.body.Q[4])}));
//   {0.0} = Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint({mechanics.b2.body.Q[1],mechanics.b2.body.Q[2],mechanics.b2.body.Q[3],mechanics.b2.body.Q[4]});
//   mechanics.b2.body.phi[1] = 0.0;
//   mechanics.b2.body.phi[2] = 0.0;
//   mechanics.b2.body.phi[3] = 0.0;
//   mechanics.b2.body.phi_d[1] = 0.0;
//   mechanics.b2.body.phi_d[2] = 0.0;
//   mechanics.b2.body.phi_d[3] = 0.0;
//   mechanics.b2.body.phi_dd[1] = 0.0;
//   mechanics.b2.body.phi_dd[2] = 0.0;
//   mechanics.b2.body.phi_dd[3] = 0.0;
//   else
//   mechanics.b2.body.phi_d[1] = der(mechanics.b2.body.phi[1]);
//   mechanics.b2.body.phi_d[2] = der(mechanics.b2.body.phi[2]);
//   mechanics.b2.body.phi_d[3] = der(mechanics.b2.body.phi[3]);
//   mechanics.b2.body.phi_dd[1] = der(mechanics.b2.body.phi_d[1]);
//   mechanics.b2.body.phi_dd[2] = der(mechanics.b2.body.phi_d[2]);
//   mechanics.b2.body.phi_dd[3] = der(mechanics.b2.body.phi_d[3]);
//   mechanics.b2.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.axesRotations({mechanics.b2.body.sequence_angleStates[1],mechanics.b2.body.sequence_angleStates[2],mechanics.b2.body.sequence_angleStates[3]},{mechanics.b2.body.phi[1],mechanics.b2.body.phi[2],mechanics.b2.body.phi[3]},{mechanics.b2.body.phi_d[1],mechanics.b2.body.phi_d[2],mechanics.b2.body.phi_d[3]});
//   mechanics.b2.body.Q[1] = 0.0;
//   mechanics.b2.body.Q[2] = 0.0;
//   mechanics.b2.body.Q[3] = 0.0;
//   mechanics.b2.body.Q[4] = 1.0;
//   end if;
//   mechanics.b2.body.g_0 = Modelica.Mechanics.MultiBody.Parts.Body.world__gravityAcceleration({mechanics.b2.body.frame_a.r_0[1],mechanics.b2.body.frame_a.r_0[2],mechanics.b2.body.frame_a.r_0[3]} + Modelica.Mechanics.MultiBody.Frames.resolve1(mechanics.b2.body.frame_a.R,{mechanics.b2.body.r_CM[1],mechanics.b2.body.r_CM[2],mechanics.b2.body.r_CM[3]}),mechanics.world.gravityType,mechanics.world.g * Modelica.Math.Vectors.normalize({mechanics.world.n[1],mechanics.world.n[2],mechanics.world.n[3]},1e-13),mechanics.world.mue);
//   mechanics.b2.body.v_0[1] = der(mechanics.b2.body.frame_a.r_0[1]);
//   mechanics.b2.body.v_0[2] = der(mechanics.b2.body.frame_a.r_0[2]);
//   mechanics.b2.body.v_0[3] = der(mechanics.b2.body.frame_a.r_0[3]);
//   mechanics.b2.body.a_0[1] = der(mechanics.b2.body.v_0[1]);
//   mechanics.b2.body.a_0[2] = der(mechanics.b2.body.v_0[2]);
//   mechanics.b2.body.a_0[3] = der(mechanics.b2.body.v_0[3]);
//   mechanics.b2.body.w_a = Modelica.Mechanics.MultiBody.Frames.angularVelocity2(mechanics.b2.body.frame_a.R);
//   mechanics.b2.body.z_a[1] = der(mechanics.b2.body.w_a[1]);
//   mechanics.b2.body.z_a[2] = der(mechanics.b2.body.w_a[2]);
//   mechanics.b2.body.z_a[3] = der(mechanics.b2.body.w_a[3]);
//   mechanics.b2.body.frame_a.f = mechanics.b2.body.m * (Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b2.body.frame_a.R,{mechanics.b2.body.a_0[1] - mechanics.b2.body.g_0[1],mechanics.b2.body.a_0[2] - mechanics.b2.body.g_0[2],mechanics.b2.body.a_0[3] - mechanics.b2.body.g_0[3]}) + {mechanics.b2.body.z_a[2] * mechanics.b2.body.r_CM[3] - mechanics.b2.body.z_a[3] * mechanics.b2.body.r_CM[2],mechanics.b2.body.z_a[3] * mechanics.b2.body.r_CM[1] - mechanics.b2.body.z_a[1] * mechanics.b2.body.r_CM[3],mechanics.b2.body.z_a[1] * mechanics.b2.body.r_CM[2] - mechanics.b2.body.z_a[2] * mechanics.b2.body.r_CM[1]} + {mechanics.b2.body.w_a[2] * (mechanics.b2.body.w_a[1] * mechanics.b2.body.r_CM[2] - mechanics.b2.body.w_a[2] * mechanics.b2.body.r_CM[1]) - mechanics.b2.body.w_a[3] * (mechanics.b2.body.w_a[3] * mechanics.b2.body.r_CM[1] - mechanics.b2.body.w_a[1] * mechanics.b2.body.r_CM[3]),mechanics.b2.body.w_a[3] * (mechanics.b2.body.w_a[2] * mechanics.b2.body.r_CM[3] - mechanics.b2.body.w_a[3] * mechanics.b2.body.r_CM[2]) - mechanics.b2.body.w_a[1] * (mechanics.b2.body.w_a[1] * mechanics.b2.body.r_CM[2] - mechanics.b2.body.w_a[2] * mechanics.b2.body.r_CM[1]),mechanics.b2.body.w_a[1] * (mechanics.b2.body.w_a[3] * mechanics.b2.body.r_CM[1] - mechanics.b2.body.w_a[1] * mechanics.b2.body.r_CM[3]) - mechanics.b2.body.w_a[2] * (mechanics.b2.body.w_a[2] * mechanics.b2.body.r_CM[3] - mechanics.b2.body.w_a[3] * mechanics.b2.body.r_CM[2])});
//   mechanics.b2.body.frame_a.t[1] = mechanics.b2.body.I[1,1] * mechanics.b2.body.z_a[1] + mechanics.b2.body.I[1,2] * mechanics.b2.body.z_a[2] + mechanics.b2.body.I[1,3] * mechanics.b2.body.z_a[3] + (mechanics.b2.body.w_a[2] * (mechanics.b2.body.I[3,1] * mechanics.b2.body.w_a[1] + mechanics.b2.body.I[3,2] * mechanics.b2.body.w_a[2] + mechanics.b2.body.I[3,3] * mechanics.b2.body.w_a[3]) - mechanics.b2.body.w_a[3] * (mechanics.b2.body.I[2,1] * mechanics.b2.body.w_a[1] + mechanics.b2.body.I[2,2] * mechanics.b2.body.w_a[2] + mechanics.b2.body.I[2,3] * mechanics.b2.body.w_a[3])) + (mechanics.b2.body.r_CM[2] * mechanics.b2.body.frame_a.f[3] - mechanics.b2.body.r_CM[3] * mechanics.b2.body.frame_a.f[2]);
//   mechanics.b2.body.frame_a.t[2] = mechanics.b2.body.I[2,1] * mechanics.b2.body.z_a[1] + mechanics.b2.body.I[2,2] * mechanics.b2.body.z_a[2] + mechanics.b2.body.I[2,3] * mechanics.b2.body.z_a[3] + (mechanics.b2.body.w_a[3] * (mechanics.b2.body.I[1,1] * mechanics.b2.body.w_a[1] + mechanics.b2.body.I[1,2] * mechanics.b2.body.w_a[2] + mechanics.b2.body.I[1,3] * mechanics.b2.body.w_a[3]) - mechanics.b2.body.w_a[1] * (mechanics.b2.body.I[3,1] * mechanics.b2.body.w_a[1] + mechanics.b2.body.I[3,2] * mechanics.b2.body.w_a[2] + mechanics.b2.body.I[3,3] * mechanics.b2.body.w_a[3])) + (mechanics.b2.body.r_CM[3] * mechanics.b2.body.frame_a.f[1] - mechanics.b2.body.r_CM[1] * mechanics.b2.body.frame_a.f[3]);
//   mechanics.b2.body.frame_a.t[3] = mechanics.b2.body.I[3,1] * mechanics.b2.body.z_a[1] + mechanics.b2.body.I[3,2] * mechanics.b2.body.z_a[2] + mechanics.b2.body.I[3,3] * mechanics.b2.body.z_a[3] + (mechanics.b2.body.w_a[1] * (mechanics.b2.body.I[2,1] * mechanics.b2.body.w_a[1] + mechanics.b2.body.I[2,2] * mechanics.b2.body.w_a[2] + mechanics.b2.body.I[2,3] * mechanics.b2.body.w_a[3]) - mechanics.b2.body.w_a[2] * (mechanics.b2.body.I[1,1] * mechanics.b2.body.w_a[1] + mechanics.b2.body.I[1,2] * mechanics.b2.body.w_a[2] + mechanics.b2.body.I[1,3] * mechanics.b2.body.w_a[3])) + (mechanics.b2.body.r_CM[1] * mechanics.b2.body.frame_a.f[2] - mechanics.b2.body.r_CM[2] * mechanics.b2.body.frame_a.f[1]);
//   mechanics.b2.shape1.R.T[1,1] = mechanics.b2.frame_a.R.T[1,1];
//   mechanics.b2.shape1.R.T[1,2] = mechanics.b2.frame_a.R.T[1,2];
//   mechanics.b2.shape1.R.T[1,3] = mechanics.b2.frame_a.R.T[1,3];
//   mechanics.b2.shape1.R.T[2,1] = mechanics.b2.frame_a.R.T[2,1];
//   mechanics.b2.shape1.R.T[2,2] = mechanics.b2.frame_a.R.T[2,2];
//   mechanics.b2.shape1.R.T[2,3] = mechanics.b2.frame_a.R.T[2,3];
//   mechanics.b2.shape1.R.T[3,1] = mechanics.b2.frame_a.R.T[3,1];
//   mechanics.b2.shape1.R.T[3,2] = mechanics.b2.frame_a.R.T[3,2];
//   mechanics.b2.shape1.R.T[3,3] = mechanics.b2.frame_a.R.T[3,3];
//   mechanics.b2.shape1.R.w[1] = mechanics.b2.frame_a.R.w[1];
//   mechanics.b2.shape1.R.w[2] = mechanics.b2.frame_a.R.w[2];
//   mechanics.b2.shape1.R.w[3] = mechanics.b2.frame_a.R.w[3];
//   mechanics.b2.shape1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(mechanics.b2.shape1.shapeType);
//   mechanics.b2.shape1.rxvisobj[1] = mechanics.b2.shape1.R.T[1,1] * mechanics.b2.shape1.e_x[1] + mechanics.b2.shape1.R.T[2,1] * mechanics.b2.shape1.e_x[2] + mechanics.b2.shape1.R.T[3,1] * mechanics.b2.shape1.e_x[3];
//   mechanics.b2.shape1.rxvisobj[2] = mechanics.b2.shape1.R.T[1,2] * mechanics.b2.shape1.e_x[1] + mechanics.b2.shape1.R.T[2,2] * mechanics.b2.shape1.e_x[2] + mechanics.b2.shape1.R.T[3,2] * mechanics.b2.shape1.e_x[3];
//   mechanics.b2.shape1.rxvisobj[3] = mechanics.b2.shape1.R.T[1,3] * mechanics.b2.shape1.e_x[1] + mechanics.b2.shape1.R.T[2,3] * mechanics.b2.shape1.e_x[2] + mechanics.b2.shape1.R.T[3,3] * mechanics.b2.shape1.e_x[3];
//   mechanics.b2.shape1.ryvisobj[1] = mechanics.b2.shape1.R.T[1,1] * mechanics.b2.shape1.e_y[1] + mechanics.b2.shape1.R.T[2,1] * mechanics.b2.shape1.e_y[2] + mechanics.b2.shape1.R.T[3,1] * mechanics.b2.shape1.e_y[3];
//   mechanics.b2.shape1.ryvisobj[2] = mechanics.b2.shape1.R.T[1,2] * mechanics.b2.shape1.e_y[1] + mechanics.b2.shape1.R.T[2,2] * mechanics.b2.shape1.e_y[2] + mechanics.b2.shape1.R.T[3,2] * mechanics.b2.shape1.e_y[3];
//   mechanics.b2.shape1.ryvisobj[3] = mechanics.b2.shape1.R.T[1,3] * mechanics.b2.shape1.e_y[1] + mechanics.b2.shape1.R.T[2,3] * mechanics.b2.shape1.e_y[2] + mechanics.b2.shape1.R.T[3,3] * mechanics.b2.shape1.e_y[3];
//   mechanics.b2.shape1.rvisobj = mechanics.b2.shape1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{mechanics.b2.shape1.R.T[1,1],mechanics.b2.shape1.R.T[1,2],mechanics.b2.shape1.R.T[1,3]},{mechanics.b2.shape1.R.T[2,1],mechanics.b2.shape1.R.T[2,2],mechanics.b2.shape1.R.T[2,3]},{mechanics.b2.shape1.R.T[3,1],mechanics.b2.shape1.R.T[3,2],mechanics.b2.shape1.R.T[3,3]}},{mechanics.b2.shape1.r_shape[1],mechanics.b2.shape1.r_shape[2],mechanics.b2.shape1.r_shape[3]});
//   mechanics.b2.shape1.size[1] = mechanics.b2.shape1.length;
//   mechanics.b2.shape1.size[2] = mechanics.b2.shape1.width;
//   mechanics.b2.shape1.size[3] = mechanics.b2.shape1.height;
//   mechanics.b2.shape1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(mechanics.b2.shape1.color[1] / 255.0,mechanics.b2.shape1.color[2] / 255.0,mechanics.b2.shape1.color[3] / 255.0,mechanics.b2.shape1.specularCoefficient);
//   mechanics.b2.shape1.Extra = mechanics.b2.shape1.extra;
//   mechanics.b2.r_0[1] = mechanics.b2.frame_a.r_0[1];
//   mechanics.b2.r_0[2] = mechanics.b2.frame_a.r_0[2];
//   mechanics.b2.r_0[3] = mechanics.b2.frame_a.r_0[3];
//   mechanics.b2.v_0[1] = der(mechanics.b2.r_0[1]);
//   mechanics.b2.v_0[2] = der(mechanics.b2.r_0[2]);
//   mechanics.b2.v_0[3] = der(mechanics.b2.r_0[3]);
//   mechanics.b2.a_0[1] = der(mechanics.b2.v_0[1]);
//   mechanics.b2.a_0[2] = der(mechanics.b2.v_0[2]);
//   mechanics.b2.a_0[3] = der(mechanics.b2.v_0[3]);
//   assert(true,\"Neither connector frame_a nor frame_b of FixedTranslation object is connected\");
//   mechanics.b3.frameTranslation.frame_b.r_0 = mechanics.b3.frameTranslation.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(mechanics.b3.frameTranslation.frame_a.R,{mechanics.b3.frameTranslation.r[1],mechanics.b3.frameTranslation.r[2],mechanics.b3.frameTranslation.r[3]});
//   mechanics.b3.frameTranslation.frame_b.R.T[1,1] = mechanics.b3.frameTranslation.frame_a.R.T[1,1];
//   mechanics.b3.frameTranslation.frame_b.R.T[1,2] = mechanics.b3.frameTranslation.frame_a.R.T[1,2];
//   mechanics.b3.frameTranslation.frame_b.R.T[1,3] = mechanics.b3.frameTranslation.frame_a.R.T[1,3];
//   mechanics.b3.frameTranslation.frame_b.R.T[2,1] = mechanics.b3.frameTranslation.frame_a.R.T[2,1];
//   mechanics.b3.frameTranslation.frame_b.R.T[2,2] = mechanics.b3.frameTranslation.frame_a.R.T[2,2];
//   mechanics.b3.frameTranslation.frame_b.R.T[2,3] = mechanics.b3.frameTranslation.frame_a.R.T[2,3];
//   mechanics.b3.frameTranslation.frame_b.R.T[3,1] = mechanics.b3.frameTranslation.frame_a.R.T[3,1];
//   mechanics.b3.frameTranslation.frame_b.R.T[3,2] = mechanics.b3.frameTranslation.frame_a.R.T[3,2];
//   mechanics.b3.frameTranslation.frame_b.R.T[3,3] = mechanics.b3.frameTranslation.frame_a.R.T[3,3];
//   mechanics.b3.frameTranslation.frame_b.R.w[1] = mechanics.b3.frameTranslation.frame_a.R.w[1];
//   mechanics.b3.frameTranslation.frame_b.R.w[2] = mechanics.b3.frameTranslation.frame_a.R.w[2];
//   mechanics.b3.frameTranslation.frame_b.R.w[3] = mechanics.b3.frameTranslation.frame_a.R.w[3];
//   0.0 = mechanics.b3.frameTranslation.frame_a.f[1] + mechanics.b3.frameTranslation.frame_b.f[1];
//   0.0 = mechanics.b3.frameTranslation.frame_a.f[2] + mechanics.b3.frameTranslation.frame_b.f[2];
//   0.0 = mechanics.b3.frameTranslation.frame_a.f[3] + mechanics.b3.frameTranslation.frame_b.f[3];
//   0.0 = mechanics.b3.frameTranslation.frame_a.t[1] + mechanics.b3.frameTranslation.frame_b.t[1] + (mechanics.b3.frameTranslation.r[2] * mechanics.b3.frameTranslation.frame_b.f[3] - mechanics.b3.frameTranslation.r[3] * mechanics.b3.frameTranslation.frame_b.f[2]);
//   0.0 = mechanics.b3.frameTranslation.frame_a.t[2] + mechanics.b3.frameTranslation.frame_b.t[2] + (mechanics.b3.frameTranslation.r[3] * mechanics.b3.frameTranslation.frame_b.f[1] - mechanics.b3.frameTranslation.r[1] * mechanics.b3.frameTranslation.frame_b.f[3]);
//   0.0 = mechanics.b3.frameTranslation.frame_a.t[3] + mechanics.b3.frameTranslation.frame_b.t[3] + (mechanics.b3.frameTranslation.r[1] * mechanics.b3.frameTranslation.frame_b.f[2] - mechanics.b3.frameTranslation.r[2] * mechanics.b3.frameTranslation.frame_b.f[1]);
//   mechanics.b3.body.r_0[1] = mechanics.b3.body.frame_a.r_0[1];
//   mechanics.b3.body.r_0[2] = mechanics.b3.body.frame_a.r_0[2];
//   mechanics.b3.body.r_0[3] = mechanics.b3.body.frame_a.r_0[3];
//   if true then
//   mechanics.b3.body.Q[1] = 0.0;
//   mechanics.b3.body.Q[2] = 0.0;
//   mechanics.b3.body.Q[3] = 0.0;
//   mechanics.b3.body.Q[4] = 1.0;
//   mechanics.b3.body.phi[1] = 0.0;
//   mechanics.b3.body.phi[2] = 0.0;
//   mechanics.b3.body.phi[3] = 0.0;
//   mechanics.b3.body.phi_d[1] = 0.0;
//   mechanics.b3.body.phi_d[2] = 0.0;
//   mechanics.b3.body.phi_d[3] = 0.0;
//   mechanics.b3.body.phi_dd[1] = 0.0;
//   mechanics.b3.body.phi_dd[2] = 0.0;
//   mechanics.b3.body.phi_dd[3] = 0.0;
//   elseif mechanics.b3.body.useQuaternions then
//   mechanics.b3.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.from_Q({mechanics.b3.body.Q[1],mechanics.b3.body.Q[2],mechanics.b3.body.Q[3],mechanics.b3.body.Q[4]},Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2({mechanics.b3.body.Q[1],mechanics.b3.body.Q[2],mechanics.b3.body.Q[3],mechanics.b3.body.Q[4]},{der(mechanics.b3.body.Q[1]),der(mechanics.b3.body.Q[2]),der(mechanics.b3.body.Q[3]),der(mechanics.b3.body.Q[4])}));
//   {0.0} = Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint({mechanics.b3.body.Q[1],mechanics.b3.body.Q[2],mechanics.b3.body.Q[3],mechanics.b3.body.Q[4]});
//   mechanics.b3.body.phi[1] = 0.0;
//   mechanics.b3.body.phi[2] = 0.0;
//   mechanics.b3.body.phi[3] = 0.0;
//   mechanics.b3.body.phi_d[1] = 0.0;
//   mechanics.b3.body.phi_d[2] = 0.0;
//   mechanics.b3.body.phi_d[3] = 0.0;
//   mechanics.b3.body.phi_dd[1] = 0.0;
//   mechanics.b3.body.phi_dd[2] = 0.0;
//   mechanics.b3.body.phi_dd[3] = 0.0;
//   else
//   mechanics.b3.body.phi_d[1] = der(mechanics.b3.body.phi[1]);
//   mechanics.b3.body.phi_d[2] = der(mechanics.b3.body.phi[2]);
//   mechanics.b3.body.phi_d[3] = der(mechanics.b3.body.phi[3]);
//   mechanics.b3.body.phi_dd[1] = der(mechanics.b3.body.phi_d[1]);
//   mechanics.b3.body.phi_dd[2] = der(mechanics.b3.body.phi_d[2]);
//   mechanics.b3.body.phi_dd[3] = der(mechanics.b3.body.phi_d[3]);
//   mechanics.b3.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.axesRotations({mechanics.b3.body.sequence_angleStates[1],mechanics.b3.body.sequence_angleStates[2],mechanics.b3.body.sequence_angleStates[3]},{mechanics.b3.body.phi[1],mechanics.b3.body.phi[2],mechanics.b3.body.phi[3]},{mechanics.b3.body.phi_d[1],mechanics.b3.body.phi_d[2],mechanics.b3.body.phi_d[3]});
//   mechanics.b3.body.Q[1] = 0.0;
//   mechanics.b3.body.Q[2] = 0.0;
//   mechanics.b3.body.Q[3] = 0.0;
//   mechanics.b3.body.Q[4] = 1.0;
//   end if;
//   mechanics.b3.body.g_0 = Modelica.Mechanics.MultiBody.Parts.Body.world__gravityAcceleration({mechanics.b3.body.frame_a.r_0[1],mechanics.b3.body.frame_a.r_0[2],mechanics.b3.body.frame_a.r_0[3]} + Modelica.Mechanics.MultiBody.Frames.resolve1(mechanics.b3.body.frame_a.R,{mechanics.b3.body.r_CM[1],mechanics.b3.body.r_CM[2],mechanics.b3.body.r_CM[3]}),mechanics.world.gravityType,mechanics.world.g * Modelica.Math.Vectors.normalize({mechanics.world.n[1],mechanics.world.n[2],mechanics.world.n[3]},1e-13),mechanics.world.mue);
//   mechanics.b3.body.v_0[1] = der(mechanics.b3.body.frame_a.r_0[1]);
//   mechanics.b3.body.v_0[2] = der(mechanics.b3.body.frame_a.r_0[2]);
//   mechanics.b3.body.v_0[3] = der(mechanics.b3.body.frame_a.r_0[3]);
//   mechanics.b3.body.a_0[1] = der(mechanics.b3.body.v_0[1]);
//   mechanics.b3.body.a_0[2] = der(mechanics.b3.body.v_0[2]);
//   mechanics.b3.body.a_0[3] = der(mechanics.b3.body.v_0[3]);
//   mechanics.b3.body.w_a = Modelica.Mechanics.MultiBody.Frames.angularVelocity2(mechanics.b3.body.frame_a.R);
//   mechanics.b3.body.z_a[1] = der(mechanics.b3.body.w_a[1]);
//   mechanics.b3.body.z_a[2] = der(mechanics.b3.body.w_a[2]);
//   mechanics.b3.body.z_a[3] = der(mechanics.b3.body.w_a[3]);
//   mechanics.b3.body.frame_a.f = mechanics.b3.body.m * (Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b3.body.frame_a.R,{mechanics.b3.body.a_0[1] - mechanics.b3.body.g_0[1],mechanics.b3.body.a_0[2] - mechanics.b3.body.g_0[2],mechanics.b3.body.a_0[3] - mechanics.b3.body.g_0[3]}) + {mechanics.b3.body.z_a[2] * mechanics.b3.body.r_CM[3] - mechanics.b3.body.z_a[3] * mechanics.b3.body.r_CM[2],mechanics.b3.body.z_a[3] * mechanics.b3.body.r_CM[1] - mechanics.b3.body.z_a[1] * mechanics.b3.body.r_CM[3],mechanics.b3.body.z_a[1] * mechanics.b3.body.r_CM[2] - mechanics.b3.body.z_a[2] * mechanics.b3.body.r_CM[1]} + {mechanics.b3.body.w_a[2] * (mechanics.b3.body.w_a[1] * mechanics.b3.body.r_CM[2] - mechanics.b3.body.w_a[2] * mechanics.b3.body.r_CM[1]) - mechanics.b3.body.w_a[3] * (mechanics.b3.body.w_a[3] * mechanics.b3.body.r_CM[1] - mechanics.b3.body.w_a[1] * mechanics.b3.body.r_CM[3]),mechanics.b3.body.w_a[3] * (mechanics.b3.body.w_a[2] * mechanics.b3.body.r_CM[3] - mechanics.b3.body.w_a[3] * mechanics.b3.body.r_CM[2]) - mechanics.b3.body.w_a[1] * (mechanics.b3.body.w_a[1] * mechanics.b3.body.r_CM[2] - mechanics.b3.body.w_a[2] * mechanics.b3.body.r_CM[1]),mechanics.b3.body.w_a[1] * (mechanics.b3.body.w_a[3] * mechanics.b3.body.r_CM[1] - mechanics.b3.body.w_a[1] * mechanics.b3.body.r_CM[3]) - mechanics.b3.body.w_a[2] * (mechanics.b3.body.w_a[2] * mechanics.b3.body.r_CM[3] - mechanics.b3.body.w_a[3] * mechanics.b3.body.r_CM[2])});
//   mechanics.b3.body.frame_a.t[1] = mechanics.b3.body.I[1,1] * mechanics.b3.body.z_a[1] + mechanics.b3.body.I[1,2] * mechanics.b3.body.z_a[2] + mechanics.b3.body.I[1,3] * mechanics.b3.body.z_a[3] + (mechanics.b3.body.w_a[2] * (mechanics.b3.body.I[3,1] * mechanics.b3.body.w_a[1] + mechanics.b3.body.I[3,2] * mechanics.b3.body.w_a[2] + mechanics.b3.body.I[3,3] * mechanics.b3.body.w_a[3]) - mechanics.b3.body.w_a[3] * (mechanics.b3.body.I[2,1] * mechanics.b3.body.w_a[1] + mechanics.b3.body.I[2,2] * mechanics.b3.body.w_a[2] + mechanics.b3.body.I[2,3] * mechanics.b3.body.w_a[3])) + (mechanics.b3.body.r_CM[2] * mechanics.b3.body.frame_a.f[3] - mechanics.b3.body.r_CM[3] * mechanics.b3.body.frame_a.f[2]);
//   mechanics.b3.body.frame_a.t[2] = mechanics.b3.body.I[2,1] * mechanics.b3.body.z_a[1] + mechanics.b3.body.I[2,2] * mechanics.b3.body.z_a[2] + mechanics.b3.body.I[2,3] * mechanics.b3.body.z_a[3] + (mechanics.b3.body.w_a[3] * (mechanics.b3.body.I[1,1] * mechanics.b3.body.w_a[1] + mechanics.b3.body.I[1,2] * mechanics.b3.body.w_a[2] + mechanics.b3.body.I[1,3] * mechanics.b3.body.w_a[3]) - mechanics.b3.body.w_a[1] * (mechanics.b3.body.I[3,1] * mechanics.b3.body.w_a[1] + mechanics.b3.body.I[3,2] * mechanics.b3.body.w_a[2] + mechanics.b3.body.I[3,3] * mechanics.b3.body.w_a[3])) + (mechanics.b3.body.r_CM[3] * mechanics.b3.body.frame_a.f[1] - mechanics.b3.body.r_CM[1] * mechanics.b3.body.frame_a.f[3]);
//   mechanics.b3.body.frame_a.t[3] = mechanics.b3.body.I[3,1] * mechanics.b3.body.z_a[1] + mechanics.b3.body.I[3,2] * mechanics.b3.body.z_a[2] + mechanics.b3.body.I[3,3] * mechanics.b3.body.z_a[3] + (mechanics.b3.body.w_a[1] * (mechanics.b3.body.I[2,1] * mechanics.b3.body.w_a[1] + mechanics.b3.body.I[2,2] * mechanics.b3.body.w_a[2] + mechanics.b3.body.I[2,3] * mechanics.b3.body.w_a[3]) - mechanics.b3.body.w_a[2] * (mechanics.b3.body.I[1,1] * mechanics.b3.body.w_a[1] + mechanics.b3.body.I[1,2] * mechanics.b3.body.w_a[2] + mechanics.b3.body.I[1,3] * mechanics.b3.body.w_a[3])) + (mechanics.b3.body.r_CM[1] * mechanics.b3.body.frame_a.f[2] - mechanics.b3.body.r_CM[2] * mechanics.b3.body.frame_a.f[1]);
//   mechanics.b3.shape1.R.T[1,1] = mechanics.b3.frame_a.R.T[1,1];
//   mechanics.b3.shape1.R.T[1,2] = mechanics.b3.frame_a.R.T[1,2];
//   mechanics.b3.shape1.R.T[1,3] = mechanics.b3.frame_a.R.T[1,3];
//   mechanics.b3.shape1.R.T[2,1] = mechanics.b3.frame_a.R.T[2,1];
//   mechanics.b3.shape1.R.T[2,2] = mechanics.b3.frame_a.R.T[2,2];
//   mechanics.b3.shape1.R.T[2,3] = mechanics.b3.frame_a.R.T[2,3];
//   mechanics.b3.shape1.R.T[3,1] = mechanics.b3.frame_a.R.T[3,1];
//   mechanics.b3.shape1.R.T[3,2] = mechanics.b3.frame_a.R.T[3,2];
//   mechanics.b3.shape1.R.T[3,3] = mechanics.b3.frame_a.R.T[3,3];
//   mechanics.b3.shape1.R.w[1] = mechanics.b3.frame_a.R.w[1];
//   mechanics.b3.shape1.R.w[2] = mechanics.b3.frame_a.R.w[2];
//   mechanics.b3.shape1.R.w[3] = mechanics.b3.frame_a.R.w[3];
//   mechanics.b3.shape1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(mechanics.b3.shape1.shapeType);
//   mechanics.b3.shape1.rxvisobj[1] = mechanics.b3.shape1.R.T[1,1] * mechanics.b3.shape1.e_x[1] + mechanics.b3.shape1.R.T[2,1] * mechanics.b3.shape1.e_x[2] + mechanics.b3.shape1.R.T[3,1] * mechanics.b3.shape1.e_x[3];
//   mechanics.b3.shape1.rxvisobj[2] = mechanics.b3.shape1.R.T[1,2] * mechanics.b3.shape1.e_x[1] + mechanics.b3.shape1.R.T[2,2] * mechanics.b3.shape1.e_x[2] + mechanics.b3.shape1.R.T[3,2] * mechanics.b3.shape1.e_x[3];
//   mechanics.b3.shape1.rxvisobj[3] = mechanics.b3.shape1.R.T[1,3] * mechanics.b3.shape1.e_x[1] + mechanics.b3.shape1.R.T[2,3] * mechanics.b3.shape1.e_x[2] + mechanics.b3.shape1.R.T[3,3] * mechanics.b3.shape1.e_x[3];
//   mechanics.b3.shape1.ryvisobj[1] = mechanics.b3.shape1.R.T[1,1] * mechanics.b3.shape1.e_y[1] + mechanics.b3.shape1.R.T[2,1] * mechanics.b3.shape1.e_y[2] + mechanics.b3.shape1.R.T[3,1] * mechanics.b3.shape1.e_y[3];
//   mechanics.b3.shape1.ryvisobj[2] = mechanics.b3.shape1.R.T[1,2] * mechanics.b3.shape1.e_y[1] + mechanics.b3.shape1.R.T[2,2] * mechanics.b3.shape1.e_y[2] + mechanics.b3.shape1.R.T[3,2] * mechanics.b3.shape1.e_y[3];
//   mechanics.b3.shape1.ryvisobj[3] = mechanics.b3.shape1.R.T[1,3] * mechanics.b3.shape1.e_y[1] + mechanics.b3.shape1.R.T[2,3] * mechanics.b3.shape1.e_y[2] + mechanics.b3.shape1.R.T[3,3] * mechanics.b3.shape1.e_y[3];
//   mechanics.b3.shape1.rvisobj = mechanics.b3.shape1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{mechanics.b3.shape1.R.T[1,1],mechanics.b3.shape1.R.T[1,2],mechanics.b3.shape1.R.T[1,3]},{mechanics.b3.shape1.R.T[2,1],mechanics.b3.shape1.R.T[2,2],mechanics.b3.shape1.R.T[2,3]},{mechanics.b3.shape1.R.T[3,1],mechanics.b3.shape1.R.T[3,2],mechanics.b3.shape1.R.T[3,3]}},{mechanics.b3.shape1.r_shape[1],mechanics.b3.shape1.r_shape[2],mechanics.b3.shape1.r_shape[3]});
//   mechanics.b3.shape1.size[1] = mechanics.b3.shape1.length;
//   mechanics.b3.shape1.size[2] = mechanics.b3.shape1.width;
//   mechanics.b3.shape1.size[3] = mechanics.b3.shape1.height;
//   mechanics.b3.shape1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(mechanics.b3.shape1.color[1] / 255.0,mechanics.b3.shape1.color[2] / 255.0,mechanics.b3.shape1.color[3] / 255.0,mechanics.b3.shape1.specularCoefficient);
//   mechanics.b3.shape1.Extra = mechanics.b3.shape1.extra;
//   mechanics.b3.r_0[1] = mechanics.b3.frame_a.r_0[1];
//   mechanics.b3.r_0[2] = mechanics.b3.frame_a.r_0[2];
//   mechanics.b3.r_0[3] = mechanics.b3.frame_a.r_0[3];
//   mechanics.b3.v_0[1] = der(mechanics.b3.r_0[1]);
//   mechanics.b3.v_0[2] = der(mechanics.b3.r_0[2]);
//   mechanics.b3.v_0[3] = der(mechanics.b3.r_0[3]);
//   mechanics.b3.a_0[1] = der(mechanics.b3.v_0[1]);
//   mechanics.b3.a_0[2] = der(mechanics.b3.v_0[2]);
//   mechanics.b3.a_0[3] = der(mechanics.b3.v_0[3]);
//   assert(true,\"Neither connector frame_a nor frame_b of FixedTranslation object is connected\");
//   mechanics.b4.frameTranslation.frame_b.r_0 = mechanics.b4.frameTranslation.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(mechanics.b4.frameTranslation.frame_a.R,{mechanics.b4.frameTranslation.r[1],mechanics.b4.frameTranslation.r[2],mechanics.b4.frameTranslation.r[3]});
//   mechanics.b4.frameTranslation.frame_b.R.T[1,1] = mechanics.b4.frameTranslation.frame_a.R.T[1,1];
//   mechanics.b4.frameTranslation.frame_b.R.T[1,2] = mechanics.b4.frameTranslation.frame_a.R.T[1,2];
//   mechanics.b4.frameTranslation.frame_b.R.T[1,3] = mechanics.b4.frameTranslation.frame_a.R.T[1,3];
//   mechanics.b4.frameTranslation.frame_b.R.T[2,1] = mechanics.b4.frameTranslation.frame_a.R.T[2,1];
//   mechanics.b4.frameTranslation.frame_b.R.T[2,2] = mechanics.b4.frameTranslation.frame_a.R.T[2,2];
//   mechanics.b4.frameTranslation.frame_b.R.T[2,3] = mechanics.b4.frameTranslation.frame_a.R.T[2,3];
//   mechanics.b4.frameTranslation.frame_b.R.T[3,1] = mechanics.b4.frameTranslation.frame_a.R.T[3,1];
//   mechanics.b4.frameTranslation.frame_b.R.T[3,2] = mechanics.b4.frameTranslation.frame_a.R.T[3,2];
//   mechanics.b4.frameTranslation.frame_b.R.T[3,3] = mechanics.b4.frameTranslation.frame_a.R.T[3,3];
//   mechanics.b4.frameTranslation.frame_b.R.w[1] = mechanics.b4.frameTranslation.frame_a.R.w[1];
//   mechanics.b4.frameTranslation.frame_b.R.w[2] = mechanics.b4.frameTranslation.frame_a.R.w[2];
//   mechanics.b4.frameTranslation.frame_b.R.w[3] = mechanics.b4.frameTranslation.frame_a.R.w[3];
//   0.0 = mechanics.b4.frameTranslation.frame_a.f[1] + mechanics.b4.frameTranslation.frame_b.f[1];
//   0.0 = mechanics.b4.frameTranslation.frame_a.f[2] + mechanics.b4.frameTranslation.frame_b.f[2];
//   0.0 = mechanics.b4.frameTranslation.frame_a.f[3] + mechanics.b4.frameTranslation.frame_b.f[3];
//   0.0 = mechanics.b4.frameTranslation.frame_a.t[1] + mechanics.b4.frameTranslation.frame_b.t[1] + (mechanics.b4.frameTranslation.r[2] * mechanics.b4.frameTranslation.frame_b.f[3] - mechanics.b4.frameTranslation.r[3] * mechanics.b4.frameTranslation.frame_b.f[2]);
//   0.0 = mechanics.b4.frameTranslation.frame_a.t[2] + mechanics.b4.frameTranslation.frame_b.t[2] + (mechanics.b4.frameTranslation.r[3] * mechanics.b4.frameTranslation.frame_b.f[1] - mechanics.b4.frameTranslation.r[1] * mechanics.b4.frameTranslation.frame_b.f[3]);
//   0.0 = mechanics.b4.frameTranslation.frame_a.t[3] + mechanics.b4.frameTranslation.frame_b.t[3] + (mechanics.b4.frameTranslation.r[1] * mechanics.b4.frameTranslation.frame_b.f[2] - mechanics.b4.frameTranslation.r[2] * mechanics.b4.frameTranslation.frame_b.f[1]);
//   mechanics.b4.body.r_0[1] = mechanics.b4.body.frame_a.r_0[1];
//   mechanics.b4.body.r_0[2] = mechanics.b4.body.frame_a.r_0[2];
//   mechanics.b4.body.r_0[3] = mechanics.b4.body.frame_a.r_0[3];
//   if true then
//   mechanics.b4.body.Q[1] = 0.0;
//   mechanics.b4.body.Q[2] = 0.0;
//   mechanics.b4.body.Q[3] = 0.0;
//   mechanics.b4.body.Q[4] = 1.0;
//   mechanics.b4.body.phi[1] = 0.0;
//   mechanics.b4.body.phi[2] = 0.0;
//   mechanics.b4.body.phi[3] = 0.0;
//   mechanics.b4.body.phi_d[1] = 0.0;
//   mechanics.b4.body.phi_d[2] = 0.0;
//   mechanics.b4.body.phi_d[3] = 0.0;
//   mechanics.b4.body.phi_dd[1] = 0.0;
//   mechanics.b4.body.phi_dd[2] = 0.0;
//   mechanics.b4.body.phi_dd[3] = 0.0;
//   elseif mechanics.b4.body.useQuaternions then
//   mechanics.b4.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.from_Q({mechanics.b4.body.Q[1],mechanics.b4.body.Q[2],mechanics.b4.body.Q[3],mechanics.b4.body.Q[4]},Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2({mechanics.b4.body.Q[1],mechanics.b4.body.Q[2],mechanics.b4.body.Q[3],mechanics.b4.body.Q[4]},{der(mechanics.b4.body.Q[1]),der(mechanics.b4.body.Q[2]),der(mechanics.b4.body.Q[3]),der(mechanics.b4.body.Q[4])}));
//   {0.0} = Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint({mechanics.b4.body.Q[1],mechanics.b4.body.Q[2],mechanics.b4.body.Q[3],mechanics.b4.body.Q[4]});
//   mechanics.b4.body.phi[1] = 0.0;
//   mechanics.b4.body.phi[2] = 0.0;
//   mechanics.b4.body.phi[3] = 0.0;
//   mechanics.b4.body.phi_d[1] = 0.0;
//   mechanics.b4.body.phi_d[2] = 0.0;
//   mechanics.b4.body.phi_d[3] = 0.0;
//   mechanics.b4.body.phi_dd[1] = 0.0;
//   mechanics.b4.body.phi_dd[2] = 0.0;
//   mechanics.b4.body.phi_dd[3] = 0.0;
//   else
//   mechanics.b4.body.phi_d[1] = der(mechanics.b4.body.phi[1]);
//   mechanics.b4.body.phi_d[2] = der(mechanics.b4.body.phi[2]);
//   mechanics.b4.body.phi_d[3] = der(mechanics.b4.body.phi[3]);
//   mechanics.b4.body.phi_dd[1] = der(mechanics.b4.body.phi_d[1]);
//   mechanics.b4.body.phi_dd[2] = der(mechanics.b4.body.phi_d[2]);
//   mechanics.b4.body.phi_dd[3] = der(mechanics.b4.body.phi_d[3]);
//   mechanics.b4.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.axesRotations({mechanics.b4.body.sequence_angleStates[1],mechanics.b4.body.sequence_angleStates[2],mechanics.b4.body.sequence_angleStates[3]},{mechanics.b4.body.phi[1],mechanics.b4.body.phi[2],mechanics.b4.body.phi[3]},{mechanics.b4.body.phi_d[1],mechanics.b4.body.phi_d[2],mechanics.b4.body.phi_d[3]});
//   mechanics.b4.body.Q[1] = 0.0;
//   mechanics.b4.body.Q[2] = 0.0;
//   mechanics.b4.body.Q[3] = 0.0;
//   mechanics.b4.body.Q[4] = 1.0;
//   end if;
//   mechanics.b4.body.g_0 = Modelica.Mechanics.MultiBody.Parts.Body.world__gravityAcceleration({mechanics.b4.body.frame_a.r_0[1],mechanics.b4.body.frame_a.r_0[2],mechanics.b4.body.frame_a.r_0[3]} + Modelica.Mechanics.MultiBody.Frames.resolve1(mechanics.b4.body.frame_a.R,{mechanics.b4.body.r_CM[1],mechanics.b4.body.r_CM[2],mechanics.b4.body.r_CM[3]}),mechanics.world.gravityType,mechanics.world.g * Modelica.Math.Vectors.normalize({mechanics.world.n[1],mechanics.world.n[2],mechanics.world.n[3]},1e-13),mechanics.world.mue);
//   mechanics.b4.body.v_0[1] = der(mechanics.b4.body.frame_a.r_0[1]);
//   mechanics.b4.body.v_0[2] = der(mechanics.b4.body.frame_a.r_0[2]);
//   mechanics.b4.body.v_0[3] = der(mechanics.b4.body.frame_a.r_0[3]);
//   mechanics.b4.body.a_0[1] = der(mechanics.b4.body.v_0[1]);
//   mechanics.b4.body.a_0[2] = der(mechanics.b4.body.v_0[2]);
//   mechanics.b4.body.a_0[3] = der(mechanics.b4.body.v_0[3]);
//   mechanics.b4.body.w_a = Modelica.Mechanics.MultiBody.Frames.angularVelocity2(mechanics.b4.body.frame_a.R);
//   mechanics.b4.body.z_a[1] = der(mechanics.b4.body.w_a[1]);
//   mechanics.b4.body.z_a[2] = der(mechanics.b4.body.w_a[2]);
//   mechanics.b4.body.z_a[3] = der(mechanics.b4.body.w_a[3]);
//   mechanics.b4.body.frame_a.f = mechanics.b4.body.m * (Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b4.body.frame_a.R,{mechanics.b4.body.a_0[1] - mechanics.b4.body.g_0[1],mechanics.b4.body.a_0[2] - mechanics.b4.body.g_0[2],mechanics.b4.body.a_0[3] - mechanics.b4.body.g_0[3]}) + {mechanics.b4.body.z_a[2] * mechanics.b4.body.r_CM[3] - mechanics.b4.body.z_a[3] * mechanics.b4.body.r_CM[2],mechanics.b4.body.z_a[3] * mechanics.b4.body.r_CM[1] - mechanics.b4.body.z_a[1] * mechanics.b4.body.r_CM[3],mechanics.b4.body.z_a[1] * mechanics.b4.body.r_CM[2] - mechanics.b4.body.z_a[2] * mechanics.b4.body.r_CM[1]} + {mechanics.b4.body.w_a[2] * (mechanics.b4.body.w_a[1] * mechanics.b4.body.r_CM[2] - mechanics.b4.body.w_a[2] * mechanics.b4.body.r_CM[1]) - mechanics.b4.body.w_a[3] * (mechanics.b4.body.w_a[3] * mechanics.b4.body.r_CM[1] - mechanics.b4.body.w_a[1] * mechanics.b4.body.r_CM[3]),mechanics.b4.body.w_a[3] * (mechanics.b4.body.w_a[2] * mechanics.b4.body.r_CM[3] - mechanics.b4.body.w_a[3] * mechanics.b4.body.r_CM[2]) - mechanics.b4.body.w_a[1] * (mechanics.b4.body.w_a[1] * mechanics.b4.body.r_CM[2] - mechanics.b4.body.w_a[2] * mechanics.b4.body.r_CM[1]),mechanics.b4.body.w_a[1] * (mechanics.b4.body.w_a[3] * mechanics.b4.body.r_CM[1] - mechanics.b4.body.w_a[1] * mechanics.b4.body.r_CM[3]) - mechanics.b4.body.w_a[2] * (mechanics.b4.body.w_a[2] * mechanics.b4.body.r_CM[3] - mechanics.b4.body.w_a[3] * mechanics.b4.body.r_CM[2])});
//   mechanics.b4.body.frame_a.t[1] = mechanics.b4.body.I[1,1] * mechanics.b4.body.z_a[1] + mechanics.b4.body.I[1,2] * mechanics.b4.body.z_a[2] + mechanics.b4.body.I[1,3] * mechanics.b4.body.z_a[3] + (mechanics.b4.body.w_a[2] * (mechanics.b4.body.I[3,1] * mechanics.b4.body.w_a[1] + mechanics.b4.body.I[3,2] * mechanics.b4.body.w_a[2] + mechanics.b4.body.I[3,3] * mechanics.b4.body.w_a[3]) - mechanics.b4.body.w_a[3] * (mechanics.b4.body.I[2,1] * mechanics.b4.body.w_a[1] + mechanics.b4.body.I[2,2] * mechanics.b4.body.w_a[2] + mechanics.b4.body.I[2,3] * mechanics.b4.body.w_a[3])) + (mechanics.b4.body.r_CM[2] * mechanics.b4.body.frame_a.f[3] - mechanics.b4.body.r_CM[3] * mechanics.b4.body.frame_a.f[2]);
//   mechanics.b4.body.frame_a.t[2] = mechanics.b4.body.I[2,1] * mechanics.b4.body.z_a[1] + mechanics.b4.body.I[2,2] * mechanics.b4.body.z_a[2] + mechanics.b4.body.I[2,3] * mechanics.b4.body.z_a[3] + (mechanics.b4.body.w_a[3] * (mechanics.b4.body.I[1,1] * mechanics.b4.body.w_a[1] + mechanics.b4.body.I[1,2] * mechanics.b4.body.w_a[2] + mechanics.b4.body.I[1,3] * mechanics.b4.body.w_a[3]) - mechanics.b4.body.w_a[1] * (mechanics.b4.body.I[3,1] * mechanics.b4.body.w_a[1] + mechanics.b4.body.I[3,2] * mechanics.b4.body.w_a[2] + mechanics.b4.body.I[3,3] * mechanics.b4.body.w_a[3])) + (mechanics.b4.body.r_CM[3] * mechanics.b4.body.frame_a.f[1] - mechanics.b4.body.r_CM[1] * mechanics.b4.body.frame_a.f[3]);
//   mechanics.b4.body.frame_a.t[3] = mechanics.b4.body.I[3,1] * mechanics.b4.body.z_a[1] + mechanics.b4.body.I[3,2] * mechanics.b4.body.z_a[2] + mechanics.b4.body.I[3,3] * mechanics.b4.body.z_a[3] + (mechanics.b4.body.w_a[1] * (mechanics.b4.body.I[2,1] * mechanics.b4.body.w_a[1] + mechanics.b4.body.I[2,2] * mechanics.b4.body.w_a[2] + mechanics.b4.body.I[2,3] * mechanics.b4.body.w_a[3]) - mechanics.b4.body.w_a[2] * (mechanics.b4.body.I[1,1] * mechanics.b4.body.w_a[1] + mechanics.b4.body.I[1,2] * mechanics.b4.body.w_a[2] + mechanics.b4.body.I[1,3] * mechanics.b4.body.w_a[3])) + (mechanics.b4.body.r_CM[1] * mechanics.b4.body.frame_a.f[2] - mechanics.b4.body.r_CM[2] * mechanics.b4.body.frame_a.f[1]);
//   mechanics.b4.shape1.R.T[1,1] = mechanics.b4.frame_a.R.T[1,1];
//   mechanics.b4.shape1.R.T[1,2] = mechanics.b4.frame_a.R.T[1,2];
//   mechanics.b4.shape1.R.T[1,3] = mechanics.b4.frame_a.R.T[1,3];
//   mechanics.b4.shape1.R.T[2,1] = mechanics.b4.frame_a.R.T[2,1];
//   mechanics.b4.shape1.R.T[2,2] = mechanics.b4.frame_a.R.T[2,2];
//   mechanics.b4.shape1.R.T[2,3] = mechanics.b4.frame_a.R.T[2,3];
//   mechanics.b4.shape1.R.T[3,1] = mechanics.b4.frame_a.R.T[3,1];
//   mechanics.b4.shape1.R.T[3,2] = mechanics.b4.frame_a.R.T[3,2];
//   mechanics.b4.shape1.R.T[3,3] = mechanics.b4.frame_a.R.T[3,3];
//   mechanics.b4.shape1.R.w[1] = mechanics.b4.frame_a.R.w[1];
//   mechanics.b4.shape1.R.w[2] = mechanics.b4.frame_a.R.w[2];
//   mechanics.b4.shape1.R.w[3] = mechanics.b4.frame_a.R.w[3];
//   mechanics.b4.shape1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(mechanics.b4.shape1.shapeType);
//   mechanics.b4.shape1.rxvisobj[1] = mechanics.b4.shape1.R.T[1,1] * mechanics.b4.shape1.e_x[1] + mechanics.b4.shape1.R.T[2,1] * mechanics.b4.shape1.e_x[2] + mechanics.b4.shape1.R.T[3,1] * mechanics.b4.shape1.e_x[3];
//   mechanics.b4.shape1.rxvisobj[2] = mechanics.b4.shape1.R.T[1,2] * mechanics.b4.shape1.e_x[1] + mechanics.b4.shape1.R.T[2,2] * mechanics.b4.shape1.e_x[2] + mechanics.b4.shape1.R.T[3,2] * mechanics.b4.shape1.e_x[3];
//   mechanics.b4.shape1.rxvisobj[3] = mechanics.b4.shape1.R.T[1,3] * mechanics.b4.shape1.e_x[1] + mechanics.b4.shape1.R.T[2,3] * mechanics.b4.shape1.e_x[2] + mechanics.b4.shape1.R.T[3,3] * mechanics.b4.shape1.e_x[3];
//   mechanics.b4.shape1.ryvisobj[1] = mechanics.b4.shape1.R.T[1,1] * mechanics.b4.shape1.e_y[1] + mechanics.b4.shape1.R.T[2,1] * mechanics.b4.shape1.e_y[2] + mechanics.b4.shape1.R.T[3,1] * mechanics.b4.shape1.e_y[3];
//   mechanics.b4.shape1.ryvisobj[2] = mechanics.b4.shape1.R.T[1,2] * mechanics.b4.shape1.e_y[1] + mechanics.b4.shape1.R.T[2,2] * mechanics.b4.shape1.e_y[2] + mechanics.b4.shape1.R.T[3,2] * mechanics.b4.shape1.e_y[3];
//   mechanics.b4.shape1.ryvisobj[3] = mechanics.b4.shape1.R.T[1,3] * mechanics.b4.shape1.e_y[1] + mechanics.b4.shape1.R.T[2,3] * mechanics.b4.shape1.e_y[2] + mechanics.b4.shape1.R.T[3,3] * mechanics.b4.shape1.e_y[3];
//   mechanics.b4.shape1.rvisobj = mechanics.b4.shape1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{mechanics.b4.shape1.R.T[1,1],mechanics.b4.shape1.R.T[1,2],mechanics.b4.shape1.R.T[1,3]},{mechanics.b4.shape1.R.T[2,1],mechanics.b4.shape1.R.T[2,2],mechanics.b4.shape1.R.T[2,3]},{mechanics.b4.shape1.R.T[3,1],mechanics.b4.shape1.R.T[3,2],mechanics.b4.shape1.R.T[3,3]}},{mechanics.b4.shape1.r_shape[1],mechanics.b4.shape1.r_shape[2],mechanics.b4.shape1.r_shape[3]});
//   mechanics.b4.shape1.size[1] = mechanics.b4.shape1.length;
//   mechanics.b4.shape1.size[2] = mechanics.b4.shape1.width;
//   mechanics.b4.shape1.size[3] = mechanics.b4.shape1.height;
//   mechanics.b4.shape1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(mechanics.b4.shape1.color[1] / 255.0,mechanics.b4.shape1.color[2] / 255.0,mechanics.b4.shape1.color[3] / 255.0,mechanics.b4.shape1.specularCoefficient);
//   mechanics.b4.shape1.Extra = mechanics.b4.shape1.extra;
//   mechanics.b4.r_0[1] = mechanics.b4.frame_a.r_0[1];
//   mechanics.b4.r_0[2] = mechanics.b4.frame_a.r_0[2];
//   mechanics.b4.r_0[3] = mechanics.b4.frame_a.r_0[3];
//   mechanics.b4.v_0[1] = der(mechanics.b4.r_0[1]);
//   mechanics.b4.v_0[2] = der(mechanics.b4.r_0[2]);
//   mechanics.b4.v_0[3] = der(mechanics.b4.r_0[3]);
//   mechanics.b4.a_0[1] = der(mechanics.b4.v_0[1]);
//   mechanics.b4.a_0[2] = der(mechanics.b4.v_0[2]);
//   mechanics.b4.a_0[3] = der(mechanics.b4.v_0[3]);
//   assert(true,\"Neither connector frame_a nor frame_b of FixedTranslation object is connected\");
//   mechanics.b5.frameTranslation.frame_b.r_0 = mechanics.b5.frameTranslation.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(mechanics.b5.frameTranslation.frame_a.R,{mechanics.b5.frameTranslation.r[1],mechanics.b5.frameTranslation.r[2],mechanics.b5.frameTranslation.r[3]});
//   mechanics.b5.frameTranslation.frame_b.R.T[1,1] = mechanics.b5.frameTranslation.frame_a.R.T[1,1];
//   mechanics.b5.frameTranslation.frame_b.R.T[1,2] = mechanics.b5.frameTranslation.frame_a.R.T[1,2];
//   mechanics.b5.frameTranslation.frame_b.R.T[1,3] = mechanics.b5.frameTranslation.frame_a.R.T[1,3];
//   mechanics.b5.frameTranslation.frame_b.R.T[2,1] = mechanics.b5.frameTranslation.frame_a.R.T[2,1];
//   mechanics.b5.frameTranslation.frame_b.R.T[2,2] = mechanics.b5.frameTranslation.frame_a.R.T[2,2];
//   mechanics.b5.frameTranslation.frame_b.R.T[2,3] = mechanics.b5.frameTranslation.frame_a.R.T[2,3];
//   mechanics.b5.frameTranslation.frame_b.R.T[3,1] = mechanics.b5.frameTranslation.frame_a.R.T[3,1];
//   mechanics.b5.frameTranslation.frame_b.R.T[3,2] = mechanics.b5.frameTranslation.frame_a.R.T[3,2];
//   mechanics.b5.frameTranslation.frame_b.R.T[3,3] = mechanics.b5.frameTranslation.frame_a.R.T[3,3];
//   mechanics.b5.frameTranslation.frame_b.R.w[1] = mechanics.b5.frameTranslation.frame_a.R.w[1];
//   mechanics.b5.frameTranslation.frame_b.R.w[2] = mechanics.b5.frameTranslation.frame_a.R.w[2];
//   mechanics.b5.frameTranslation.frame_b.R.w[3] = mechanics.b5.frameTranslation.frame_a.R.w[3];
//   0.0 = mechanics.b5.frameTranslation.frame_a.f[1] + mechanics.b5.frameTranslation.frame_b.f[1];
//   0.0 = mechanics.b5.frameTranslation.frame_a.f[2] + mechanics.b5.frameTranslation.frame_b.f[2];
//   0.0 = mechanics.b5.frameTranslation.frame_a.f[3] + mechanics.b5.frameTranslation.frame_b.f[3];
//   0.0 = mechanics.b5.frameTranslation.frame_a.t[1] + mechanics.b5.frameTranslation.frame_b.t[1] + (mechanics.b5.frameTranslation.r[2] * mechanics.b5.frameTranslation.frame_b.f[3] - mechanics.b5.frameTranslation.r[3] * mechanics.b5.frameTranslation.frame_b.f[2]);
//   0.0 = mechanics.b5.frameTranslation.frame_a.t[2] + mechanics.b5.frameTranslation.frame_b.t[2] + (mechanics.b5.frameTranslation.r[3] * mechanics.b5.frameTranslation.frame_b.f[1] - mechanics.b5.frameTranslation.r[1] * mechanics.b5.frameTranslation.frame_b.f[3]);
//   0.0 = mechanics.b5.frameTranslation.frame_a.t[3] + mechanics.b5.frameTranslation.frame_b.t[3] + (mechanics.b5.frameTranslation.r[1] * mechanics.b5.frameTranslation.frame_b.f[2] - mechanics.b5.frameTranslation.r[2] * mechanics.b5.frameTranslation.frame_b.f[1]);
//   mechanics.b5.body.r_0[1] = mechanics.b5.body.frame_a.r_0[1];
//   mechanics.b5.body.r_0[2] = mechanics.b5.body.frame_a.r_0[2];
//   mechanics.b5.body.r_0[3] = mechanics.b5.body.frame_a.r_0[3];
//   if true then
//   mechanics.b5.body.Q[1] = 0.0;
//   mechanics.b5.body.Q[2] = 0.0;
//   mechanics.b5.body.Q[3] = 0.0;
//   mechanics.b5.body.Q[4] = 1.0;
//   mechanics.b5.body.phi[1] = 0.0;
//   mechanics.b5.body.phi[2] = 0.0;
//   mechanics.b5.body.phi[3] = 0.0;
//   mechanics.b5.body.phi_d[1] = 0.0;
//   mechanics.b5.body.phi_d[2] = 0.0;
//   mechanics.b5.body.phi_d[3] = 0.0;
//   mechanics.b5.body.phi_dd[1] = 0.0;
//   mechanics.b5.body.phi_dd[2] = 0.0;
//   mechanics.b5.body.phi_dd[3] = 0.0;
//   elseif mechanics.b5.body.useQuaternions then
//   mechanics.b5.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.from_Q({mechanics.b5.body.Q[1],mechanics.b5.body.Q[2],mechanics.b5.body.Q[3],mechanics.b5.body.Q[4]},Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2({mechanics.b5.body.Q[1],mechanics.b5.body.Q[2],mechanics.b5.body.Q[3],mechanics.b5.body.Q[4]},{der(mechanics.b5.body.Q[1]),der(mechanics.b5.body.Q[2]),der(mechanics.b5.body.Q[3]),der(mechanics.b5.body.Q[4])}));
//   {0.0} = Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint({mechanics.b5.body.Q[1],mechanics.b5.body.Q[2],mechanics.b5.body.Q[3],mechanics.b5.body.Q[4]});
//   mechanics.b5.body.phi[1] = 0.0;
//   mechanics.b5.body.phi[2] = 0.0;
//   mechanics.b5.body.phi[3] = 0.0;
//   mechanics.b5.body.phi_d[1] = 0.0;
//   mechanics.b5.body.phi_d[2] = 0.0;
//   mechanics.b5.body.phi_d[3] = 0.0;
//   mechanics.b5.body.phi_dd[1] = 0.0;
//   mechanics.b5.body.phi_dd[2] = 0.0;
//   mechanics.b5.body.phi_dd[3] = 0.0;
//   else
//   mechanics.b5.body.phi_d[1] = der(mechanics.b5.body.phi[1]);
//   mechanics.b5.body.phi_d[2] = der(mechanics.b5.body.phi[2]);
//   mechanics.b5.body.phi_d[3] = der(mechanics.b5.body.phi[3]);
//   mechanics.b5.body.phi_dd[1] = der(mechanics.b5.body.phi_d[1]);
//   mechanics.b5.body.phi_dd[2] = der(mechanics.b5.body.phi_d[2]);
//   mechanics.b5.body.phi_dd[3] = der(mechanics.b5.body.phi_d[3]);
//   mechanics.b5.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.axesRotations({mechanics.b5.body.sequence_angleStates[1],mechanics.b5.body.sequence_angleStates[2],mechanics.b5.body.sequence_angleStates[3]},{mechanics.b5.body.phi[1],mechanics.b5.body.phi[2],mechanics.b5.body.phi[3]},{mechanics.b5.body.phi_d[1],mechanics.b5.body.phi_d[2],mechanics.b5.body.phi_d[3]});
//   mechanics.b5.body.Q[1] = 0.0;
//   mechanics.b5.body.Q[2] = 0.0;
//   mechanics.b5.body.Q[3] = 0.0;
//   mechanics.b5.body.Q[4] = 1.0;
//   end if;
//   mechanics.b5.body.g_0 = Modelica.Mechanics.MultiBody.Parts.Body.world__gravityAcceleration({mechanics.b5.body.frame_a.r_0[1],mechanics.b5.body.frame_a.r_0[2],mechanics.b5.body.frame_a.r_0[3]} + Modelica.Mechanics.MultiBody.Frames.resolve1(mechanics.b5.body.frame_a.R,{mechanics.b5.body.r_CM[1],mechanics.b5.body.r_CM[2],mechanics.b5.body.r_CM[3]}),mechanics.world.gravityType,mechanics.world.g * Modelica.Math.Vectors.normalize({mechanics.world.n[1],mechanics.world.n[2],mechanics.world.n[3]},1e-13),mechanics.world.mue);
//   mechanics.b5.body.v_0[1] = der(mechanics.b5.body.frame_a.r_0[1]);
//   mechanics.b5.body.v_0[2] = der(mechanics.b5.body.frame_a.r_0[2]);
//   mechanics.b5.body.v_0[3] = der(mechanics.b5.body.frame_a.r_0[3]);
//   mechanics.b5.body.a_0[1] = der(mechanics.b5.body.v_0[1]);
//   mechanics.b5.body.a_0[2] = der(mechanics.b5.body.v_0[2]);
//   mechanics.b5.body.a_0[3] = der(mechanics.b5.body.v_0[3]);
//   mechanics.b5.body.w_a = Modelica.Mechanics.MultiBody.Frames.angularVelocity2(mechanics.b5.body.frame_a.R);
//   mechanics.b5.body.z_a[1] = der(mechanics.b5.body.w_a[1]);
//   mechanics.b5.body.z_a[2] = der(mechanics.b5.body.w_a[2]);
//   mechanics.b5.body.z_a[3] = der(mechanics.b5.body.w_a[3]);
//   mechanics.b5.body.frame_a.f = mechanics.b5.body.m * (Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b5.body.frame_a.R,{mechanics.b5.body.a_0[1] - mechanics.b5.body.g_0[1],mechanics.b5.body.a_0[2] - mechanics.b5.body.g_0[2],mechanics.b5.body.a_0[3] - mechanics.b5.body.g_0[3]}) + {mechanics.b5.body.z_a[2] * mechanics.b5.body.r_CM[3] - mechanics.b5.body.z_a[3] * mechanics.b5.body.r_CM[2],mechanics.b5.body.z_a[3] * mechanics.b5.body.r_CM[1] - mechanics.b5.body.z_a[1] * mechanics.b5.body.r_CM[3],mechanics.b5.body.z_a[1] * mechanics.b5.body.r_CM[2] - mechanics.b5.body.z_a[2] * mechanics.b5.body.r_CM[1]} + {mechanics.b5.body.w_a[2] * (mechanics.b5.body.w_a[1] * mechanics.b5.body.r_CM[2] - mechanics.b5.body.w_a[2] * mechanics.b5.body.r_CM[1]) - mechanics.b5.body.w_a[3] * (mechanics.b5.body.w_a[3] * mechanics.b5.body.r_CM[1] - mechanics.b5.body.w_a[1] * mechanics.b5.body.r_CM[3]),mechanics.b5.body.w_a[3] * (mechanics.b5.body.w_a[2] * mechanics.b5.body.r_CM[3] - mechanics.b5.body.w_a[3] * mechanics.b5.body.r_CM[2]) - mechanics.b5.body.w_a[1] * (mechanics.b5.body.w_a[1] * mechanics.b5.body.r_CM[2] - mechanics.b5.body.w_a[2] * mechanics.b5.body.r_CM[1]),mechanics.b5.body.w_a[1] * (mechanics.b5.body.w_a[3] * mechanics.b5.body.r_CM[1] - mechanics.b5.body.w_a[1] * mechanics.b5.body.r_CM[3]) - mechanics.b5.body.w_a[2] * (mechanics.b5.body.w_a[2] * mechanics.b5.body.r_CM[3] - mechanics.b5.body.w_a[3] * mechanics.b5.body.r_CM[2])});
//   mechanics.b5.body.frame_a.t[1] = mechanics.b5.body.I[1,1] * mechanics.b5.body.z_a[1] + mechanics.b5.body.I[1,2] * mechanics.b5.body.z_a[2] + mechanics.b5.body.I[1,3] * mechanics.b5.body.z_a[3] + (mechanics.b5.body.w_a[2] * (mechanics.b5.body.I[3,1] * mechanics.b5.body.w_a[1] + mechanics.b5.body.I[3,2] * mechanics.b5.body.w_a[2] + mechanics.b5.body.I[3,3] * mechanics.b5.body.w_a[3]) - mechanics.b5.body.w_a[3] * (mechanics.b5.body.I[2,1] * mechanics.b5.body.w_a[1] + mechanics.b5.body.I[2,2] * mechanics.b5.body.w_a[2] + mechanics.b5.body.I[2,3] * mechanics.b5.body.w_a[3])) + (mechanics.b5.body.r_CM[2] * mechanics.b5.body.frame_a.f[3] - mechanics.b5.body.r_CM[3] * mechanics.b5.body.frame_a.f[2]);
//   mechanics.b5.body.frame_a.t[2] = mechanics.b5.body.I[2,1] * mechanics.b5.body.z_a[1] + mechanics.b5.body.I[2,2] * mechanics.b5.body.z_a[2] + mechanics.b5.body.I[2,3] * mechanics.b5.body.z_a[3] + (mechanics.b5.body.w_a[3] * (mechanics.b5.body.I[1,1] * mechanics.b5.body.w_a[1] + mechanics.b5.body.I[1,2] * mechanics.b5.body.w_a[2] + mechanics.b5.body.I[1,3] * mechanics.b5.body.w_a[3]) - mechanics.b5.body.w_a[1] * (mechanics.b5.body.I[3,1] * mechanics.b5.body.w_a[1] + mechanics.b5.body.I[3,2] * mechanics.b5.body.w_a[2] + mechanics.b5.body.I[3,3] * mechanics.b5.body.w_a[3])) + (mechanics.b5.body.r_CM[3] * mechanics.b5.body.frame_a.f[1] - mechanics.b5.body.r_CM[1] * mechanics.b5.body.frame_a.f[3]);
//   mechanics.b5.body.frame_a.t[3] = mechanics.b5.body.I[3,1] * mechanics.b5.body.z_a[1] + mechanics.b5.body.I[3,2] * mechanics.b5.body.z_a[2] + mechanics.b5.body.I[3,3] * mechanics.b5.body.z_a[3] + (mechanics.b5.body.w_a[1] * (mechanics.b5.body.I[2,1] * mechanics.b5.body.w_a[1] + mechanics.b5.body.I[2,2] * mechanics.b5.body.w_a[2] + mechanics.b5.body.I[2,3] * mechanics.b5.body.w_a[3]) - mechanics.b5.body.w_a[2] * (mechanics.b5.body.I[1,1] * mechanics.b5.body.w_a[1] + mechanics.b5.body.I[1,2] * mechanics.b5.body.w_a[2] + mechanics.b5.body.I[1,3] * mechanics.b5.body.w_a[3])) + (mechanics.b5.body.r_CM[1] * mechanics.b5.body.frame_a.f[2] - mechanics.b5.body.r_CM[2] * mechanics.b5.body.frame_a.f[1]);
//   mechanics.b5.shape1.R.T[1,1] = mechanics.b5.frame_a.R.T[1,1];
//   mechanics.b5.shape1.R.T[1,2] = mechanics.b5.frame_a.R.T[1,2];
//   mechanics.b5.shape1.R.T[1,3] = mechanics.b5.frame_a.R.T[1,3];
//   mechanics.b5.shape1.R.T[2,1] = mechanics.b5.frame_a.R.T[2,1];
//   mechanics.b5.shape1.R.T[2,2] = mechanics.b5.frame_a.R.T[2,2];
//   mechanics.b5.shape1.R.T[2,3] = mechanics.b5.frame_a.R.T[2,3];
//   mechanics.b5.shape1.R.T[3,1] = mechanics.b5.frame_a.R.T[3,1];
//   mechanics.b5.shape1.R.T[3,2] = mechanics.b5.frame_a.R.T[3,2];
//   mechanics.b5.shape1.R.T[3,3] = mechanics.b5.frame_a.R.T[3,3];
//   mechanics.b5.shape1.R.w[1] = mechanics.b5.frame_a.R.w[1];
//   mechanics.b5.shape1.R.w[2] = mechanics.b5.frame_a.R.w[2];
//   mechanics.b5.shape1.R.w[3] = mechanics.b5.frame_a.R.w[3];
//   mechanics.b5.shape1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(mechanics.b5.shape1.shapeType);
//   mechanics.b5.shape1.rxvisobj[1] = mechanics.b5.shape1.R.T[1,1] * mechanics.b5.shape1.e_x[1] + mechanics.b5.shape1.R.T[2,1] * mechanics.b5.shape1.e_x[2] + mechanics.b5.shape1.R.T[3,1] * mechanics.b5.shape1.e_x[3];
//   mechanics.b5.shape1.rxvisobj[2] = mechanics.b5.shape1.R.T[1,2] * mechanics.b5.shape1.e_x[1] + mechanics.b5.shape1.R.T[2,2] * mechanics.b5.shape1.e_x[2] + mechanics.b5.shape1.R.T[3,2] * mechanics.b5.shape1.e_x[3];
//   mechanics.b5.shape1.rxvisobj[3] = mechanics.b5.shape1.R.T[1,3] * mechanics.b5.shape1.e_x[1] + mechanics.b5.shape1.R.T[2,3] * mechanics.b5.shape1.e_x[2] + mechanics.b5.shape1.R.T[3,3] * mechanics.b5.shape1.e_x[3];
//   mechanics.b5.shape1.ryvisobj[1] = mechanics.b5.shape1.R.T[1,1] * mechanics.b5.shape1.e_y[1] + mechanics.b5.shape1.R.T[2,1] * mechanics.b5.shape1.e_y[2] + mechanics.b5.shape1.R.T[3,1] * mechanics.b5.shape1.e_y[3];
//   mechanics.b5.shape1.ryvisobj[2] = mechanics.b5.shape1.R.T[1,2] * mechanics.b5.shape1.e_y[1] + mechanics.b5.shape1.R.T[2,2] * mechanics.b5.shape1.e_y[2] + mechanics.b5.shape1.R.T[3,2] * mechanics.b5.shape1.e_y[3];
//   mechanics.b5.shape1.ryvisobj[3] = mechanics.b5.shape1.R.T[1,3] * mechanics.b5.shape1.e_y[1] + mechanics.b5.shape1.R.T[2,3] * mechanics.b5.shape1.e_y[2] + mechanics.b5.shape1.R.T[3,3] * mechanics.b5.shape1.e_y[3];
//   mechanics.b5.shape1.rvisobj = mechanics.b5.shape1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{mechanics.b5.shape1.R.T[1,1],mechanics.b5.shape1.R.T[1,2],mechanics.b5.shape1.R.T[1,3]},{mechanics.b5.shape1.R.T[2,1],mechanics.b5.shape1.R.T[2,2],mechanics.b5.shape1.R.T[2,3]},{mechanics.b5.shape1.R.T[3,1],mechanics.b5.shape1.R.T[3,2],mechanics.b5.shape1.R.T[3,3]}},{mechanics.b5.shape1.r_shape[1],mechanics.b5.shape1.r_shape[2],mechanics.b5.shape1.r_shape[3]});
//   mechanics.b5.shape1.size[1] = mechanics.b5.shape1.length;
//   mechanics.b5.shape1.size[2] = mechanics.b5.shape1.width;
//   mechanics.b5.shape1.size[3] = mechanics.b5.shape1.height;
//   mechanics.b5.shape1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(mechanics.b5.shape1.color[1] / 255.0,mechanics.b5.shape1.color[2] / 255.0,mechanics.b5.shape1.color[3] / 255.0,mechanics.b5.shape1.specularCoefficient);
//   mechanics.b5.shape1.Extra = mechanics.b5.shape1.extra;
//   mechanics.b5.r_0[1] = mechanics.b5.frame_a.r_0[1];
//   mechanics.b5.r_0[2] = mechanics.b5.frame_a.r_0[2];
//   mechanics.b5.r_0[3] = mechanics.b5.frame_a.r_0[3];
//   mechanics.b5.v_0[1] = der(mechanics.b5.r_0[1]);
//   mechanics.b5.v_0[2] = der(mechanics.b5.r_0[2]);
//   mechanics.b5.v_0[3] = der(mechanics.b5.r_0[3]);
//   mechanics.b5.a_0[1] = der(mechanics.b5.v_0[1]);
//   mechanics.b5.a_0[2] = der(mechanics.b5.v_0[2]);
//   mechanics.b5.a_0[3] = der(mechanics.b5.v_0[3]);
//   assert(true,\"Neither connector frame_a nor frame_b of FixedTranslation object is connected\");
//   mechanics.b6.frameTranslation.frame_b.r_0 = mechanics.b6.frameTranslation.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(mechanics.b6.frameTranslation.frame_a.R,{mechanics.b6.frameTranslation.r[1],mechanics.b6.frameTranslation.r[2],mechanics.b6.frameTranslation.r[3]});
//   mechanics.b6.frameTranslation.frame_b.R.T[1,1] = mechanics.b6.frameTranslation.frame_a.R.T[1,1];
//   mechanics.b6.frameTranslation.frame_b.R.T[1,2] = mechanics.b6.frameTranslation.frame_a.R.T[1,2];
//   mechanics.b6.frameTranslation.frame_b.R.T[1,3] = mechanics.b6.frameTranslation.frame_a.R.T[1,3];
//   mechanics.b6.frameTranslation.frame_b.R.T[2,1] = mechanics.b6.frameTranslation.frame_a.R.T[2,1];
//   mechanics.b6.frameTranslation.frame_b.R.T[2,2] = mechanics.b6.frameTranslation.frame_a.R.T[2,2];
//   mechanics.b6.frameTranslation.frame_b.R.T[2,3] = mechanics.b6.frameTranslation.frame_a.R.T[2,3];
//   mechanics.b6.frameTranslation.frame_b.R.T[3,1] = mechanics.b6.frameTranslation.frame_a.R.T[3,1];
//   mechanics.b6.frameTranslation.frame_b.R.T[3,2] = mechanics.b6.frameTranslation.frame_a.R.T[3,2];
//   mechanics.b6.frameTranslation.frame_b.R.T[3,3] = mechanics.b6.frameTranslation.frame_a.R.T[3,3];
//   mechanics.b6.frameTranslation.frame_b.R.w[1] = mechanics.b6.frameTranslation.frame_a.R.w[1];
//   mechanics.b6.frameTranslation.frame_b.R.w[2] = mechanics.b6.frameTranslation.frame_a.R.w[2];
//   mechanics.b6.frameTranslation.frame_b.R.w[3] = mechanics.b6.frameTranslation.frame_a.R.w[3];
//   0.0 = mechanics.b6.frameTranslation.frame_a.f[1] + mechanics.b6.frameTranslation.frame_b.f[1];
//   0.0 = mechanics.b6.frameTranslation.frame_a.f[2] + mechanics.b6.frameTranslation.frame_b.f[2];
//   0.0 = mechanics.b6.frameTranslation.frame_a.f[3] + mechanics.b6.frameTranslation.frame_b.f[3];
//   0.0 = mechanics.b6.frameTranslation.frame_a.t[1] + mechanics.b6.frameTranslation.frame_b.t[1] + (mechanics.b6.frameTranslation.r[2] * mechanics.b6.frameTranslation.frame_b.f[3] - mechanics.b6.frameTranslation.r[3] * mechanics.b6.frameTranslation.frame_b.f[2]);
//   0.0 = mechanics.b6.frameTranslation.frame_a.t[2] + mechanics.b6.frameTranslation.frame_b.t[2] + (mechanics.b6.frameTranslation.r[3] * mechanics.b6.frameTranslation.frame_b.f[1] - mechanics.b6.frameTranslation.r[1] * mechanics.b6.frameTranslation.frame_b.f[3]);
//   0.0 = mechanics.b6.frameTranslation.frame_a.t[3] + mechanics.b6.frameTranslation.frame_b.t[3] + (mechanics.b6.frameTranslation.r[1] * mechanics.b6.frameTranslation.frame_b.f[2] - mechanics.b6.frameTranslation.r[2] * mechanics.b6.frameTranslation.frame_b.f[1]);
//   mechanics.b6.body.r_0[1] = mechanics.b6.body.frame_a.r_0[1];
//   mechanics.b6.body.r_0[2] = mechanics.b6.body.frame_a.r_0[2];
//   mechanics.b6.body.r_0[3] = mechanics.b6.body.frame_a.r_0[3];
//   if true then
//   mechanics.b6.body.Q[1] = 0.0;
//   mechanics.b6.body.Q[2] = 0.0;
//   mechanics.b6.body.Q[3] = 0.0;
//   mechanics.b6.body.Q[4] = 1.0;
//   mechanics.b6.body.phi[1] = 0.0;
//   mechanics.b6.body.phi[2] = 0.0;
//   mechanics.b6.body.phi[3] = 0.0;
//   mechanics.b6.body.phi_d[1] = 0.0;
//   mechanics.b6.body.phi_d[2] = 0.0;
//   mechanics.b6.body.phi_d[3] = 0.0;
//   mechanics.b6.body.phi_dd[1] = 0.0;
//   mechanics.b6.body.phi_dd[2] = 0.0;
//   mechanics.b6.body.phi_dd[3] = 0.0;
//   elseif mechanics.b6.body.useQuaternions then
//   mechanics.b6.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.from_Q({mechanics.b6.body.Q[1],mechanics.b6.body.Q[2],mechanics.b6.body.Q[3],mechanics.b6.body.Q[4]},Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2({mechanics.b6.body.Q[1],mechanics.b6.body.Q[2],mechanics.b6.body.Q[3],mechanics.b6.body.Q[4]},{der(mechanics.b6.body.Q[1]),der(mechanics.b6.body.Q[2]),der(mechanics.b6.body.Q[3]),der(mechanics.b6.body.Q[4])}));
//   {0.0} = Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint({mechanics.b6.body.Q[1],mechanics.b6.body.Q[2],mechanics.b6.body.Q[3],mechanics.b6.body.Q[4]});
//   mechanics.b6.body.phi[1] = 0.0;
//   mechanics.b6.body.phi[2] = 0.0;
//   mechanics.b6.body.phi[3] = 0.0;
//   mechanics.b6.body.phi_d[1] = 0.0;
//   mechanics.b6.body.phi_d[2] = 0.0;
//   mechanics.b6.body.phi_d[3] = 0.0;
//   mechanics.b6.body.phi_dd[1] = 0.0;
//   mechanics.b6.body.phi_dd[2] = 0.0;
//   mechanics.b6.body.phi_dd[3] = 0.0;
//   else
//   mechanics.b6.body.phi_d[1] = der(mechanics.b6.body.phi[1]);
//   mechanics.b6.body.phi_d[2] = der(mechanics.b6.body.phi[2]);
//   mechanics.b6.body.phi_d[3] = der(mechanics.b6.body.phi[3]);
//   mechanics.b6.body.phi_dd[1] = der(mechanics.b6.body.phi_d[1]);
//   mechanics.b6.body.phi_dd[2] = der(mechanics.b6.body.phi_d[2]);
//   mechanics.b6.body.phi_dd[3] = der(mechanics.b6.body.phi_d[3]);
//   mechanics.b6.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.axesRotations({mechanics.b6.body.sequence_angleStates[1],mechanics.b6.body.sequence_angleStates[2],mechanics.b6.body.sequence_angleStates[3]},{mechanics.b6.body.phi[1],mechanics.b6.body.phi[2],mechanics.b6.body.phi[3]},{mechanics.b6.body.phi_d[1],mechanics.b6.body.phi_d[2],mechanics.b6.body.phi_d[3]});
//   mechanics.b6.body.Q[1] = 0.0;
//   mechanics.b6.body.Q[2] = 0.0;
//   mechanics.b6.body.Q[3] = 0.0;
//   mechanics.b6.body.Q[4] = 1.0;
//   end if;
//   mechanics.b6.body.g_0 = Modelica.Mechanics.MultiBody.Parts.Body.world__gravityAcceleration({mechanics.b6.body.frame_a.r_0[1],mechanics.b6.body.frame_a.r_0[2],mechanics.b6.body.frame_a.r_0[3]} + Modelica.Mechanics.MultiBody.Frames.resolve1(mechanics.b6.body.frame_a.R,{mechanics.b6.body.r_CM[1],mechanics.b6.body.r_CM[2],mechanics.b6.body.r_CM[3]}),mechanics.world.gravityType,mechanics.world.g * Modelica.Math.Vectors.normalize({mechanics.world.n[1],mechanics.world.n[2],mechanics.world.n[3]},1e-13),mechanics.world.mue);
//   mechanics.b6.body.v_0[1] = der(mechanics.b6.body.frame_a.r_0[1]);
//   mechanics.b6.body.v_0[2] = der(mechanics.b6.body.frame_a.r_0[2]);
//   mechanics.b6.body.v_0[3] = der(mechanics.b6.body.frame_a.r_0[3]);
//   mechanics.b6.body.a_0[1] = der(mechanics.b6.body.v_0[1]);
//   mechanics.b6.body.a_0[2] = der(mechanics.b6.body.v_0[2]);
//   mechanics.b6.body.a_0[3] = der(mechanics.b6.body.v_0[3]);
//   mechanics.b6.body.w_a = Modelica.Mechanics.MultiBody.Frames.angularVelocity2(mechanics.b6.body.frame_a.R);
//   mechanics.b6.body.z_a[1] = der(mechanics.b6.body.w_a[1]);
//   mechanics.b6.body.z_a[2] = der(mechanics.b6.body.w_a[2]);
//   mechanics.b6.body.z_a[3] = der(mechanics.b6.body.w_a[3]);
//   mechanics.b6.body.frame_a.f = mechanics.b6.body.m * (Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.b6.body.frame_a.R,{mechanics.b6.body.a_0[1] - mechanics.b6.body.g_0[1],mechanics.b6.body.a_0[2] - mechanics.b6.body.g_0[2],mechanics.b6.body.a_0[3] - mechanics.b6.body.g_0[3]}) + {mechanics.b6.body.z_a[2] * mechanics.b6.body.r_CM[3] - mechanics.b6.body.z_a[3] * mechanics.b6.body.r_CM[2],mechanics.b6.body.z_a[3] * mechanics.b6.body.r_CM[1] - mechanics.b6.body.z_a[1] * mechanics.b6.body.r_CM[3],mechanics.b6.body.z_a[1] * mechanics.b6.body.r_CM[2] - mechanics.b6.body.z_a[2] * mechanics.b6.body.r_CM[1]} + {mechanics.b6.body.w_a[2] * (mechanics.b6.body.w_a[1] * mechanics.b6.body.r_CM[2] - mechanics.b6.body.w_a[2] * mechanics.b6.body.r_CM[1]) - mechanics.b6.body.w_a[3] * (mechanics.b6.body.w_a[3] * mechanics.b6.body.r_CM[1] - mechanics.b6.body.w_a[1] * mechanics.b6.body.r_CM[3]),mechanics.b6.body.w_a[3] * (mechanics.b6.body.w_a[2] * mechanics.b6.body.r_CM[3] - mechanics.b6.body.w_a[3] * mechanics.b6.body.r_CM[2]) - mechanics.b6.body.w_a[1] * (mechanics.b6.body.w_a[1] * mechanics.b6.body.r_CM[2] - mechanics.b6.body.w_a[2] * mechanics.b6.body.r_CM[1]),mechanics.b6.body.w_a[1] * (mechanics.b6.body.w_a[3] * mechanics.b6.body.r_CM[1] - mechanics.b6.body.w_a[1] * mechanics.b6.body.r_CM[3]) - mechanics.b6.body.w_a[2] * (mechanics.b6.body.w_a[2] * mechanics.b6.body.r_CM[3] - mechanics.b6.body.w_a[3] * mechanics.b6.body.r_CM[2])});
//   mechanics.b6.body.frame_a.t[1] = mechanics.b6.body.I[1,1] * mechanics.b6.body.z_a[1] + mechanics.b6.body.I[1,2] * mechanics.b6.body.z_a[2] + mechanics.b6.body.I[1,3] * mechanics.b6.body.z_a[3] + (mechanics.b6.body.w_a[2] * (mechanics.b6.body.I[3,1] * mechanics.b6.body.w_a[1] + mechanics.b6.body.I[3,2] * mechanics.b6.body.w_a[2] + mechanics.b6.body.I[3,3] * mechanics.b6.body.w_a[3]) - mechanics.b6.body.w_a[3] * (mechanics.b6.body.I[2,1] * mechanics.b6.body.w_a[1] + mechanics.b6.body.I[2,2] * mechanics.b6.body.w_a[2] + mechanics.b6.body.I[2,3] * mechanics.b6.body.w_a[3])) + (mechanics.b6.body.r_CM[2] * mechanics.b6.body.frame_a.f[3] - mechanics.b6.body.r_CM[3] * mechanics.b6.body.frame_a.f[2]);
//   mechanics.b6.body.frame_a.t[2] = mechanics.b6.body.I[2,1] * mechanics.b6.body.z_a[1] + mechanics.b6.body.I[2,2] * mechanics.b6.body.z_a[2] + mechanics.b6.body.I[2,3] * mechanics.b6.body.z_a[3] + (mechanics.b6.body.w_a[3] * (mechanics.b6.body.I[1,1] * mechanics.b6.body.w_a[1] + mechanics.b6.body.I[1,2] * mechanics.b6.body.w_a[2] + mechanics.b6.body.I[1,3] * mechanics.b6.body.w_a[3]) - mechanics.b6.body.w_a[1] * (mechanics.b6.body.I[3,1] * mechanics.b6.body.w_a[1] + mechanics.b6.body.I[3,2] * mechanics.b6.body.w_a[2] + mechanics.b6.body.I[3,3] * mechanics.b6.body.w_a[3])) + (mechanics.b6.body.r_CM[3] * mechanics.b6.body.frame_a.f[1] - mechanics.b6.body.r_CM[1] * mechanics.b6.body.frame_a.f[3]);
//   mechanics.b6.body.frame_a.t[3] = mechanics.b6.body.I[3,1] * mechanics.b6.body.z_a[1] + mechanics.b6.body.I[3,2] * mechanics.b6.body.z_a[2] + mechanics.b6.body.I[3,3] * mechanics.b6.body.z_a[3] + (mechanics.b6.body.w_a[1] * (mechanics.b6.body.I[2,1] * mechanics.b6.body.w_a[1] + mechanics.b6.body.I[2,2] * mechanics.b6.body.w_a[2] + mechanics.b6.body.I[2,3] * mechanics.b6.body.w_a[3]) - mechanics.b6.body.w_a[2] * (mechanics.b6.body.I[1,1] * mechanics.b6.body.w_a[1] + mechanics.b6.body.I[1,2] * mechanics.b6.body.w_a[2] + mechanics.b6.body.I[1,3] * mechanics.b6.body.w_a[3])) + (mechanics.b6.body.r_CM[1] * mechanics.b6.body.frame_a.f[2] - mechanics.b6.body.r_CM[2] * mechanics.b6.body.frame_a.f[1]);
//   mechanics.b6.shape1.R.T[1,1] = mechanics.b6.frame_a.R.T[1,1];
//   mechanics.b6.shape1.R.T[1,2] = mechanics.b6.frame_a.R.T[1,2];
//   mechanics.b6.shape1.R.T[1,3] = mechanics.b6.frame_a.R.T[1,3];
//   mechanics.b6.shape1.R.T[2,1] = mechanics.b6.frame_a.R.T[2,1];
//   mechanics.b6.shape1.R.T[2,2] = mechanics.b6.frame_a.R.T[2,2];
//   mechanics.b6.shape1.R.T[2,3] = mechanics.b6.frame_a.R.T[2,3];
//   mechanics.b6.shape1.R.T[3,1] = mechanics.b6.frame_a.R.T[3,1];
//   mechanics.b6.shape1.R.T[3,2] = mechanics.b6.frame_a.R.T[3,2];
//   mechanics.b6.shape1.R.T[3,3] = mechanics.b6.frame_a.R.T[3,3];
//   mechanics.b6.shape1.R.w[1] = mechanics.b6.frame_a.R.w[1];
//   mechanics.b6.shape1.R.w[2] = mechanics.b6.frame_a.R.w[2];
//   mechanics.b6.shape1.R.w[3] = mechanics.b6.frame_a.R.w[3];
//   mechanics.b6.shape1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(mechanics.b6.shape1.shapeType);
//   mechanics.b6.shape1.rxvisobj[1] = mechanics.b6.shape1.R.T[1,1] * mechanics.b6.shape1.e_x[1] + mechanics.b6.shape1.R.T[2,1] * mechanics.b6.shape1.e_x[2] + mechanics.b6.shape1.R.T[3,1] * mechanics.b6.shape1.e_x[3];
//   mechanics.b6.shape1.rxvisobj[2] = mechanics.b6.shape1.R.T[1,2] * mechanics.b6.shape1.e_x[1] + mechanics.b6.shape1.R.T[2,2] * mechanics.b6.shape1.e_x[2] + mechanics.b6.shape1.R.T[3,2] * mechanics.b6.shape1.e_x[3];
//   mechanics.b6.shape1.rxvisobj[3] = mechanics.b6.shape1.R.T[1,3] * mechanics.b6.shape1.e_x[1] + mechanics.b6.shape1.R.T[2,3] * mechanics.b6.shape1.e_x[2] + mechanics.b6.shape1.R.T[3,3] * mechanics.b6.shape1.e_x[3];
//   mechanics.b6.shape1.ryvisobj[1] = mechanics.b6.shape1.R.T[1,1] * mechanics.b6.shape1.e_y[1] + mechanics.b6.shape1.R.T[2,1] * mechanics.b6.shape1.e_y[2] + mechanics.b6.shape1.R.T[3,1] * mechanics.b6.shape1.e_y[3];
//   mechanics.b6.shape1.ryvisobj[2] = mechanics.b6.shape1.R.T[1,2] * mechanics.b6.shape1.e_y[1] + mechanics.b6.shape1.R.T[2,2] * mechanics.b6.shape1.e_y[2] + mechanics.b6.shape1.R.T[3,2] * mechanics.b6.shape1.e_y[3];
//   mechanics.b6.shape1.ryvisobj[3] = mechanics.b6.shape1.R.T[1,3] * mechanics.b6.shape1.e_y[1] + mechanics.b6.shape1.R.T[2,3] * mechanics.b6.shape1.e_y[2] + mechanics.b6.shape1.R.T[3,3] * mechanics.b6.shape1.e_y[3];
//   mechanics.b6.shape1.rvisobj = mechanics.b6.shape1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{mechanics.b6.shape1.R.T[1,1],mechanics.b6.shape1.R.T[1,2],mechanics.b6.shape1.R.T[1,3]},{mechanics.b6.shape1.R.T[2,1],mechanics.b6.shape1.R.T[2,2],mechanics.b6.shape1.R.T[2,3]},{mechanics.b6.shape1.R.T[3,1],mechanics.b6.shape1.R.T[3,2],mechanics.b6.shape1.R.T[3,3]}},{mechanics.b6.shape1.r_shape[1],mechanics.b6.shape1.r_shape[2],mechanics.b6.shape1.r_shape[3]});
//   mechanics.b6.shape1.size[1] = mechanics.b6.shape1.length;
//   mechanics.b6.shape1.size[2] = mechanics.b6.shape1.width;
//   mechanics.b6.shape1.size[3] = mechanics.b6.shape1.height;
//   mechanics.b6.shape1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(mechanics.b6.shape1.color[1] / 255.0,mechanics.b6.shape1.color[2] / 255.0,mechanics.b6.shape1.color[3] / 255.0,mechanics.b6.shape1.specularCoefficient);
//   mechanics.b6.shape1.Extra = mechanics.b6.shape1.extra;
//   mechanics.b6.r_0[1] = mechanics.b6.frame_a.r_0[1];
//   mechanics.b6.r_0[2] = mechanics.b6.frame_a.r_0[2];
//   mechanics.b6.r_0[3] = mechanics.b6.frame_a.r_0[3];
//   mechanics.b6.v_0[1] = der(mechanics.b6.r_0[1]);
//   mechanics.b6.v_0[2] = der(mechanics.b6.r_0[2]);
//   mechanics.b6.v_0[3] = der(mechanics.b6.r_0[3]);
//   mechanics.b6.a_0[1] = der(mechanics.b6.v_0[1]);
//   mechanics.b6.a_0[2] = der(mechanics.b6.v_0[2]);
//   mechanics.b6.a_0[3] = der(mechanics.b6.v_0[3]);
//   assert(true,\"Neither connector frame_a nor frame_b of FixedTranslation object is connected\");
//   mechanics.load.frameTranslation.frame_b.r_0 = mechanics.load.frameTranslation.frame_a.r_0 + Modelica.Mechanics.MultiBody.Frames.resolve1(mechanics.load.frameTranslation.frame_a.R,{mechanics.load.frameTranslation.r[1],mechanics.load.frameTranslation.r[2],mechanics.load.frameTranslation.r[3]});
//   mechanics.load.frameTranslation.frame_b.R.T[1,1] = mechanics.load.frameTranslation.frame_a.R.T[1,1];
//   mechanics.load.frameTranslation.frame_b.R.T[1,2] = mechanics.load.frameTranslation.frame_a.R.T[1,2];
//   mechanics.load.frameTranslation.frame_b.R.T[1,3] = mechanics.load.frameTranslation.frame_a.R.T[1,3];
//   mechanics.load.frameTranslation.frame_b.R.T[2,1] = mechanics.load.frameTranslation.frame_a.R.T[2,1];
//   mechanics.load.frameTranslation.frame_b.R.T[2,2] = mechanics.load.frameTranslation.frame_a.R.T[2,2];
//   mechanics.load.frameTranslation.frame_b.R.T[2,3] = mechanics.load.frameTranslation.frame_a.R.T[2,3];
//   mechanics.load.frameTranslation.frame_b.R.T[3,1] = mechanics.load.frameTranslation.frame_a.R.T[3,1];
//   mechanics.load.frameTranslation.frame_b.R.T[3,2] = mechanics.load.frameTranslation.frame_a.R.T[3,2];
//   mechanics.load.frameTranslation.frame_b.R.T[3,3] = mechanics.load.frameTranslation.frame_a.R.T[3,3];
//   mechanics.load.frameTranslation.frame_b.R.w[1] = mechanics.load.frameTranslation.frame_a.R.w[1];
//   mechanics.load.frameTranslation.frame_b.R.w[2] = mechanics.load.frameTranslation.frame_a.R.w[2];
//   mechanics.load.frameTranslation.frame_b.R.w[3] = mechanics.load.frameTranslation.frame_a.R.w[3];
//   0.0 = mechanics.load.frameTranslation.frame_a.f[1] + mechanics.load.frameTranslation.frame_b.f[1];
//   0.0 = mechanics.load.frameTranslation.frame_a.f[2] + mechanics.load.frameTranslation.frame_b.f[2];
//   0.0 = mechanics.load.frameTranslation.frame_a.f[3] + mechanics.load.frameTranslation.frame_b.f[3];
//   0.0 = mechanics.load.frameTranslation.frame_a.t[1] + mechanics.load.frameTranslation.frame_b.t[1] + (mechanics.load.frameTranslation.r[2] * mechanics.load.frameTranslation.frame_b.f[3] - mechanics.load.frameTranslation.r[3] * mechanics.load.frameTranslation.frame_b.f[2]);
//   0.0 = mechanics.load.frameTranslation.frame_a.t[2] + mechanics.load.frameTranslation.frame_b.t[2] + (mechanics.load.frameTranslation.r[3] * mechanics.load.frameTranslation.frame_b.f[1] - mechanics.load.frameTranslation.r[1] * mechanics.load.frameTranslation.frame_b.f[3]);
//   0.0 = mechanics.load.frameTranslation.frame_a.t[3] + mechanics.load.frameTranslation.frame_b.t[3] + (mechanics.load.frameTranslation.r[1] * mechanics.load.frameTranslation.frame_b.f[2] - mechanics.load.frameTranslation.r[2] * mechanics.load.frameTranslation.frame_b.f[1]);
//   mechanics.load.body.r_0[1] = mechanics.load.body.frame_a.r_0[1];
//   mechanics.load.body.r_0[2] = mechanics.load.body.frame_a.r_0[2];
//   mechanics.load.body.r_0[3] = mechanics.load.body.frame_a.r_0[3];
//   if true then
//   mechanics.load.body.Q[1] = 0.0;
//   mechanics.load.body.Q[2] = 0.0;
//   mechanics.load.body.Q[3] = 0.0;
//   mechanics.load.body.Q[4] = 1.0;
//   mechanics.load.body.phi[1] = 0.0;
//   mechanics.load.body.phi[2] = 0.0;
//   mechanics.load.body.phi[3] = 0.0;
//   mechanics.load.body.phi_d[1] = 0.0;
//   mechanics.load.body.phi_d[2] = 0.0;
//   mechanics.load.body.phi_d[3] = 0.0;
//   mechanics.load.body.phi_dd[1] = 0.0;
//   mechanics.load.body.phi_dd[2] = 0.0;
//   mechanics.load.body.phi_dd[3] = 0.0;
//   elseif mechanics.load.body.useQuaternions then
//   mechanics.load.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.from_Q({mechanics.load.body.Q[1],mechanics.load.body.Q[2],mechanics.load.body.Q[3],mechanics.load.body.Q[4]},Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2({mechanics.load.body.Q[1],mechanics.load.body.Q[2],mechanics.load.body.Q[3],mechanics.load.body.Q[4]},{der(mechanics.load.body.Q[1]),der(mechanics.load.body.Q[2]),der(mechanics.load.body.Q[3]),der(mechanics.load.body.Q[4])}));
//   {0.0} = Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint({mechanics.load.body.Q[1],mechanics.load.body.Q[2],mechanics.load.body.Q[3],mechanics.load.body.Q[4]});
//   mechanics.load.body.phi[1] = 0.0;
//   mechanics.load.body.phi[2] = 0.0;
//   mechanics.load.body.phi[3] = 0.0;
//   mechanics.load.body.phi_d[1] = 0.0;
//   mechanics.load.body.phi_d[2] = 0.0;
//   mechanics.load.body.phi_d[3] = 0.0;
//   mechanics.load.body.phi_dd[1] = 0.0;
//   mechanics.load.body.phi_dd[2] = 0.0;
//   mechanics.load.body.phi_dd[3] = 0.0;
//   else
//   mechanics.load.body.phi_d[1] = der(mechanics.load.body.phi[1]);
//   mechanics.load.body.phi_d[2] = der(mechanics.load.body.phi[2]);
//   mechanics.load.body.phi_d[3] = der(mechanics.load.body.phi[3]);
//   mechanics.load.body.phi_dd[1] = der(mechanics.load.body.phi_d[1]);
//   mechanics.load.body.phi_dd[2] = der(mechanics.load.body.phi_d[2]);
//   mechanics.load.body.phi_dd[3] = der(mechanics.load.body.phi_d[3]);
//   mechanics.load.body.frame_a.R = Modelica.Mechanics.MultiBody.Frames.axesRotations({mechanics.load.body.sequence_angleStates[1],mechanics.load.body.sequence_angleStates[2],mechanics.load.body.sequence_angleStates[3]},{mechanics.load.body.phi[1],mechanics.load.body.phi[2],mechanics.load.body.phi[3]},{mechanics.load.body.phi_d[1],mechanics.load.body.phi_d[2],mechanics.load.body.phi_d[3]});
//   mechanics.load.body.Q[1] = 0.0;
//   mechanics.load.body.Q[2] = 0.0;
//   mechanics.load.body.Q[3] = 0.0;
//   mechanics.load.body.Q[4] = 1.0;
//   end if;
//   mechanics.load.body.g_0 = Modelica.Mechanics.MultiBody.Parts.Body.world__gravityAcceleration({mechanics.load.body.frame_a.r_0[1],mechanics.load.body.frame_a.r_0[2],mechanics.load.body.frame_a.r_0[3]} + Modelica.Mechanics.MultiBody.Frames.resolve1(mechanics.load.body.frame_a.R,{mechanics.load.body.r_CM[1],mechanics.load.body.r_CM[2],mechanics.load.body.r_CM[3]}),mechanics.world.gravityType,mechanics.world.g * Modelica.Math.Vectors.normalize({mechanics.world.n[1],mechanics.world.n[2],mechanics.world.n[3]},1e-13),mechanics.world.mue);
//   mechanics.load.body.v_0[1] = der(mechanics.load.body.frame_a.r_0[1]);
//   mechanics.load.body.v_0[2] = der(mechanics.load.body.frame_a.r_0[2]);
//   mechanics.load.body.v_0[3] = der(mechanics.load.body.frame_a.r_0[3]);
//   mechanics.load.body.a_0[1] = der(mechanics.load.body.v_0[1]);
//   mechanics.load.body.a_0[2] = der(mechanics.load.body.v_0[2]);
//   mechanics.load.body.a_0[3] = der(mechanics.load.body.v_0[3]);
//   mechanics.load.body.w_a = Modelica.Mechanics.MultiBody.Frames.angularVelocity2(mechanics.load.body.frame_a.R);
//   mechanics.load.body.z_a[1] = der(mechanics.load.body.w_a[1]);
//   mechanics.load.body.z_a[2] = der(mechanics.load.body.w_a[2]);
//   mechanics.load.body.z_a[3] = der(mechanics.load.body.w_a[3]);
//   mechanics.load.body.frame_a.f = mechanics.load.body.m * (Modelica.Mechanics.MultiBody.Frames.resolve2(mechanics.load.body.frame_a.R,{mechanics.load.body.a_0[1] - mechanics.load.body.g_0[1],mechanics.load.body.a_0[2] - mechanics.load.body.g_0[2],mechanics.load.body.a_0[3] - mechanics.load.body.g_0[3]}) + {mechanics.load.body.z_a[2] * mechanics.load.body.r_CM[3] - mechanics.load.body.z_a[3] * mechanics.load.body.r_CM[2],mechanics.load.body.z_a[3] * mechanics.load.body.r_CM[1] - mechanics.load.body.z_a[1] * mechanics.load.body.r_CM[3],mechanics.load.body.z_a[1] * mechanics.load.body.r_CM[2] - mechanics.load.body.z_a[2] * mechanics.load.body.r_CM[1]} + {mechanics.load.body.w_a[2] * (mechanics.load.body.w_a[1] * mechanics.load.body.r_CM[2] - mechanics.load.body.w_a[2] * mechanics.load.body.r_CM[1]) - mechanics.load.body.w_a[3] * (mechanics.load.body.w_a[3] * mechanics.load.body.r_CM[1] - mechanics.load.body.w_a[1] * mechanics.load.body.r_CM[3]),mechanics.load.body.w_a[3] * (mechanics.load.body.w_a[2] * mechanics.load.body.r_CM[3] - mechanics.load.body.w_a[3] * mechanics.load.body.r_CM[2]) - mechanics.load.body.w_a[1] * (mechanics.load.body.w_a[1] * mechanics.load.body.r_CM[2] - mechanics.load.body.w_a[2] * mechanics.load.body.r_CM[1]),mechanics.load.body.w_a[1] * (mechanics.load.body.w_a[3] * mechanics.load.body.r_CM[1] - mechanics.load.body.w_a[1] * mechanics.load.body.r_CM[3]) - mechanics.load.body.w_a[2] * (mechanics.load.body.w_a[2] * mechanics.load.body.r_CM[3] - mechanics.load.body.w_a[3] * mechanics.load.body.r_CM[2])});
//   mechanics.load.body.frame_a.t[1] = mechanics.load.body.I[1,1] * mechanics.load.body.z_a[1] + mechanics.load.body.I[1,2] * mechanics.load.body.z_a[2] + mechanics.load.body.I[1,3] * mechanics.load.body.z_a[3] + (mechanics.load.body.w_a[2] * (mechanics.load.body.I[3,1] * mechanics.load.body.w_a[1] + mechanics.load.body.I[3,2] * mechanics.load.body.w_a[2] + mechanics.load.body.I[3,3] * mechanics.load.body.w_a[3]) - mechanics.load.body.w_a[3] * (mechanics.load.body.I[2,1] * mechanics.load.body.w_a[1] + mechanics.load.body.I[2,2] * mechanics.load.body.w_a[2] + mechanics.load.body.I[2,3] * mechanics.load.body.w_a[3])) + (mechanics.load.body.r_CM[2] * mechanics.load.body.frame_a.f[3] - mechanics.load.body.r_CM[3] * mechanics.load.body.frame_a.f[2]);
//   mechanics.load.body.frame_a.t[2] = mechanics.load.body.I[2,1] * mechanics.load.body.z_a[1] + mechanics.load.body.I[2,2] * mechanics.load.body.z_a[2] + mechanics.load.body.I[2,3] * mechanics.load.body.z_a[3] + (mechanics.load.body.w_a[3] * (mechanics.load.body.I[1,1] * mechanics.load.body.w_a[1] + mechanics.load.body.I[1,2] * mechanics.load.body.w_a[2] + mechanics.load.body.I[1,3] * mechanics.load.body.w_a[3]) - mechanics.load.body.w_a[1] * (mechanics.load.body.I[3,1] * mechanics.load.body.w_a[1] + mechanics.load.body.I[3,2] * mechanics.load.body.w_a[2] + mechanics.load.body.I[3,3] * mechanics.load.body.w_a[3])) + (mechanics.load.body.r_CM[3] * mechanics.load.body.frame_a.f[1] - mechanics.load.body.r_CM[1] * mechanics.load.body.frame_a.f[3]);
//   mechanics.load.body.frame_a.t[3] = mechanics.load.body.I[3,1] * mechanics.load.body.z_a[1] + mechanics.load.body.I[3,2] * mechanics.load.body.z_a[2] + mechanics.load.body.I[3,3] * mechanics.load.body.z_a[3] + (mechanics.load.body.w_a[1] * (mechanics.load.body.I[2,1] * mechanics.load.body.w_a[1] + mechanics.load.body.I[2,2] * mechanics.load.body.w_a[2] + mechanics.load.body.I[2,3] * mechanics.load.body.w_a[3]) - mechanics.load.body.w_a[2] * (mechanics.load.body.I[1,1] * mechanics.load.body.w_a[1] + mechanics.load.body.I[1,2] * mechanics.load.body.w_a[2] + mechanics.load.body.I[1,3] * mechanics.load.body.w_a[3])) + (mechanics.load.body.r_CM[1] * mechanics.load.body.frame_a.f[2] - mechanics.load.body.r_CM[2] * mechanics.load.body.frame_a.f[1]);
//   mechanics.load.shape1.R.T[1,1] = mechanics.load.frame_a.R.T[1,1];
//   mechanics.load.shape1.R.T[1,2] = mechanics.load.frame_a.R.T[1,2];
//   mechanics.load.shape1.R.T[1,3] = mechanics.load.frame_a.R.T[1,3];
//   mechanics.load.shape1.R.T[2,1] = mechanics.load.frame_a.R.T[2,1];
//   mechanics.load.shape1.R.T[2,2] = mechanics.load.frame_a.R.T[2,2];
//   mechanics.load.shape1.R.T[2,3] = mechanics.load.frame_a.R.T[2,3];
//   mechanics.load.shape1.R.T[3,1] = mechanics.load.frame_a.R.T[3,1];
//   mechanics.load.shape1.R.T[3,2] = mechanics.load.frame_a.R.T[3,2];
//   mechanics.load.shape1.R.T[3,3] = mechanics.load.frame_a.R.T[3,3];
//   mechanics.load.shape1.R.w[1] = mechanics.load.frame_a.R.w[1];
//   mechanics.load.shape1.R.w[2] = mechanics.load.frame_a.R.w[2];
//   mechanics.load.shape1.R.w[3] = mechanics.load.frame_a.R.w[3];
//   mechanics.load.shape1.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(mechanics.load.shape1.shapeType);
//   mechanics.load.shape1.rxvisobj[1] = mechanics.load.shape1.R.T[1,1] * mechanics.load.shape1.e_x[1] + mechanics.load.shape1.R.T[2,1] * mechanics.load.shape1.e_x[2] + mechanics.load.shape1.R.T[3,1] * mechanics.load.shape1.e_x[3];
//   mechanics.load.shape1.rxvisobj[2] = mechanics.load.shape1.R.T[1,2] * mechanics.load.shape1.e_x[1] + mechanics.load.shape1.R.T[2,2] * mechanics.load.shape1.e_x[2] + mechanics.load.shape1.R.T[3,2] * mechanics.load.shape1.e_x[3];
//   mechanics.load.shape1.rxvisobj[3] = mechanics.load.shape1.R.T[1,3] * mechanics.load.shape1.e_x[1] + mechanics.load.shape1.R.T[2,3] * mechanics.load.shape1.e_x[2] + mechanics.load.shape1.R.T[3,3] * mechanics.load.shape1.e_x[3];
//   mechanics.load.shape1.ryvisobj[1] = mechanics.load.shape1.R.T[1,1] * mechanics.load.shape1.e_y[1] + mechanics.load.shape1.R.T[2,1] * mechanics.load.shape1.e_y[2] + mechanics.load.shape1.R.T[3,1] * mechanics.load.shape1.e_y[3];
//   mechanics.load.shape1.ryvisobj[2] = mechanics.load.shape1.R.T[1,2] * mechanics.load.shape1.e_y[1] + mechanics.load.shape1.R.T[2,2] * mechanics.load.shape1.e_y[2] + mechanics.load.shape1.R.T[3,2] * mechanics.load.shape1.e_y[3];
//   mechanics.load.shape1.ryvisobj[3] = mechanics.load.shape1.R.T[1,3] * mechanics.load.shape1.e_y[1] + mechanics.load.shape1.R.T[2,3] * mechanics.load.shape1.e_y[2] + mechanics.load.shape1.R.T[3,3] * mechanics.load.shape1.e_y[3];
//   mechanics.load.shape1.rvisobj = mechanics.load.shape1.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{mechanics.load.shape1.R.T[1,1],mechanics.load.shape1.R.T[1,2],mechanics.load.shape1.R.T[1,3]},{mechanics.load.shape1.R.T[2,1],mechanics.load.shape1.R.T[2,2],mechanics.load.shape1.R.T[2,3]},{mechanics.load.shape1.R.T[3,1],mechanics.load.shape1.R.T[3,2],mechanics.load.shape1.R.T[3,3]}},{mechanics.load.shape1.r_shape[1],mechanics.load.shape1.r_shape[2],mechanics.load.shape1.r_shape[3]});
//   mechanics.load.shape1.size[1] = mechanics.load.shape1.length;
//   mechanics.load.shape1.size[2] = mechanics.load.shape1.width;
//   mechanics.load.shape1.size[3] = mechanics.load.shape1.height;
//   mechanics.load.shape1.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(mechanics.load.shape1.color[1] / 255.0,mechanics.load.shape1.color[2] / 255.0,mechanics.load.shape1.color[3] / 255.0,mechanics.load.shape1.specularCoefficient);
//   mechanics.load.shape1.Extra = mechanics.load.shape1.extra;
//   mechanics.load.shape2.R.T[1,1] = mechanics.load.frame_a.R.T[1,1];
//   mechanics.load.shape2.R.T[1,2] = mechanics.load.frame_a.R.T[1,2];
//   mechanics.load.shape2.R.T[1,3] = mechanics.load.frame_a.R.T[1,3];
//   mechanics.load.shape2.R.T[2,1] = mechanics.load.frame_a.R.T[2,1];
//   mechanics.load.shape2.R.T[2,2] = mechanics.load.frame_a.R.T[2,2];
//   mechanics.load.shape2.R.T[2,3] = mechanics.load.frame_a.R.T[2,3];
//   mechanics.load.shape2.R.T[3,1] = mechanics.load.frame_a.R.T[3,1];
//   mechanics.load.shape2.R.T[3,2] = mechanics.load.frame_a.R.T[3,2];
//   mechanics.load.shape2.R.T[3,3] = mechanics.load.frame_a.R.T[3,3];
//   mechanics.load.shape2.R.w[1] = mechanics.load.frame_a.R.w[1];
//   mechanics.load.shape2.R.w[2] = mechanics.load.frame_a.R.w[2];
//   mechanics.load.shape2.R.w[3] = mechanics.load.frame_a.R.w[3];
//   mechanics.load.shape2.Form = 9.87e+25 + 1e+20 * Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackShape(mechanics.load.shape2.shapeType);
//   mechanics.load.shape2.rxvisobj[1] = mechanics.load.shape2.R.T[1,1] * mechanics.load.shape2.e_x[1] + mechanics.load.shape2.R.T[2,1] * mechanics.load.shape2.e_x[2] + mechanics.load.shape2.R.T[3,1] * mechanics.load.shape2.e_x[3];
//   mechanics.load.shape2.rxvisobj[2] = mechanics.load.shape2.R.T[1,2] * mechanics.load.shape2.e_x[1] + mechanics.load.shape2.R.T[2,2] * mechanics.load.shape2.e_x[2] + mechanics.load.shape2.R.T[3,2] * mechanics.load.shape2.e_x[3];
//   mechanics.load.shape2.rxvisobj[3] = mechanics.load.shape2.R.T[1,3] * mechanics.load.shape2.e_x[1] + mechanics.load.shape2.R.T[2,3] * mechanics.load.shape2.e_x[2] + mechanics.load.shape2.R.T[3,3] * mechanics.load.shape2.e_x[3];
//   mechanics.load.shape2.ryvisobj[1] = mechanics.load.shape2.R.T[1,1] * mechanics.load.shape2.e_y[1] + mechanics.load.shape2.R.T[2,1] * mechanics.load.shape2.e_y[2] + mechanics.load.shape2.R.T[3,1] * mechanics.load.shape2.e_y[3];
//   mechanics.load.shape2.ryvisobj[2] = mechanics.load.shape2.R.T[1,2] * mechanics.load.shape2.e_y[1] + mechanics.load.shape2.R.T[2,2] * mechanics.load.shape2.e_y[2] + mechanics.load.shape2.R.T[3,2] * mechanics.load.shape2.e_y[3];
//   mechanics.load.shape2.ryvisobj[3] = mechanics.load.shape2.R.T[1,3] * mechanics.load.shape2.e_y[1] + mechanics.load.shape2.R.T[2,3] * mechanics.load.shape2.e_y[2] + mechanics.load.shape2.R.T[3,3] * mechanics.load.shape2.e_y[3];
//   mechanics.load.shape2.rvisobj = mechanics.load.shape2.r + Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1({{mechanics.load.shape2.R.T[1,1],mechanics.load.shape2.R.T[1,2],mechanics.load.shape2.R.T[1,3]},{mechanics.load.shape2.R.T[2,1],mechanics.load.shape2.R.T[2,2],mechanics.load.shape2.R.T[2,3]},{mechanics.load.shape2.R.T[3,1],mechanics.load.shape2.R.T[3,2],mechanics.load.shape2.R.T[3,3]}},{mechanics.load.shape2.r_shape[1],mechanics.load.shape2.r_shape[2],mechanics.load.shape2.r_shape[3]});
//   mechanics.load.shape2.size[1] = mechanics.load.shape2.length;
//   mechanics.load.shape2.size[2] = mechanics.load.shape2.width;
//   mechanics.load.shape2.size[3] = mechanics.load.shape2.height;
//   mechanics.load.shape2.Material = Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape.PackMaterial(mechanics.load.shape2.color[1] / 255.0,mechanics.load.shape2.color[2] / 255.0,mechanics.load.shape2.color[3] / 255.0,mechanics.load.shape2.specularCoefficient);
//   mechanics.load.shape2.Extra = mechanics.load.shape2.extra;
//   mechanics.load.r_0[1] = mechanics.load.frame_a.r_0[1];
//   mechanics.load.r_0[2] = mechanics.load.frame_a.r_0[2];
//   mechanics.load.r_0[3] = mechanics.load.frame_a.r_0[3];
//   mechanics.load.v_0[1] = der(mechanics.load.r_0[1]);
//   mechanics.load.v_0[2] = der(mechanics.load.r_0[2]);
//   mechanics.load.v_0[3] = der(mechanics.load.r_0[3]);
//   mechanics.load.a_0[1] = der(mechanics.load.v_0[1]);
//   mechanics.load.a_0[2] = der(mechanics.load.v_0[2]);
//   mechanics.load.a_0[3] = der(mechanics.load.v_0[3]);
//   mechanics.q[1] = mechanics.r1.phi;
//   mechanics.q[2] = mechanics.r2.phi;
//   mechanics.q[3] = mechanics.r3.phi;
//   mechanics.q[4] = mechanics.r4.phi;
//   mechanics.q[5] = mechanics.r5.phi;
//   mechanics.q[6] = mechanics.r6.phi;
//   mechanics.qd[1] = der(mechanics.q[1]);
//   mechanics.qd[2] = der(mechanics.q[2]);
//   mechanics.qd[3] = der(mechanics.q[3]);
//   mechanics.qd[4] = der(mechanics.q[4]);
//   mechanics.qd[5] = der(mechanics.q[5]);
//   mechanics.qd[6] = der(mechanics.q[6]);
//   mechanics.qdd[1] = der(mechanics.qd[1]);
//   mechanics.qdd[2] = der(mechanics.qd[2]);
//   mechanics.qdd[3] = der(mechanics.qd[3]);
//   mechanics.qdd[4] = der(mechanics.qd[4]);
//   mechanics.qdd[5] = der(mechanics.qd[5]);
//   mechanics.qdd[6] = der(mechanics.qd[6]);
//   mechanics.tau[1] = mechanics.r1.axis.tau;
//   mechanics.tau[2] = mechanics.r2.axis.tau;
//   mechanics.tau[3] = mechanics.r3.axis.tau;
//   mechanics.tau[4] = mechanics.r4.axis.tau;
//   mechanics.tau[5] = mechanics.r5.axis.tau;
//   mechanics.tau[6] = mechanics.r6.axis.tau;
//   pathPlanning.path.aux1[1] = pathPlanning.path.p_deltaq[1] / pathPlanning.path.p_qd_max[1];
//   pathPlanning.path.aux2[1] = pathPlanning.path.p_deltaq[1] / pathPlanning.path.p_qdd_max[1];
//   pathPlanning.path.aux1[2] = pathPlanning.path.p_deltaq[2] / pathPlanning.path.p_qd_max[2];
//   pathPlanning.path.aux2[2] = pathPlanning.path.p_deltaq[2] / pathPlanning.path.p_qdd_max[2];
//   pathPlanning.path.aux1[3] = pathPlanning.path.p_deltaq[3] / pathPlanning.path.p_qd_max[3];
//   pathPlanning.path.aux2[3] = pathPlanning.path.p_deltaq[3] / pathPlanning.path.p_qdd_max[3];
//   pathPlanning.path.aux1[4] = pathPlanning.path.p_deltaq[4] / pathPlanning.path.p_qd_max[4];
//   pathPlanning.path.aux2[4] = pathPlanning.path.p_deltaq[4] / pathPlanning.path.p_qdd_max[4];
//   pathPlanning.path.aux1[5] = pathPlanning.path.p_deltaq[5] / pathPlanning.path.p_qd_max[5];
//   pathPlanning.path.aux2[5] = pathPlanning.path.p_deltaq[5] / pathPlanning.path.p_qdd_max[5];
//   pathPlanning.path.aux1[6] = pathPlanning.path.p_deltaq[6] / pathPlanning.path.p_qd_max[6];
//   pathPlanning.path.aux2[6] = pathPlanning.path.p_deltaq[6] / pathPlanning.path.p_qdd_max[6];
//   pathPlanning.path.sd_max_inv = max({abs(pathPlanning.path.aux1[1]),abs(pathPlanning.path.aux1[2]),abs(pathPlanning.path.aux1[3]),abs(pathPlanning.path.aux1[4]),abs(pathPlanning.path.aux1[5]),abs(pathPlanning.path.aux1[6])});
//   pathPlanning.path.sdd_max_inv = max({abs(pathPlanning.path.aux2[1]),abs(pathPlanning.path.aux2[2]),abs(pathPlanning.path.aux2[3]),abs(pathPlanning.path.aux2[4]),abs(pathPlanning.path.aux2[5]),abs(pathPlanning.path.aux2[6])});
//   if pathPlanning.path.sd_max_inv <= 1e-14 or pathPlanning.path.sdd_max_inv <= 1e-14 then
//   pathPlanning.path.sd_max = 0.0;
//   pathPlanning.path.sdd_max = 0.0;
//   pathPlanning.path.Ta1 = 0.0;
//   pathPlanning.path.Ta2 = 0.0;
//   pathPlanning.path.noWphase = false;
//   pathPlanning.path.Tv = 0.0;
//   pathPlanning.path.Te = 0.0;
//   pathPlanning.path.Ta1s = 0.0;
//   pathPlanning.path.Ta2s = 0.0;
//   pathPlanning.path.Tvs = 0.0;
//   pathPlanning.path.Tes = 0.0;
//   pathPlanning.path.sd_max2 = 0.0;
//   pathPlanning.path.s1 = 0.0;
//   pathPlanning.path.s2 = 0.0;
//   pathPlanning.path.s3 = 0.0;
//   pathPlanning.path.r_sdd = 0.0;
//   pathPlanning.path.r_sd = 0.0;
//   pathPlanning.path.r_s = 0.0;
//   else
//   pathPlanning.path.sd_max = 1.0 / max({abs(pathPlanning.path.aux1[1]),abs(pathPlanning.path.aux1[2]),abs(pathPlanning.path.aux1[3]),abs(pathPlanning.path.aux1[4]),abs(pathPlanning.path.aux1[5]),abs(pathPlanning.path.aux1[6])});
//   pathPlanning.path.sdd_max = 1.0 / max({abs(pathPlanning.path.aux2[1]),abs(pathPlanning.path.aux2[2]),abs(pathPlanning.path.aux2[3]),abs(pathPlanning.path.aux2[4]),abs(pathPlanning.path.aux2[5]),abs(pathPlanning.path.aux2[6])});
//   pathPlanning.path.Ta1 = sqrt(1.0 / pathPlanning.path.sdd_max);
//   pathPlanning.path.Ta2 = pathPlanning.path.sd_max / pathPlanning.path.sdd_max;
//   pathPlanning.path.noWphase = pathPlanning.path.Ta2 >= pathPlanning.path.Ta1;
//   pathPlanning.path.Tv = if pathPlanning.path.noWphase then pathPlanning.path.Ta1 else 1.0 / pathPlanning.path.sd_max;
//   pathPlanning.path.Te = if pathPlanning.path.noWphase then 2.0 * pathPlanning.path.Ta1 else pathPlanning.path.Tv + pathPlanning.path.Ta2;
//   pathPlanning.path.Ta1s = pathPlanning.path.Ta1 + pathPlanning.path.startTime;
//   pathPlanning.path.Ta2s = pathPlanning.path.Ta2 + pathPlanning.path.startTime;
//   pathPlanning.path.Tvs = pathPlanning.path.Tv + pathPlanning.path.startTime;
//   pathPlanning.path.Tes = pathPlanning.path.Te + pathPlanning.path.startTime;
//   pathPlanning.path.sd_max2 = pathPlanning.path.sdd_max * pathPlanning.path.Ta1;
//   pathPlanning.path.s1 = (pathPlanning.path.sdd_max * (if pathPlanning.path.noWphase then pathPlanning.path.Ta1 ^ 2.0 else pathPlanning.path.Ta2 ^ 2.0)) / 2.0;
//   pathPlanning.path.s2 = pathPlanning.path.s1 + (if pathPlanning.path.noWphase then pathPlanning.path.sd_max2 * (pathPlanning.path.Te - pathPlanning.path.Ta1) + ((-(pathPlanning.path.Te - pathPlanning.path.Ta1) ^ 2.0) * pathPlanning.path.sdd_max) / 2.0 else pathPlanning.path.sd_max * (pathPlanning.path.Tv - pathPlanning.path.Ta2));
//   pathPlanning.path.s3 = pathPlanning.path.s2 + (pathPlanning.path.sd_max * (pathPlanning.path.Te - pathPlanning.path.Tv) + ((-(pathPlanning.path.Te - pathPlanning.path.Tv) ^ 2.0) * pathPlanning.path.sdd_max) / 2.0);
//   if time < pathPlanning.path.startTime then
//   pathPlanning.path.r_sdd = 0.0;
//   pathPlanning.path.r_sd = 0.0;
//   pathPlanning.path.r_s = 0.0;
//   elseif pathPlanning.path.noWphase then
//   if time < pathPlanning.path.Ta1s then
//   pathPlanning.path.r_sdd = pathPlanning.path.sdd_max;
//   pathPlanning.path.r_sd = pathPlanning.path.sdd_max * (time - pathPlanning.path.startTime);
//   pathPlanning.path.r_s = ((time - pathPlanning.path.startTime) ^ 2.0 * pathPlanning.path.sdd_max) / 2.0;
//   elseif time < pathPlanning.path.Tes then
//   pathPlanning.path.r_sdd = -pathPlanning.path.sdd_max;
//   pathPlanning.path.r_sd = pathPlanning.path.sd_max2 - pathPlanning.path.sdd_max * (time - pathPlanning.path.Ta1s);
//   pathPlanning.path.r_s = pathPlanning.path.s1 + (pathPlanning.path.sd_max2 * (time - pathPlanning.path.Ta1s) + ((-(time - pathPlanning.path.Ta1s) ^ 2.0) * pathPlanning.path.sdd_max) / 2.0);
//   else
//   pathPlanning.path.r_sdd = 0.0;
//   pathPlanning.path.r_sd = 0.0;
//   pathPlanning.path.r_s = pathPlanning.path.s2;
//   end if;
//   elseif time < pathPlanning.path.Ta2s then
//   pathPlanning.path.r_sdd = pathPlanning.path.sdd_max;
//   pathPlanning.path.r_sd = pathPlanning.path.sdd_max * (time - pathPlanning.path.startTime);
//   pathPlanning.path.r_s = ((time - pathPlanning.path.startTime) ^ 2.0 * pathPlanning.path.sdd_max) / 2.0;
//   elseif time < pathPlanning.path.Tvs then
//   pathPlanning.path.r_sdd = 0.0;
//   pathPlanning.path.r_sd = pathPlanning.path.sd_max;
//   pathPlanning.path.r_s = pathPlanning.path.s1 + pathPlanning.path.sd_max * (time - pathPlanning.path.Ta2s);
//   elseif time < pathPlanning.path.Tes then
//   pathPlanning.path.r_sdd = -pathPlanning.path.sdd_max;
//   pathPlanning.path.r_sd = pathPlanning.path.sd_max - pathPlanning.path.sdd_max * (time - pathPlanning.path.Tvs);
//   pathPlanning.path.r_s = pathPlanning.path.s2 + (pathPlanning.path.sd_max * (time - pathPlanning.path.Tvs) + ((-(time - pathPlanning.path.Tvs) ^ 2.0) * pathPlanning.path.sdd_max) / 2.0);
//   else
//   pathPlanning.path.r_sdd = 0.0;
//   pathPlanning.path.r_sd = 0.0;
//   pathPlanning.path.r_s = pathPlanning.path.s3;
//   end if;
//   end if;
//   pathPlanning.path.qdd[1] = pathPlanning.path.sdd * pathPlanning.path.p_deltaq[1];
//   pathPlanning.path.qdd[2] = pathPlanning.path.sdd * pathPlanning.path.p_deltaq[2];
//   pathPlanning.path.qdd[3] = pathPlanning.path.sdd * pathPlanning.path.p_deltaq[3];
//   pathPlanning.path.qdd[4] = pathPlanning.path.sdd * pathPlanning.path.p_deltaq[4];
//   pathPlanning.path.qdd[5] = pathPlanning.path.sdd * pathPlanning.path.p_deltaq[5];
//   pathPlanning.path.qdd[6] = pathPlanning.path.sdd * pathPlanning.path.p_deltaq[6];
//   pathPlanning.path.qd[1] = pathPlanning.path.sd * pathPlanning.path.p_deltaq[1];
//   pathPlanning.path.qd[2] = pathPlanning.path.sd * pathPlanning.path.p_deltaq[2];
//   pathPlanning.path.qd[3] = pathPlanning.path.sd * pathPlanning.path.p_deltaq[3];
//   pathPlanning.path.qd[4] = pathPlanning.path.sd * pathPlanning.path.p_deltaq[4];
//   pathPlanning.path.qd[5] = pathPlanning.path.sd * pathPlanning.path.p_deltaq[5];
//   pathPlanning.path.qd[6] = pathPlanning.path.sd * pathPlanning.path.p_deltaq[6];
//   pathPlanning.path.q[1] = pathPlanning.path.p_q_begin[1] + pathPlanning.path.s * pathPlanning.path.p_deltaq[1];
//   pathPlanning.path.q[2] = pathPlanning.path.p_q_begin[2] + pathPlanning.path.s * pathPlanning.path.p_deltaq[2];
//   pathPlanning.path.q[3] = pathPlanning.path.p_q_begin[3] + pathPlanning.path.s * pathPlanning.path.p_deltaq[3];
//   pathPlanning.path.q[4] = pathPlanning.path.p_q_begin[4] + pathPlanning.path.s * pathPlanning.path.p_deltaq[4];
//   pathPlanning.path.q[5] = pathPlanning.path.p_q_begin[5] + pathPlanning.path.s * pathPlanning.path.p_deltaq[5];
//   pathPlanning.path.q[6] = pathPlanning.path.p_q_begin[6] + pathPlanning.path.s * pathPlanning.path.p_deltaq[6];
//   pathPlanning.path.endTime = pathPlanning.path.Tes;
//   pathPlanning.path.s = Modelica.Blocks.Sources.KinematicPTP2.position({pathPlanning.path.r_s,pathPlanning.path.r_sd,pathPlanning.path.r_sdd},time);
//   pathPlanning.path.sd = der(pathPlanning.path.s);
//   pathPlanning.path.sdd = der(pathPlanning.path.sd);
//   pathPlanning.path.motion_ref = time <= pathPlanning.path.endTime;
//   pathPlanning.path.moving[1] = if abs(pathPlanning.path.q_begin[1] - pathPlanning.path.q_end[1]) > 1e-14 then pathPlanning.path.motion_ref else false;
//   pathPlanning.path.moving[2] = if abs(pathPlanning.path.q_begin[2] - pathPlanning.path.q_end[2]) > 1e-14 then pathPlanning.path.motion_ref else false;
//   pathPlanning.path.moving[3] = if abs(pathPlanning.path.q_begin[3] - pathPlanning.path.q_end[3]) > 1e-14 then pathPlanning.path.motion_ref else false;
//   pathPlanning.path.moving[4] = if abs(pathPlanning.path.q_begin[4] - pathPlanning.path.q_end[4]) > 1e-14 then pathPlanning.path.motion_ref else false;
//   pathPlanning.path.moving[5] = if abs(pathPlanning.path.q_begin[5] - pathPlanning.path.q_end[5]) > 1e-14 then pathPlanning.path.motion_ref else false;
//   pathPlanning.path.moving[6] = if abs(pathPlanning.path.q_begin[6] - pathPlanning.path.q_end[6]) > 1e-14 then pathPlanning.path.motion_ref else false;
//   pathPlanning.pathToAxis1.q_axisUsed.y = pathPlanning.pathToAxis1.q_axisUsed.u;
//   pathPlanning.pathToAxis1.qd_axisUsed.y = pathPlanning.pathToAxis1.qd_axisUsed.u;
//   pathPlanning.pathToAxis1.qdd_axisUsed.y = pathPlanning.pathToAxis1.qdd_axisUsed.u;
//   pathPlanning.pathToAxis1.motion_ref_axisUsed.y = pathPlanning.pathToAxis1.motion_ref_axisUsed.u;
//   pathPlanning.pathToAxis2.q_axisUsed.y = pathPlanning.pathToAxis2.q_axisUsed.u;
//   pathPlanning.pathToAxis2.qd_axisUsed.y = pathPlanning.pathToAxis2.qd_axisUsed.u;
//   pathPlanning.pathToAxis2.qdd_axisUsed.y = pathPlanning.pathToAxis2.qdd_axisUsed.u;
//   pathPlanning.pathToAxis2.motion_ref_axisUsed.y = pathPlanning.pathToAxis2.motion_ref_axisUsed.u;
//   pathPlanning.pathToAxis3.q_axisUsed.y = pathPlanning.pathToAxis3.q_axisUsed.u;
//   pathPlanning.pathToAxis3.qd_axisUsed.y = pathPlanning.pathToAxis3.qd_axisUsed.u;
//   pathPlanning.pathToAxis3.qdd_axisUsed.y = pathPlanning.pathToAxis3.qdd_axisUsed.u;
//   pathPlanning.pathToAxis3.motion_ref_axisUsed.y = pathPlanning.pathToAxis3.motion_ref_axisUsed.u;
//   pathPlanning.pathToAxis4.q_axisUsed.y = pathPlanning.pathToAxis4.q_axisUsed.u;
//   pathPlanning.pathToAxis4.qd_axisUsed.y = pathPlanning.pathToAxis4.qd_axisUsed.u;
//   pathPlanning.pathToAxis4.qdd_axisUsed.y = pathPlanning.pathToAxis4.qdd_axisUsed.u;
//   pathPlanning.pathToAxis4.motion_ref_axisUsed.y = pathPlanning.pathToAxis4.motion_ref_axisUsed.u;
//   pathPlanning.pathToAxis5.q_axisUsed.y = pathPlanning.pathToAxis5.q_axisUsed.u;
//   pathPlanning.pathToAxis5.qd_axisUsed.y = pathPlanning.pathToAxis5.qd_axisUsed.u;
//   pathPlanning.pathToAxis5.qdd_axisUsed.y = pathPlanning.pathToAxis5.qdd_axisUsed.u;
//   pathPlanning.pathToAxis5.motion_ref_axisUsed.y = pathPlanning.pathToAxis5.motion_ref_axisUsed.u;
//   pathPlanning.pathToAxis6.q_axisUsed.y = pathPlanning.pathToAxis6.q_axisUsed.u;
//   pathPlanning.pathToAxis6.qd_axisUsed.y = pathPlanning.pathToAxis6.qd_axisUsed.u;
//   pathPlanning.pathToAxis6.qdd_axisUsed.y = pathPlanning.pathToAxis6.qdd_axisUsed.u;
//   pathPlanning.pathToAxis6.motion_ref_axisUsed.y = pathPlanning.pathToAxis6.motion_ref_axisUsed.u;
//   when pathPlanning.terminateSimulation.condition then
//   terminate(pathPlanning.terminateSimulation.terminationText);
//   end when;
//   axis1.gear.gear.phi_a = axis1.gear.gear.flange_a.phi - axis1.gear.gear.phi_support;
//   axis1.gear.gear.phi_b = axis1.gear.gear.flange_b.phi - axis1.gear.gear.phi_support;
//   axis1.gear.gear.phi_a = axis1.gear.gear.ratio * axis1.gear.gear.phi_b;
//   0.0 = axis1.gear.gear.ratio * axis1.gear.gear.flange_a.tau + axis1.gear.gear.flange_b.tau;
//   axis1.gear.gear.phi_support = 0.0;
//   axis1.gear.spring.tau = axis1.gear.spring.c * (axis1.gear.spring.phi_rel - axis1.gear.spring.phi_rel0) + axis1.gear.spring.d * axis1.gear.spring.w_rel;
//   axis1.gear.spring.phi_rel = axis1.gear.spring.flange_b.phi - axis1.gear.spring.flange_a.phi;
//   axis1.gear.spring.w_rel = der(axis1.gear.spring.phi_rel);
//   axis1.gear.spring.a_rel = der(axis1.gear.spring.w_rel);
//   axis1.gear.spring.flange_b.tau = axis1.gear.spring.tau;
//   axis1.gear.spring.flange_a.tau = -axis1.gear.spring.tau;
//   axis1.gear.bearingFriction.tau0 = Modelica.Math.tempInterpol1(0.0,{{axis1.gear.bearingFriction.tau_pos[1,1],axis1.gear.bearingFriction.tau_pos[1,2]},{axis1.gear.bearingFriction.tau_pos[2,1],axis1.gear.bearingFriction.tau_pos[2,2]}},2);
//   axis1.gear.bearingFriction.tau0_max = axis1.gear.bearingFriction.peak * axis1.gear.bearingFriction.tau0;
//   axis1.gear.bearingFriction.free = false;
//   axis1.gear.bearingFriction.phi = axis1.gear.bearingFriction.flange_a.phi - axis1.gear.bearingFriction.phi_support;
//   axis1.gear.bearingFriction.flange_b.phi = axis1.gear.bearingFriction.flange_a.phi;
//   axis1.gear.bearingFriction.w = der(axis1.gear.bearingFriction.phi);
//   axis1.gear.bearingFriction.a = der(axis1.gear.bearingFriction.w);
//   axis1.gear.bearingFriction.w_relfric = axis1.gear.bearingFriction.w;
//   axis1.gear.bearingFriction.a_relfric = axis1.gear.bearingFriction.a;
//   axis1.gear.bearingFriction.flange_a.tau + (axis1.gear.bearingFriction.flange_b.tau - axis1.gear.bearingFriction.tau) = 0.0;
//   axis1.gear.bearingFriction.tau = if axis1.gear.bearingFriction.locked then axis1.gear.bearingFriction.sa else if axis1.gear.bearingFriction.startForward then Modelica.Math.tempInterpol1(axis1.gear.bearingFriction.w,{{axis1.gear.bearingFriction.tau_pos[1,1],axis1.gear.bearingFriction.tau_pos[1,2]},{axis1.gear.bearingFriction.tau_pos[2,1],axis1.gear.bearingFriction.tau_pos[2,2]}},2) else if axis1.gear.bearingFriction.startBackward then -Modelica.Math.tempInterpol1(-axis1.gear.bearingFriction.w,{{axis1.gear.bearingFriction.tau_pos[1,1],axis1.gear.bearingFriction.tau_pos[1,2]},{axis1.gear.bearingFriction.tau_pos[2,1],axis1.gear.bearingFriction.tau_pos[2,2]}},2) else if pre(axis1.gear.bearingFriction.mode) == 1 then Modelica.Math.tempInterpol1(axis1.gear.bearingFriction.w,{{axis1.gear.bearingFriction.tau_pos[1,1],axis1.gear.bearingFriction.tau_pos[1,2]},{axis1.gear.bearingFriction.tau_pos[2,1],axis1.gear.bearingFriction.tau_pos[2,2]}},2) else -Modelica.Math.tempInterpol1(-axis1.gear.bearingFriction.w,{{axis1.gear.bearingFriction.tau_pos[1,1],axis1.gear.bearingFriction.tau_pos[1,2]},{axis1.gear.bearingFriction.tau_pos[2,1],axis1.gear.bearingFriction.tau_pos[2,2]}},2);
//   axis1.gear.bearingFriction.phi_support = 0.0;
//   axis1.gear.bearingFriction.startForward = pre(axis1.gear.bearingFriction.mode) == 0 and (axis1.gear.bearingFriction.sa > axis1.gear.bearingFriction.tau0_max or pre(axis1.gear.bearingFriction.startForward) and axis1.gear.bearingFriction.sa > axis1.gear.bearingFriction.tau0) or pre(axis1.gear.bearingFriction.mode) == -1 and axis1.gear.bearingFriction.w_relfric > axis1.gear.bearingFriction.w_small or initial() and axis1.gear.bearingFriction.w_relfric > 0.0;
//   axis1.gear.bearingFriction.startBackward = pre(axis1.gear.bearingFriction.mode) == 0 and (axis1.gear.bearingFriction.sa < -axis1.gear.bearingFriction.tau0_max or pre(axis1.gear.bearingFriction.startBackward) and axis1.gear.bearingFriction.sa < -axis1.gear.bearingFriction.tau0) or pre(axis1.gear.bearingFriction.mode) == 1 and axis1.gear.bearingFriction.w_relfric < -axis1.gear.bearingFriction.w_small or initial() and axis1.gear.bearingFriction.w_relfric < 0.0;
//   axis1.gear.bearingFriction.locked = not axis1.gear.bearingFriction.free and not (pre(axis1.gear.bearingFriction.mode) == 1 or axis1.gear.bearingFriction.startForward or pre(axis1.gear.bearingFriction.mode) == -1 or axis1.gear.bearingFriction.startBackward);
//   axis1.gear.bearingFriction.a_relfric = if axis1.gear.bearingFriction.locked then 0.0 else if axis1.gear.bearingFriction.free then axis1.gear.bearingFriction.sa else if axis1.gear.bearingFriction.startForward then axis1.gear.bearingFriction.sa - axis1.gear.bearingFriction.tau0_max else if axis1.gear.bearingFriction.startBackward then axis1.gear.bearingFriction.sa + axis1.gear.bearingFriction.tau0_max else if pre(axis1.gear.bearingFriction.mode) == 1 then axis1.gear.bearingFriction.sa - axis1.gear.bearingFriction.tau0_max else axis1.gear.bearingFriction.sa + axis1.gear.bearingFriction.tau0_max;
//   axis1.gear.bearingFriction.mode = if axis1.gear.bearingFriction.free then 2 else if (pre(axis1.gear.bearingFriction.mode) == 1 or pre(axis1.gear.bearingFriction.mode) == 2 or axis1.gear.bearingFriction.startForward) and axis1.gear.bearingFriction.w_relfric > 0.0 then 1 else if (pre(axis1.gear.bearingFriction.mode) == -1 or pre(axis1.gear.bearingFriction.mode) == 2 or axis1.gear.bearingFriction.startBackward) and axis1.gear.bearingFriction.w_relfric < 0.0 then -1 else 0;
//   axis1.motor.Vs.v = axis1.motor.Vs.p.v - axis1.motor.Vs.n.v;
//   0.0 = axis1.motor.Vs.p.i + axis1.motor.Vs.n.i;
//   axis1.motor.Vs.i = axis1.motor.Vs.p.i;
//   axis1.motor.diff.v1 = axis1.motor.diff.p1.v - axis1.motor.diff.n1.v;
//   axis1.motor.diff.v2 = axis1.motor.diff.p2.v - axis1.motor.diff.n2.v;
//   0.0 = axis1.motor.diff.p1.i + axis1.motor.diff.n1.i;
//   0.0 = axis1.motor.diff.p2.i + axis1.motor.diff.n2.i;
//   axis1.motor.diff.i1 = axis1.motor.diff.p1.i;
//   axis1.motor.diff.i2 = axis1.motor.diff.p2.i;
//   axis1.motor.diff.v1 = 0.0;
//   axis1.motor.diff.i1 = 0.0;
//   axis1.motor.power.v1 = axis1.motor.power.p1.v - axis1.motor.power.n1.v;
//   axis1.motor.power.v2 = axis1.motor.power.p2.v - axis1.motor.power.n2.v;
//   0.0 = axis1.motor.power.p1.i + axis1.motor.power.n1.i;
//   0.0 = axis1.motor.power.p2.i + axis1.motor.power.n2.i;
//   axis1.motor.power.i1 = axis1.motor.power.p1.i;
//   axis1.motor.power.i2 = axis1.motor.power.p2.i;
//   axis1.motor.power.v1 = 0.0;
//   axis1.motor.power.i1 = 0.0;
//   axis1.motor.emf.internalSupport.flange.tau = axis1.motor.emf.internalSupport.tau;
//   axis1.motor.emf.internalSupport.flange.phi = axis1.motor.emf.internalSupport.phi;
//   axis1.motor.emf.fixed.flange.phi = axis1.motor.emf.fixed.phi0;
//   axis1.motor.emf.v = axis1.motor.emf.p.v - axis1.motor.emf.n.v;
//   0.0 = axis1.motor.emf.p.i + axis1.motor.emf.n.i;
//   axis1.motor.emf.i = axis1.motor.emf.p.i;
//   axis1.motor.emf.phi = axis1.motor.emf.flange.phi - axis1.motor.emf.internalSupport.phi;
//   axis1.motor.emf.w = der(axis1.motor.emf.phi);
//   axis1.motor.emf.k * axis1.motor.emf.w = axis1.motor.emf.v;
//   axis1.motor.emf.flange.tau = (-axis1.motor.emf.k) * axis1.motor.emf.i;
//   axis1.motor.La.L * der(axis1.motor.La.i) = axis1.motor.La.v;
//   axis1.motor.La.v = axis1.motor.La.p.v - axis1.motor.La.n.v;
//   0.0 = axis1.motor.La.p.i + axis1.motor.La.n.i;
//   axis1.motor.La.i = axis1.motor.La.p.i;
//   assert(1.0 + axis1.motor.Ra.alpha * (axis1.motor.Ra.T_heatPort - axis1.motor.Ra.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis1.motor.Ra.R_actual = axis1.motor.Ra.R * (1.0 + axis1.motor.Ra.alpha * (axis1.motor.Ra.T_heatPort - axis1.motor.Ra.T_ref));
//   axis1.motor.Ra.v = axis1.motor.Ra.R_actual * axis1.motor.Ra.i;
//   axis1.motor.Ra.LossPower = axis1.motor.Ra.v * axis1.motor.Ra.i;
//   axis1.motor.Ra.i = axis1.motor.Ra.p.i;
//   0.0 = axis1.motor.Ra.p.i + axis1.motor.Ra.n.i;
//   axis1.motor.Ra.v = axis1.motor.Ra.p.v - axis1.motor.Ra.n.v;
//   axis1.motor.Ra.T_heatPort = axis1.motor.Ra.T;
//   assert(1.0 + axis1.motor.Rd2.alpha * (axis1.motor.Rd2.T_heatPort - axis1.motor.Rd2.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis1.motor.Rd2.R_actual = axis1.motor.Rd2.R * (1.0 + axis1.motor.Rd2.alpha * (axis1.motor.Rd2.T_heatPort - axis1.motor.Rd2.T_ref));
//   axis1.motor.Rd2.v = axis1.motor.Rd2.R_actual * axis1.motor.Rd2.i;
//   axis1.motor.Rd2.LossPower = axis1.motor.Rd2.v * axis1.motor.Rd2.i;
//   axis1.motor.Rd2.i = axis1.motor.Rd2.p.i;
//   0.0 = axis1.motor.Rd2.p.i + axis1.motor.Rd2.n.i;
//   axis1.motor.Rd2.v = axis1.motor.Rd2.p.v - axis1.motor.Rd2.n.v;
//   axis1.motor.Rd2.T_heatPort = axis1.motor.Rd2.T;
//   axis1.motor.C.i = axis1.motor.C.C * der(axis1.motor.C.v);
//   axis1.motor.C.v = axis1.motor.C.p.v - axis1.motor.C.n.v;
//   0.0 = axis1.motor.C.p.i + axis1.motor.C.n.i;
//   axis1.motor.C.i = axis1.motor.C.p.i;
//   axis1.motor.OpI.v1 = axis1.motor.OpI.p1.v - axis1.motor.OpI.n1.v;
//   axis1.motor.OpI.v2 = axis1.motor.OpI.p2.v - axis1.motor.OpI.n2.v;
//   0.0 = axis1.motor.OpI.p1.i + axis1.motor.OpI.n1.i;
//   0.0 = axis1.motor.OpI.p2.i + axis1.motor.OpI.n2.i;
//   axis1.motor.OpI.i1 = axis1.motor.OpI.p1.i;
//   axis1.motor.OpI.i2 = axis1.motor.OpI.p2.i;
//   axis1.motor.OpI.v1 = 0.0;
//   axis1.motor.OpI.i1 = 0.0;
//   assert(1.0 + axis1.motor.Rd1.alpha * (axis1.motor.Rd1.T_heatPort - axis1.motor.Rd1.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis1.motor.Rd1.R_actual = axis1.motor.Rd1.R * (1.0 + axis1.motor.Rd1.alpha * (axis1.motor.Rd1.T_heatPort - axis1.motor.Rd1.T_ref));
//   axis1.motor.Rd1.v = axis1.motor.Rd1.R_actual * axis1.motor.Rd1.i;
//   axis1.motor.Rd1.LossPower = axis1.motor.Rd1.v * axis1.motor.Rd1.i;
//   axis1.motor.Rd1.i = axis1.motor.Rd1.p.i;
//   0.0 = axis1.motor.Rd1.p.i + axis1.motor.Rd1.n.i;
//   axis1.motor.Rd1.v = axis1.motor.Rd1.p.v - axis1.motor.Rd1.n.v;
//   axis1.motor.Rd1.T_heatPort = axis1.motor.Rd1.T;
//   assert(1.0 + axis1.motor.Ri.alpha * (axis1.motor.Ri.T_heatPort - axis1.motor.Ri.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis1.motor.Ri.R_actual = axis1.motor.Ri.R * (1.0 + axis1.motor.Ri.alpha * (axis1.motor.Ri.T_heatPort - axis1.motor.Ri.T_ref));
//   axis1.motor.Ri.v = axis1.motor.Ri.R_actual * axis1.motor.Ri.i;
//   axis1.motor.Ri.LossPower = axis1.motor.Ri.v * axis1.motor.Ri.i;
//   axis1.motor.Ri.i = axis1.motor.Ri.p.i;
//   0.0 = axis1.motor.Ri.p.i + axis1.motor.Ri.n.i;
//   axis1.motor.Ri.v = axis1.motor.Ri.p.v - axis1.motor.Ri.n.v;
//   axis1.motor.Ri.T_heatPort = axis1.motor.Ri.T;
//   assert(1.0 + axis1.motor.Rp1.alpha * (axis1.motor.Rp1.T_heatPort - axis1.motor.Rp1.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis1.motor.Rp1.R_actual = axis1.motor.Rp1.R * (1.0 + axis1.motor.Rp1.alpha * (axis1.motor.Rp1.T_heatPort - axis1.motor.Rp1.T_ref));
//   axis1.motor.Rp1.v = axis1.motor.Rp1.R_actual * axis1.motor.Rp1.i;
//   axis1.motor.Rp1.LossPower = axis1.motor.Rp1.v * axis1.motor.Rp1.i;
//   axis1.motor.Rp1.i = axis1.motor.Rp1.p.i;
//   0.0 = axis1.motor.Rp1.p.i + axis1.motor.Rp1.n.i;
//   axis1.motor.Rp1.v = axis1.motor.Rp1.p.v - axis1.motor.Rp1.n.v;
//   axis1.motor.Rp1.T_heatPort = axis1.motor.Rp1.T;
//   assert(1.0 + axis1.motor.Rp2.alpha * (axis1.motor.Rp2.T_heatPort - axis1.motor.Rp2.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis1.motor.Rp2.R_actual = axis1.motor.Rp2.R * (1.0 + axis1.motor.Rp2.alpha * (axis1.motor.Rp2.T_heatPort - axis1.motor.Rp2.T_ref));
//   axis1.motor.Rp2.v = axis1.motor.Rp2.R_actual * axis1.motor.Rp2.i;
//   axis1.motor.Rp2.LossPower = axis1.motor.Rp2.v * axis1.motor.Rp2.i;
//   axis1.motor.Rp2.i = axis1.motor.Rp2.p.i;
//   0.0 = axis1.motor.Rp2.p.i + axis1.motor.Rp2.n.i;
//   axis1.motor.Rp2.v = axis1.motor.Rp2.p.v - axis1.motor.Rp2.n.v;
//   axis1.motor.Rp2.T_heatPort = axis1.motor.Rp2.T;
//   assert(1.0 + axis1.motor.Rd4.alpha * (axis1.motor.Rd4.T_heatPort - axis1.motor.Rd4.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis1.motor.Rd4.R_actual = axis1.motor.Rd4.R * (1.0 + axis1.motor.Rd4.alpha * (axis1.motor.Rd4.T_heatPort - axis1.motor.Rd4.T_ref));
//   axis1.motor.Rd4.v = axis1.motor.Rd4.R_actual * axis1.motor.Rd4.i;
//   axis1.motor.Rd4.LossPower = axis1.motor.Rd4.v * axis1.motor.Rd4.i;
//   axis1.motor.Rd4.i = axis1.motor.Rd4.p.i;
//   0.0 = axis1.motor.Rd4.p.i + axis1.motor.Rd4.n.i;
//   axis1.motor.Rd4.v = axis1.motor.Rd4.p.v - axis1.motor.Rd4.n.v;
//   axis1.motor.Rd4.T_heatPort = axis1.motor.Rd4.T;
//   axis1.motor.hall2.v = axis1.motor.hall2.p.v - axis1.motor.hall2.n.v;
//   0.0 = axis1.motor.hall2.p.i + axis1.motor.hall2.n.i;
//   axis1.motor.hall2.i = axis1.motor.hall2.p.i;
//   assert(1.0 + axis1.motor.Rd3.alpha * (axis1.motor.Rd3.T_heatPort - axis1.motor.Rd3.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis1.motor.Rd3.R_actual = axis1.motor.Rd3.R * (1.0 + axis1.motor.Rd3.alpha * (axis1.motor.Rd3.T_heatPort - axis1.motor.Rd3.T_ref));
//   axis1.motor.Rd3.v = axis1.motor.Rd3.R_actual * axis1.motor.Rd3.i;
//   axis1.motor.Rd3.LossPower = axis1.motor.Rd3.v * axis1.motor.Rd3.i;
//   axis1.motor.Rd3.i = axis1.motor.Rd3.p.i;
//   0.0 = axis1.motor.Rd3.p.i + axis1.motor.Rd3.n.i;
//   axis1.motor.Rd3.v = axis1.motor.Rd3.p.v - axis1.motor.Rd3.n.v;
//   axis1.motor.Rd3.T_heatPort = axis1.motor.Rd3.T;
//   axis1.motor.g1.p.v = 0.0;
//   axis1.motor.g2.p.v = 0.0;
//   axis1.motor.g3.p.v = 0.0;
//   axis1.motor.hall1.p.v = axis1.motor.hall1.n.v;
//   axis1.motor.hall1.p.i = axis1.motor.hall1.i;
//   axis1.motor.hall1.n.i = -axis1.motor.hall1.i;
//   axis1.motor.g4.p.v = 0.0;
//   axis1.motor.g5.p.v = 0.0;
//   axis1.motor.phi.phi = axis1.motor.phi.flange.phi;
//   0.0 = axis1.motor.phi.flange.tau;
//   axis1.motor.speed.w = der(axis1.motor.speed.flange.phi);
//   0.0 = axis1.motor.speed.flange.tau;
//   axis1.motor.Jmotor.phi = axis1.motor.Jmotor.flange_a.phi;
//   axis1.motor.Jmotor.phi = axis1.motor.Jmotor.flange_b.phi;
//   axis1.motor.Jmotor.w = der(axis1.motor.Jmotor.phi);
//   axis1.motor.Jmotor.a = der(axis1.motor.Jmotor.w);
//   axis1.motor.Jmotor.J * axis1.motor.Jmotor.a = axis1.motor.Jmotor.flange_a.tau + axis1.motor.Jmotor.flange_b.tau;
//   axis1.motor.convert1.y = axis1.motor.convert1.k * axis1.motor.convert1.u;
//   axis1.motor.convert2.y = axis1.motor.convert2.k * axis1.motor.convert2.u;
//   axis1.controller.gain1.y = axis1.controller.gain1.k * axis1.controller.gain1.u;
//   der(axis1.controller.PI.x) = axis1.controller.PI.u / axis1.controller.PI.T;
//   axis1.controller.PI.y = axis1.controller.PI.k * (axis1.controller.PI.x + axis1.controller.PI.u);
//   axis1.controller.feedback1.y = axis1.controller.feedback1.u1 - axis1.controller.feedback1.u2;
//   axis1.controller.P.y = axis1.controller.P.k * axis1.controller.P.u;
//   axis1.controller.add3.y = axis1.controller.add3.k1 * axis1.controller.add3.u1 + (axis1.controller.add3.k2 * axis1.controller.add3.u2 + axis1.controller.add3.k3 * axis1.controller.add3.u3);
//   axis1.controller.gain2.y = axis1.controller.gain2.k * axis1.controller.gain2.u;
//   axis1.angleSensor.phi = axis1.angleSensor.flange.phi;
//   0.0 = axis1.angleSensor.flange.tau;
//   axis1.speedSensor.w = der(axis1.speedSensor.flange.phi);
//   0.0 = axis1.speedSensor.flange.tau;
//   axis1.accSensor.w = der(axis1.accSensor.flange.phi);
//   axis1.accSensor.a = der(axis1.accSensor.w);
//   0.0 = axis1.accSensor.flange.tau;
//   axis1.initializeFlange.set_flange_tau.flange.tau = 0.0;
//   axis1.initializeFlange.set_phi_start.flange.tau = 0.0;
//   axis1.initializeFlange.set_w_start.flange.tau = 0.0;
//   axis1.initializeFlange.set_a_start.flange.tau = 0.0;
//   axis1.const.y = axis1.const.k;
//   axis2.gear.gear.phi_a = axis2.gear.gear.flange_a.phi - axis2.gear.gear.phi_support;
//   axis2.gear.gear.phi_b = axis2.gear.gear.flange_b.phi - axis2.gear.gear.phi_support;
//   axis2.gear.gear.phi_a = axis2.gear.gear.ratio * axis2.gear.gear.phi_b;
//   0.0 = axis2.gear.gear.ratio * axis2.gear.gear.flange_a.tau + axis2.gear.gear.flange_b.tau;
//   axis2.gear.gear.phi_support = 0.0;
//   axis2.gear.spring.tau = axis2.gear.spring.c * (axis2.gear.spring.phi_rel - axis2.gear.spring.phi_rel0) + axis2.gear.spring.d * axis2.gear.spring.w_rel;
//   axis2.gear.spring.phi_rel = axis2.gear.spring.flange_b.phi - axis2.gear.spring.flange_a.phi;
//   axis2.gear.spring.w_rel = der(axis2.gear.spring.phi_rel);
//   axis2.gear.spring.a_rel = der(axis2.gear.spring.w_rel);
//   axis2.gear.spring.flange_b.tau = axis2.gear.spring.tau;
//   axis2.gear.spring.flange_a.tau = -axis2.gear.spring.tau;
//   axis2.gear.bearingFriction.tau0 = Modelica.Math.tempInterpol1(0.0,{{axis2.gear.bearingFriction.tau_pos[1,1],axis2.gear.bearingFriction.tau_pos[1,2]},{axis2.gear.bearingFriction.tau_pos[2,1],axis2.gear.bearingFriction.tau_pos[2,2]}},2);
//   axis2.gear.bearingFriction.tau0_max = axis2.gear.bearingFriction.peak * axis2.gear.bearingFriction.tau0;
//   axis2.gear.bearingFriction.free = false;
//   axis2.gear.bearingFriction.phi = axis2.gear.bearingFriction.flange_a.phi - axis2.gear.bearingFriction.phi_support;
//   axis2.gear.bearingFriction.flange_b.phi = axis2.gear.bearingFriction.flange_a.phi;
//   axis2.gear.bearingFriction.w = der(axis2.gear.bearingFriction.phi);
//   axis2.gear.bearingFriction.a = der(axis2.gear.bearingFriction.w);
//   axis2.gear.bearingFriction.w_relfric = axis2.gear.bearingFriction.w;
//   axis2.gear.bearingFriction.a_relfric = axis2.gear.bearingFriction.a;
//   axis2.gear.bearingFriction.flange_a.tau + (axis2.gear.bearingFriction.flange_b.tau - axis2.gear.bearingFriction.tau) = 0.0;
//   axis2.gear.bearingFriction.tau = if axis2.gear.bearingFriction.locked then axis2.gear.bearingFriction.sa else if axis2.gear.bearingFriction.startForward then Modelica.Math.tempInterpol1(axis2.gear.bearingFriction.w,{{axis2.gear.bearingFriction.tau_pos[1,1],axis2.gear.bearingFriction.tau_pos[1,2]},{axis2.gear.bearingFriction.tau_pos[2,1],axis2.gear.bearingFriction.tau_pos[2,2]}},2) else if axis2.gear.bearingFriction.startBackward then -Modelica.Math.tempInterpol1(-axis2.gear.bearingFriction.w,{{axis2.gear.bearingFriction.tau_pos[1,1],axis2.gear.bearingFriction.tau_pos[1,2]},{axis2.gear.bearingFriction.tau_pos[2,1],axis2.gear.bearingFriction.tau_pos[2,2]}},2) else if pre(axis2.gear.bearingFriction.mode) == 1 then Modelica.Math.tempInterpol1(axis2.gear.bearingFriction.w,{{axis2.gear.bearingFriction.tau_pos[1,1],axis2.gear.bearingFriction.tau_pos[1,2]},{axis2.gear.bearingFriction.tau_pos[2,1],axis2.gear.bearingFriction.tau_pos[2,2]}},2) else -Modelica.Math.tempInterpol1(-axis2.gear.bearingFriction.w,{{axis2.gear.bearingFriction.tau_pos[1,1],axis2.gear.bearingFriction.tau_pos[1,2]},{axis2.gear.bearingFriction.tau_pos[2,1],axis2.gear.bearingFriction.tau_pos[2,2]}},2);
//   axis2.gear.bearingFriction.phi_support = 0.0;
//   axis2.gear.bearingFriction.startForward = pre(axis2.gear.bearingFriction.mode) == 0 and (axis2.gear.bearingFriction.sa > axis2.gear.bearingFriction.tau0_max or pre(axis2.gear.bearingFriction.startForward) and axis2.gear.bearingFriction.sa > axis2.gear.bearingFriction.tau0) or pre(axis2.gear.bearingFriction.mode) == -1 and axis2.gear.bearingFriction.w_relfric > axis2.gear.bearingFriction.w_small or initial() and axis2.gear.bearingFriction.w_relfric > 0.0;
//   axis2.gear.bearingFriction.startBackward = pre(axis2.gear.bearingFriction.mode) == 0 and (axis2.gear.bearingFriction.sa < -axis2.gear.bearingFriction.tau0_max or pre(axis2.gear.bearingFriction.startBackward) and axis2.gear.bearingFriction.sa < -axis2.gear.bearingFriction.tau0) or pre(axis2.gear.bearingFriction.mode) == 1 and axis2.gear.bearingFriction.w_relfric < -axis2.gear.bearingFriction.w_small or initial() and axis2.gear.bearingFriction.w_relfric < 0.0;
//   axis2.gear.bearingFriction.locked = not axis2.gear.bearingFriction.free and not (pre(axis2.gear.bearingFriction.mode) == 1 or axis2.gear.bearingFriction.startForward or pre(axis2.gear.bearingFriction.mode) == -1 or axis2.gear.bearingFriction.startBackward);
//   axis2.gear.bearingFriction.a_relfric = if axis2.gear.bearingFriction.locked then 0.0 else if axis2.gear.bearingFriction.free then axis2.gear.bearingFriction.sa else if axis2.gear.bearingFriction.startForward then axis2.gear.bearingFriction.sa - axis2.gear.bearingFriction.tau0_max else if axis2.gear.bearingFriction.startBackward then axis2.gear.bearingFriction.sa + axis2.gear.bearingFriction.tau0_max else if pre(axis2.gear.bearingFriction.mode) == 1 then axis2.gear.bearingFriction.sa - axis2.gear.bearingFriction.tau0_max else axis2.gear.bearingFriction.sa + axis2.gear.bearingFriction.tau0_max;
//   axis2.gear.bearingFriction.mode = if axis2.gear.bearingFriction.free then 2 else if (pre(axis2.gear.bearingFriction.mode) == 1 or pre(axis2.gear.bearingFriction.mode) == 2 or axis2.gear.bearingFriction.startForward) and axis2.gear.bearingFriction.w_relfric > 0.0 then 1 else if (pre(axis2.gear.bearingFriction.mode) == -1 or pre(axis2.gear.bearingFriction.mode) == 2 or axis2.gear.bearingFriction.startBackward) and axis2.gear.bearingFriction.w_relfric < 0.0 then -1 else 0;
//   axis2.motor.Vs.v = axis2.motor.Vs.p.v - axis2.motor.Vs.n.v;
//   0.0 = axis2.motor.Vs.p.i + axis2.motor.Vs.n.i;
//   axis2.motor.Vs.i = axis2.motor.Vs.p.i;
//   axis2.motor.diff.v1 = axis2.motor.diff.p1.v - axis2.motor.diff.n1.v;
//   axis2.motor.diff.v2 = axis2.motor.diff.p2.v - axis2.motor.diff.n2.v;
//   0.0 = axis2.motor.diff.p1.i + axis2.motor.diff.n1.i;
//   0.0 = axis2.motor.diff.p2.i + axis2.motor.diff.n2.i;
//   axis2.motor.diff.i1 = axis2.motor.diff.p1.i;
//   axis2.motor.diff.i2 = axis2.motor.diff.p2.i;
//   axis2.motor.diff.v1 = 0.0;
//   axis2.motor.diff.i1 = 0.0;
//   axis2.motor.power.v1 = axis2.motor.power.p1.v - axis2.motor.power.n1.v;
//   axis2.motor.power.v2 = axis2.motor.power.p2.v - axis2.motor.power.n2.v;
//   0.0 = axis2.motor.power.p1.i + axis2.motor.power.n1.i;
//   0.0 = axis2.motor.power.p2.i + axis2.motor.power.n2.i;
//   axis2.motor.power.i1 = axis2.motor.power.p1.i;
//   axis2.motor.power.i2 = axis2.motor.power.p2.i;
//   axis2.motor.power.v1 = 0.0;
//   axis2.motor.power.i1 = 0.0;
//   axis2.motor.emf.internalSupport.flange.tau = axis2.motor.emf.internalSupport.tau;
//   axis2.motor.emf.internalSupport.flange.phi = axis2.motor.emf.internalSupport.phi;
//   axis2.motor.emf.fixed.flange.phi = axis2.motor.emf.fixed.phi0;
//   axis2.motor.emf.v = axis2.motor.emf.p.v - axis2.motor.emf.n.v;
//   0.0 = axis2.motor.emf.p.i + axis2.motor.emf.n.i;
//   axis2.motor.emf.i = axis2.motor.emf.p.i;
//   axis2.motor.emf.phi = axis2.motor.emf.flange.phi - axis2.motor.emf.internalSupport.phi;
//   axis2.motor.emf.w = der(axis2.motor.emf.phi);
//   axis2.motor.emf.k * axis2.motor.emf.w = axis2.motor.emf.v;
//   axis2.motor.emf.flange.tau = (-axis2.motor.emf.k) * axis2.motor.emf.i;
//   axis2.motor.La.L * der(axis2.motor.La.i) = axis2.motor.La.v;
//   axis2.motor.La.v = axis2.motor.La.p.v - axis2.motor.La.n.v;
//   0.0 = axis2.motor.La.p.i + axis2.motor.La.n.i;
//   axis2.motor.La.i = axis2.motor.La.p.i;
//   assert(1.0 + axis2.motor.Ra.alpha * (axis2.motor.Ra.T_heatPort - axis2.motor.Ra.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis2.motor.Ra.R_actual = axis2.motor.Ra.R * (1.0 + axis2.motor.Ra.alpha * (axis2.motor.Ra.T_heatPort - axis2.motor.Ra.T_ref));
//   axis2.motor.Ra.v = axis2.motor.Ra.R_actual * axis2.motor.Ra.i;
//   axis2.motor.Ra.LossPower = axis2.motor.Ra.v * axis2.motor.Ra.i;
//   axis2.motor.Ra.i = axis2.motor.Ra.p.i;
//   0.0 = axis2.motor.Ra.p.i + axis2.motor.Ra.n.i;
//   axis2.motor.Ra.v = axis2.motor.Ra.p.v - axis2.motor.Ra.n.v;
//   axis2.motor.Ra.T_heatPort = axis2.motor.Ra.T;
//   assert(1.0 + axis2.motor.Rd2.alpha * (axis2.motor.Rd2.T_heatPort - axis2.motor.Rd2.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis2.motor.Rd2.R_actual = axis2.motor.Rd2.R * (1.0 + axis2.motor.Rd2.alpha * (axis2.motor.Rd2.T_heatPort - axis2.motor.Rd2.T_ref));
//   axis2.motor.Rd2.v = axis2.motor.Rd2.R_actual * axis2.motor.Rd2.i;
//   axis2.motor.Rd2.LossPower = axis2.motor.Rd2.v * axis2.motor.Rd2.i;
//   axis2.motor.Rd2.i = axis2.motor.Rd2.p.i;
//   0.0 = axis2.motor.Rd2.p.i + axis2.motor.Rd2.n.i;
//   axis2.motor.Rd2.v = axis2.motor.Rd2.p.v - axis2.motor.Rd2.n.v;
//   axis2.motor.Rd2.T_heatPort = axis2.motor.Rd2.T;
//   axis2.motor.C.i = axis2.motor.C.C * der(axis2.motor.C.v);
//   axis2.motor.C.v = axis2.motor.C.p.v - axis2.motor.C.n.v;
//   0.0 = axis2.motor.C.p.i + axis2.motor.C.n.i;
//   axis2.motor.C.i = axis2.motor.C.p.i;
//   axis2.motor.OpI.v1 = axis2.motor.OpI.p1.v - axis2.motor.OpI.n1.v;
//   axis2.motor.OpI.v2 = axis2.motor.OpI.p2.v - axis2.motor.OpI.n2.v;
//   0.0 = axis2.motor.OpI.p1.i + axis2.motor.OpI.n1.i;
//   0.0 = axis2.motor.OpI.p2.i + axis2.motor.OpI.n2.i;
//   axis2.motor.OpI.i1 = axis2.motor.OpI.p1.i;
//   axis2.motor.OpI.i2 = axis2.motor.OpI.p2.i;
//   axis2.motor.OpI.v1 = 0.0;
//   axis2.motor.OpI.i1 = 0.0;
//   assert(1.0 + axis2.motor.Rd1.alpha * (axis2.motor.Rd1.T_heatPort - axis2.motor.Rd1.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis2.motor.Rd1.R_actual = axis2.motor.Rd1.R * (1.0 + axis2.motor.Rd1.alpha * (axis2.motor.Rd1.T_heatPort - axis2.motor.Rd1.T_ref));
//   axis2.motor.Rd1.v = axis2.motor.Rd1.R_actual * axis2.motor.Rd1.i;
//   axis2.motor.Rd1.LossPower = axis2.motor.Rd1.v * axis2.motor.Rd1.i;
//   axis2.motor.Rd1.i = axis2.motor.Rd1.p.i;
//   0.0 = axis2.motor.Rd1.p.i + axis2.motor.Rd1.n.i;
//   axis2.motor.Rd1.v = axis2.motor.Rd1.p.v - axis2.motor.Rd1.n.v;
//   axis2.motor.Rd1.T_heatPort = axis2.motor.Rd1.T;
//   assert(1.0 + axis2.motor.Ri.alpha * (axis2.motor.Ri.T_heatPort - axis2.motor.Ri.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis2.motor.Ri.R_actual = axis2.motor.Ri.R * (1.0 + axis2.motor.Ri.alpha * (axis2.motor.Ri.T_heatPort - axis2.motor.Ri.T_ref));
//   axis2.motor.Ri.v = axis2.motor.Ri.R_actual * axis2.motor.Ri.i;
//   axis2.motor.Ri.LossPower = axis2.motor.Ri.v * axis2.motor.Ri.i;
//   axis2.motor.Ri.i = axis2.motor.Ri.p.i;
//   0.0 = axis2.motor.Ri.p.i + axis2.motor.Ri.n.i;
//   axis2.motor.Ri.v = axis2.motor.Ri.p.v - axis2.motor.Ri.n.v;
//   axis2.motor.Ri.T_heatPort = axis2.motor.Ri.T;
//   assert(1.0 + axis2.motor.Rp1.alpha * (axis2.motor.Rp1.T_heatPort - axis2.motor.Rp1.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis2.motor.Rp1.R_actual = axis2.motor.Rp1.R * (1.0 + axis2.motor.Rp1.alpha * (axis2.motor.Rp1.T_heatPort - axis2.motor.Rp1.T_ref));
//   axis2.motor.Rp1.v = axis2.motor.Rp1.R_actual * axis2.motor.Rp1.i;
//   axis2.motor.Rp1.LossPower = axis2.motor.Rp1.v * axis2.motor.Rp1.i;
//   axis2.motor.Rp1.i = axis2.motor.Rp1.p.i;
//   0.0 = axis2.motor.Rp1.p.i + axis2.motor.Rp1.n.i;
//   axis2.motor.Rp1.v = axis2.motor.Rp1.p.v - axis2.motor.Rp1.n.v;
//   axis2.motor.Rp1.T_heatPort = axis2.motor.Rp1.T;
//   assert(1.0 + axis2.motor.Rp2.alpha * (axis2.motor.Rp2.T_heatPort - axis2.motor.Rp2.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis2.motor.Rp2.R_actual = axis2.motor.Rp2.R * (1.0 + axis2.motor.Rp2.alpha * (axis2.motor.Rp2.T_heatPort - axis2.motor.Rp2.T_ref));
//   axis2.motor.Rp2.v = axis2.motor.Rp2.R_actual * axis2.motor.Rp2.i;
//   axis2.motor.Rp2.LossPower = axis2.motor.Rp2.v * axis2.motor.Rp2.i;
//   axis2.motor.Rp2.i = axis2.motor.Rp2.p.i;
//   0.0 = axis2.motor.Rp2.p.i + axis2.motor.Rp2.n.i;
//   axis2.motor.Rp2.v = axis2.motor.Rp2.p.v - axis2.motor.Rp2.n.v;
//   axis2.motor.Rp2.T_heatPort = axis2.motor.Rp2.T;
//   assert(1.0 + axis2.motor.Rd4.alpha * (axis2.motor.Rd4.T_heatPort - axis2.motor.Rd4.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis2.motor.Rd4.R_actual = axis2.motor.Rd4.R * (1.0 + axis2.motor.Rd4.alpha * (axis2.motor.Rd4.T_heatPort - axis2.motor.Rd4.T_ref));
//   axis2.motor.Rd4.v = axis2.motor.Rd4.R_actual * axis2.motor.Rd4.i;
//   axis2.motor.Rd4.LossPower = axis2.motor.Rd4.v * axis2.motor.Rd4.i;
//   axis2.motor.Rd4.i = axis2.motor.Rd4.p.i;
//   0.0 = axis2.motor.Rd4.p.i + axis2.motor.Rd4.n.i;
//   axis2.motor.Rd4.v = axis2.motor.Rd4.p.v - axis2.motor.Rd4.n.v;
//   axis2.motor.Rd4.T_heatPort = axis2.motor.Rd4.T;
//   axis2.motor.hall2.v = axis2.motor.hall2.p.v - axis2.motor.hall2.n.v;
//   0.0 = axis2.motor.hall2.p.i + axis2.motor.hall2.n.i;
//   axis2.motor.hall2.i = axis2.motor.hall2.p.i;
//   assert(1.0 + axis2.motor.Rd3.alpha * (axis2.motor.Rd3.T_heatPort - axis2.motor.Rd3.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis2.motor.Rd3.R_actual = axis2.motor.Rd3.R * (1.0 + axis2.motor.Rd3.alpha * (axis2.motor.Rd3.T_heatPort - axis2.motor.Rd3.T_ref));
//   axis2.motor.Rd3.v = axis2.motor.Rd3.R_actual * axis2.motor.Rd3.i;
//   axis2.motor.Rd3.LossPower = axis2.motor.Rd3.v * axis2.motor.Rd3.i;
//   axis2.motor.Rd3.i = axis2.motor.Rd3.p.i;
//   0.0 = axis2.motor.Rd3.p.i + axis2.motor.Rd3.n.i;
//   axis2.motor.Rd3.v = axis2.motor.Rd3.p.v - axis2.motor.Rd3.n.v;
//   axis2.motor.Rd3.T_heatPort = axis2.motor.Rd3.T;
//   axis2.motor.g1.p.v = 0.0;
//   axis2.motor.g2.p.v = 0.0;
//   axis2.motor.g3.p.v = 0.0;
//   axis2.motor.hall1.p.v = axis2.motor.hall1.n.v;
//   axis2.motor.hall1.p.i = axis2.motor.hall1.i;
//   axis2.motor.hall1.n.i = -axis2.motor.hall1.i;
//   axis2.motor.g4.p.v = 0.0;
//   axis2.motor.g5.p.v = 0.0;
//   axis2.motor.phi.phi = axis2.motor.phi.flange.phi;
//   0.0 = axis2.motor.phi.flange.tau;
//   axis2.motor.speed.w = der(axis2.motor.speed.flange.phi);
//   0.0 = axis2.motor.speed.flange.tau;
//   axis2.motor.Jmotor.phi = axis2.motor.Jmotor.flange_a.phi;
//   axis2.motor.Jmotor.phi = axis2.motor.Jmotor.flange_b.phi;
//   axis2.motor.Jmotor.w = der(axis2.motor.Jmotor.phi);
//   axis2.motor.Jmotor.a = der(axis2.motor.Jmotor.w);
//   axis2.motor.Jmotor.J * axis2.motor.Jmotor.a = axis2.motor.Jmotor.flange_a.tau + axis2.motor.Jmotor.flange_b.tau;
//   axis2.motor.convert1.y = axis2.motor.convert1.k * axis2.motor.convert1.u;
//   axis2.motor.convert2.y = axis2.motor.convert2.k * axis2.motor.convert2.u;
//   axis2.controller.gain1.y = axis2.controller.gain1.k * axis2.controller.gain1.u;
//   der(axis2.controller.PI.x) = axis2.controller.PI.u / axis2.controller.PI.T;
//   axis2.controller.PI.y = axis2.controller.PI.k * (axis2.controller.PI.x + axis2.controller.PI.u);
//   axis2.controller.feedback1.y = axis2.controller.feedback1.u1 - axis2.controller.feedback1.u2;
//   axis2.controller.P.y = axis2.controller.P.k * axis2.controller.P.u;
//   axis2.controller.add3.y = axis2.controller.add3.k1 * axis2.controller.add3.u1 + (axis2.controller.add3.k2 * axis2.controller.add3.u2 + axis2.controller.add3.k3 * axis2.controller.add3.u3);
//   axis2.controller.gain2.y = axis2.controller.gain2.k * axis2.controller.gain2.u;
//   axis2.angleSensor.phi = axis2.angleSensor.flange.phi;
//   0.0 = axis2.angleSensor.flange.tau;
//   axis2.speedSensor.w = der(axis2.speedSensor.flange.phi);
//   0.0 = axis2.speedSensor.flange.tau;
//   axis2.accSensor.w = der(axis2.accSensor.flange.phi);
//   axis2.accSensor.a = der(axis2.accSensor.w);
//   0.0 = axis2.accSensor.flange.tau;
//   axis2.initializeFlange.set_flange_tau.flange.tau = 0.0;
//   axis2.initializeFlange.set_phi_start.flange.tau = 0.0;
//   axis2.initializeFlange.set_w_start.flange.tau = 0.0;
//   axis2.initializeFlange.set_a_start.flange.tau = 0.0;
//   axis2.const.y = axis2.const.k;
//   axis3.gear.gear.phi_a = axis3.gear.gear.flange_a.phi - axis3.gear.gear.phi_support;
//   axis3.gear.gear.phi_b = axis3.gear.gear.flange_b.phi - axis3.gear.gear.phi_support;
//   axis3.gear.gear.phi_a = axis3.gear.gear.ratio * axis3.gear.gear.phi_b;
//   0.0 = axis3.gear.gear.ratio * axis3.gear.gear.flange_a.tau + axis3.gear.gear.flange_b.tau;
//   axis3.gear.gear.phi_support = 0.0;
//   axis3.gear.spring.tau = axis3.gear.spring.c * (axis3.gear.spring.phi_rel - axis3.gear.spring.phi_rel0) + axis3.gear.spring.d * axis3.gear.spring.w_rel;
//   axis3.gear.spring.phi_rel = axis3.gear.spring.flange_b.phi - axis3.gear.spring.flange_a.phi;
//   axis3.gear.spring.w_rel = der(axis3.gear.spring.phi_rel);
//   axis3.gear.spring.a_rel = der(axis3.gear.spring.w_rel);
//   axis3.gear.spring.flange_b.tau = axis3.gear.spring.tau;
//   axis3.gear.spring.flange_a.tau = -axis3.gear.spring.tau;
//   axis3.gear.bearingFriction.tau0 = Modelica.Math.tempInterpol1(0.0,{{axis3.gear.bearingFriction.tau_pos[1,1],axis3.gear.bearingFriction.tau_pos[1,2]},{axis3.gear.bearingFriction.tau_pos[2,1],axis3.gear.bearingFriction.tau_pos[2,2]}},2);
//   axis3.gear.bearingFriction.tau0_max = axis3.gear.bearingFriction.peak * axis3.gear.bearingFriction.tau0;
//   axis3.gear.bearingFriction.free = false;
//   axis3.gear.bearingFriction.phi = axis3.gear.bearingFriction.flange_a.phi - axis3.gear.bearingFriction.phi_support;
//   axis3.gear.bearingFriction.flange_b.phi = axis3.gear.bearingFriction.flange_a.phi;
//   axis3.gear.bearingFriction.w = der(axis3.gear.bearingFriction.phi);
//   axis3.gear.bearingFriction.a = der(axis3.gear.bearingFriction.w);
//   axis3.gear.bearingFriction.w_relfric = axis3.gear.bearingFriction.w;
//   axis3.gear.bearingFriction.a_relfric = axis3.gear.bearingFriction.a;
//   axis3.gear.bearingFriction.flange_a.tau + (axis3.gear.bearingFriction.flange_b.tau - axis3.gear.bearingFriction.tau) = 0.0;
//   axis3.gear.bearingFriction.tau = if axis3.gear.bearingFriction.locked then axis3.gear.bearingFriction.sa else if axis3.gear.bearingFriction.startForward then Modelica.Math.tempInterpol1(axis3.gear.bearingFriction.w,{{axis3.gear.bearingFriction.tau_pos[1,1],axis3.gear.bearingFriction.tau_pos[1,2]},{axis3.gear.bearingFriction.tau_pos[2,1],axis3.gear.bearingFriction.tau_pos[2,2]}},2) else if axis3.gear.bearingFriction.startBackward then -Modelica.Math.tempInterpol1(-axis3.gear.bearingFriction.w,{{axis3.gear.bearingFriction.tau_pos[1,1],axis3.gear.bearingFriction.tau_pos[1,2]},{axis3.gear.bearingFriction.tau_pos[2,1],axis3.gear.bearingFriction.tau_pos[2,2]}},2) else if pre(axis3.gear.bearingFriction.mode) == 1 then Modelica.Math.tempInterpol1(axis3.gear.bearingFriction.w,{{axis3.gear.bearingFriction.tau_pos[1,1],axis3.gear.bearingFriction.tau_pos[1,2]},{axis3.gear.bearingFriction.tau_pos[2,1],axis3.gear.bearingFriction.tau_pos[2,2]}},2) else -Modelica.Math.tempInterpol1(-axis3.gear.bearingFriction.w,{{axis3.gear.bearingFriction.tau_pos[1,1],axis3.gear.bearingFriction.tau_pos[1,2]},{axis3.gear.bearingFriction.tau_pos[2,1],axis3.gear.bearingFriction.tau_pos[2,2]}},2);
//   axis3.gear.bearingFriction.phi_support = 0.0;
//   axis3.gear.bearingFriction.startForward = pre(axis3.gear.bearingFriction.mode) == 0 and (axis3.gear.bearingFriction.sa > axis3.gear.bearingFriction.tau0_max or pre(axis3.gear.bearingFriction.startForward) and axis3.gear.bearingFriction.sa > axis3.gear.bearingFriction.tau0) or pre(axis3.gear.bearingFriction.mode) == -1 and axis3.gear.bearingFriction.w_relfric > axis3.gear.bearingFriction.w_small or initial() and axis3.gear.bearingFriction.w_relfric > 0.0;
//   axis3.gear.bearingFriction.startBackward = pre(axis3.gear.bearingFriction.mode) == 0 and (axis3.gear.bearingFriction.sa < -axis3.gear.bearingFriction.tau0_max or pre(axis3.gear.bearingFriction.startBackward) and axis3.gear.bearingFriction.sa < -axis3.gear.bearingFriction.tau0) or pre(axis3.gear.bearingFriction.mode) == 1 and axis3.gear.bearingFriction.w_relfric < -axis3.gear.bearingFriction.w_small or initial() and axis3.gear.bearingFriction.w_relfric < 0.0;
//   axis3.gear.bearingFriction.locked = not axis3.gear.bearingFriction.free and not (pre(axis3.gear.bearingFriction.mode) == 1 or axis3.gear.bearingFriction.startForward or pre(axis3.gear.bearingFriction.mode) == -1 or axis3.gear.bearingFriction.startBackward);
//   axis3.gear.bearingFriction.a_relfric = if axis3.gear.bearingFriction.locked then 0.0 else if axis3.gear.bearingFriction.free then axis3.gear.bearingFriction.sa else if axis3.gear.bearingFriction.startForward then axis3.gear.bearingFriction.sa - axis3.gear.bearingFriction.tau0_max else if axis3.gear.bearingFriction.startBackward then axis3.gear.bearingFriction.sa + axis3.gear.bearingFriction.tau0_max else if pre(axis3.gear.bearingFriction.mode) == 1 then axis3.gear.bearingFriction.sa - axis3.gear.bearingFriction.tau0_max else axis3.gear.bearingFriction.sa + axis3.gear.bearingFriction.tau0_max;
//   axis3.gear.bearingFriction.mode = if axis3.gear.bearingFriction.free then 2 else if (pre(axis3.gear.bearingFriction.mode) == 1 or pre(axis3.gear.bearingFriction.mode) == 2 or axis3.gear.bearingFriction.startForward) and axis3.gear.bearingFriction.w_relfric > 0.0 then 1 else if (pre(axis3.gear.bearingFriction.mode) == -1 or pre(axis3.gear.bearingFriction.mode) == 2 or axis3.gear.bearingFriction.startBackward) and axis3.gear.bearingFriction.w_relfric < 0.0 then -1 else 0;
//   axis3.motor.Vs.v = axis3.motor.Vs.p.v - axis3.motor.Vs.n.v;
//   0.0 = axis3.motor.Vs.p.i + axis3.motor.Vs.n.i;
//   axis3.motor.Vs.i = axis3.motor.Vs.p.i;
//   axis3.motor.diff.v1 = axis3.motor.diff.p1.v - axis3.motor.diff.n1.v;
//   axis3.motor.diff.v2 = axis3.motor.diff.p2.v - axis3.motor.diff.n2.v;
//   0.0 = axis3.motor.diff.p1.i + axis3.motor.diff.n1.i;
//   0.0 = axis3.motor.diff.p2.i + axis3.motor.diff.n2.i;
//   axis3.motor.diff.i1 = axis3.motor.diff.p1.i;
//   axis3.motor.diff.i2 = axis3.motor.diff.p2.i;
//   axis3.motor.diff.v1 = 0.0;
//   axis3.motor.diff.i1 = 0.0;
//   axis3.motor.power.v1 = axis3.motor.power.p1.v - axis3.motor.power.n1.v;
//   axis3.motor.power.v2 = axis3.motor.power.p2.v - axis3.motor.power.n2.v;
//   0.0 = axis3.motor.power.p1.i + axis3.motor.power.n1.i;
//   0.0 = axis3.motor.power.p2.i + axis3.motor.power.n2.i;
//   axis3.motor.power.i1 = axis3.motor.power.p1.i;
//   axis3.motor.power.i2 = axis3.motor.power.p2.i;
//   axis3.motor.power.v1 = 0.0;
//   axis3.motor.power.i1 = 0.0;
//   axis3.motor.emf.internalSupport.flange.tau = axis3.motor.emf.internalSupport.tau;
//   axis3.motor.emf.internalSupport.flange.phi = axis3.motor.emf.internalSupport.phi;
//   axis3.motor.emf.fixed.flange.phi = axis3.motor.emf.fixed.phi0;
//   axis3.motor.emf.v = axis3.motor.emf.p.v - axis3.motor.emf.n.v;
//   0.0 = axis3.motor.emf.p.i + axis3.motor.emf.n.i;
//   axis3.motor.emf.i = axis3.motor.emf.p.i;
//   axis3.motor.emf.phi = axis3.motor.emf.flange.phi - axis3.motor.emf.internalSupport.phi;
//   axis3.motor.emf.w = der(axis3.motor.emf.phi);
//   axis3.motor.emf.k * axis3.motor.emf.w = axis3.motor.emf.v;
//   axis3.motor.emf.flange.tau = (-axis3.motor.emf.k) * axis3.motor.emf.i;
//   axis3.motor.La.L * der(axis3.motor.La.i) = axis3.motor.La.v;
//   axis3.motor.La.v = axis3.motor.La.p.v - axis3.motor.La.n.v;
//   0.0 = axis3.motor.La.p.i + axis3.motor.La.n.i;
//   axis3.motor.La.i = axis3.motor.La.p.i;
//   assert(1.0 + axis3.motor.Ra.alpha * (axis3.motor.Ra.T_heatPort - axis3.motor.Ra.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis3.motor.Ra.R_actual = axis3.motor.Ra.R * (1.0 + axis3.motor.Ra.alpha * (axis3.motor.Ra.T_heatPort - axis3.motor.Ra.T_ref));
//   axis3.motor.Ra.v = axis3.motor.Ra.R_actual * axis3.motor.Ra.i;
//   axis3.motor.Ra.LossPower = axis3.motor.Ra.v * axis3.motor.Ra.i;
//   axis3.motor.Ra.i = axis3.motor.Ra.p.i;
//   0.0 = axis3.motor.Ra.p.i + axis3.motor.Ra.n.i;
//   axis3.motor.Ra.v = axis3.motor.Ra.p.v - axis3.motor.Ra.n.v;
//   axis3.motor.Ra.T_heatPort = axis3.motor.Ra.T;
//   assert(1.0 + axis3.motor.Rd2.alpha * (axis3.motor.Rd2.T_heatPort - axis3.motor.Rd2.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis3.motor.Rd2.R_actual = axis3.motor.Rd2.R * (1.0 + axis3.motor.Rd2.alpha * (axis3.motor.Rd2.T_heatPort - axis3.motor.Rd2.T_ref));
//   axis3.motor.Rd2.v = axis3.motor.Rd2.R_actual * axis3.motor.Rd2.i;
//   axis3.motor.Rd2.LossPower = axis3.motor.Rd2.v * axis3.motor.Rd2.i;
//   axis3.motor.Rd2.i = axis3.motor.Rd2.p.i;
//   0.0 = axis3.motor.Rd2.p.i + axis3.motor.Rd2.n.i;
//   axis3.motor.Rd2.v = axis3.motor.Rd2.p.v - axis3.motor.Rd2.n.v;
//   axis3.motor.Rd2.T_heatPort = axis3.motor.Rd2.T;
//   axis3.motor.C.i = axis3.motor.C.C * der(axis3.motor.C.v);
//   axis3.motor.C.v = axis3.motor.C.p.v - axis3.motor.C.n.v;
//   0.0 = axis3.motor.C.p.i + axis3.motor.C.n.i;
//   axis3.motor.C.i = axis3.motor.C.p.i;
//   axis3.motor.OpI.v1 = axis3.motor.OpI.p1.v - axis3.motor.OpI.n1.v;
//   axis3.motor.OpI.v2 = axis3.motor.OpI.p2.v - axis3.motor.OpI.n2.v;
//   0.0 = axis3.motor.OpI.p1.i + axis3.motor.OpI.n1.i;
//   0.0 = axis3.motor.OpI.p2.i + axis3.motor.OpI.n2.i;
//   axis3.motor.OpI.i1 = axis3.motor.OpI.p1.i;
//   axis3.motor.OpI.i2 = axis3.motor.OpI.p2.i;
//   axis3.motor.OpI.v1 = 0.0;
//   axis3.motor.OpI.i1 = 0.0;
//   assert(1.0 + axis3.motor.Rd1.alpha * (axis3.motor.Rd1.T_heatPort - axis3.motor.Rd1.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis3.motor.Rd1.R_actual = axis3.motor.Rd1.R * (1.0 + axis3.motor.Rd1.alpha * (axis3.motor.Rd1.T_heatPort - axis3.motor.Rd1.T_ref));
//   axis3.motor.Rd1.v = axis3.motor.Rd1.R_actual * axis3.motor.Rd1.i;
//   axis3.motor.Rd1.LossPower = axis3.motor.Rd1.v * axis3.motor.Rd1.i;
//   axis3.motor.Rd1.i = axis3.motor.Rd1.p.i;
//   0.0 = axis3.motor.Rd1.p.i + axis3.motor.Rd1.n.i;
//   axis3.motor.Rd1.v = axis3.motor.Rd1.p.v - axis3.motor.Rd1.n.v;
//   axis3.motor.Rd1.T_heatPort = axis3.motor.Rd1.T;
//   assert(1.0 + axis3.motor.Ri.alpha * (axis3.motor.Ri.T_heatPort - axis3.motor.Ri.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis3.motor.Ri.R_actual = axis3.motor.Ri.R * (1.0 + axis3.motor.Ri.alpha * (axis3.motor.Ri.T_heatPort - axis3.motor.Ri.T_ref));
//   axis3.motor.Ri.v = axis3.motor.Ri.R_actual * axis3.motor.Ri.i;
//   axis3.motor.Ri.LossPower = axis3.motor.Ri.v * axis3.motor.Ri.i;
//   axis3.motor.Ri.i = axis3.motor.Ri.p.i;
//   0.0 = axis3.motor.Ri.p.i + axis3.motor.Ri.n.i;
//   axis3.motor.Ri.v = axis3.motor.Ri.p.v - axis3.motor.Ri.n.v;
//   axis3.motor.Ri.T_heatPort = axis3.motor.Ri.T;
//   assert(1.0 + axis3.motor.Rp1.alpha * (axis3.motor.Rp1.T_heatPort - axis3.motor.Rp1.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis3.motor.Rp1.R_actual = axis3.motor.Rp1.R * (1.0 + axis3.motor.Rp1.alpha * (axis3.motor.Rp1.T_heatPort - axis3.motor.Rp1.T_ref));
//   axis3.motor.Rp1.v = axis3.motor.Rp1.R_actual * axis3.motor.Rp1.i;
//   axis3.motor.Rp1.LossPower = axis3.motor.Rp1.v * axis3.motor.Rp1.i;
//   axis3.motor.Rp1.i = axis3.motor.Rp1.p.i;
//   0.0 = axis3.motor.Rp1.p.i + axis3.motor.Rp1.n.i;
//   axis3.motor.Rp1.v = axis3.motor.Rp1.p.v - axis3.motor.Rp1.n.v;
//   axis3.motor.Rp1.T_heatPort = axis3.motor.Rp1.T;
//   assert(1.0 + axis3.motor.Rp2.alpha * (axis3.motor.Rp2.T_heatPort - axis3.motor.Rp2.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis3.motor.Rp2.R_actual = axis3.motor.Rp2.R * (1.0 + axis3.motor.Rp2.alpha * (axis3.motor.Rp2.T_heatPort - axis3.motor.Rp2.T_ref));
//   axis3.motor.Rp2.v = axis3.motor.Rp2.R_actual * axis3.motor.Rp2.i;
//   axis3.motor.Rp2.LossPower = axis3.motor.Rp2.v * axis3.motor.Rp2.i;
//   axis3.motor.Rp2.i = axis3.motor.Rp2.p.i;
//   0.0 = axis3.motor.Rp2.p.i + axis3.motor.Rp2.n.i;
//   axis3.motor.Rp2.v = axis3.motor.Rp2.p.v - axis3.motor.Rp2.n.v;
//   axis3.motor.Rp2.T_heatPort = axis3.motor.Rp2.T;
//   assert(1.0 + axis3.motor.Rd4.alpha * (axis3.motor.Rd4.T_heatPort - axis3.motor.Rd4.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis3.motor.Rd4.R_actual = axis3.motor.Rd4.R * (1.0 + axis3.motor.Rd4.alpha * (axis3.motor.Rd4.T_heatPort - axis3.motor.Rd4.T_ref));
//   axis3.motor.Rd4.v = axis3.motor.Rd4.R_actual * axis3.motor.Rd4.i;
//   axis3.motor.Rd4.LossPower = axis3.motor.Rd4.v * axis3.motor.Rd4.i;
//   axis3.motor.Rd4.i = axis3.motor.Rd4.p.i;
//   0.0 = axis3.motor.Rd4.p.i + axis3.motor.Rd4.n.i;
//   axis3.motor.Rd4.v = axis3.motor.Rd4.p.v - axis3.motor.Rd4.n.v;
//   axis3.motor.Rd4.T_heatPort = axis3.motor.Rd4.T;
//   axis3.motor.hall2.v = axis3.motor.hall2.p.v - axis3.motor.hall2.n.v;
//   0.0 = axis3.motor.hall2.p.i + axis3.motor.hall2.n.i;
//   axis3.motor.hall2.i = axis3.motor.hall2.p.i;
//   assert(1.0 + axis3.motor.Rd3.alpha * (axis3.motor.Rd3.T_heatPort - axis3.motor.Rd3.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis3.motor.Rd3.R_actual = axis3.motor.Rd3.R * (1.0 + axis3.motor.Rd3.alpha * (axis3.motor.Rd3.T_heatPort - axis3.motor.Rd3.T_ref));
//   axis3.motor.Rd3.v = axis3.motor.Rd3.R_actual * axis3.motor.Rd3.i;
//   axis3.motor.Rd3.LossPower = axis3.motor.Rd3.v * axis3.motor.Rd3.i;
//   axis3.motor.Rd3.i = axis3.motor.Rd3.p.i;
//   0.0 = axis3.motor.Rd3.p.i + axis3.motor.Rd3.n.i;
//   axis3.motor.Rd3.v = axis3.motor.Rd3.p.v - axis3.motor.Rd3.n.v;
//   axis3.motor.Rd3.T_heatPort = axis3.motor.Rd3.T;
//   axis3.motor.g1.p.v = 0.0;
//   axis3.motor.g2.p.v = 0.0;
//   axis3.motor.g3.p.v = 0.0;
//   axis3.motor.hall1.p.v = axis3.motor.hall1.n.v;
//   axis3.motor.hall1.p.i = axis3.motor.hall1.i;
//   axis3.motor.hall1.n.i = -axis3.motor.hall1.i;
//   axis3.motor.g4.p.v = 0.0;
//   axis3.motor.g5.p.v = 0.0;
//   axis3.motor.phi.phi = axis3.motor.phi.flange.phi;
//   0.0 = axis3.motor.phi.flange.tau;
//   axis3.motor.speed.w = der(axis3.motor.speed.flange.phi);
//   0.0 = axis3.motor.speed.flange.tau;
//   axis3.motor.Jmotor.phi = axis3.motor.Jmotor.flange_a.phi;
//   axis3.motor.Jmotor.phi = axis3.motor.Jmotor.flange_b.phi;
//   axis3.motor.Jmotor.w = der(axis3.motor.Jmotor.phi);
//   axis3.motor.Jmotor.a = der(axis3.motor.Jmotor.w);
//   axis3.motor.Jmotor.J * axis3.motor.Jmotor.a = axis3.motor.Jmotor.flange_a.tau + axis3.motor.Jmotor.flange_b.tau;
//   axis3.motor.convert1.y = axis3.motor.convert1.k * axis3.motor.convert1.u;
//   axis3.motor.convert2.y = axis3.motor.convert2.k * axis3.motor.convert2.u;
//   axis3.controller.gain1.y = axis3.controller.gain1.k * axis3.controller.gain1.u;
//   der(axis3.controller.PI.x) = axis3.controller.PI.u / axis3.controller.PI.T;
//   axis3.controller.PI.y = axis3.controller.PI.k * (axis3.controller.PI.x + axis3.controller.PI.u);
//   axis3.controller.feedback1.y = axis3.controller.feedback1.u1 - axis3.controller.feedback1.u2;
//   axis3.controller.P.y = axis3.controller.P.k * axis3.controller.P.u;
//   axis3.controller.add3.y = axis3.controller.add3.k1 * axis3.controller.add3.u1 + (axis3.controller.add3.k2 * axis3.controller.add3.u2 + axis3.controller.add3.k3 * axis3.controller.add3.u3);
//   axis3.controller.gain2.y = axis3.controller.gain2.k * axis3.controller.gain2.u;
//   axis3.angleSensor.phi = axis3.angleSensor.flange.phi;
//   0.0 = axis3.angleSensor.flange.tau;
//   axis3.speedSensor.w = der(axis3.speedSensor.flange.phi);
//   0.0 = axis3.speedSensor.flange.tau;
//   axis3.accSensor.w = der(axis3.accSensor.flange.phi);
//   axis3.accSensor.a = der(axis3.accSensor.w);
//   0.0 = axis3.accSensor.flange.tau;
//   axis3.initializeFlange.set_flange_tau.flange.tau = 0.0;
//   axis3.initializeFlange.set_phi_start.flange.tau = 0.0;
//   axis3.initializeFlange.set_w_start.flange.tau = 0.0;
//   axis3.initializeFlange.set_a_start.flange.tau = 0.0;
//   axis3.const.y = axis3.const.k;
//   axis4.gear.gear.phi_a = axis4.gear.gear.flange_a.phi - axis4.gear.gear.phi_support;
//   axis4.gear.gear.phi_b = axis4.gear.gear.flange_b.phi - axis4.gear.gear.phi_support;
//   axis4.gear.gear.phi_a = axis4.gear.gear.ratio * axis4.gear.gear.phi_b;
//   0.0 = axis4.gear.gear.ratio * axis4.gear.gear.flange_a.tau + axis4.gear.gear.flange_b.tau;
//   axis4.gear.gear.phi_support = 0.0;
//   axis4.gear.bearingFriction.tau0 = Modelica.Math.tempInterpol1(0.0,{{axis4.gear.bearingFriction.tau_pos[1,1],axis4.gear.bearingFriction.tau_pos[1,2]},{axis4.gear.bearingFriction.tau_pos[2,1],axis4.gear.bearingFriction.tau_pos[2,2]}},2);
//   axis4.gear.bearingFriction.tau0_max = axis4.gear.bearingFriction.peak * axis4.gear.bearingFriction.tau0;
//   axis4.gear.bearingFriction.free = false;
//   axis4.gear.bearingFriction.phi = axis4.gear.bearingFriction.flange_a.phi - axis4.gear.bearingFriction.phi_support;
//   axis4.gear.bearingFriction.flange_b.phi = axis4.gear.bearingFriction.flange_a.phi;
//   axis4.gear.bearingFriction.w = der(axis4.gear.bearingFriction.phi);
//   axis4.gear.bearingFriction.a = der(axis4.gear.bearingFriction.w);
//   axis4.gear.bearingFriction.w_relfric = axis4.gear.bearingFriction.w;
//   axis4.gear.bearingFriction.a_relfric = axis4.gear.bearingFriction.a;
//   axis4.gear.bearingFriction.flange_a.tau + (axis4.gear.bearingFriction.flange_b.tau - axis4.gear.bearingFriction.tau) = 0.0;
//   axis4.gear.bearingFriction.tau = if axis4.gear.bearingFriction.locked then axis4.gear.bearingFriction.sa else if axis4.gear.bearingFriction.startForward then Modelica.Math.tempInterpol1(axis4.gear.bearingFriction.w,{{axis4.gear.bearingFriction.tau_pos[1,1],axis4.gear.bearingFriction.tau_pos[1,2]},{axis4.gear.bearingFriction.tau_pos[2,1],axis4.gear.bearingFriction.tau_pos[2,2]}},2) else if axis4.gear.bearingFriction.startBackward then -Modelica.Math.tempInterpol1(-axis4.gear.bearingFriction.w,{{axis4.gear.bearingFriction.tau_pos[1,1],axis4.gear.bearingFriction.tau_pos[1,2]},{axis4.gear.bearingFriction.tau_pos[2,1],axis4.gear.bearingFriction.tau_pos[2,2]}},2) else if pre(axis4.gear.bearingFriction.mode) == 1 then Modelica.Math.tempInterpol1(axis4.gear.bearingFriction.w,{{axis4.gear.bearingFriction.tau_pos[1,1],axis4.gear.bearingFriction.tau_pos[1,2]},{axis4.gear.bearingFriction.tau_pos[2,1],axis4.gear.bearingFriction.tau_pos[2,2]}},2) else -Modelica.Math.tempInterpol1(-axis4.gear.bearingFriction.w,{{axis4.gear.bearingFriction.tau_pos[1,1],axis4.gear.bearingFriction.tau_pos[1,2]},{axis4.gear.bearingFriction.tau_pos[2,1],axis4.gear.bearingFriction.tau_pos[2,2]}},2);
//   axis4.gear.bearingFriction.phi_support = 0.0;
//   axis4.gear.bearingFriction.startForward = pre(axis4.gear.bearingFriction.mode) == 0 and (axis4.gear.bearingFriction.sa > axis4.gear.bearingFriction.tau0_max or pre(axis4.gear.bearingFriction.startForward) and axis4.gear.bearingFriction.sa > axis4.gear.bearingFriction.tau0) or pre(axis4.gear.bearingFriction.mode) == -1 and axis4.gear.bearingFriction.w_relfric > axis4.gear.bearingFriction.w_small or initial() and axis4.gear.bearingFriction.w_relfric > 0.0;
//   axis4.gear.bearingFriction.startBackward = pre(axis4.gear.bearingFriction.mode) == 0 and (axis4.gear.bearingFriction.sa < -axis4.gear.bearingFriction.tau0_max or pre(axis4.gear.bearingFriction.startBackward) and axis4.gear.bearingFriction.sa < -axis4.gear.bearingFriction.tau0) or pre(axis4.gear.bearingFriction.mode) == 1 and axis4.gear.bearingFriction.w_relfric < -axis4.gear.bearingFriction.w_small or initial() and axis4.gear.bearingFriction.w_relfric < 0.0;
//   axis4.gear.bearingFriction.locked = not axis4.gear.bearingFriction.free and not (pre(axis4.gear.bearingFriction.mode) == 1 or axis4.gear.bearingFriction.startForward or pre(axis4.gear.bearingFriction.mode) == -1 or axis4.gear.bearingFriction.startBackward);
//   axis4.gear.bearingFriction.a_relfric = if axis4.gear.bearingFriction.locked then 0.0 else if axis4.gear.bearingFriction.free then axis4.gear.bearingFriction.sa else if axis4.gear.bearingFriction.startForward then axis4.gear.bearingFriction.sa - axis4.gear.bearingFriction.tau0_max else if axis4.gear.bearingFriction.startBackward then axis4.gear.bearingFriction.sa + axis4.gear.bearingFriction.tau0_max else if pre(axis4.gear.bearingFriction.mode) == 1 then axis4.gear.bearingFriction.sa - axis4.gear.bearingFriction.tau0_max else axis4.gear.bearingFriction.sa + axis4.gear.bearingFriction.tau0_max;
//   axis4.gear.bearingFriction.mode = if axis4.gear.bearingFriction.free then 2 else if (pre(axis4.gear.bearingFriction.mode) == 1 or pre(axis4.gear.bearingFriction.mode) == 2 or axis4.gear.bearingFriction.startForward) and axis4.gear.bearingFriction.w_relfric > 0.0 then 1 else if (pre(axis4.gear.bearingFriction.mode) == -1 or pre(axis4.gear.bearingFriction.mode) == 2 or axis4.gear.bearingFriction.startBackward) and axis4.gear.bearingFriction.w_relfric < 0.0 then -1 else 0;
//   axis4.motor.Vs.v = axis4.motor.Vs.p.v - axis4.motor.Vs.n.v;
//   0.0 = axis4.motor.Vs.p.i + axis4.motor.Vs.n.i;
//   axis4.motor.Vs.i = axis4.motor.Vs.p.i;
//   axis4.motor.diff.v1 = axis4.motor.diff.p1.v - axis4.motor.diff.n1.v;
//   axis4.motor.diff.v2 = axis4.motor.diff.p2.v - axis4.motor.diff.n2.v;
//   0.0 = axis4.motor.diff.p1.i + axis4.motor.diff.n1.i;
//   0.0 = axis4.motor.diff.p2.i + axis4.motor.diff.n2.i;
//   axis4.motor.diff.i1 = axis4.motor.diff.p1.i;
//   axis4.motor.diff.i2 = axis4.motor.diff.p2.i;
//   axis4.motor.diff.v1 = 0.0;
//   axis4.motor.diff.i1 = 0.0;
//   axis4.motor.power.v1 = axis4.motor.power.p1.v - axis4.motor.power.n1.v;
//   axis4.motor.power.v2 = axis4.motor.power.p2.v - axis4.motor.power.n2.v;
//   0.0 = axis4.motor.power.p1.i + axis4.motor.power.n1.i;
//   0.0 = axis4.motor.power.p2.i + axis4.motor.power.n2.i;
//   axis4.motor.power.i1 = axis4.motor.power.p1.i;
//   axis4.motor.power.i2 = axis4.motor.power.p2.i;
//   axis4.motor.power.v1 = 0.0;
//   axis4.motor.power.i1 = 0.0;
//   axis4.motor.emf.internalSupport.flange.tau = axis4.motor.emf.internalSupport.tau;
//   axis4.motor.emf.internalSupport.flange.phi = axis4.motor.emf.internalSupport.phi;
//   axis4.motor.emf.fixed.flange.phi = axis4.motor.emf.fixed.phi0;
//   axis4.motor.emf.v = axis4.motor.emf.p.v - axis4.motor.emf.n.v;
//   0.0 = axis4.motor.emf.p.i + axis4.motor.emf.n.i;
//   axis4.motor.emf.i = axis4.motor.emf.p.i;
//   axis4.motor.emf.phi = axis4.motor.emf.flange.phi - axis4.motor.emf.internalSupport.phi;
//   axis4.motor.emf.w = der(axis4.motor.emf.phi);
//   axis4.motor.emf.k * axis4.motor.emf.w = axis4.motor.emf.v;
//   axis4.motor.emf.flange.tau = (-axis4.motor.emf.k) * axis4.motor.emf.i;
//   axis4.motor.La.L * der(axis4.motor.La.i) = axis4.motor.La.v;
//   axis4.motor.La.v = axis4.motor.La.p.v - axis4.motor.La.n.v;
//   0.0 = axis4.motor.La.p.i + axis4.motor.La.n.i;
//   axis4.motor.La.i = axis4.motor.La.p.i;
//   assert(1.0 + axis4.motor.Ra.alpha * (axis4.motor.Ra.T_heatPort - axis4.motor.Ra.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis4.motor.Ra.R_actual = axis4.motor.Ra.R * (1.0 + axis4.motor.Ra.alpha * (axis4.motor.Ra.T_heatPort - axis4.motor.Ra.T_ref));
//   axis4.motor.Ra.v = axis4.motor.Ra.R_actual * axis4.motor.Ra.i;
//   axis4.motor.Ra.LossPower = axis4.motor.Ra.v * axis4.motor.Ra.i;
//   axis4.motor.Ra.i = axis4.motor.Ra.p.i;
//   0.0 = axis4.motor.Ra.p.i + axis4.motor.Ra.n.i;
//   axis4.motor.Ra.v = axis4.motor.Ra.p.v - axis4.motor.Ra.n.v;
//   axis4.motor.Ra.T_heatPort = axis4.motor.Ra.T;
//   assert(1.0 + axis4.motor.Rd2.alpha * (axis4.motor.Rd2.T_heatPort - axis4.motor.Rd2.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis4.motor.Rd2.R_actual = axis4.motor.Rd2.R * (1.0 + axis4.motor.Rd2.alpha * (axis4.motor.Rd2.T_heatPort - axis4.motor.Rd2.T_ref));
//   axis4.motor.Rd2.v = axis4.motor.Rd2.R_actual * axis4.motor.Rd2.i;
//   axis4.motor.Rd2.LossPower = axis4.motor.Rd2.v * axis4.motor.Rd2.i;
//   axis4.motor.Rd2.i = axis4.motor.Rd2.p.i;
//   0.0 = axis4.motor.Rd2.p.i + axis4.motor.Rd2.n.i;
//   axis4.motor.Rd2.v = axis4.motor.Rd2.p.v - axis4.motor.Rd2.n.v;
//   axis4.motor.Rd2.T_heatPort = axis4.motor.Rd2.T;
//   axis4.motor.C.i = axis4.motor.C.C * der(axis4.motor.C.v);
//   axis4.motor.C.v = axis4.motor.C.p.v - axis4.motor.C.n.v;
//   0.0 = axis4.motor.C.p.i + axis4.motor.C.n.i;
//   axis4.motor.C.i = axis4.motor.C.p.i;
//   axis4.motor.OpI.v1 = axis4.motor.OpI.p1.v - axis4.motor.OpI.n1.v;
//   axis4.motor.OpI.v2 = axis4.motor.OpI.p2.v - axis4.motor.OpI.n2.v;
//   0.0 = axis4.motor.OpI.p1.i + axis4.motor.OpI.n1.i;
//   0.0 = axis4.motor.OpI.p2.i + axis4.motor.OpI.n2.i;
//   axis4.motor.OpI.i1 = axis4.motor.OpI.p1.i;
//   axis4.motor.OpI.i2 = axis4.motor.OpI.p2.i;
//   axis4.motor.OpI.v1 = 0.0;
//   axis4.motor.OpI.i1 = 0.0;
//   assert(1.0 + axis4.motor.Rd1.alpha * (axis4.motor.Rd1.T_heatPort - axis4.motor.Rd1.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis4.motor.Rd1.R_actual = axis4.motor.Rd1.R * (1.0 + axis4.motor.Rd1.alpha * (axis4.motor.Rd1.T_heatPort - axis4.motor.Rd1.T_ref));
//   axis4.motor.Rd1.v = axis4.motor.Rd1.R_actual * axis4.motor.Rd1.i;
//   axis4.motor.Rd1.LossPower = axis4.motor.Rd1.v * axis4.motor.Rd1.i;
//   axis4.motor.Rd1.i = axis4.motor.Rd1.p.i;
//   0.0 = axis4.motor.Rd1.p.i + axis4.motor.Rd1.n.i;
//   axis4.motor.Rd1.v = axis4.motor.Rd1.p.v - axis4.motor.Rd1.n.v;
//   axis4.motor.Rd1.T_heatPort = axis4.motor.Rd1.T;
//   assert(1.0 + axis4.motor.Ri.alpha * (axis4.motor.Ri.T_heatPort - axis4.motor.Ri.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis4.motor.Ri.R_actual = axis4.motor.Ri.R * (1.0 + axis4.motor.Ri.alpha * (axis4.motor.Ri.T_heatPort - axis4.motor.Ri.T_ref));
//   axis4.motor.Ri.v = axis4.motor.Ri.R_actual * axis4.motor.Ri.i;
//   axis4.motor.Ri.LossPower = axis4.motor.Ri.v * axis4.motor.Ri.i;
//   axis4.motor.Ri.i = axis4.motor.Ri.p.i;
//   0.0 = axis4.motor.Ri.p.i + axis4.motor.Ri.n.i;
//   axis4.motor.Ri.v = axis4.motor.Ri.p.v - axis4.motor.Ri.n.v;
//   axis4.motor.Ri.T_heatPort = axis4.motor.Ri.T;
//   assert(1.0 + axis4.motor.Rp1.alpha * (axis4.motor.Rp1.T_heatPort - axis4.motor.Rp1.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis4.motor.Rp1.R_actual = axis4.motor.Rp1.R * (1.0 + axis4.motor.Rp1.alpha * (axis4.motor.Rp1.T_heatPort - axis4.motor.Rp1.T_ref));
//   axis4.motor.Rp1.v = axis4.motor.Rp1.R_actual * axis4.motor.Rp1.i;
//   axis4.motor.Rp1.LossPower = axis4.motor.Rp1.v * axis4.motor.Rp1.i;
//   axis4.motor.Rp1.i = axis4.motor.Rp1.p.i;
//   0.0 = axis4.motor.Rp1.p.i + axis4.motor.Rp1.n.i;
//   axis4.motor.Rp1.v = axis4.motor.Rp1.p.v - axis4.motor.Rp1.n.v;
//   axis4.motor.Rp1.T_heatPort = axis4.motor.Rp1.T;
//   assert(1.0 + axis4.motor.Rp2.alpha * (axis4.motor.Rp2.T_heatPort - axis4.motor.Rp2.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis4.motor.Rp2.R_actual = axis4.motor.Rp2.R * (1.0 + axis4.motor.Rp2.alpha * (axis4.motor.Rp2.T_heatPort - axis4.motor.Rp2.T_ref));
//   axis4.motor.Rp2.v = axis4.motor.Rp2.R_actual * axis4.motor.Rp2.i;
//   axis4.motor.Rp2.LossPower = axis4.motor.Rp2.v * axis4.motor.Rp2.i;
//   axis4.motor.Rp2.i = axis4.motor.Rp2.p.i;
//   0.0 = axis4.motor.Rp2.p.i + axis4.motor.Rp2.n.i;
//   axis4.motor.Rp2.v = axis4.motor.Rp2.p.v - axis4.motor.Rp2.n.v;
//   axis4.motor.Rp2.T_heatPort = axis4.motor.Rp2.T;
//   assert(1.0 + axis4.motor.Rd4.alpha * (axis4.motor.Rd4.T_heatPort - axis4.motor.Rd4.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis4.motor.Rd4.R_actual = axis4.motor.Rd4.R * (1.0 + axis4.motor.Rd4.alpha * (axis4.motor.Rd4.T_heatPort - axis4.motor.Rd4.T_ref));
//   axis4.motor.Rd4.v = axis4.motor.Rd4.R_actual * axis4.motor.Rd4.i;
//   axis4.motor.Rd4.LossPower = axis4.motor.Rd4.v * axis4.motor.Rd4.i;
//   axis4.motor.Rd4.i = axis4.motor.Rd4.p.i;
//   0.0 = axis4.motor.Rd4.p.i + axis4.motor.Rd4.n.i;
//   axis4.motor.Rd4.v = axis4.motor.Rd4.p.v - axis4.motor.Rd4.n.v;
//   axis4.motor.Rd4.T_heatPort = axis4.motor.Rd4.T;
//   axis4.motor.hall2.v = axis4.motor.hall2.p.v - axis4.motor.hall2.n.v;
//   0.0 = axis4.motor.hall2.p.i + axis4.motor.hall2.n.i;
//   axis4.motor.hall2.i = axis4.motor.hall2.p.i;
//   assert(1.0 + axis4.motor.Rd3.alpha * (axis4.motor.Rd3.T_heatPort - axis4.motor.Rd3.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis4.motor.Rd3.R_actual = axis4.motor.Rd3.R * (1.0 + axis4.motor.Rd3.alpha * (axis4.motor.Rd3.T_heatPort - axis4.motor.Rd3.T_ref));
//   axis4.motor.Rd3.v = axis4.motor.Rd3.R_actual * axis4.motor.Rd3.i;
//   axis4.motor.Rd3.LossPower = axis4.motor.Rd3.v * axis4.motor.Rd3.i;
//   axis4.motor.Rd3.i = axis4.motor.Rd3.p.i;
//   0.0 = axis4.motor.Rd3.p.i + axis4.motor.Rd3.n.i;
//   axis4.motor.Rd3.v = axis4.motor.Rd3.p.v - axis4.motor.Rd3.n.v;
//   axis4.motor.Rd3.T_heatPort = axis4.motor.Rd3.T;
//   axis4.motor.g1.p.v = 0.0;
//   axis4.motor.g2.p.v = 0.0;
//   axis4.motor.g3.p.v = 0.0;
//   axis4.motor.hall1.p.v = axis4.motor.hall1.n.v;
//   axis4.motor.hall1.p.i = axis4.motor.hall1.i;
//   axis4.motor.hall1.n.i = -axis4.motor.hall1.i;
//   axis4.motor.g4.p.v = 0.0;
//   axis4.motor.g5.p.v = 0.0;
//   axis4.motor.phi.phi = axis4.motor.phi.flange.phi;
//   0.0 = axis4.motor.phi.flange.tau;
//   axis4.motor.speed.w = der(axis4.motor.speed.flange.phi);
//   0.0 = axis4.motor.speed.flange.tau;
//   axis4.motor.Jmotor.phi = axis4.motor.Jmotor.flange_a.phi;
//   axis4.motor.Jmotor.phi = axis4.motor.Jmotor.flange_b.phi;
//   axis4.motor.Jmotor.w = der(axis4.motor.Jmotor.phi);
//   axis4.motor.Jmotor.a = der(axis4.motor.Jmotor.w);
//   axis4.motor.Jmotor.J * axis4.motor.Jmotor.a = axis4.motor.Jmotor.flange_a.tau + axis4.motor.Jmotor.flange_b.tau;
//   axis4.motor.convert1.y = axis4.motor.convert1.k * axis4.motor.convert1.u;
//   axis4.motor.convert2.y = axis4.motor.convert2.k * axis4.motor.convert2.u;
//   axis4.controller.gain1.y = axis4.controller.gain1.k * axis4.controller.gain1.u;
//   der(axis4.controller.PI.x) = axis4.controller.PI.u / axis4.controller.PI.T;
//   axis4.controller.PI.y = axis4.controller.PI.k * (axis4.controller.PI.x + axis4.controller.PI.u);
//   axis4.controller.feedback1.y = axis4.controller.feedback1.u1 - axis4.controller.feedback1.u2;
//   axis4.controller.P.y = axis4.controller.P.k * axis4.controller.P.u;
//   axis4.controller.add3.y = axis4.controller.add3.k1 * axis4.controller.add3.u1 + (axis4.controller.add3.k2 * axis4.controller.add3.u2 + axis4.controller.add3.k3 * axis4.controller.add3.u3);
//   axis4.controller.gain2.y = axis4.controller.gain2.k * axis4.controller.gain2.u;
//   axis4.angleSensor.phi = axis4.angleSensor.flange.phi;
//   0.0 = axis4.angleSensor.flange.tau;
//   axis4.speedSensor.w = der(axis4.speedSensor.flange.phi);
//   0.0 = axis4.speedSensor.flange.tau;
//   axis4.accSensor.w = der(axis4.accSensor.flange.phi);
//   axis4.accSensor.a = der(axis4.accSensor.w);
//   0.0 = axis4.accSensor.flange.tau;
//   axis4.initializeFlange.set_flange_tau.flange.tau = 0.0;
//   axis4.initializeFlange.set_phi_start.flange.tau = 0.0;
//   axis4.initializeFlange.set_w_start.flange.tau = 0.0;
//   axis4.initializeFlange.set_a_start.flange.tau = 0.0;
//   axis4.const.y = axis4.const.k;
//   axis5.gear.gear.phi_a = axis5.gear.gear.flange_a.phi - axis5.gear.gear.phi_support;
//   axis5.gear.gear.phi_b = axis5.gear.gear.flange_b.phi - axis5.gear.gear.phi_support;
//   axis5.gear.gear.phi_a = axis5.gear.gear.ratio * axis5.gear.gear.phi_b;
//   0.0 = axis5.gear.gear.ratio * axis5.gear.gear.flange_a.tau + axis5.gear.gear.flange_b.tau;
//   axis5.gear.gear.phi_support = 0.0;
//   axis5.gear.bearingFriction.tau0 = Modelica.Math.tempInterpol1(0.0,{{axis5.gear.bearingFriction.tau_pos[1,1],axis5.gear.bearingFriction.tau_pos[1,2]},{axis5.gear.bearingFriction.tau_pos[2,1],axis5.gear.bearingFriction.tau_pos[2,2]}},2);
//   axis5.gear.bearingFriction.tau0_max = axis5.gear.bearingFriction.peak * axis5.gear.bearingFriction.tau0;
//   axis5.gear.bearingFriction.free = false;
//   axis5.gear.bearingFriction.phi = axis5.gear.bearingFriction.flange_a.phi - axis5.gear.bearingFriction.phi_support;
//   axis5.gear.bearingFriction.flange_b.phi = axis5.gear.bearingFriction.flange_a.phi;
//   axis5.gear.bearingFriction.w = der(axis5.gear.bearingFriction.phi);
//   axis5.gear.bearingFriction.a = der(axis5.gear.bearingFriction.w);
//   axis5.gear.bearingFriction.w_relfric = axis5.gear.bearingFriction.w;
//   axis5.gear.bearingFriction.a_relfric = axis5.gear.bearingFriction.a;
//   axis5.gear.bearingFriction.flange_a.tau + (axis5.gear.bearingFriction.flange_b.tau - axis5.gear.bearingFriction.tau) = 0.0;
//   axis5.gear.bearingFriction.tau = if axis5.gear.bearingFriction.locked then axis5.gear.bearingFriction.sa else if axis5.gear.bearingFriction.startForward then Modelica.Math.tempInterpol1(axis5.gear.bearingFriction.w,{{axis5.gear.bearingFriction.tau_pos[1,1],axis5.gear.bearingFriction.tau_pos[1,2]},{axis5.gear.bearingFriction.tau_pos[2,1],axis5.gear.bearingFriction.tau_pos[2,2]}},2) else if axis5.gear.bearingFriction.startBackward then -Modelica.Math.tempInterpol1(-axis5.gear.bearingFriction.w,{{axis5.gear.bearingFriction.tau_pos[1,1],axis5.gear.bearingFriction.tau_pos[1,2]},{axis5.gear.bearingFriction.tau_pos[2,1],axis5.gear.bearingFriction.tau_pos[2,2]}},2) else if pre(axis5.gear.bearingFriction.mode) == 1 then Modelica.Math.tempInterpol1(axis5.gear.bearingFriction.w,{{axis5.gear.bearingFriction.tau_pos[1,1],axis5.gear.bearingFriction.tau_pos[1,2]},{axis5.gear.bearingFriction.tau_pos[2,1],axis5.gear.bearingFriction.tau_pos[2,2]}},2) else -Modelica.Math.tempInterpol1(-axis5.gear.bearingFriction.w,{{axis5.gear.bearingFriction.tau_pos[1,1],axis5.gear.bearingFriction.tau_pos[1,2]},{axis5.gear.bearingFriction.tau_pos[2,1],axis5.gear.bearingFriction.tau_pos[2,2]}},2);
//   axis5.gear.bearingFriction.phi_support = 0.0;
//   axis5.gear.bearingFriction.startForward = pre(axis5.gear.bearingFriction.mode) == 0 and (axis5.gear.bearingFriction.sa > axis5.gear.bearingFriction.tau0_max or pre(axis5.gear.bearingFriction.startForward) and axis5.gear.bearingFriction.sa > axis5.gear.bearingFriction.tau0) or pre(axis5.gear.bearingFriction.mode) == -1 and axis5.gear.bearingFriction.w_relfric > axis5.gear.bearingFriction.w_small or initial() and axis5.gear.bearingFriction.w_relfric > 0.0;
//   axis5.gear.bearingFriction.startBackward = pre(axis5.gear.bearingFriction.mode) == 0 and (axis5.gear.bearingFriction.sa < -axis5.gear.bearingFriction.tau0_max or pre(axis5.gear.bearingFriction.startBackward) and axis5.gear.bearingFriction.sa < -axis5.gear.bearingFriction.tau0) or pre(axis5.gear.bearingFriction.mode) == 1 and axis5.gear.bearingFriction.w_relfric < -axis5.gear.bearingFriction.w_small or initial() and axis5.gear.bearingFriction.w_relfric < 0.0;
//   axis5.gear.bearingFriction.locked = not axis5.gear.bearingFriction.free and not (pre(axis5.gear.bearingFriction.mode) == 1 or axis5.gear.bearingFriction.startForward or pre(axis5.gear.bearingFriction.mode) == -1 or axis5.gear.bearingFriction.startBackward);
//   axis5.gear.bearingFriction.a_relfric = if axis5.gear.bearingFriction.locked then 0.0 else if axis5.gear.bearingFriction.free then axis5.gear.bearingFriction.sa else if axis5.gear.bearingFriction.startForward then axis5.gear.bearingFriction.sa - axis5.gear.bearingFriction.tau0_max else if axis5.gear.bearingFriction.startBackward then axis5.gear.bearingFriction.sa + axis5.gear.bearingFriction.tau0_max else if pre(axis5.gear.bearingFriction.mode) == 1 then axis5.gear.bearingFriction.sa - axis5.gear.bearingFriction.tau0_max else axis5.gear.bearingFriction.sa + axis5.gear.bearingFriction.tau0_max;
//   axis5.gear.bearingFriction.mode = if axis5.gear.bearingFriction.free then 2 else if (pre(axis5.gear.bearingFriction.mode) == 1 or pre(axis5.gear.bearingFriction.mode) == 2 or axis5.gear.bearingFriction.startForward) and axis5.gear.bearingFriction.w_relfric > 0.0 then 1 else if (pre(axis5.gear.bearingFriction.mode) == -1 or pre(axis5.gear.bearingFriction.mode) == 2 or axis5.gear.bearingFriction.startBackward) and axis5.gear.bearingFriction.w_relfric < 0.0 then -1 else 0;
//   axis5.motor.Vs.v = axis5.motor.Vs.p.v - axis5.motor.Vs.n.v;
//   0.0 = axis5.motor.Vs.p.i + axis5.motor.Vs.n.i;
//   axis5.motor.Vs.i = axis5.motor.Vs.p.i;
//   axis5.motor.diff.v1 = axis5.motor.diff.p1.v - axis5.motor.diff.n1.v;
//   axis5.motor.diff.v2 = axis5.motor.diff.p2.v - axis5.motor.diff.n2.v;
//   0.0 = axis5.motor.diff.p1.i + axis5.motor.diff.n1.i;
//   0.0 = axis5.motor.diff.p2.i + axis5.motor.diff.n2.i;
//   axis5.motor.diff.i1 = axis5.motor.diff.p1.i;
//   axis5.motor.diff.i2 = axis5.motor.diff.p2.i;
//   axis5.motor.diff.v1 = 0.0;
//   axis5.motor.diff.i1 = 0.0;
//   axis5.motor.power.v1 = axis5.motor.power.p1.v - axis5.motor.power.n1.v;
//   axis5.motor.power.v2 = axis5.motor.power.p2.v - axis5.motor.power.n2.v;
//   0.0 = axis5.motor.power.p1.i + axis5.motor.power.n1.i;
//   0.0 = axis5.motor.power.p2.i + axis5.motor.power.n2.i;
//   axis5.motor.power.i1 = axis5.motor.power.p1.i;
//   axis5.motor.power.i2 = axis5.motor.power.p2.i;
//   axis5.motor.power.v1 = 0.0;
//   axis5.motor.power.i1 = 0.0;
//   axis5.motor.emf.internalSupport.flange.tau = axis5.motor.emf.internalSupport.tau;
//   axis5.motor.emf.internalSupport.flange.phi = axis5.motor.emf.internalSupport.phi;
//   axis5.motor.emf.fixed.flange.phi = axis5.motor.emf.fixed.phi0;
//   axis5.motor.emf.v = axis5.motor.emf.p.v - axis5.motor.emf.n.v;
//   0.0 = axis5.motor.emf.p.i + axis5.motor.emf.n.i;
//   axis5.motor.emf.i = axis5.motor.emf.p.i;
//   axis5.motor.emf.phi = axis5.motor.emf.flange.phi - axis5.motor.emf.internalSupport.phi;
//   axis5.motor.emf.w = der(axis5.motor.emf.phi);
//   axis5.motor.emf.k * axis5.motor.emf.w = axis5.motor.emf.v;
//   axis5.motor.emf.flange.tau = (-axis5.motor.emf.k) * axis5.motor.emf.i;
//   axis5.motor.La.L * der(axis5.motor.La.i) = axis5.motor.La.v;
//   axis5.motor.La.v = axis5.motor.La.p.v - axis5.motor.La.n.v;
//   0.0 = axis5.motor.La.p.i + axis5.motor.La.n.i;
//   axis5.motor.La.i = axis5.motor.La.p.i;
//   assert(1.0 + axis5.motor.Ra.alpha * (axis5.motor.Ra.T_heatPort - axis5.motor.Ra.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis5.motor.Ra.R_actual = axis5.motor.Ra.R * (1.0 + axis5.motor.Ra.alpha * (axis5.motor.Ra.T_heatPort - axis5.motor.Ra.T_ref));
//   axis5.motor.Ra.v = axis5.motor.Ra.R_actual * axis5.motor.Ra.i;
//   axis5.motor.Ra.LossPower = axis5.motor.Ra.v * axis5.motor.Ra.i;
//   axis5.motor.Ra.i = axis5.motor.Ra.p.i;
//   0.0 = axis5.motor.Ra.p.i + axis5.motor.Ra.n.i;
//   axis5.motor.Ra.v = axis5.motor.Ra.p.v - axis5.motor.Ra.n.v;
//   axis5.motor.Ra.T_heatPort = axis5.motor.Ra.T;
//   assert(1.0 + axis5.motor.Rd2.alpha * (axis5.motor.Rd2.T_heatPort - axis5.motor.Rd2.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis5.motor.Rd2.R_actual = axis5.motor.Rd2.R * (1.0 + axis5.motor.Rd2.alpha * (axis5.motor.Rd2.T_heatPort - axis5.motor.Rd2.T_ref));
//   axis5.motor.Rd2.v = axis5.motor.Rd2.R_actual * axis5.motor.Rd2.i;
//   axis5.motor.Rd2.LossPower = axis5.motor.Rd2.v * axis5.motor.Rd2.i;
//   axis5.motor.Rd2.i = axis5.motor.Rd2.p.i;
//   0.0 = axis5.motor.Rd2.p.i + axis5.motor.Rd2.n.i;
//   axis5.motor.Rd2.v = axis5.motor.Rd2.p.v - axis5.motor.Rd2.n.v;
//   axis5.motor.Rd2.T_heatPort = axis5.motor.Rd2.T;
//   axis5.motor.C.i = axis5.motor.C.C * der(axis5.motor.C.v);
//   axis5.motor.C.v = axis5.motor.C.p.v - axis5.motor.C.n.v;
//   0.0 = axis5.motor.C.p.i + axis5.motor.C.n.i;
//   axis5.motor.C.i = axis5.motor.C.p.i;
//   axis5.motor.OpI.v1 = axis5.motor.OpI.p1.v - axis5.motor.OpI.n1.v;
//   axis5.motor.OpI.v2 = axis5.motor.OpI.p2.v - axis5.motor.OpI.n2.v;
//   0.0 = axis5.motor.OpI.p1.i + axis5.motor.OpI.n1.i;
//   0.0 = axis5.motor.OpI.p2.i + axis5.motor.OpI.n2.i;
//   axis5.motor.OpI.i1 = axis5.motor.OpI.p1.i;
//   axis5.motor.OpI.i2 = axis5.motor.OpI.p2.i;
//   axis5.motor.OpI.v1 = 0.0;
//   axis5.motor.OpI.i1 = 0.0;
//   assert(1.0 + axis5.motor.Rd1.alpha * (axis5.motor.Rd1.T_heatPort - axis5.motor.Rd1.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis5.motor.Rd1.R_actual = axis5.motor.Rd1.R * (1.0 + axis5.motor.Rd1.alpha * (axis5.motor.Rd1.T_heatPort - axis5.motor.Rd1.T_ref));
//   axis5.motor.Rd1.v = axis5.motor.Rd1.R_actual * axis5.motor.Rd1.i;
//   axis5.motor.Rd1.LossPower = axis5.motor.Rd1.v * axis5.motor.Rd1.i;
//   axis5.motor.Rd1.i = axis5.motor.Rd1.p.i;
//   0.0 = axis5.motor.Rd1.p.i + axis5.motor.Rd1.n.i;
//   axis5.motor.Rd1.v = axis5.motor.Rd1.p.v - axis5.motor.Rd1.n.v;
//   axis5.motor.Rd1.T_heatPort = axis5.motor.Rd1.T;
//   assert(1.0 + axis5.motor.Ri.alpha * (axis5.motor.Ri.T_heatPort - axis5.motor.Ri.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis5.motor.Ri.R_actual = axis5.motor.Ri.R * (1.0 + axis5.motor.Ri.alpha * (axis5.motor.Ri.T_heatPort - axis5.motor.Ri.T_ref));
//   axis5.motor.Ri.v = axis5.motor.Ri.R_actual * axis5.motor.Ri.i;
//   axis5.motor.Ri.LossPower = axis5.motor.Ri.v * axis5.motor.Ri.i;
//   axis5.motor.Ri.i = axis5.motor.Ri.p.i;
//   0.0 = axis5.motor.Ri.p.i + axis5.motor.Ri.n.i;
//   axis5.motor.Ri.v = axis5.motor.Ri.p.v - axis5.motor.Ri.n.v;
//   axis5.motor.Ri.T_heatPort = axis5.motor.Ri.T;
//   assert(1.0 + axis5.motor.Rp1.alpha * (axis5.motor.Rp1.T_heatPort - axis5.motor.Rp1.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis5.motor.Rp1.R_actual = axis5.motor.Rp1.R * (1.0 + axis5.motor.Rp1.alpha * (axis5.motor.Rp1.T_heatPort - axis5.motor.Rp1.T_ref));
//   axis5.motor.Rp1.v = axis5.motor.Rp1.R_actual * axis5.motor.Rp1.i;
//   axis5.motor.Rp1.LossPower = axis5.motor.Rp1.v * axis5.motor.Rp1.i;
//   axis5.motor.Rp1.i = axis5.motor.Rp1.p.i;
//   0.0 = axis5.motor.Rp1.p.i + axis5.motor.Rp1.n.i;
//   axis5.motor.Rp1.v = axis5.motor.Rp1.p.v - axis5.motor.Rp1.n.v;
//   axis5.motor.Rp1.T_heatPort = axis5.motor.Rp1.T;
//   assert(1.0 + axis5.motor.Rp2.alpha * (axis5.motor.Rp2.T_heatPort - axis5.motor.Rp2.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis5.motor.Rp2.R_actual = axis5.motor.Rp2.R * (1.0 + axis5.motor.Rp2.alpha * (axis5.motor.Rp2.T_heatPort - axis5.motor.Rp2.T_ref));
//   axis5.motor.Rp2.v = axis5.motor.Rp2.R_actual * axis5.motor.Rp2.i;
//   axis5.motor.Rp2.LossPower = axis5.motor.Rp2.v * axis5.motor.Rp2.i;
//   axis5.motor.Rp2.i = axis5.motor.Rp2.p.i;
//   0.0 = axis5.motor.Rp2.p.i + axis5.motor.Rp2.n.i;
//   axis5.motor.Rp2.v = axis5.motor.Rp2.p.v - axis5.motor.Rp2.n.v;
//   axis5.motor.Rp2.T_heatPort = axis5.motor.Rp2.T;
//   assert(1.0 + axis5.motor.Rd4.alpha * (axis5.motor.Rd4.T_heatPort - axis5.motor.Rd4.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis5.motor.Rd4.R_actual = axis5.motor.Rd4.R * (1.0 + axis5.motor.Rd4.alpha * (axis5.motor.Rd4.T_heatPort - axis5.motor.Rd4.T_ref));
//   axis5.motor.Rd4.v = axis5.motor.Rd4.R_actual * axis5.motor.Rd4.i;
//   axis5.motor.Rd4.LossPower = axis5.motor.Rd4.v * axis5.motor.Rd4.i;
//   axis5.motor.Rd4.i = axis5.motor.Rd4.p.i;
//   0.0 = axis5.motor.Rd4.p.i + axis5.motor.Rd4.n.i;
//   axis5.motor.Rd4.v = axis5.motor.Rd4.p.v - axis5.motor.Rd4.n.v;
//   axis5.motor.Rd4.T_heatPort = axis5.motor.Rd4.T;
//   axis5.motor.hall2.v = axis5.motor.hall2.p.v - axis5.motor.hall2.n.v;
//   0.0 = axis5.motor.hall2.p.i + axis5.motor.hall2.n.i;
//   axis5.motor.hall2.i = axis5.motor.hall2.p.i;
//   assert(1.0 + axis5.motor.Rd3.alpha * (axis5.motor.Rd3.T_heatPort - axis5.motor.Rd3.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis5.motor.Rd3.R_actual = axis5.motor.Rd3.R * (1.0 + axis5.motor.Rd3.alpha * (axis5.motor.Rd3.T_heatPort - axis5.motor.Rd3.T_ref));
//   axis5.motor.Rd3.v = axis5.motor.Rd3.R_actual * axis5.motor.Rd3.i;
//   axis5.motor.Rd3.LossPower = axis5.motor.Rd3.v * axis5.motor.Rd3.i;
//   axis5.motor.Rd3.i = axis5.motor.Rd3.p.i;
//   0.0 = axis5.motor.Rd3.p.i + axis5.motor.Rd3.n.i;
//   axis5.motor.Rd3.v = axis5.motor.Rd3.p.v - axis5.motor.Rd3.n.v;
//   axis5.motor.Rd3.T_heatPort = axis5.motor.Rd3.T;
//   axis5.motor.g1.p.v = 0.0;
//   axis5.motor.g2.p.v = 0.0;
//   axis5.motor.g3.p.v = 0.0;
//   axis5.motor.hall1.p.v = axis5.motor.hall1.n.v;
//   axis5.motor.hall1.p.i = axis5.motor.hall1.i;
//   axis5.motor.hall1.n.i = -axis5.motor.hall1.i;
//   axis5.motor.g4.p.v = 0.0;
//   axis5.motor.g5.p.v = 0.0;
//   axis5.motor.phi.phi = axis5.motor.phi.flange.phi;
//   0.0 = axis5.motor.phi.flange.tau;
//   axis5.motor.speed.w = der(axis5.motor.speed.flange.phi);
//   0.0 = axis5.motor.speed.flange.tau;
//   axis5.motor.Jmotor.phi = axis5.motor.Jmotor.flange_a.phi;
//   axis5.motor.Jmotor.phi = axis5.motor.Jmotor.flange_b.phi;
//   axis5.motor.Jmotor.w = der(axis5.motor.Jmotor.phi);
//   axis5.motor.Jmotor.a = der(axis5.motor.Jmotor.w);
//   axis5.motor.Jmotor.J * axis5.motor.Jmotor.a = axis5.motor.Jmotor.flange_a.tau + axis5.motor.Jmotor.flange_b.tau;
//   axis5.motor.convert1.y = axis5.motor.convert1.k * axis5.motor.convert1.u;
//   axis5.motor.convert2.y = axis5.motor.convert2.k * axis5.motor.convert2.u;
//   axis5.controller.gain1.y = axis5.controller.gain1.k * axis5.controller.gain1.u;
//   der(axis5.controller.PI.x) = axis5.controller.PI.u / axis5.controller.PI.T;
//   axis5.controller.PI.y = axis5.controller.PI.k * (axis5.controller.PI.x + axis5.controller.PI.u);
//   axis5.controller.feedback1.y = axis5.controller.feedback1.u1 - axis5.controller.feedback1.u2;
//   axis5.controller.P.y = axis5.controller.P.k * axis5.controller.P.u;
//   axis5.controller.add3.y = axis5.controller.add3.k1 * axis5.controller.add3.u1 + (axis5.controller.add3.k2 * axis5.controller.add3.u2 + axis5.controller.add3.k3 * axis5.controller.add3.u3);
//   axis5.controller.gain2.y = axis5.controller.gain2.k * axis5.controller.gain2.u;
//   axis5.angleSensor.phi = axis5.angleSensor.flange.phi;
//   0.0 = axis5.angleSensor.flange.tau;
//   axis5.speedSensor.w = der(axis5.speedSensor.flange.phi);
//   0.0 = axis5.speedSensor.flange.tau;
//   axis5.accSensor.w = der(axis5.accSensor.flange.phi);
//   axis5.accSensor.a = der(axis5.accSensor.w);
//   0.0 = axis5.accSensor.flange.tau;
//   axis5.initializeFlange.set_flange_tau.flange.tau = 0.0;
//   axis5.initializeFlange.set_phi_start.flange.tau = 0.0;
//   axis5.initializeFlange.set_w_start.flange.tau = 0.0;
//   axis5.initializeFlange.set_a_start.flange.tau = 0.0;
//   axis5.const.y = axis5.const.k;
//   axis6.gear.gear.phi_a = axis6.gear.gear.flange_a.phi - axis6.gear.gear.phi_support;
//   axis6.gear.gear.phi_b = axis6.gear.gear.flange_b.phi - axis6.gear.gear.phi_support;
//   axis6.gear.gear.phi_a = axis6.gear.gear.ratio * axis6.gear.gear.phi_b;
//   0.0 = axis6.gear.gear.ratio * axis6.gear.gear.flange_a.tau + axis6.gear.gear.flange_b.tau;
//   axis6.gear.gear.phi_support = 0.0;
//   axis6.gear.bearingFriction.tau0 = Modelica.Math.tempInterpol1(0.0,{{axis6.gear.bearingFriction.tau_pos[1,1],axis6.gear.bearingFriction.tau_pos[1,2]},{axis6.gear.bearingFriction.tau_pos[2,1],axis6.gear.bearingFriction.tau_pos[2,2]}},2);
//   axis6.gear.bearingFriction.tau0_max = axis6.gear.bearingFriction.peak * axis6.gear.bearingFriction.tau0;
//   axis6.gear.bearingFriction.free = false;
//   axis6.gear.bearingFriction.phi = axis6.gear.bearingFriction.flange_a.phi - axis6.gear.bearingFriction.phi_support;
//   axis6.gear.bearingFriction.flange_b.phi = axis6.gear.bearingFriction.flange_a.phi;
//   axis6.gear.bearingFriction.w = der(axis6.gear.bearingFriction.phi);
//   axis6.gear.bearingFriction.a = der(axis6.gear.bearingFriction.w);
//   axis6.gear.bearingFriction.w_relfric = axis6.gear.bearingFriction.w;
//   axis6.gear.bearingFriction.a_relfric = axis6.gear.bearingFriction.a;
//   axis6.gear.bearingFriction.flange_a.tau + (axis6.gear.bearingFriction.flange_b.tau - axis6.gear.bearingFriction.tau) = 0.0;
//   axis6.gear.bearingFriction.tau = if axis6.gear.bearingFriction.locked then axis6.gear.bearingFriction.sa else if axis6.gear.bearingFriction.startForward then Modelica.Math.tempInterpol1(axis6.gear.bearingFriction.w,{{axis6.gear.bearingFriction.tau_pos[1,1],axis6.gear.bearingFriction.tau_pos[1,2]},{axis6.gear.bearingFriction.tau_pos[2,1],axis6.gear.bearingFriction.tau_pos[2,2]}},2) else if axis6.gear.bearingFriction.startBackward then -Modelica.Math.tempInterpol1(-axis6.gear.bearingFriction.w,{{axis6.gear.bearingFriction.tau_pos[1,1],axis6.gear.bearingFriction.tau_pos[1,2]},{axis6.gear.bearingFriction.tau_pos[2,1],axis6.gear.bearingFriction.tau_pos[2,2]}},2) else if pre(axis6.gear.bearingFriction.mode) == 1 then Modelica.Math.tempInterpol1(axis6.gear.bearingFriction.w,{{axis6.gear.bearingFriction.tau_pos[1,1],axis6.gear.bearingFriction.tau_pos[1,2]},{axis6.gear.bearingFriction.tau_pos[2,1],axis6.gear.bearingFriction.tau_pos[2,2]}},2) else -Modelica.Math.tempInterpol1(-axis6.gear.bearingFriction.w,{{axis6.gear.bearingFriction.tau_pos[1,1],axis6.gear.bearingFriction.tau_pos[1,2]},{axis6.gear.bearingFriction.tau_pos[2,1],axis6.gear.bearingFriction.tau_pos[2,2]}},2);
//   axis6.gear.bearingFriction.phi_support = 0.0;
//   axis6.gear.bearingFriction.startForward = pre(axis6.gear.bearingFriction.mode) == 0 and (axis6.gear.bearingFriction.sa > axis6.gear.bearingFriction.tau0_max or pre(axis6.gear.bearingFriction.startForward) and axis6.gear.bearingFriction.sa > axis6.gear.bearingFriction.tau0) or pre(axis6.gear.bearingFriction.mode) == -1 and axis6.gear.bearingFriction.w_relfric > axis6.gear.bearingFriction.w_small or initial() and axis6.gear.bearingFriction.w_relfric > 0.0;
//   axis6.gear.bearingFriction.startBackward = pre(axis6.gear.bearingFriction.mode) == 0 and (axis6.gear.bearingFriction.sa < -axis6.gear.bearingFriction.tau0_max or pre(axis6.gear.bearingFriction.startBackward) and axis6.gear.bearingFriction.sa < -axis6.gear.bearingFriction.tau0) or pre(axis6.gear.bearingFriction.mode) == 1 and axis6.gear.bearingFriction.w_relfric < -axis6.gear.bearingFriction.w_small or initial() and axis6.gear.bearingFriction.w_relfric < 0.0;
//   axis6.gear.bearingFriction.locked = not axis6.gear.bearingFriction.free and not (pre(axis6.gear.bearingFriction.mode) == 1 or axis6.gear.bearingFriction.startForward or pre(axis6.gear.bearingFriction.mode) == -1 or axis6.gear.bearingFriction.startBackward);
//   axis6.gear.bearingFriction.a_relfric = if axis6.gear.bearingFriction.locked then 0.0 else if axis6.gear.bearingFriction.free then axis6.gear.bearingFriction.sa else if axis6.gear.bearingFriction.startForward then axis6.gear.bearingFriction.sa - axis6.gear.bearingFriction.tau0_max else if axis6.gear.bearingFriction.startBackward then axis6.gear.bearingFriction.sa + axis6.gear.bearingFriction.tau0_max else if pre(axis6.gear.bearingFriction.mode) == 1 then axis6.gear.bearingFriction.sa - axis6.gear.bearingFriction.tau0_max else axis6.gear.bearingFriction.sa + axis6.gear.bearingFriction.tau0_max;
//   axis6.gear.bearingFriction.mode = if axis6.gear.bearingFriction.free then 2 else if (pre(axis6.gear.bearingFriction.mode) == 1 or pre(axis6.gear.bearingFriction.mode) == 2 or axis6.gear.bearingFriction.startForward) and axis6.gear.bearingFriction.w_relfric > 0.0 then 1 else if (pre(axis6.gear.bearingFriction.mode) == -1 or pre(axis6.gear.bearingFriction.mode) == 2 or axis6.gear.bearingFriction.startBackward) and axis6.gear.bearingFriction.w_relfric < 0.0 then -1 else 0;
//   axis6.motor.Vs.v = axis6.motor.Vs.p.v - axis6.motor.Vs.n.v;
//   0.0 = axis6.motor.Vs.p.i + axis6.motor.Vs.n.i;
//   axis6.motor.Vs.i = axis6.motor.Vs.p.i;
//   axis6.motor.diff.v1 = axis6.motor.diff.p1.v - axis6.motor.diff.n1.v;
//   axis6.motor.diff.v2 = axis6.motor.diff.p2.v - axis6.motor.diff.n2.v;
//   0.0 = axis6.motor.diff.p1.i + axis6.motor.diff.n1.i;
//   0.0 = axis6.motor.diff.p2.i + axis6.motor.diff.n2.i;
//   axis6.motor.diff.i1 = axis6.motor.diff.p1.i;
//   axis6.motor.diff.i2 = axis6.motor.diff.p2.i;
//   axis6.motor.diff.v1 = 0.0;
//   axis6.motor.diff.i1 = 0.0;
//   axis6.motor.power.v1 = axis6.motor.power.p1.v - axis6.motor.power.n1.v;
//   axis6.motor.power.v2 = axis6.motor.power.p2.v - axis6.motor.power.n2.v;
//   0.0 = axis6.motor.power.p1.i + axis6.motor.power.n1.i;
//   0.0 = axis6.motor.power.p2.i + axis6.motor.power.n2.i;
//   axis6.motor.power.i1 = axis6.motor.power.p1.i;
//   axis6.motor.power.i2 = axis6.motor.power.p2.i;
//   axis6.motor.power.v1 = 0.0;
//   axis6.motor.power.i1 = 0.0;
//   axis6.motor.emf.internalSupport.flange.tau = axis6.motor.emf.internalSupport.tau;
//   axis6.motor.emf.internalSupport.flange.phi = axis6.motor.emf.internalSupport.phi;
//   axis6.motor.emf.fixed.flange.phi = axis6.motor.emf.fixed.phi0;
//   axis6.motor.emf.v = axis6.motor.emf.p.v - axis6.motor.emf.n.v;
//   0.0 = axis6.motor.emf.p.i + axis6.motor.emf.n.i;
//   axis6.motor.emf.i = axis6.motor.emf.p.i;
//   axis6.motor.emf.phi = axis6.motor.emf.flange.phi - axis6.motor.emf.internalSupport.phi;
//   axis6.motor.emf.w = der(axis6.motor.emf.phi);
//   axis6.motor.emf.k * axis6.motor.emf.w = axis6.motor.emf.v;
//   axis6.motor.emf.flange.tau = (-axis6.motor.emf.k) * axis6.motor.emf.i;
//   axis6.motor.La.L * der(axis6.motor.La.i) = axis6.motor.La.v;
//   axis6.motor.La.v = axis6.motor.La.p.v - axis6.motor.La.n.v;
//   0.0 = axis6.motor.La.p.i + axis6.motor.La.n.i;
//   axis6.motor.La.i = axis6.motor.La.p.i;
//   assert(1.0 + axis6.motor.Ra.alpha * (axis6.motor.Ra.T_heatPort - axis6.motor.Ra.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis6.motor.Ra.R_actual = axis6.motor.Ra.R * (1.0 + axis6.motor.Ra.alpha * (axis6.motor.Ra.T_heatPort - axis6.motor.Ra.T_ref));
//   axis6.motor.Ra.v = axis6.motor.Ra.R_actual * axis6.motor.Ra.i;
//   axis6.motor.Ra.LossPower = axis6.motor.Ra.v * axis6.motor.Ra.i;
//   axis6.motor.Ra.i = axis6.motor.Ra.p.i;
//   0.0 = axis6.motor.Ra.p.i + axis6.motor.Ra.n.i;
//   axis6.motor.Ra.v = axis6.motor.Ra.p.v - axis6.motor.Ra.n.v;
//   axis6.motor.Ra.T_heatPort = axis6.motor.Ra.T;
//   assert(1.0 + axis6.motor.Rd2.alpha * (axis6.motor.Rd2.T_heatPort - axis6.motor.Rd2.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis6.motor.Rd2.R_actual = axis6.motor.Rd2.R * (1.0 + axis6.motor.Rd2.alpha * (axis6.motor.Rd2.T_heatPort - axis6.motor.Rd2.T_ref));
//   axis6.motor.Rd2.v = axis6.motor.Rd2.R_actual * axis6.motor.Rd2.i;
//   axis6.motor.Rd2.LossPower = axis6.motor.Rd2.v * axis6.motor.Rd2.i;
//   axis6.motor.Rd2.i = axis6.motor.Rd2.p.i;
//   0.0 = axis6.motor.Rd2.p.i + axis6.motor.Rd2.n.i;
//   axis6.motor.Rd2.v = axis6.motor.Rd2.p.v - axis6.motor.Rd2.n.v;
//   axis6.motor.Rd2.T_heatPort = axis6.motor.Rd2.T;
//   axis6.motor.C.i = axis6.motor.C.C * der(axis6.motor.C.v);
//   axis6.motor.C.v = axis6.motor.C.p.v - axis6.motor.C.n.v;
//   0.0 = axis6.motor.C.p.i + axis6.motor.C.n.i;
//   axis6.motor.C.i = axis6.motor.C.p.i;
//   axis6.motor.OpI.v1 = axis6.motor.OpI.p1.v - axis6.motor.OpI.n1.v;
//   axis6.motor.OpI.v2 = axis6.motor.OpI.p2.v - axis6.motor.OpI.n2.v;
//   0.0 = axis6.motor.OpI.p1.i + axis6.motor.OpI.n1.i;
//   0.0 = axis6.motor.OpI.p2.i + axis6.motor.OpI.n2.i;
//   axis6.motor.OpI.i1 = axis6.motor.OpI.p1.i;
//   axis6.motor.OpI.i2 = axis6.motor.OpI.p2.i;
//   axis6.motor.OpI.v1 = 0.0;
//   axis6.motor.OpI.i1 = 0.0;
//   assert(1.0 + axis6.motor.Rd1.alpha * (axis6.motor.Rd1.T_heatPort - axis6.motor.Rd1.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis6.motor.Rd1.R_actual = axis6.motor.Rd1.R * (1.0 + axis6.motor.Rd1.alpha * (axis6.motor.Rd1.T_heatPort - axis6.motor.Rd1.T_ref));
//   axis6.motor.Rd1.v = axis6.motor.Rd1.R_actual * axis6.motor.Rd1.i;
//   axis6.motor.Rd1.LossPower = axis6.motor.Rd1.v * axis6.motor.Rd1.i;
//   axis6.motor.Rd1.i = axis6.motor.Rd1.p.i;
//   0.0 = axis6.motor.Rd1.p.i + axis6.motor.Rd1.n.i;
//   axis6.motor.Rd1.v = axis6.motor.Rd1.p.v - axis6.motor.Rd1.n.v;
//   axis6.motor.Rd1.T_heatPort = axis6.motor.Rd1.T;
//   assert(1.0 + axis6.motor.Ri.alpha * (axis6.motor.Ri.T_heatPort - axis6.motor.Ri.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis6.motor.Ri.R_actual = axis6.motor.Ri.R * (1.0 + axis6.motor.Ri.alpha * (axis6.motor.Ri.T_heatPort - axis6.motor.Ri.T_ref));
//   axis6.motor.Ri.v = axis6.motor.Ri.R_actual * axis6.motor.Ri.i;
//   axis6.motor.Ri.LossPower = axis6.motor.Ri.v * axis6.motor.Ri.i;
//   axis6.motor.Ri.i = axis6.motor.Ri.p.i;
//   0.0 = axis6.motor.Ri.p.i + axis6.motor.Ri.n.i;
//   axis6.motor.Ri.v = axis6.motor.Ri.p.v - axis6.motor.Ri.n.v;
//   axis6.motor.Ri.T_heatPort = axis6.motor.Ri.T;
//   assert(1.0 + axis6.motor.Rp1.alpha * (axis6.motor.Rp1.T_heatPort - axis6.motor.Rp1.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis6.motor.Rp1.R_actual = axis6.motor.Rp1.R * (1.0 + axis6.motor.Rp1.alpha * (axis6.motor.Rp1.T_heatPort - axis6.motor.Rp1.T_ref));
//   axis6.motor.Rp1.v = axis6.motor.Rp1.R_actual * axis6.motor.Rp1.i;
//   axis6.motor.Rp1.LossPower = axis6.motor.Rp1.v * axis6.motor.Rp1.i;
//   axis6.motor.Rp1.i = axis6.motor.Rp1.p.i;
//   0.0 = axis6.motor.Rp1.p.i + axis6.motor.Rp1.n.i;
//   axis6.motor.Rp1.v = axis6.motor.Rp1.p.v - axis6.motor.Rp1.n.v;
//   axis6.motor.Rp1.T_heatPort = axis6.motor.Rp1.T;
//   assert(1.0 + axis6.motor.Rp2.alpha * (axis6.motor.Rp2.T_heatPort - axis6.motor.Rp2.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis6.motor.Rp2.R_actual = axis6.motor.Rp2.R * (1.0 + axis6.motor.Rp2.alpha * (axis6.motor.Rp2.T_heatPort - axis6.motor.Rp2.T_ref));
//   axis6.motor.Rp2.v = axis6.motor.Rp2.R_actual * axis6.motor.Rp2.i;
//   axis6.motor.Rp2.LossPower = axis6.motor.Rp2.v * axis6.motor.Rp2.i;
//   axis6.motor.Rp2.i = axis6.motor.Rp2.p.i;
//   0.0 = axis6.motor.Rp2.p.i + axis6.motor.Rp2.n.i;
//   axis6.motor.Rp2.v = axis6.motor.Rp2.p.v - axis6.motor.Rp2.n.v;
//   axis6.motor.Rp2.T_heatPort = axis6.motor.Rp2.T;
//   assert(1.0 + axis6.motor.Rd4.alpha * (axis6.motor.Rd4.T_heatPort - axis6.motor.Rd4.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis6.motor.Rd4.R_actual = axis6.motor.Rd4.R * (1.0 + axis6.motor.Rd4.alpha * (axis6.motor.Rd4.T_heatPort - axis6.motor.Rd4.T_ref));
//   axis6.motor.Rd4.v = axis6.motor.Rd4.R_actual * axis6.motor.Rd4.i;
//   axis6.motor.Rd4.LossPower = axis6.motor.Rd4.v * axis6.motor.Rd4.i;
//   axis6.motor.Rd4.i = axis6.motor.Rd4.p.i;
//   0.0 = axis6.motor.Rd4.p.i + axis6.motor.Rd4.n.i;
//   axis6.motor.Rd4.v = axis6.motor.Rd4.p.v - axis6.motor.Rd4.n.v;
//   axis6.motor.Rd4.T_heatPort = axis6.motor.Rd4.T;
//   axis6.motor.hall2.v = axis6.motor.hall2.p.v - axis6.motor.hall2.n.v;
//   0.0 = axis6.motor.hall2.p.i + axis6.motor.hall2.n.i;
//   axis6.motor.hall2.i = axis6.motor.hall2.p.i;
//   assert(1.0 + axis6.motor.Rd3.alpha * (axis6.motor.Rd3.T_heatPort - axis6.motor.Rd3.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   axis6.motor.Rd3.R_actual = axis6.motor.Rd3.R * (1.0 + axis6.motor.Rd3.alpha * (axis6.motor.Rd3.T_heatPort - axis6.motor.Rd3.T_ref));
//   axis6.motor.Rd3.v = axis6.motor.Rd3.R_actual * axis6.motor.Rd3.i;
//   axis6.motor.Rd3.LossPower = axis6.motor.Rd3.v * axis6.motor.Rd3.i;
//   axis6.motor.Rd3.i = axis6.motor.Rd3.p.i;
//   0.0 = axis6.motor.Rd3.p.i + axis6.motor.Rd3.n.i;
//   axis6.motor.Rd3.v = axis6.motor.Rd3.p.v - axis6.motor.Rd3.n.v;
//   axis6.motor.Rd3.T_heatPort = axis6.motor.Rd3.T;
//   axis6.motor.g1.p.v = 0.0;
//   axis6.motor.g2.p.v = 0.0;
//   axis6.motor.g3.p.v = 0.0;
//   axis6.motor.hall1.p.v = axis6.motor.hall1.n.v;
//   axis6.motor.hall1.p.i = axis6.motor.hall1.i;
//   axis6.motor.hall1.n.i = -axis6.motor.hall1.i;
//   axis6.motor.g4.p.v = 0.0;
//   axis6.motor.g5.p.v = 0.0;
//   axis6.motor.phi.phi = axis6.motor.phi.flange.phi;
//   0.0 = axis6.motor.phi.flange.tau;
//   axis6.motor.speed.w = der(axis6.motor.speed.flange.phi);
//   0.0 = axis6.motor.speed.flange.tau;
//   axis6.motor.Jmotor.phi = axis6.motor.Jmotor.flange_a.phi;
//   axis6.motor.Jmotor.phi = axis6.motor.Jmotor.flange_b.phi;
//   axis6.motor.Jmotor.w = der(axis6.motor.Jmotor.phi);
//   axis6.motor.Jmotor.a = der(axis6.motor.Jmotor.w);
//   axis6.motor.Jmotor.J * axis6.motor.Jmotor.a = axis6.motor.Jmotor.flange_a.tau + axis6.motor.Jmotor.flange_b.tau;
//   axis6.motor.convert1.y = axis6.motor.convert1.k * axis6.motor.convert1.u;
//   axis6.motor.convert2.y = axis6.motor.convert2.k * axis6.motor.convert2.u;
//   axis6.controller.gain1.y = axis6.controller.gain1.k * axis6.controller.gain1.u;
//   der(axis6.controller.PI.x) = axis6.controller.PI.u / axis6.controller.PI.T;
//   axis6.controller.PI.y = axis6.controller.PI.k * (axis6.controller.PI.x + axis6.controller.PI.u);
//   axis6.controller.feedback1.y = axis6.controller.feedback1.u1 - axis6.controller.feedback1.u2;
//   axis6.controller.P.y = axis6.controller.P.k * axis6.controller.P.u;
//   axis6.controller.add3.y = axis6.controller.add3.k1 * axis6.controller.add3.u1 + (axis6.controller.add3.k2 * axis6.controller.add3.u2 + axis6.controller.add3.k3 * axis6.controller.add3.u3);
//   axis6.controller.gain2.y = axis6.controller.gain2.k * axis6.controller.gain2.u;
//   axis6.angleSensor.phi = axis6.angleSensor.flange.phi;
//   0.0 = axis6.angleSensor.flange.tau;
//   axis6.speedSensor.w = der(axis6.speedSensor.flange.phi);
//   0.0 = axis6.speedSensor.flange.tau;
//   axis6.accSensor.w = der(axis6.accSensor.flange.phi);
//   axis6.accSensor.a = der(axis6.accSensor.w);
//   0.0 = axis6.accSensor.flange.tau;
//   axis6.initializeFlange.set_flange_tau.flange.tau = 0.0;
//   axis6.initializeFlange.set_phi_start.flange.tau = 0.0;
//   axis6.initializeFlange.set_w_start.flange.tau = 0.0;
//   axis6.initializeFlange.set_a_start.flange.tau = 0.0;
//   axis6.const.y = axis6.const.k;
//   axis6.axisControlBus.speed_ref = controlBus.axisControlBus6.speed_ref;
//   axis6.axisControlBus.speed_ref = pathPlanning.controlBus.axisControlBus6.speed_ref;
//   controlBus.axisControlBus6.motion_ref = pathPlanning.controlBus.axisControlBus6.motion_ref;
//   controlBus.axisControlBus6.acceleration_ref = pathPlanning.controlBus.axisControlBus6.acceleration_ref;
//   axis6.axisControlBus.angle_ref = controlBus.axisControlBus6.angle_ref;
//   axis6.axisControlBus.angle_ref = pathPlanning.controlBus.axisControlBus6.angle_ref;
//   axis6.axisControlBus.angle = controlBus.axisControlBus6.angle;
//   axis6.axisControlBus.angle = pathPlanning.controlBus.axisControlBus6.angle;
//   axis6.axisControlBus.acceleration = controlBus.axisControlBus6.acceleration;
//   axis6.axisControlBus.acceleration = pathPlanning.controlBus.axisControlBus6.acceleration;
//   axis6.axisControlBus.motorSpeed = controlBus.axisControlBus6.motorSpeed;
//   axis6.axisControlBus.motorSpeed = pathPlanning.controlBus.axisControlBus6.motorSpeed;
//   axis6.axisControlBus.current_ref = controlBus.axisControlBus6.current_ref;
//   axis6.axisControlBus.current_ref = pathPlanning.controlBus.axisControlBus6.current_ref;
//   axis6.axisControlBus.current = controlBus.axisControlBus6.current;
//   axis6.axisControlBus.current = pathPlanning.controlBus.axisControlBus6.current;
//   axis6.axisControlBus.motorAngle = controlBus.axisControlBus6.motorAngle;
//   axis6.axisControlBus.motorAngle = pathPlanning.controlBus.axisControlBus6.motorAngle;
//   axis6.axisControlBus.speed = controlBus.axisControlBus6.speed;
//   axis6.axisControlBus.speed = pathPlanning.controlBus.axisControlBus6.speed;
//   axis5.axisControlBus.speed_ref = controlBus.axisControlBus5.speed_ref;
//   axis5.axisControlBus.speed_ref = pathPlanning.controlBus.axisControlBus5.speed_ref;
//   controlBus.axisControlBus5.motion_ref = pathPlanning.controlBus.axisControlBus5.motion_ref;
//   controlBus.axisControlBus5.acceleration_ref = pathPlanning.controlBus.axisControlBus5.acceleration_ref;
//   axis5.axisControlBus.angle_ref = controlBus.axisControlBus5.angle_ref;
//   axis5.axisControlBus.angle_ref = pathPlanning.controlBus.axisControlBus5.angle_ref;
//   axis5.axisControlBus.angle = controlBus.axisControlBus5.angle;
//   axis5.axisControlBus.angle = pathPlanning.controlBus.axisControlBus5.angle;
//   axis5.axisControlBus.acceleration = controlBus.axisControlBus5.acceleration;
//   axis5.axisControlBus.acceleration = pathPlanning.controlBus.axisControlBus5.acceleration;
//   axis5.axisControlBus.motorSpeed = controlBus.axisControlBus5.motorSpeed;
//   axis5.axisControlBus.motorSpeed = pathPlanning.controlBus.axisControlBus5.motorSpeed;
//   axis5.axisControlBus.current_ref = controlBus.axisControlBus5.current_ref;
//   axis5.axisControlBus.current_ref = pathPlanning.controlBus.axisControlBus5.current_ref;
//   axis5.axisControlBus.current = controlBus.axisControlBus5.current;
//   axis5.axisControlBus.current = pathPlanning.controlBus.axisControlBus5.current;
//   axis5.axisControlBus.motorAngle = controlBus.axisControlBus5.motorAngle;
//   axis5.axisControlBus.motorAngle = pathPlanning.controlBus.axisControlBus5.motorAngle;
//   axis5.axisControlBus.speed = controlBus.axisControlBus5.speed;
//   axis5.axisControlBus.speed = pathPlanning.controlBus.axisControlBus5.speed;
//   axis3.axisControlBus.speed_ref = controlBus.axisControlBus3.speed_ref;
//   axis3.axisControlBus.speed_ref = pathPlanning.controlBus.axisControlBus3.speed_ref;
//   controlBus.axisControlBus3.motion_ref = pathPlanning.controlBus.axisControlBus3.motion_ref;
//   controlBus.axisControlBus3.acceleration_ref = pathPlanning.controlBus.axisControlBus3.acceleration_ref;
//   axis3.axisControlBus.angle_ref = controlBus.axisControlBus3.angle_ref;
//   axis3.axisControlBus.angle_ref = pathPlanning.controlBus.axisControlBus3.angle_ref;
//   axis3.axisControlBus.angle = controlBus.axisControlBus3.angle;
//   axis3.axisControlBus.angle = pathPlanning.controlBus.axisControlBus3.angle;
//   axis3.axisControlBus.acceleration = controlBus.axisControlBus3.acceleration;
//   axis3.axisControlBus.acceleration = pathPlanning.controlBus.axisControlBus3.acceleration;
//   axis3.axisControlBus.motorSpeed = controlBus.axisControlBus3.motorSpeed;
//   axis3.axisControlBus.motorSpeed = pathPlanning.controlBus.axisControlBus3.motorSpeed;
//   axis3.axisControlBus.current_ref = controlBus.axisControlBus3.current_ref;
//   axis3.axisControlBus.current_ref = pathPlanning.controlBus.axisControlBus3.current_ref;
//   axis3.axisControlBus.current = controlBus.axisControlBus3.current;
//   axis3.axisControlBus.current = pathPlanning.controlBus.axisControlBus3.current;
//   axis3.axisControlBus.motorAngle = controlBus.axisControlBus3.motorAngle;
//   axis3.axisControlBus.motorAngle = pathPlanning.controlBus.axisControlBus3.motorAngle;
//   axis3.axisControlBus.speed = controlBus.axisControlBus3.speed;
//   axis3.axisControlBus.speed = pathPlanning.controlBus.axisControlBus3.speed;
//   axis1.axisControlBus.speed_ref = controlBus.axisControlBus1.speed_ref;
//   axis1.axisControlBus.speed_ref = pathPlanning.controlBus.axisControlBus1.speed_ref;
//   controlBus.axisControlBus1.motion_ref = pathPlanning.controlBus.axisControlBus1.motion_ref;
//   controlBus.axisControlBus1.acceleration_ref = pathPlanning.controlBus.axisControlBus1.acceleration_ref;
//   axis1.axisControlBus.angle_ref = controlBus.axisControlBus1.angle_ref;
//   axis1.axisControlBus.angle_ref = pathPlanning.controlBus.axisControlBus1.angle_ref;
//   axis1.axisControlBus.angle = controlBus.axisControlBus1.angle;
//   axis1.axisControlBus.angle = pathPlanning.controlBus.axisControlBus1.angle;
//   axis1.axisControlBus.acceleration = controlBus.axisControlBus1.acceleration;
//   axis1.axisControlBus.acceleration = pathPlanning.controlBus.axisControlBus1.acceleration;
//   axis1.axisControlBus.motorSpeed = controlBus.axisControlBus1.motorSpeed;
//   axis1.axisControlBus.motorSpeed = pathPlanning.controlBus.axisControlBus1.motorSpeed;
//   axis1.axisControlBus.current_ref = controlBus.axisControlBus1.current_ref;
//   axis1.axisControlBus.current_ref = pathPlanning.controlBus.axisControlBus1.current_ref;
//   axis1.axisControlBus.current = controlBus.axisControlBus1.current;
//   axis1.axisControlBus.current = pathPlanning.controlBus.axisControlBus1.current;
//   axis1.axisControlBus.motorAngle = controlBus.axisControlBus1.motorAngle;
//   axis1.axisControlBus.motorAngle = pathPlanning.controlBus.axisControlBus1.motorAngle;
//   axis1.axisControlBus.speed = controlBus.axisControlBus1.speed;
//   axis1.axisControlBus.speed = pathPlanning.controlBus.axisControlBus1.speed;
//   axis2.axisControlBus.speed_ref = controlBus.axisControlBus2.speed_ref;
//   axis2.axisControlBus.speed_ref = pathPlanning.controlBus.axisControlBus2.speed_ref;
//   controlBus.axisControlBus2.motion_ref = pathPlanning.controlBus.axisControlBus2.motion_ref;
//   controlBus.axisControlBus2.acceleration_ref = pathPlanning.controlBus.axisControlBus2.acceleration_ref;
//   axis2.axisControlBus.angle_ref = controlBus.axisControlBus2.angle_ref;
//   axis2.axisControlBus.angle_ref = pathPlanning.controlBus.axisControlBus2.angle_ref;
//   axis2.axisControlBus.angle = controlBus.axisControlBus2.angle;
//   axis2.axisControlBus.angle = pathPlanning.controlBus.axisControlBus2.angle;
//   axis2.axisControlBus.acceleration = controlBus.axisControlBus2.acceleration;
//   axis2.axisControlBus.acceleration = pathPlanning.controlBus.axisControlBus2.acceleration;
//   axis2.axisControlBus.motorSpeed = controlBus.axisControlBus2.motorSpeed;
//   axis2.axisControlBus.motorSpeed = pathPlanning.controlBus.axisControlBus2.motorSpeed;
//   axis2.axisControlBus.current_ref = controlBus.axisControlBus2.current_ref;
//   axis2.axisControlBus.current_ref = pathPlanning.controlBus.axisControlBus2.current_ref;
//   axis2.axisControlBus.current = controlBus.axisControlBus2.current;
//   axis2.axisControlBus.current = pathPlanning.controlBus.axisControlBus2.current;
//   axis2.axisControlBus.motorAngle = controlBus.axisControlBus2.motorAngle;
//   axis2.axisControlBus.motorAngle = pathPlanning.controlBus.axisControlBus2.motorAngle;
//   axis2.axisControlBus.speed = controlBus.axisControlBus2.speed;
//   axis2.axisControlBus.speed = pathPlanning.controlBus.axisControlBus2.speed;
//   axis4.axisControlBus.speed_ref = controlBus.axisControlBus4.speed_ref;
//   axis4.axisControlBus.speed_ref = pathPlanning.controlBus.axisControlBus4.speed_ref;
//   controlBus.axisControlBus4.motion_ref = pathPlanning.controlBus.axisControlBus4.motion_ref;
//   controlBus.axisControlBus4.acceleration_ref = pathPlanning.controlBus.axisControlBus4.acceleration_ref;
//   axis4.axisControlBus.angle_ref = controlBus.axisControlBus4.angle_ref;
//   axis4.axisControlBus.angle_ref = pathPlanning.controlBus.axisControlBus4.angle_ref;
//   axis4.axisControlBus.angle = controlBus.axisControlBus4.angle;
//   axis4.axisControlBus.angle = pathPlanning.controlBus.axisControlBus4.angle;
//   axis4.axisControlBus.acceleration = controlBus.axisControlBus4.acceleration;
//   axis4.axisControlBus.acceleration = pathPlanning.controlBus.axisControlBus4.acceleration;
//   axis4.axisControlBus.motorSpeed = controlBus.axisControlBus4.motorSpeed;
//   axis4.axisControlBus.motorSpeed = pathPlanning.controlBus.axisControlBus4.motorSpeed;
//   axis4.axisControlBus.current_ref = controlBus.axisControlBus4.current_ref;
//   axis4.axisControlBus.current_ref = pathPlanning.controlBus.axisControlBus4.current_ref;
//   axis4.axisControlBus.current = controlBus.axisControlBus4.current;
//   axis4.axisControlBus.current = pathPlanning.controlBus.axisControlBus4.current;
//   axis4.axisControlBus.motorAngle = controlBus.axisControlBus4.motorAngle;
//   axis4.axisControlBus.motorAngle = pathPlanning.controlBus.axisControlBus4.motorAngle;
//   axis4.axisControlBus.speed = controlBus.axisControlBus4.speed;
//   axis4.axisControlBus.speed = pathPlanning.controlBus.axisControlBus4.speed;
//   axis6.flange.tau + mechanics.axis6.tau = 0.0;
//   axis6.flange.phi = mechanics.axis6.phi;
//   axis5.flange.tau + mechanics.axis5.tau = 0.0;
//   axis5.flange.phi = mechanics.axis5.phi;
//   axis4.flange.tau + mechanics.axis4.tau = 0.0;
//   axis4.flange.phi = mechanics.axis4.phi;
//   axis3.flange.tau + mechanics.axis3.tau = 0.0;
//   axis3.flange.phi = mechanics.axis3.phi;
//   axis1.flange.tau + mechanics.axis1.tau = 0.0;
//   axis1.flange.phi = mechanics.axis1.phi;
//   axis2.flange.tau + mechanics.axis2.tau = 0.0;
//   axis2.flange.phi = mechanics.axis2.phi;
//   axis6.axisControlBus.speed_ref = axis6.controller.axisControlBus.speed_ref;
//   axis6.axisControlBus.speed_ref = axis6.initializeFlange.w_start;
//   axis6.axisControlBus.speed_ref = axis6.motor.axisControlBus.speed_ref;
//   axis6.axisControlBus.speed = axis6.controller.axisControlBus.speed;
//   axis6.axisControlBus.speed = axis6.motor.axisControlBus.speed;
//   axis6.axisControlBus.speed = axis6.speedSensor.w;
//   axis6.axisControlBus.motorAngle = axis6.controller.axisControlBus.motorAngle;
//   axis6.axisControlBus.motorAngle = axis6.motor.axisControlBus.motorAngle;
//   axis6.axisControlBus.current = axis6.controller.axisControlBus.current;
//   axis6.axisControlBus.current = axis6.motor.axisControlBus.current;
//   axis6.axisControlBus.current_ref = axis6.controller.axisControlBus.current_ref;
//   axis6.axisControlBus.current_ref = axis6.motor.axisControlBus.current_ref;
//   axis6.axisControlBus.motorSpeed = axis6.controller.axisControlBus.motorSpeed;
//   axis6.axisControlBus.motorSpeed = axis6.motor.axisControlBus.motorSpeed;
//   axis6.accSensor.a = axis6.axisControlBus.acceleration;
//   axis6.accSensor.a = axis6.controller.axisControlBus.acceleration;
//   axis6.accSensor.a = axis6.motor.axisControlBus.acceleration;
//   axis6.angleSensor.phi = axis6.axisControlBus.angle;
//   axis6.angleSensor.phi = axis6.controller.axisControlBus.angle;
//   axis6.angleSensor.phi = axis6.motor.axisControlBus.angle;
//   axis6.axisControlBus.angle_ref = axis6.controller.axisControlBus.angle_ref;
//   axis6.axisControlBus.angle_ref = axis6.initializeFlange.phi_start;
//   axis6.axisControlBus.angle_ref = axis6.motor.axisControlBus.angle_ref;
//   axis6.const.y = axis6.initializeFlange.a_start;
//   axis6.initializeFlange.flange.tau + (axis6.gear.flange_b.tau + ((-axis6.flange.tau) + (axis6.angleSensor.flange.tau + (axis6.speedSensor.flange.tau + axis6.accSensor.flange.tau)))) = 0.0;
//   axis6.accSensor.flange.phi = axis6.angleSensor.flange.phi;
//   axis6.accSensor.flange.phi = axis6.flange.phi;
//   axis6.accSensor.flange.phi = axis6.gear.flange_b.phi;
//   axis6.accSensor.flange.phi = axis6.initializeFlange.flange.phi;
//   axis6.accSensor.flange.phi = axis6.speedSensor.flange.phi;
//   axis6.motor.flange_motor.tau + axis6.gear.flange_a.tau = 0.0;
//   axis6.gear.flange_a.phi = axis6.motor.flange_motor.phi;
//   axis6.initializeFlange.set_flange_tau.flange.tau + (axis6.initializeFlange.set_a_start.flange.tau + (axis6.initializeFlange.set_w_start.flange.tau + (axis6.initializeFlange.set_phi_start.flange.tau + (-axis6.initializeFlange.flange.tau)))) = 0.0;
//   axis6.initializeFlange.flange.phi = axis6.initializeFlange.set_a_start.flange.phi;
//   axis6.initializeFlange.flange.phi = axis6.initializeFlange.set_flange_tau.flange.phi;
//   axis6.initializeFlange.flange.phi = axis6.initializeFlange.set_phi_start.flange.phi;
//   axis6.initializeFlange.flange.phi = axis6.initializeFlange.set_w_start.flange.phi;
//   axis6.initializeFlange.a_start = axis6.initializeFlange.set_a_start.a_start;
//   axis6.initializeFlange.set_w_start.w_start = axis6.initializeFlange.w_start;
//   axis6.initializeFlange.phi_start = axis6.initializeFlange.set_phi_start.phi_start;
//   axis6.controller.PI.y = axis6.controller.axisControlBus.current_ref;
//   axis6.controller.add3.u3 = axis6.controller.axisControlBus.motorSpeed;
//   axis6.controller.axisControlBus.motorAngle = axis6.controller.feedback1.u2;
//   axis6.controller.axisControlBus.angle_ref = axis6.controller.gain1.u;
//   axis6.controller.axisControlBus.speed_ref = axis6.controller.gain2.u;
//   axis6.controller.PI.u = axis6.controller.add3.y;
//   axis6.controller.add3.u1 = axis6.controller.gain2.y;
//   axis6.controller.P.y = axis6.controller.add3.u2;
//   axis6.controller.P.u = axis6.controller.feedback1.y;
//   axis6.controller.feedback1.u1 = axis6.controller.gain1.y;
//   axis6.motor.emf.flange.tau + (axis6.motor.phi.flange.tau + (axis6.motor.speed.flange.tau + axis6.motor.Jmotor.flange_a.tau)) = 0.0;
//   axis6.motor.Jmotor.flange_a.phi = axis6.motor.emf.flange.phi;
//   axis6.motor.Jmotor.flange_a.phi = axis6.motor.phi.flange.phi;
//   axis6.motor.Jmotor.flange_a.phi = axis6.motor.speed.flange.phi;
//   axis6.motor.Vs.v = axis6.motor.convert2.y;
//   axis6.motor.axisControlBus.current_ref = axis6.motor.convert2.u;
//   axis6.motor.convert1.y = axis6.motor.hall2.v;
//   axis6.motor.axisControlBus.current = axis6.motor.convert1.u;
//   axis6.motor.axisControlBus.current = axis6.motor.hall1.i;
//   axis6.motor.axisControlBus.motorSpeed = axis6.motor.speed.w;
//   axis6.motor.axisControlBus.motorAngle = axis6.motor.phi.phi;
//   axis6.motor.Jmotor.flange_b.tau + (-axis6.motor.flange_motor.tau) = 0.0;
//   axis6.motor.Jmotor.flange_b.phi = axis6.motor.flange_motor.phi;
//   axis6.motor.Rd4.n.i + (axis6.motor.g3.p.i + (axis6.motor.OpI.p1.i + (axis6.motor.OpI.n2.i + (axis6.motor.power.n2.i + axis6.motor.diff.n2.i)))) = 0.0;
//   axis6.motor.OpI.n2.v = axis6.motor.OpI.p1.v;
//   axis6.motor.OpI.n2.v = axis6.motor.Rd4.n.v;
//   axis6.motor.OpI.n2.v = axis6.motor.diff.n2.v;
//   axis6.motor.OpI.n2.v = axis6.motor.g3.p.v;
//   axis6.motor.OpI.n2.v = axis6.motor.power.n2.v;
//   axis6.motor.hall1.n.i + axis6.motor.g4.p.i = 0.0;
//   axis6.motor.g4.p.v = axis6.motor.hall1.n.v;
//   axis6.motor.emf.n.i + axis6.motor.hall1.p.i = 0.0;
//   axis6.motor.emf.n.v = axis6.motor.hall1.p.v;
//   axis6.motor.g5.p.i + axis6.motor.Rp2.n.i = 0.0;
//   axis6.motor.Rp2.n.v = axis6.motor.g5.p.v;
//   axis6.motor.g2.p.i + axis6.motor.hall2.n.i = 0.0;
//   axis6.motor.g2.p.v = axis6.motor.hall2.n.v;
//   axis6.motor.Vs.n.i + axis6.motor.g1.p.i = 0.0;
//   axis6.motor.Vs.n.v = axis6.motor.g1.p.v;
//   axis6.motor.Rd3.n.i + (axis6.motor.diff.p1.i + axis6.motor.Rd4.p.i) = 0.0;
//   axis6.motor.Rd3.n.v = axis6.motor.Rd4.p.v;
//   axis6.motor.Rd3.n.v = axis6.motor.diff.p1.v;
//   axis6.motor.Rd3.p.i + axis6.motor.hall2.p.i = 0.0;
//   axis6.motor.Rd3.p.v = axis6.motor.hall2.p.v;
//   axis6.motor.power.p2.i + (axis6.motor.Rp1.n.i + axis6.motor.Ra.p.i) = 0.0;
//   axis6.motor.Ra.p.v = axis6.motor.Rp1.n.v;
//   axis6.motor.Ra.p.v = axis6.motor.power.p2.v;
//   axis6.motor.power.n1.i + (axis6.motor.Rp1.p.i + axis6.motor.Rp2.p.i) = 0.0;
//   axis6.motor.Rp1.p.v = axis6.motor.Rp2.p.v;
//   axis6.motor.Rp1.p.v = axis6.motor.power.n1.v;
//   axis6.motor.Ri.n.i + (axis6.motor.OpI.n1.i + axis6.motor.C.p.i) = 0.0;
//   axis6.motor.C.p.v = axis6.motor.OpI.n1.v;
//   axis6.motor.C.p.v = axis6.motor.Ri.n.v;
//   axis6.motor.Rd1.n.i + (axis6.motor.diff.p2.i + axis6.motor.Ri.p.i) = 0.0;
//   axis6.motor.Rd1.n.v = axis6.motor.Ri.p.v;
//   axis6.motor.Rd1.n.v = axis6.motor.diff.p2.v;
//   axis6.motor.Rd2.n.i + (axis6.motor.diff.n1.i + axis6.motor.Rd1.p.i) = 0.0;
//   axis6.motor.Rd1.p.v = axis6.motor.Rd2.n.v;
//   axis6.motor.Rd1.p.v = axis6.motor.diff.n1.v;
//   axis6.motor.Vs.p.i + axis6.motor.Rd2.p.i = 0.0;
//   axis6.motor.Rd2.p.v = axis6.motor.Vs.p.v;
//   axis6.motor.C.n.i + (axis6.motor.OpI.p2.i + axis6.motor.power.p1.i) = 0.0;
//   axis6.motor.C.n.v = axis6.motor.OpI.p2.v;
//   axis6.motor.C.n.v = axis6.motor.power.p1.v;
//   axis6.motor.Ra.n.i + axis6.motor.La.p.i = 0.0;
//   axis6.motor.La.p.v = axis6.motor.Ra.n.v;
//   axis6.motor.La.n.i + axis6.motor.emf.p.i = 0.0;
//   axis6.motor.La.n.v = axis6.motor.emf.p.v;
//   axis6.motor.emf.internalSupport.flange.tau + axis6.motor.emf.fixed.flange.tau = 0.0;
//   axis6.motor.emf.fixed.flange.phi = axis6.motor.emf.internalSupport.flange.phi;
//   axis6.gear.gear.flange_a.tau + (-axis6.gear.flange_a.tau) = 0.0;
//   axis6.gear.flange_a.phi = axis6.gear.gear.flange_a.phi;
//   axis6.gear.bearingFriction.flange_b.tau + (-axis6.gear.flange_b.tau) = 0.0;
//   axis6.gear.bearingFriction.flange_b.phi = axis6.gear.flange_b.phi;
//   axis6.gear.gear.flange_b.tau + axis6.gear.bearingFriction.flange_a.tau = 0.0;
//   axis6.gear.bearingFriction.flange_a.phi = axis6.gear.gear.flange_b.phi;
//   axis5.axisControlBus.speed_ref = axis5.controller.axisControlBus.speed_ref;
//   axis5.axisControlBus.speed_ref = axis5.initializeFlange.w_start;
//   axis5.axisControlBus.speed_ref = axis5.motor.axisControlBus.speed_ref;
//   axis5.axisControlBus.speed = axis5.controller.axisControlBus.speed;
//   axis5.axisControlBus.speed = axis5.motor.axisControlBus.speed;
//   axis5.axisControlBus.speed = axis5.speedSensor.w;
//   axis5.axisControlBus.motorAngle = axis5.controller.axisControlBus.motorAngle;
//   axis5.axisControlBus.motorAngle = axis5.motor.axisControlBus.motorAngle;
//   axis5.axisControlBus.current = axis5.controller.axisControlBus.current;
//   axis5.axisControlBus.current = axis5.motor.axisControlBus.current;
//   axis5.axisControlBus.current_ref = axis5.controller.axisControlBus.current_ref;
//   axis5.axisControlBus.current_ref = axis5.motor.axisControlBus.current_ref;
//   axis5.axisControlBus.motorSpeed = axis5.controller.axisControlBus.motorSpeed;
//   axis5.axisControlBus.motorSpeed = axis5.motor.axisControlBus.motorSpeed;
//   axis5.accSensor.a = axis5.axisControlBus.acceleration;
//   axis5.accSensor.a = axis5.controller.axisControlBus.acceleration;
//   axis5.accSensor.a = axis5.motor.axisControlBus.acceleration;
//   axis5.angleSensor.phi = axis5.axisControlBus.angle;
//   axis5.angleSensor.phi = axis5.controller.axisControlBus.angle;
//   axis5.angleSensor.phi = axis5.motor.axisControlBus.angle;
//   axis5.axisControlBus.angle_ref = axis5.controller.axisControlBus.angle_ref;
//   axis5.axisControlBus.angle_ref = axis5.initializeFlange.phi_start;
//   axis5.axisControlBus.angle_ref = axis5.motor.axisControlBus.angle_ref;
//   axis5.const.y = axis5.initializeFlange.a_start;
//   axis5.initializeFlange.flange.tau + (axis5.gear.flange_b.tau + ((-axis5.flange.tau) + (axis5.angleSensor.flange.tau + (axis5.speedSensor.flange.tau + axis5.accSensor.flange.tau)))) = 0.0;
//   axis5.accSensor.flange.phi = axis5.angleSensor.flange.phi;
//   axis5.accSensor.flange.phi = axis5.flange.phi;
//   axis5.accSensor.flange.phi = axis5.gear.flange_b.phi;
//   axis5.accSensor.flange.phi = axis5.initializeFlange.flange.phi;
//   axis5.accSensor.flange.phi = axis5.speedSensor.flange.phi;
//   axis5.motor.flange_motor.tau + axis5.gear.flange_a.tau = 0.0;
//   axis5.gear.flange_a.phi = axis5.motor.flange_motor.phi;
//   axis5.initializeFlange.set_flange_tau.flange.tau + (axis5.initializeFlange.set_a_start.flange.tau + (axis5.initializeFlange.set_w_start.flange.tau + (axis5.initializeFlange.set_phi_start.flange.tau + (-axis5.initializeFlange.flange.tau)))) = 0.0;
//   axis5.initializeFlange.flange.phi = axis5.initializeFlange.set_a_start.flange.phi;
//   axis5.initializeFlange.flange.phi = axis5.initializeFlange.set_flange_tau.flange.phi;
//   axis5.initializeFlange.flange.phi = axis5.initializeFlange.set_phi_start.flange.phi;
//   axis5.initializeFlange.flange.phi = axis5.initializeFlange.set_w_start.flange.phi;
//   axis5.initializeFlange.a_start = axis5.initializeFlange.set_a_start.a_start;
//   axis5.initializeFlange.set_w_start.w_start = axis5.initializeFlange.w_start;
//   axis5.initializeFlange.phi_start = axis5.initializeFlange.set_phi_start.phi_start;
//   axis5.controller.PI.y = axis5.controller.axisControlBus.current_ref;
//   axis5.controller.add3.u3 = axis5.controller.axisControlBus.motorSpeed;
//   axis5.controller.axisControlBus.motorAngle = axis5.controller.feedback1.u2;
//   axis5.controller.axisControlBus.angle_ref = axis5.controller.gain1.u;
//   axis5.controller.axisControlBus.speed_ref = axis5.controller.gain2.u;
//   axis5.controller.PI.u = axis5.controller.add3.y;
//   axis5.controller.add3.u1 = axis5.controller.gain2.y;
//   axis5.controller.P.y = axis5.controller.add3.u2;
//   axis5.controller.P.u = axis5.controller.feedback1.y;
//   axis5.controller.feedback1.u1 = axis5.controller.gain1.y;
//   axis5.motor.emf.flange.tau + (axis5.motor.phi.flange.tau + (axis5.motor.speed.flange.tau + axis5.motor.Jmotor.flange_a.tau)) = 0.0;
//   axis5.motor.Jmotor.flange_a.phi = axis5.motor.emf.flange.phi;
//   axis5.motor.Jmotor.flange_a.phi = axis5.motor.phi.flange.phi;
//   axis5.motor.Jmotor.flange_a.phi = axis5.motor.speed.flange.phi;
//   axis5.motor.Vs.v = axis5.motor.convert2.y;
//   axis5.motor.axisControlBus.current_ref = axis5.motor.convert2.u;
//   axis5.motor.convert1.y = axis5.motor.hall2.v;
//   axis5.motor.axisControlBus.current = axis5.motor.convert1.u;
//   axis5.motor.axisControlBus.current = axis5.motor.hall1.i;
//   axis5.motor.axisControlBus.motorSpeed = axis5.motor.speed.w;
//   axis5.motor.axisControlBus.motorAngle = axis5.motor.phi.phi;
//   axis5.motor.Jmotor.flange_b.tau + (-axis5.motor.flange_motor.tau) = 0.0;
//   axis5.motor.Jmotor.flange_b.phi = axis5.motor.flange_motor.phi;
//   axis5.motor.Rd4.n.i + (axis5.motor.g3.p.i + (axis5.motor.OpI.p1.i + (axis5.motor.OpI.n2.i + (axis5.motor.power.n2.i + axis5.motor.diff.n2.i)))) = 0.0;
//   axis5.motor.OpI.n2.v = axis5.motor.OpI.p1.v;
//   axis5.motor.OpI.n2.v = axis5.motor.Rd4.n.v;
//   axis5.motor.OpI.n2.v = axis5.motor.diff.n2.v;
//   axis5.motor.OpI.n2.v = axis5.motor.g3.p.v;
//   axis5.motor.OpI.n2.v = axis5.motor.power.n2.v;
//   axis5.motor.hall1.n.i + axis5.motor.g4.p.i = 0.0;
//   axis5.motor.g4.p.v = axis5.motor.hall1.n.v;
//   axis5.motor.emf.n.i + axis5.motor.hall1.p.i = 0.0;
//   axis5.motor.emf.n.v = axis5.motor.hall1.p.v;
//   axis5.motor.g5.p.i + axis5.motor.Rp2.n.i = 0.0;
//   axis5.motor.Rp2.n.v = axis5.motor.g5.p.v;
//   axis5.motor.g2.p.i + axis5.motor.hall2.n.i = 0.0;
//   axis5.motor.g2.p.v = axis5.motor.hall2.n.v;
//   axis5.motor.Vs.n.i + axis5.motor.g1.p.i = 0.0;
//   axis5.motor.Vs.n.v = axis5.motor.g1.p.v;
//   axis5.motor.Rd3.n.i + (axis5.motor.diff.p1.i + axis5.motor.Rd4.p.i) = 0.0;
//   axis5.motor.Rd3.n.v = axis5.motor.Rd4.p.v;
//   axis5.motor.Rd3.n.v = axis5.motor.diff.p1.v;
//   axis5.motor.Rd3.p.i + axis5.motor.hall2.p.i = 0.0;
//   axis5.motor.Rd3.p.v = axis5.motor.hall2.p.v;
//   axis5.motor.power.p2.i + (axis5.motor.Rp1.n.i + axis5.motor.Ra.p.i) = 0.0;
//   axis5.motor.Ra.p.v = axis5.motor.Rp1.n.v;
//   axis5.motor.Ra.p.v = axis5.motor.power.p2.v;
//   axis5.motor.power.n1.i + (axis5.motor.Rp1.p.i + axis5.motor.Rp2.p.i) = 0.0;
//   axis5.motor.Rp1.p.v = axis5.motor.Rp2.p.v;
//   axis5.motor.Rp1.p.v = axis5.motor.power.n1.v;
//   axis5.motor.Ri.n.i + (axis5.motor.OpI.n1.i + axis5.motor.C.p.i) = 0.0;
//   axis5.motor.C.p.v = axis5.motor.OpI.n1.v;
//   axis5.motor.C.p.v = axis5.motor.Ri.n.v;
//   axis5.motor.Rd1.n.i + (axis5.motor.diff.p2.i + axis5.motor.Ri.p.i) = 0.0;
//   axis5.motor.Rd1.n.v = axis5.motor.Ri.p.v;
//   axis5.motor.Rd1.n.v = axis5.motor.diff.p2.v;
//   axis5.motor.Rd2.n.i + (axis5.motor.diff.n1.i + axis5.motor.Rd1.p.i) = 0.0;
//   axis5.motor.Rd1.p.v = axis5.motor.Rd2.n.v;
//   axis5.motor.Rd1.p.v = axis5.motor.diff.n1.v;
//   axis5.motor.Vs.p.i + axis5.motor.Rd2.p.i = 0.0;
//   axis5.motor.Rd2.p.v = axis5.motor.Vs.p.v;
//   axis5.motor.C.n.i + (axis5.motor.OpI.p2.i + axis5.motor.power.p1.i) = 0.0;
//   axis5.motor.C.n.v = axis5.motor.OpI.p2.v;
//   axis5.motor.C.n.v = axis5.motor.power.p1.v;
//   axis5.motor.Ra.n.i + axis5.motor.La.p.i = 0.0;
//   axis5.motor.La.p.v = axis5.motor.Ra.n.v;
//   axis5.motor.La.n.i + axis5.motor.emf.p.i = 0.0;
//   axis5.motor.La.n.v = axis5.motor.emf.p.v;
//   axis5.motor.emf.internalSupport.flange.tau + axis5.motor.emf.fixed.flange.tau = 0.0;
//   axis5.motor.emf.fixed.flange.phi = axis5.motor.emf.internalSupport.flange.phi;
//   axis5.gear.gear.flange_a.tau + (-axis5.gear.flange_a.tau) = 0.0;
//   axis5.gear.flange_a.phi = axis5.gear.gear.flange_a.phi;
//   axis5.gear.bearingFriction.flange_b.tau + (-axis5.gear.flange_b.tau) = 0.0;
//   axis5.gear.bearingFriction.flange_b.phi = axis5.gear.flange_b.phi;
//   axis5.gear.gear.flange_b.tau + axis5.gear.bearingFriction.flange_a.tau = 0.0;
//   axis5.gear.bearingFriction.flange_a.phi = axis5.gear.gear.flange_b.phi;
//   axis4.axisControlBus.speed_ref = axis4.controller.axisControlBus.speed_ref;
//   axis4.axisControlBus.speed_ref = axis4.initializeFlange.w_start;
//   axis4.axisControlBus.speed_ref = axis4.motor.axisControlBus.speed_ref;
//   axis4.axisControlBus.speed = axis4.controller.axisControlBus.speed;
//   axis4.axisControlBus.speed = axis4.motor.axisControlBus.speed;
//   axis4.axisControlBus.speed = axis4.speedSensor.w;
//   axis4.axisControlBus.motorAngle = axis4.controller.axisControlBus.motorAngle;
//   axis4.axisControlBus.motorAngle = axis4.motor.axisControlBus.motorAngle;
//   axis4.axisControlBus.current = axis4.controller.axisControlBus.current;
//   axis4.axisControlBus.current = axis4.motor.axisControlBus.current;
//   axis4.axisControlBus.current_ref = axis4.controller.axisControlBus.current_ref;
//   axis4.axisControlBus.current_ref = axis4.motor.axisControlBus.current_ref;
//   axis4.axisControlBus.motorSpeed = axis4.controller.axisControlBus.motorSpeed;
//   axis4.axisControlBus.motorSpeed = axis4.motor.axisControlBus.motorSpeed;
//   axis4.accSensor.a = axis4.axisControlBus.acceleration;
//   axis4.accSensor.a = axis4.controller.axisControlBus.acceleration;
//   axis4.accSensor.a = axis4.motor.axisControlBus.acceleration;
//   axis4.angleSensor.phi = axis4.axisControlBus.angle;
//   axis4.angleSensor.phi = axis4.controller.axisControlBus.angle;
//   axis4.angleSensor.phi = axis4.motor.axisControlBus.angle;
//   axis4.axisControlBus.angle_ref = axis4.controller.axisControlBus.angle_ref;
//   axis4.axisControlBus.angle_ref = axis4.initializeFlange.phi_start;
//   axis4.axisControlBus.angle_ref = axis4.motor.axisControlBus.angle_ref;
//   axis4.const.y = axis4.initializeFlange.a_start;
//   axis4.initializeFlange.flange.tau + (axis4.gear.flange_b.tau + ((-axis4.flange.tau) + (axis4.angleSensor.flange.tau + (axis4.speedSensor.flange.tau + axis4.accSensor.flange.tau)))) = 0.0;
//   axis4.accSensor.flange.phi = axis4.angleSensor.flange.phi;
//   axis4.accSensor.flange.phi = axis4.flange.phi;
//   axis4.accSensor.flange.phi = axis4.gear.flange_b.phi;
//   axis4.accSensor.flange.phi = axis4.initializeFlange.flange.phi;
//   axis4.accSensor.flange.phi = axis4.speedSensor.flange.phi;
//   axis4.motor.flange_motor.tau + axis4.gear.flange_a.tau = 0.0;
//   axis4.gear.flange_a.phi = axis4.motor.flange_motor.phi;
//   axis4.initializeFlange.set_flange_tau.flange.tau + (axis4.initializeFlange.set_a_start.flange.tau + (axis4.initializeFlange.set_w_start.flange.tau + (axis4.initializeFlange.set_phi_start.flange.tau + (-axis4.initializeFlange.flange.tau)))) = 0.0;
//   axis4.initializeFlange.flange.phi = axis4.initializeFlange.set_a_start.flange.phi;
//   axis4.initializeFlange.flange.phi = axis4.initializeFlange.set_flange_tau.flange.phi;
//   axis4.initializeFlange.flange.phi = axis4.initializeFlange.set_phi_start.flange.phi;
//   axis4.initializeFlange.flange.phi = axis4.initializeFlange.set_w_start.flange.phi;
//   axis4.initializeFlange.a_start = axis4.initializeFlange.set_a_start.a_start;
//   axis4.initializeFlange.set_w_start.w_start = axis4.initializeFlange.w_start;
//   axis4.initializeFlange.phi_start = axis4.initializeFlange.set_phi_start.phi_start;
//   axis4.controller.PI.y = axis4.controller.axisControlBus.current_ref;
//   axis4.controller.add3.u3 = axis4.controller.axisControlBus.motorSpeed;
//   axis4.controller.axisControlBus.motorAngle = axis4.controller.feedback1.u2;
//   axis4.controller.axisControlBus.angle_ref = axis4.controller.gain1.u;
//   axis4.controller.axisControlBus.speed_ref = axis4.controller.gain2.u;
//   axis4.controller.PI.u = axis4.controller.add3.y;
//   axis4.controller.add3.u1 = axis4.controller.gain2.y;
//   axis4.controller.P.y = axis4.controller.add3.u2;
//   axis4.controller.P.u = axis4.controller.feedback1.y;
//   axis4.controller.feedback1.u1 = axis4.controller.gain1.y;
//   axis4.motor.emf.flange.tau + (axis4.motor.phi.flange.tau + (axis4.motor.speed.flange.tau + axis4.motor.Jmotor.flange_a.tau)) = 0.0;
//   axis4.motor.Jmotor.flange_a.phi = axis4.motor.emf.flange.phi;
//   axis4.motor.Jmotor.flange_a.phi = axis4.motor.phi.flange.phi;
//   axis4.motor.Jmotor.flange_a.phi = axis4.motor.speed.flange.phi;
//   axis4.motor.Vs.v = axis4.motor.convert2.y;
//   axis4.motor.axisControlBus.current_ref = axis4.motor.convert2.u;
//   axis4.motor.convert1.y = axis4.motor.hall2.v;
//   axis4.motor.axisControlBus.current = axis4.motor.convert1.u;
//   axis4.motor.axisControlBus.current = axis4.motor.hall1.i;
//   axis4.motor.axisControlBus.motorSpeed = axis4.motor.speed.w;
//   axis4.motor.axisControlBus.motorAngle = axis4.motor.phi.phi;
//   axis4.motor.Jmotor.flange_b.tau + (-axis4.motor.flange_motor.tau) = 0.0;
//   axis4.motor.Jmotor.flange_b.phi = axis4.motor.flange_motor.phi;
//   axis4.motor.Rd4.n.i + (axis4.motor.g3.p.i + (axis4.motor.OpI.p1.i + (axis4.motor.OpI.n2.i + (axis4.motor.power.n2.i + axis4.motor.diff.n2.i)))) = 0.0;
//   axis4.motor.OpI.n2.v = axis4.motor.OpI.p1.v;
//   axis4.motor.OpI.n2.v = axis4.motor.Rd4.n.v;
//   axis4.motor.OpI.n2.v = axis4.motor.diff.n2.v;
//   axis4.motor.OpI.n2.v = axis4.motor.g3.p.v;
//   axis4.motor.OpI.n2.v = axis4.motor.power.n2.v;
//   axis4.motor.hall1.n.i + axis4.motor.g4.p.i = 0.0;
//   axis4.motor.g4.p.v = axis4.motor.hall1.n.v;
//   axis4.motor.emf.n.i + axis4.motor.hall1.p.i = 0.0;
//   axis4.motor.emf.n.v = axis4.motor.hall1.p.v;
//   axis4.motor.g5.p.i + axis4.motor.Rp2.n.i = 0.0;
//   axis4.motor.Rp2.n.v = axis4.motor.g5.p.v;
//   axis4.motor.g2.p.i + axis4.motor.hall2.n.i = 0.0;
//   axis4.motor.g2.p.v = axis4.motor.hall2.n.v;
//   axis4.motor.Vs.n.i + axis4.motor.g1.p.i = 0.0;
//   axis4.motor.Vs.n.v = axis4.motor.g1.p.v;
//   axis4.motor.Rd3.n.i + (axis4.motor.diff.p1.i + axis4.motor.Rd4.p.i) = 0.0;
//   axis4.motor.Rd3.n.v = axis4.motor.Rd4.p.v;
//   axis4.motor.Rd3.n.v = axis4.motor.diff.p1.v;
//   axis4.motor.Rd3.p.i + axis4.motor.hall2.p.i = 0.0;
//   axis4.motor.Rd3.p.v = axis4.motor.hall2.p.v;
//   axis4.motor.power.p2.i + (axis4.motor.Rp1.n.i + axis4.motor.Ra.p.i) = 0.0;
//   axis4.motor.Ra.p.v = axis4.motor.Rp1.n.v;
//   axis4.motor.Ra.p.v = axis4.motor.power.p2.v;
//   axis4.motor.power.n1.i + (axis4.motor.Rp1.p.i + axis4.motor.Rp2.p.i) = 0.0;
//   axis4.motor.Rp1.p.v = axis4.motor.Rp2.p.v;
//   axis4.motor.Rp1.p.v = axis4.motor.power.n1.v;
//   axis4.motor.Ri.n.i + (axis4.motor.OpI.n1.i + axis4.motor.C.p.i) = 0.0;
//   axis4.motor.C.p.v = axis4.motor.OpI.n1.v;
//   axis4.motor.C.p.v = axis4.motor.Ri.n.v;
//   axis4.motor.Rd1.n.i + (axis4.motor.diff.p2.i + axis4.motor.Ri.p.i) = 0.0;
//   axis4.motor.Rd1.n.v = axis4.motor.Ri.p.v;
//   axis4.motor.Rd1.n.v = axis4.motor.diff.p2.v;
//   axis4.motor.Rd2.n.i + (axis4.motor.diff.n1.i + axis4.motor.Rd1.p.i) = 0.0;
//   axis4.motor.Rd1.p.v = axis4.motor.Rd2.n.v;
//   axis4.motor.Rd1.p.v = axis4.motor.diff.n1.v;
//   axis4.motor.Vs.p.i + axis4.motor.Rd2.p.i = 0.0;
//   axis4.motor.Rd2.p.v = axis4.motor.Vs.p.v;
//   axis4.motor.C.n.i + (axis4.motor.OpI.p2.i + axis4.motor.power.p1.i) = 0.0;
//   axis4.motor.C.n.v = axis4.motor.OpI.p2.v;
//   axis4.motor.C.n.v = axis4.motor.power.p1.v;
//   axis4.motor.Ra.n.i + axis4.motor.La.p.i = 0.0;
//   axis4.motor.La.p.v = axis4.motor.Ra.n.v;
//   axis4.motor.La.n.i + axis4.motor.emf.p.i = 0.0;
//   axis4.motor.La.n.v = axis4.motor.emf.p.v;
//   axis4.motor.emf.internalSupport.flange.tau + axis4.motor.emf.fixed.flange.tau = 0.0;
//   axis4.motor.emf.fixed.flange.phi = axis4.motor.emf.internalSupport.flange.phi;
//   axis4.gear.gear.flange_a.tau + (-axis4.gear.flange_a.tau) = 0.0;
//   axis4.gear.flange_a.phi = axis4.gear.gear.flange_a.phi;
//   axis4.gear.bearingFriction.flange_b.tau + (-axis4.gear.flange_b.tau) = 0.0;
//   axis4.gear.bearingFriction.flange_b.phi = axis4.gear.flange_b.phi;
//   axis4.gear.gear.flange_b.tau + axis4.gear.bearingFriction.flange_a.tau = 0.0;
//   axis4.gear.bearingFriction.flange_a.phi = axis4.gear.gear.flange_b.phi;
//   axis3.axisControlBus.speed_ref = axis3.controller.axisControlBus.speed_ref;
//   axis3.axisControlBus.speed_ref = axis3.initializeFlange.w_start;
//   axis3.axisControlBus.speed_ref = axis3.motor.axisControlBus.speed_ref;
//   axis3.axisControlBus.speed = axis3.controller.axisControlBus.speed;
//   axis3.axisControlBus.speed = axis3.motor.axisControlBus.speed;
//   axis3.axisControlBus.speed = axis3.speedSensor.w;
//   axis3.axisControlBus.motorAngle = axis3.controller.axisControlBus.motorAngle;
//   axis3.axisControlBus.motorAngle = axis3.motor.axisControlBus.motorAngle;
//   axis3.axisControlBus.current = axis3.controller.axisControlBus.current;
//   axis3.axisControlBus.current = axis3.motor.axisControlBus.current;
//   axis3.axisControlBus.current_ref = axis3.controller.axisControlBus.current_ref;
//   axis3.axisControlBus.current_ref = axis3.motor.axisControlBus.current_ref;
//   axis3.axisControlBus.motorSpeed = axis3.controller.axisControlBus.motorSpeed;
//   axis3.axisControlBus.motorSpeed = axis3.motor.axisControlBus.motorSpeed;
//   axis3.accSensor.a = axis3.axisControlBus.acceleration;
//   axis3.accSensor.a = axis3.controller.axisControlBus.acceleration;
//   axis3.accSensor.a = axis3.motor.axisControlBus.acceleration;
//   axis3.angleSensor.phi = axis3.axisControlBus.angle;
//   axis3.angleSensor.phi = axis3.controller.axisControlBus.angle;
//   axis3.angleSensor.phi = axis3.motor.axisControlBus.angle;
//   axis3.axisControlBus.angle_ref = axis3.controller.axisControlBus.angle_ref;
//   axis3.axisControlBus.angle_ref = axis3.initializeFlange.phi_start;
//   axis3.axisControlBus.angle_ref = axis3.motor.axisControlBus.angle_ref;
//   axis3.const.y = axis3.initializeFlange.a_start;
//   axis3.initializeFlange.flange.tau + (axis3.gear.flange_b.tau + ((-axis3.flange.tau) + (axis3.angleSensor.flange.tau + (axis3.speedSensor.flange.tau + axis3.accSensor.flange.tau)))) = 0.0;
//   axis3.accSensor.flange.phi = axis3.angleSensor.flange.phi;
//   axis3.accSensor.flange.phi = axis3.flange.phi;
//   axis3.accSensor.flange.phi = axis3.gear.flange_b.phi;
//   axis3.accSensor.flange.phi = axis3.initializeFlange.flange.phi;
//   axis3.accSensor.flange.phi = axis3.speedSensor.flange.phi;
//   axis3.motor.flange_motor.tau + axis3.gear.flange_a.tau = 0.0;
//   axis3.gear.flange_a.phi = axis3.motor.flange_motor.phi;
//   axis3.initializeFlange.set_flange_tau.flange.tau + (axis3.initializeFlange.set_a_start.flange.tau + (axis3.initializeFlange.set_w_start.flange.tau + (axis3.initializeFlange.set_phi_start.flange.tau + (-axis3.initializeFlange.flange.tau)))) = 0.0;
//   axis3.initializeFlange.flange.phi = axis3.initializeFlange.set_a_start.flange.phi;
//   axis3.initializeFlange.flange.phi = axis3.initializeFlange.set_flange_tau.flange.phi;
//   axis3.initializeFlange.flange.phi = axis3.initializeFlange.set_phi_start.flange.phi;
//   axis3.initializeFlange.flange.phi = axis3.initializeFlange.set_w_start.flange.phi;
//   axis3.initializeFlange.a_start = axis3.initializeFlange.set_a_start.a_start;
//   axis3.initializeFlange.set_w_start.w_start = axis3.initializeFlange.w_start;
//   axis3.initializeFlange.phi_start = axis3.initializeFlange.set_phi_start.phi_start;
//   axis3.controller.PI.y = axis3.controller.axisControlBus.current_ref;
//   axis3.controller.add3.u3 = axis3.controller.axisControlBus.motorSpeed;
//   axis3.controller.axisControlBus.motorAngle = axis3.controller.feedback1.u2;
//   axis3.controller.axisControlBus.angle_ref = axis3.controller.gain1.u;
//   axis3.controller.axisControlBus.speed_ref = axis3.controller.gain2.u;
//   axis3.controller.PI.u = axis3.controller.add3.y;
//   axis3.controller.add3.u1 = axis3.controller.gain2.y;
//   axis3.controller.P.y = axis3.controller.add3.u2;
//   axis3.controller.P.u = axis3.controller.feedback1.y;
//   axis3.controller.feedback1.u1 = axis3.controller.gain1.y;
//   axis3.motor.emf.flange.tau + (axis3.motor.phi.flange.tau + (axis3.motor.speed.flange.tau + axis3.motor.Jmotor.flange_a.tau)) = 0.0;
//   axis3.motor.Jmotor.flange_a.phi = axis3.motor.emf.flange.phi;
//   axis3.motor.Jmotor.flange_a.phi = axis3.motor.phi.flange.phi;
//   axis3.motor.Jmotor.flange_a.phi = axis3.motor.speed.flange.phi;
//   axis3.motor.Vs.v = axis3.motor.convert2.y;
//   axis3.motor.axisControlBus.current_ref = axis3.motor.convert2.u;
//   axis3.motor.convert1.y = axis3.motor.hall2.v;
//   axis3.motor.axisControlBus.current = axis3.motor.convert1.u;
//   axis3.motor.axisControlBus.current = axis3.motor.hall1.i;
//   axis3.motor.axisControlBus.motorSpeed = axis3.motor.speed.w;
//   axis3.motor.axisControlBus.motorAngle = axis3.motor.phi.phi;
//   axis3.motor.Jmotor.flange_b.tau + (-axis3.motor.flange_motor.tau) = 0.0;
//   axis3.motor.Jmotor.flange_b.phi = axis3.motor.flange_motor.phi;
//   axis3.motor.Rd4.n.i + (axis3.motor.g3.p.i + (axis3.motor.OpI.p1.i + (axis3.motor.OpI.n2.i + (axis3.motor.power.n2.i + axis3.motor.diff.n2.i)))) = 0.0;
//   axis3.motor.OpI.n2.v = axis3.motor.OpI.p1.v;
//   axis3.motor.OpI.n2.v = axis3.motor.Rd4.n.v;
//   axis3.motor.OpI.n2.v = axis3.motor.diff.n2.v;
//   axis3.motor.OpI.n2.v = axis3.motor.g3.p.v;
//   axis3.motor.OpI.n2.v = axis3.motor.power.n2.v;
//   axis3.motor.hall1.n.i + axis3.motor.g4.p.i = 0.0;
//   axis3.motor.g4.p.v = axis3.motor.hall1.n.v;
//   axis3.motor.emf.n.i + axis3.motor.hall1.p.i = 0.0;
//   axis3.motor.emf.n.v = axis3.motor.hall1.p.v;
//   axis3.motor.g5.p.i + axis3.motor.Rp2.n.i = 0.0;
//   axis3.motor.Rp2.n.v = axis3.motor.g5.p.v;
//   axis3.motor.g2.p.i + axis3.motor.hall2.n.i = 0.0;
//   axis3.motor.g2.p.v = axis3.motor.hall2.n.v;
//   axis3.motor.Vs.n.i + axis3.motor.g1.p.i = 0.0;
//   axis3.motor.Vs.n.v = axis3.motor.g1.p.v;
//   axis3.motor.Rd3.n.i + (axis3.motor.diff.p1.i + axis3.motor.Rd4.p.i) = 0.0;
//   axis3.motor.Rd3.n.v = axis3.motor.Rd4.p.v;
//   axis3.motor.Rd3.n.v = axis3.motor.diff.p1.v;
//   axis3.motor.Rd3.p.i + axis3.motor.hall2.p.i = 0.0;
//   axis3.motor.Rd3.p.v = axis3.motor.hall2.p.v;
//   axis3.motor.power.p2.i + (axis3.motor.Rp1.n.i + axis3.motor.Ra.p.i) = 0.0;
//   axis3.motor.Ra.p.v = axis3.motor.Rp1.n.v;
//   axis3.motor.Ra.p.v = axis3.motor.power.p2.v;
//   axis3.motor.power.n1.i + (axis3.motor.Rp1.p.i + axis3.motor.Rp2.p.i) = 0.0;
//   axis3.motor.Rp1.p.v = axis3.motor.Rp2.p.v;
//   axis3.motor.Rp1.p.v = axis3.motor.power.n1.v;
//   axis3.motor.Ri.n.i + (axis3.motor.OpI.n1.i + axis3.motor.C.p.i) = 0.0;
//   axis3.motor.C.p.v = axis3.motor.OpI.n1.v;
//   axis3.motor.C.p.v = axis3.motor.Ri.n.v;
//   axis3.motor.Rd1.n.i + (axis3.motor.diff.p2.i + axis3.motor.Ri.p.i) = 0.0;
//   axis3.motor.Rd1.n.v = axis3.motor.Ri.p.v;
//   axis3.motor.Rd1.n.v = axis3.motor.diff.p2.v;
//   axis3.motor.Rd2.n.i + (axis3.motor.diff.n1.i + axis3.motor.Rd1.p.i) = 0.0;
//   axis3.motor.Rd1.p.v = axis3.motor.Rd2.n.v;
//   axis3.motor.Rd1.p.v = axis3.motor.diff.n1.v;
//   axis3.motor.Vs.p.i + axis3.motor.Rd2.p.i = 0.0;
//   axis3.motor.Rd2.p.v = axis3.motor.Vs.p.v;
//   axis3.motor.C.n.i + (axis3.motor.OpI.p2.i + axis3.motor.power.p1.i) = 0.0;
//   axis3.motor.C.n.v = axis3.motor.OpI.p2.v;
//   axis3.motor.C.n.v = axis3.motor.power.p1.v;
//   axis3.motor.Ra.n.i + axis3.motor.La.p.i = 0.0;
//   axis3.motor.La.p.v = axis3.motor.Ra.n.v;
//   axis3.motor.La.n.i + axis3.motor.emf.p.i = 0.0;
//   axis3.motor.La.n.v = axis3.motor.emf.p.v;
//   axis3.motor.emf.internalSupport.flange.tau + axis3.motor.emf.fixed.flange.tau = 0.0;
//   axis3.motor.emf.fixed.flange.phi = axis3.motor.emf.internalSupport.flange.phi;
//   axis3.gear.bearingFriction.flange_a.tau + (-axis3.gear.flange_a.tau) = 0.0;
//   axis3.gear.bearingFriction.flange_a.phi = axis3.gear.flange_a.phi;
//   axis3.gear.gear.flange_b.tau + (-axis3.gear.flange_b.tau) = 0.0;
//   axis3.gear.flange_b.phi = axis3.gear.gear.flange_b.phi;
//   axis3.gear.bearingFriction.flange_b.tau + axis3.gear.spring.flange_a.tau = 0.0;
//   axis3.gear.bearingFriction.flange_b.phi = axis3.gear.spring.flange_a.phi;
//   axis3.gear.spring.flange_b.tau + axis3.gear.gear.flange_a.tau = 0.0;
//   axis3.gear.gear.flange_a.phi = axis3.gear.spring.flange_b.phi;
//   axis2.axisControlBus.speed_ref = axis2.controller.axisControlBus.speed_ref;
//   axis2.axisControlBus.speed_ref = axis2.initializeFlange.w_start;
//   axis2.axisControlBus.speed_ref = axis2.motor.axisControlBus.speed_ref;
//   axis2.axisControlBus.speed = axis2.controller.axisControlBus.speed;
//   axis2.axisControlBus.speed = axis2.motor.axisControlBus.speed;
//   axis2.axisControlBus.speed = axis2.speedSensor.w;
//   axis2.axisControlBus.motorAngle = axis2.controller.axisControlBus.motorAngle;
//   axis2.axisControlBus.motorAngle = axis2.motor.axisControlBus.motorAngle;
//   axis2.axisControlBus.current = axis2.controller.axisControlBus.current;
//   axis2.axisControlBus.current = axis2.motor.axisControlBus.current;
//   axis2.axisControlBus.current_ref = axis2.controller.axisControlBus.current_ref;
//   axis2.axisControlBus.current_ref = axis2.motor.axisControlBus.current_ref;
//   axis2.axisControlBus.motorSpeed = axis2.controller.axisControlBus.motorSpeed;
//   axis2.axisControlBus.motorSpeed = axis2.motor.axisControlBus.motorSpeed;
//   axis2.accSensor.a = axis2.axisControlBus.acceleration;
//   axis2.accSensor.a = axis2.controller.axisControlBus.acceleration;
//   axis2.accSensor.a = axis2.motor.axisControlBus.acceleration;
//   axis2.angleSensor.phi = axis2.axisControlBus.angle;
//   axis2.angleSensor.phi = axis2.controller.axisControlBus.angle;
//   axis2.angleSensor.phi = axis2.motor.axisControlBus.angle;
//   axis2.axisControlBus.angle_ref = axis2.controller.axisControlBus.angle_ref;
//   axis2.axisControlBus.angle_ref = axis2.initializeFlange.phi_start;
//   axis2.axisControlBus.angle_ref = axis2.motor.axisControlBus.angle_ref;
//   axis2.const.y = axis2.initializeFlange.a_start;
//   axis2.initializeFlange.flange.tau + (axis2.gear.flange_b.tau + ((-axis2.flange.tau) + (axis2.angleSensor.flange.tau + (axis2.speedSensor.flange.tau + axis2.accSensor.flange.tau)))) = 0.0;
//   axis2.accSensor.flange.phi = axis2.angleSensor.flange.phi;
//   axis2.accSensor.flange.phi = axis2.flange.phi;
//   axis2.accSensor.flange.phi = axis2.gear.flange_b.phi;
//   axis2.accSensor.flange.phi = axis2.initializeFlange.flange.phi;
//   axis2.accSensor.flange.phi = axis2.speedSensor.flange.phi;
//   axis2.motor.flange_motor.tau + axis2.gear.flange_a.tau = 0.0;
//   axis2.gear.flange_a.phi = axis2.motor.flange_motor.phi;
//   axis2.initializeFlange.set_flange_tau.flange.tau + (axis2.initializeFlange.set_a_start.flange.tau + (axis2.initializeFlange.set_w_start.flange.tau + (axis2.initializeFlange.set_phi_start.flange.tau + (-axis2.initializeFlange.flange.tau)))) = 0.0;
//   axis2.initializeFlange.flange.phi = axis2.initializeFlange.set_a_start.flange.phi;
//   axis2.initializeFlange.flange.phi = axis2.initializeFlange.set_flange_tau.flange.phi;
//   axis2.initializeFlange.flange.phi = axis2.initializeFlange.set_phi_start.flange.phi;
//   axis2.initializeFlange.flange.phi = axis2.initializeFlange.set_w_start.flange.phi;
//   axis2.initializeFlange.a_start = axis2.initializeFlange.set_a_start.a_start;
//   axis2.initializeFlange.set_w_start.w_start = axis2.initializeFlange.w_start;
//   axis2.initializeFlange.phi_start = axis2.initializeFlange.set_phi_start.phi_start;
//   axis2.controller.PI.y = axis2.controller.axisControlBus.current_ref;
//   axis2.controller.add3.u3 = axis2.controller.axisControlBus.motorSpeed;
//   axis2.controller.axisControlBus.motorAngle = axis2.controller.feedback1.u2;
//   axis2.controller.axisControlBus.angle_ref = axis2.controller.gain1.u;
//   axis2.controller.axisControlBus.speed_ref = axis2.controller.gain2.u;
//   axis2.controller.PI.u = axis2.controller.add3.y;
//   axis2.controller.add3.u1 = axis2.controller.gain2.y;
//   axis2.controller.P.y = axis2.controller.add3.u2;
//   axis2.controller.P.u = axis2.controller.feedback1.y;
//   axis2.controller.feedback1.u1 = axis2.controller.gain1.y;
//   axis2.motor.emf.flange.tau + (axis2.motor.phi.flange.tau + (axis2.motor.speed.flange.tau + axis2.motor.Jmotor.flange_a.tau)) = 0.0;
//   axis2.motor.Jmotor.flange_a.phi = axis2.motor.emf.flange.phi;
//   axis2.motor.Jmotor.flange_a.phi = axis2.motor.phi.flange.phi;
//   axis2.motor.Jmotor.flange_a.phi = axis2.motor.speed.flange.phi;
//   axis2.motor.Vs.v = axis2.motor.convert2.y;
//   axis2.motor.axisControlBus.current_ref = axis2.motor.convert2.u;
//   axis2.motor.convert1.y = axis2.motor.hall2.v;
//   axis2.motor.axisControlBus.current = axis2.motor.convert1.u;
//   axis2.motor.axisControlBus.current = axis2.motor.hall1.i;
//   axis2.motor.axisControlBus.motorSpeed = axis2.motor.speed.w;
//   axis2.motor.axisControlBus.motorAngle = axis2.motor.phi.phi;
//   axis2.motor.Jmotor.flange_b.tau + (-axis2.motor.flange_motor.tau) = 0.0;
//   axis2.motor.Jmotor.flange_b.phi = axis2.motor.flange_motor.phi;
//   axis2.motor.Rd4.n.i + (axis2.motor.g3.p.i + (axis2.motor.OpI.p1.i + (axis2.motor.OpI.n2.i + (axis2.motor.power.n2.i + axis2.motor.diff.n2.i)))) = 0.0;
//   axis2.motor.OpI.n2.v = axis2.motor.OpI.p1.v;
//   axis2.motor.OpI.n2.v = axis2.motor.Rd4.n.v;
//   axis2.motor.OpI.n2.v = axis2.motor.diff.n2.v;
//   axis2.motor.OpI.n2.v = axis2.motor.g3.p.v;
//   axis2.motor.OpI.n2.v = axis2.motor.power.n2.v;
//   axis2.motor.hall1.n.i + axis2.motor.g4.p.i = 0.0;
//   axis2.motor.g4.p.v = axis2.motor.hall1.n.v;
//   axis2.motor.emf.n.i + axis2.motor.hall1.p.i = 0.0;
//   axis2.motor.emf.n.v = axis2.motor.hall1.p.v;
//   axis2.motor.g5.p.i + axis2.motor.Rp2.n.i = 0.0;
//   axis2.motor.Rp2.n.v = axis2.motor.g5.p.v;
//   axis2.motor.g2.p.i + axis2.motor.hall2.n.i = 0.0;
//   axis2.motor.g2.p.v = axis2.motor.hall2.n.v;
//   axis2.motor.Vs.n.i + axis2.motor.g1.p.i = 0.0;
//   axis2.motor.Vs.n.v = axis2.motor.g1.p.v;
//   axis2.motor.Rd3.n.i + (axis2.motor.diff.p1.i + axis2.motor.Rd4.p.i) = 0.0;
//   axis2.motor.Rd3.n.v = axis2.motor.Rd4.p.v;
//   axis2.motor.Rd3.n.v = axis2.motor.diff.p1.v;
//   axis2.motor.Rd3.p.i + axis2.motor.hall2.p.i = 0.0;
//   axis2.motor.Rd3.p.v = axis2.motor.hall2.p.v;
//   axis2.motor.power.p2.i + (axis2.motor.Rp1.n.i + axis2.motor.Ra.p.i) = 0.0;
//   axis2.motor.Ra.p.v = axis2.motor.Rp1.n.v;
//   axis2.motor.Ra.p.v = axis2.motor.power.p2.v;
//   axis2.motor.power.n1.i + (axis2.motor.Rp1.p.i + axis2.motor.Rp2.p.i) = 0.0;
//   axis2.motor.Rp1.p.v = axis2.motor.Rp2.p.v;
//   axis2.motor.Rp1.p.v = axis2.motor.power.n1.v;
//   axis2.motor.Ri.n.i + (axis2.motor.OpI.n1.i + axis2.motor.C.p.i) = 0.0;
//   axis2.motor.C.p.v = axis2.motor.OpI.n1.v;
//   axis2.motor.C.p.v = axis2.motor.Ri.n.v;
//   axis2.motor.Rd1.n.i + (axis2.motor.diff.p2.i + axis2.motor.Ri.p.i) = 0.0;
//   axis2.motor.Rd1.n.v = axis2.motor.Ri.p.v;
//   axis2.motor.Rd1.n.v = axis2.motor.diff.p2.v;
//   axis2.motor.Rd2.n.i + (axis2.motor.diff.n1.i + axis2.motor.Rd1.p.i) = 0.0;
//   axis2.motor.Rd1.p.v = axis2.motor.Rd2.n.v;
//   axis2.motor.Rd1.p.v = axis2.motor.diff.n1.v;
//   axis2.motor.Vs.p.i + axis2.motor.Rd2.p.i = 0.0;
//   axis2.motor.Rd2.p.v = axis2.motor.Vs.p.v;
//   axis2.motor.C.n.i + (axis2.motor.OpI.p2.i + axis2.motor.power.p1.i) = 0.0;
//   axis2.motor.C.n.v = axis2.motor.OpI.p2.v;
//   axis2.motor.C.n.v = axis2.motor.power.p1.v;
//   axis2.motor.Ra.n.i + axis2.motor.La.p.i = 0.0;
//   axis2.motor.La.p.v = axis2.motor.Ra.n.v;
//   axis2.motor.La.n.i + axis2.motor.emf.p.i = 0.0;
//   axis2.motor.La.n.v = axis2.motor.emf.p.v;
//   axis2.motor.emf.internalSupport.flange.tau + axis2.motor.emf.fixed.flange.tau = 0.0;
//   axis2.motor.emf.fixed.flange.phi = axis2.motor.emf.internalSupport.flange.phi;
//   axis2.gear.bearingFriction.flange_a.tau + (-axis2.gear.flange_a.tau) = 0.0;
//   axis2.gear.bearingFriction.flange_a.phi = axis2.gear.flange_a.phi;
//   axis2.gear.gear.flange_b.tau + (-axis2.gear.flange_b.tau) = 0.0;
//   axis2.gear.flange_b.phi = axis2.gear.gear.flange_b.phi;
//   axis2.gear.bearingFriction.flange_b.tau + axis2.gear.spring.flange_a.tau = 0.0;
//   axis2.gear.bearingFriction.flange_b.phi = axis2.gear.spring.flange_a.phi;
//   axis2.gear.spring.flange_b.tau + axis2.gear.gear.flange_a.tau = 0.0;
//   axis2.gear.gear.flange_a.phi = axis2.gear.spring.flange_b.phi;
//   axis1.axisControlBus.speed_ref = axis1.controller.axisControlBus.speed_ref;
//   axis1.axisControlBus.speed_ref = axis1.initializeFlange.w_start;
//   axis1.axisControlBus.speed_ref = axis1.motor.axisControlBus.speed_ref;
//   axis1.axisControlBus.speed = axis1.controller.axisControlBus.speed;
//   axis1.axisControlBus.speed = axis1.motor.axisControlBus.speed;
//   axis1.axisControlBus.speed = axis1.speedSensor.w;
//   axis1.axisControlBus.motorAngle = axis1.controller.axisControlBus.motorAngle;
//   axis1.axisControlBus.motorAngle = axis1.motor.axisControlBus.motorAngle;
//   axis1.axisControlBus.current = axis1.controller.axisControlBus.current;
//   axis1.axisControlBus.current = axis1.motor.axisControlBus.current;
//   axis1.axisControlBus.current_ref = axis1.controller.axisControlBus.current_ref;
//   axis1.axisControlBus.current_ref = axis1.motor.axisControlBus.current_ref;
//   axis1.axisControlBus.motorSpeed = axis1.controller.axisControlBus.motorSpeed;
//   axis1.axisControlBus.motorSpeed = axis1.motor.axisControlBus.motorSpeed;
//   axis1.accSensor.a = axis1.axisControlBus.acceleration;
//   axis1.accSensor.a = axis1.controller.axisControlBus.acceleration;
//   axis1.accSensor.a = axis1.motor.axisControlBus.acceleration;
//   axis1.angleSensor.phi = axis1.axisControlBus.angle;
//   axis1.angleSensor.phi = axis1.controller.axisControlBus.angle;
//   axis1.angleSensor.phi = axis1.motor.axisControlBus.angle;
//   axis1.axisControlBus.angle_ref = axis1.controller.axisControlBus.angle_ref;
//   axis1.axisControlBus.angle_ref = axis1.initializeFlange.phi_start;
//   axis1.axisControlBus.angle_ref = axis1.motor.axisControlBus.angle_ref;
//   axis1.const.y = axis1.initializeFlange.a_start;
//   axis1.initializeFlange.flange.tau + (axis1.gear.flange_b.tau + ((-axis1.flange.tau) + (axis1.angleSensor.flange.tau + (axis1.speedSensor.flange.tau + axis1.accSensor.flange.tau)))) = 0.0;
//   axis1.accSensor.flange.phi = axis1.angleSensor.flange.phi;
//   axis1.accSensor.flange.phi = axis1.flange.phi;
//   axis1.accSensor.flange.phi = axis1.gear.flange_b.phi;
//   axis1.accSensor.flange.phi = axis1.initializeFlange.flange.phi;
//   axis1.accSensor.flange.phi = axis1.speedSensor.flange.phi;
//   axis1.motor.flange_motor.tau + axis1.gear.flange_a.tau = 0.0;
//   axis1.gear.flange_a.phi = axis1.motor.flange_motor.phi;
//   axis1.initializeFlange.set_flange_tau.flange.tau + (axis1.initializeFlange.set_a_start.flange.tau + (axis1.initializeFlange.set_w_start.flange.tau + (axis1.initializeFlange.set_phi_start.flange.tau + (-axis1.initializeFlange.flange.tau)))) = 0.0;
//   axis1.initializeFlange.flange.phi = axis1.initializeFlange.set_a_start.flange.phi;
//   axis1.initializeFlange.flange.phi = axis1.initializeFlange.set_flange_tau.flange.phi;
//   axis1.initializeFlange.flange.phi = axis1.initializeFlange.set_phi_start.flange.phi;
//   axis1.initializeFlange.flange.phi = axis1.initializeFlange.set_w_start.flange.phi;
//   axis1.initializeFlange.a_start = axis1.initializeFlange.set_a_start.a_start;
//   axis1.initializeFlange.set_w_start.w_start = axis1.initializeFlange.w_start;
//   axis1.initializeFlange.phi_start = axis1.initializeFlange.set_phi_start.phi_start;
//   axis1.controller.PI.y = axis1.controller.axisControlBus.current_ref;
//   axis1.controller.add3.u3 = axis1.controller.axisControlBus.motorSpeed;
//   axis1.controller.axisControlBus.motorAngle = axis1.controller.feedback1.u2;
//   axis1.controller.axisControlBus.angle_ref = axis1.controller.gain1.u;
//   axis1.controller.axisControlBus.speed_ref = axis1.controller.gain2.u;
//   axis1.controller.PI.u = axis1.controller.add3.y;
//   axis1.controller.add3.u1 = axis1.controller.gain2.y;
//   axis1.controller.P.y = axis1.controller.add3.u2;
//   axis1.controller.P.u = axis1.controller.feedback1.y;
//   axis1.controller.feedback1.u1 = axis1.controller.gain1.y;
//   axis1.motor.emf.flange.tau + (axis1.motor.phi.flange.tau + (axis1.motor.speed.flange.tau + axis1.motor.Jmotor.flange_a.tau)) = 0.0;
//   axis1.motor.Jmotor.flange_a.phi = axis1.motor.emf.flange.phi;
//   axis1.motor.Jmotor.flange_a.phi = axis1.motor.phi.flange.phi;
//   axis1.motor.Jmotor.flange_a.phi = axis1.motor.speed.flange.phi;
//   axis1.motor.Vs.v = axis1.motor.convert2.y;
//   axis1.motor.axisControlBus.current_ref = axis1.motor.convert2.u;
//   axis1.motor.convert1.y = axis1.motor.hall2.v;
//   axis1.motor.axisControlBus.current = axis1.motor.convert1.u;
//   axis1.motor.axisControlBus.current = axis1.motor.hall1.i;
//   axis1.motor.axisControlBus.motorSpeed = axis1.motor.speed.w;
//   axis1.motor.axisControlBus.motorAngle = axis1.motor.phi.phi;
//   axis1.motor.Jmotor.flange_b.tau + (-axis1.motor.flange_motor.tau) = 0.0;
//   axis1.motor.Jmotor.flange_b.phi = axis1.motor.flange_motor.phi;
//   axis1.motor.Rd4.n.i + (axis1.motor.g3.p.i + (axis1.motor.OpI.p1.i + (axis1.motor.OpI.n2.i + (axis1.motor.power.n2.i + axis1.motor.diff.n2.i)))) = 0.0;
//   axis1.motor.OpI.n2.v = axis1.motor.OpI.p1.v;
//   axis1.motor.OpI.n2.v = axis1.motor.Rd4.n.v;
//   axis1.motor.OpI.n2.v = axis1.motor.diff.n2.v;
//   axis1.motor.OpI.n2.v = axis1.motor.g3.p.v;
//   axis1.motor.OpI.n2.v = axis1.motor.power.n2.v;
//   axis1.motor.hall1.n.i + axis1.motor.g4.p.i = 0.0;
//   axis1.motor.g4.p.v = axis1.motor.hall1.n.v;
//   axis1.motor.emf.n.i + axis1.motor.hall1.p.i = 0.0;
//   axis1.motor.emf.n.v = axis1.motor.hall1.p.v;
//   axis1.motor.g5.p.i + axis1.motor.Rp2.n.i = 0.0;
//   axis1.motor.Rp2.n.v = axis1.motor.g5.p.v;
//   axis1.motor.g2.p.i + axis1.motor.hall2.n.i = 0.0;
//   axis1.motor.g2.p.v = axis1.motor.hall2.n.v;
//   axis1.motor.Vs.n.i + axis1.motor.g1.p.i = 0.0;
//   axis1.motor.Vs.n.v = axis1.motor.g1.p.v;
//   axis1.motor.Rd3.n.i + (axis1.motor.diff.p1.i + axis1.motor.Rd4.p.i) = 0.0;
//   axis1.motor.Rd3.n.v = axis1.motor.Rd4.p.v;
//   axis1.motor.Rd3.n.v = axis1.motor.diff.p1.v;
//   axis1.motor.Rd3.p.i + axis1.motor.hall2.p.i = 0.0;
//   axis1.motor.Rd3.p.v = axis1.motor.hall2.p.v;
//   axis1.motor.power.p2.i + (axis1.motor.Rp1.n.i + axis1.motor.Ra.p.i) = 0.0;
//   axis1.motor.Ra.p.v = axis1.motor.Rp1.n.v;
//   axis1.motor.Ra.p.v = axis1.motor.power.p2.v;
//   axis1.motor.power.n1.i + (axis1.motor.Rp1.p.i + axis1.motor.Rp2.p.i) = 0.0;
//   axis1.motor.Rp1.p.v = axis1.motor.Rp2.p.v;
//   axis1.motor.Rp1.p.v = axis1.motor.power.n1.v;
//   axis1.motor.Ri.n.i + (axis1.motor.OpI.n1.i + axis1.motor.C.p.i) = 0.0;
//   axis1.motor.C.p.v = axis1.motor.OpI.n1.v;
//   axis1.motor.C.p.v = axis1.motor.Ri.n.v;
//   axis1.motor.Rd1.n.i + (axis1.motor.diff.p2.i + axis1.motor.Ri.p.i) = 0.0;
//   axis1.motor.Rd1.n.v = axis1.motor.Ri.p.v;
//   axis1.motor.Rd1.n.v = axis1.motor.diff.p2.v;
//   axis1.motor.Rd2.n.i + (axis1.motor.diff.n1.i + axis1.motor.Rd1.p.i) = 0.0;
//   axis1.motor.Rd1.p.v = axis1.motor.Rd2.n.v;
//   axis1.motor.Rd1.p.v = axis1.motor.diff.n1.v;
//   axis1.motor.Vs.p.i + axis1.motor.Rd2.p.i = 0.0;
//   axis1.motor.Rd2.p.v = axis1.motor.Vs.p.v;
//   axis1.motor.C.n.i + (axis1.motor.OpI.p2.i + axis1.motor.power.p1.i) = 0.0;
//   axis1.motor.C.n.v = axis1.motor.OpI.p2.v;
//   axis1.motor.C.n.v = axis1.motor.power.p1.v;
//   axis1.motor.Ra.n.i + axis1.motor.La.p.i = 0.0;
//   axis1.motor.La.p.v = axis1.motor.Ra.n.v;
//   axis1.motor.La.n.i + axis1.motor.emf.p.i = 0.0;
//   axis1.motor.La.n.v = axis1.motor.emf.p.v;
//   axis1.motor.emf.internalSupport.flange.tau + axis1.motor.emf.fixed.flange.tau = 0.0;
//   axis1.motor.emf.fixed.flange.phi = axis1.motor.emf.internalSupport.flange.phi;
//   axis1.gear.bearingFriction.flange_a.tau + (-axis1.gear.flange_a.tau) = 0.0;
//   axis1.gear.bearingFriction.flange_a.phi = axis1.gear.flange_a.phi;
//   axis1.gear.gear.flange_b.tau + (-axis1.gear.flange_b.tau) = 0.0;
//   axis1.gear.flange_b.phi = axis1.gear.gear.flange_b.phi;
//   axis1.gear.bearingFriction.flange_b.tau + axis1.gear.spring.flange_a.tau = 0.0;
//   axis1.gear.bearingFriction.flange_b.phi = axis1.gear.spring.flange_a.phi;
//   axis1.gear.spring.flange_b.tau + axis1.gear.gear.flange_a.tau = 0.0;
//   axis1.gear.gear.flange_a.phi = axis1.gear.spring.flange_b.phi;
//   pathPlanning.controlBus.axisControlBus6.speed_ref = pathPlanning.pathToAxis6.axisControlBus.speed_ref;
//   pathPlanning.controlBus.axisControlBus6.angle_ref = pathPlanning.pathToAxis6.axisControlBus.angle_ref;
//   pathPlanning.controlBus.axisControlBus6.acceleration_ref = pathPlanning.pathToAxis6.axisControlBus.acceleration_ref;
//   pathPlanning.controlBus.axisControlBus6.motion_ref = pathPlanning.pathToAxis6.axisControlBus.motion_ref;
//   pathPlanning.controlBus.axisControlBus5.speed_ref = pathPlanning.pathToAxis5.axisControlBus.speed_ref;
//   pathPlanning.controlBus.axisControlBus5.angle_ref = pathPlanning.pathToAxis5.axisControlBus.angle_ref;
//   pathPlanning.controlBus.axisControlBus5.acceleration_ref = pathPlanning.pathToAxis5.axisControlBus.acceleration_ref;
//   pathPlanning.controlBus.axisControlBus5.motion_ref = pathPlanning.pathToAxis5.axisControlBus.motion_ref;
//   pathPlanning.controlBus.axisControlBus4.speed_ref = pathPlanning.pathToAxis4.axisControlBus.speed_ref;
//   pathPlanning.controlBus.axisControlBus4.angle_ref = pathPlanning.pathToAxis4.axisControlBus.angle_ref;
//   pathPlanning.controlBus.axisControlBus4.acceleration_ref = pathPlanning.pathToAxis4.axisControlBus.acceleration_ref;
//   pathPlanning.controlBus.axisControlBus4.motion_ref = pathPlanning.pathToAxis4.axisControlBus.motion_ref;
//   pathPlanning.controlBus.axisControlBus3.speed_ref = pathPlanning.pathToAxis3.axisControlBus.speed_ref;
//   pathPlanning.controlBus.axisControlBus3.angle_ref = pathPlanning.pathToAxis3.axisControlBus.angle_ref;
//   pathPlanning.controlBus.axisControlBus3.acceleration_ref = pathPlanning.pathToAxis3.axisControlBus.acceleration_ref;
//   pathPlanning.controlBus.axisControlBus3.motion_ref = pathPlanning.pathToAxis3.axisControlBus.motion_ref;
//   pathPlanning.controlBus.axisControlBus2.speed_ref = pathPlanning.pathToAxis2.axisControlBus.speed_ref;
//   pathPlanning.controlBus.axisControlBus2.angle_ref = pathPlanning.pathToAxis2.axisControlBus.angle_ref;
//   pathPlanning.controlBus.axisControlBus2.acceleration_ref = pathPlanning.pathToAxis2.axisControlBus.acceleration_ref;
//   pathPlanning.controlBus.axisControlBus2.motion_ref = pathPlanning.pathToAxis2.axisControlBus.motion_ref;
//   pathPlanning.controlBus.axisControlBus1.speed_ref = pathPlanning.pathToAxis1.axisControlBus.speed_ref;
//   pathPlanning.controlBus.axisControlBus1.angle_ref = pathPlanning.pathToAxis1.axisControlBus.angle_ref;
//   pathPlanning.controlBus.axisControlBus1.acceleration_ref = pathPlanning.pathToAxis1.axisControlBus.acceleration_ref;
//   pathPlanning.controlBus.axisControlBus1.motion_ref = pathPlanning.pathToAxis1.axisControlBus.motion_ref;
//   pathPlanning.path.moving[1] = pathPlanning.pathToAxis1.moving[1];
//   pathPlanning.path.moving[1] = pathPlanning.pathToAxis2.moving[1];
//   pathPlanning.path.moving[1] = pathPlanning.pathToAxis3.moving[1];
//   pathPlanning.path.moving[1] = pathPlanning.pathToAxis4.moving[1];
//   pathPlanning.path.moving[1] = pathPlanning.pathToAxis5.moving[1];
//   pathPlanning.path.moving[1] = pathPlanning.pathToAxis6.moving[1];
//   pathPlanning.path.moving[2] = pathPlanning.pathToAxis1.moving[2];
//   pathPlanning.path.moving[2] = pathPlanning.pathToAxis2.moving[2];
//   pathPlanning.path.moving[2] = pathPlanning.pathToAxis3.moving[2];
//   pathPlanning.path.moving[2] = pathPlanning.pathToAxis4.moving[2];
//   pathPlanning.path.moving[2] = pathPlanning.pathToAxis5.moving[2];
//   pathPlanning.path.moving[2] = pathPlanning.pathToAxis6.moving[2];
//   pathPlanning.path.moving[3] = pathPlanning.pathToAxis1.moving[3];
//   pathPlanning.path.moving[3] = pathPlanning.pathToAxis2.moving[3];
//   pathPlanning.path.moving[3] = pathPlanning.pathToAxis3.moving[3];
//   pathPlanning.path.moving[3] = pathPlanning.pathToAxis4.moving[3];
//   pathPlanning.path.moving[3] = pathPlanning.pathToAxis5.moving[3];
//   pathPlanning.path.moving[3] = pathPlanning.pathToAxis6.moving[3];
//   pathPlanning.path.moving[4] = pathPlanning.pathToAxis1.moving[4];
//   pathPlanning.path.moving[4] = pathPlanning.pathToAxis2.moving[4];
//   pathPlanning.path.moving[4] = pathPlanning.pathToAxis3.moving[4];
//   pathPlanning.path.moving[4] = pathPlanning.pathToAxis4.moving[4];
//   pathPlanning.path.moving[4] = pathPlanning.pathToAxis5.moving[4];
//   pathPlanning.path.moving[4] = pathPlanning.pathToAxis6.moving[4];
//   pathPlanning.path.moving[5] = pathPlanning.pathToAxis1.moving[5];
//   pathPlanning.path.moving[5] = pathPlanning.pathToAxis2.moving[5];
//   pathPlanning.path.moving[5] = pathPlanning.pathToAxis3.moving[5];
//   pathPlanning.path.moving[5] = pathPlanning.pathToAxis4.moving[5];
//   pathPlanning.path.moving[5] = pathPlanning.pathToAxis5.moving[5];
//   pathPlanning.path.moving[5] = pathPlanning.pathToAxis6.moving[5];
//   pathPlanning.path.moving[6] = pathPlanning.pathToAxis1.moving[6];
//   pathPlanning.path.moving[6] = pathPlanning.pathToAxis2.moving[6];
//   pathPlanning.path.moving[6] = pathPlanning.pathToAxis3.moving[6];
//   pathPlanning.path.moving[6] = pathPlanning.pathToAxis4.moving[6];
//   pathPlanning.path.moving[6] = pathPlanning.pathToAxis5.moving[6];
//   pathPlanning.path.moving[6] = pathPlanning.pathToAxis6.moving[6];
//   pathPlanning.path.qdd[1] = pathPlanning.pathToAxis1.qdd[1];
//   pathPlanning.path.qdd[1] = pathPlanning.pathToAxis2.qdd[1];
//   pathPlanning.path.qdd[1] = pathPlanning.pathToAxis3.qdd[1];
//   pathPlanning.path.qdd[1] = pathPlanning.pathToAxis4.qdd[1];
//   pathPlanning.path.qdd[1] = pathPlanning.pathToAxis5.qdd[1];
//   pathPlanning.path.qdd[1] = pathPlanning.pathToAxis6.qdd[1];
//   pathPlanning.path.qdd[2] = pathPlanning.pathToAxis1.qdd[2];
//   pathPlanning.path.qdd[2] = pathPlanning.pathToAxis2.qdd[2];
//   pathPlanning.path.qdd[2] = pathPlanning.pathToAxis3.qdd[2];
//   pathPlanning.path.qdd[2] = pathPlanning.pathToAxis4.qdd[2];
//   pathPlanning.path.qdd[2] = pathPlanning.pathToAxis5.qdd[2];
//   pathPlanning.path.qdd[2] = pathPlanning.pathToAxis6.qdd[2];
//   pathPlanning.path.qdd[3] = pathPlanning.pathToAxis1.qdd[3];
//   pathPlanning.path.qdd[3] = pathPlanning.pathToAxis2.qdd[3];
//   pathPlanning.path.qdd[3] = pathPlanning.pathToAxis3.qdd[3];
//   pathPlanning.path.qdd[3] = pathPlanning.pathToAxis4.qdd[3];
//   pathPlanning.path.qdd[3] = pathPlanning.pathToAxis5.qdd[3];
//   pathPlanning.path.qdd[3] = pathPlanning.pathToAxis6.qdd[3];
//   pathPlanning.path.qdd[4] = pathPlanning.pathToAxis1.qdd[4];
//   pathPlanning.path.qdd[4] = pathPlanning.pathToAxis2.qdd[4];
//   pathPlanning.path.qdd[4] = pathPlanning.pathToAxis3.qdd[4];
//   pathPlanning.path.qdd[4] = pathPlanning.pathToAxis4.qdd[4];
//   pathPlanning.path.qdd[4] = pathPlanning.pathToAxis5.qdd[4];
//   pathPlanning.path.qdd[4] = pathPlanning.pathToAxis6.qdd[4];
//   pathPlanning.path.qdd[5] = pathPlanning.pathToAxis1.qdd[5];
//   pathPlanning.path.qdd[5] = pathPlanning.pathToAxis2.qdd[5];
//   pathPlanning.path.qdd[5] = pathPlanning.pathToAxis3.qdd[5];
//   pathPlanning.path.qdd[5] = pathPlanning.pathToAxis4.qdd[5];
//   pathPlanning.path.qdd[5] = pathPlanning.pathToAxis5.qdd[5];
//   pathPlanning.path.qdd[5] = pathPlanning.pathToAxis6.qdd[5];
//   pathPlanning.path.qdd[6] = pathPlanning.pathToAxis1.qdd[6];
//   pathPlanning.path.qdd[6] = pathPlanning.pathToAxis2.qdd[6];
//   pathPlanning.path.qdd[6] = pathPlanning.pathToAxis3.qdd[6];
//   pathPlanning.path.qdd[6] = pathPlanning.pathToAxis4.qdd[6];
//   pathPlanning.path.qdd[6] = pathPlanning.pathToAxis5.qdd[6];
//   pathPlanning.path.qdd[6] = pathPlanning.pathToAxis6.qdd[6];
//   pathPlanning.path.qd[1] = pathPlanning.pathToAxis1.qd[1];
//   pathPlanning.path.qd[1] = pathPlanning.pathToAxis2.qd[1];
//   pathPlanning.path.qd[1] = pathPlanning.pathToAxis3.qd[1];
//   pathPlanning.path.qd[1] = pathPlanning.pathToAxis4.qd[1];
//   pathPlanning.path.qd[1] = pathPlanning.pathToAxis5.qd[1];
//   pathPlanning.path.qd[1] = pathPlanning.pathToAxis6.qd[1];
//   pathPlanning.path.qd[2] = pathPlanning.pathToAxis1.qd[2];
//   pathPlanning.path.qd[2] = pathPlanning.pathToAxis2.qd[2];
//   pathPlanning.path.qd[2] = pathPlanning.pathToAxis3.qd[2];
//   pathPlanning.path.qd[2] = pathPlanning.pathToAxis4.qd[2];
//   pathPlanning.path.qd[2] = pathPlanning.pathToAxis5.qd[2];
//   pathPlanning.path.qd[2] = pathPlanning.pathToAxis6.qd[2];
//   pathPlanning.path.qd[3] = pathPlanning.pathToAxis1.qd[3];
//   pathPlanning.path.qd[3] = pathPlanning.pathToAxis2.qd[3];
//   pathPlanning.path.qd[3] = pathPlanning.pathToAxis3.qd[3];
//   pathPlanning.path.qd[3] = pathPlanning.pathToAxis4.qd[3];
//   pathPlanning.path.qd[3] = pathPlanning.pathToAxis5.qd[3];
//   pathPlanning.path.qd[3] = pathPlanning.pathToAxis6.qd[3];
//   pathPlanning.path.qd[4] = pathPlanning.pathToAxis1.qd[4];
//   pathPlanning.path.qd[4] = pathPlanning.pathToAxis2.qd[4];
//   pathPlanning.path.qd[4] = pathPlanning.pathToAxis3.qd[4];
//   pathPlanning.path.qd[4] = pathPlanning.pathToAxis4.qd[4];
//   pathPlanning.path.qd[4] = pathPlanning.pathToAxis5.qd[4];
//   pathPlanning.path.qd[4] = pathPlanning.pathToAxis6.qd[4];
//   pathPlanning.path.qd[5] = pathPlanning.pathToAxis1.qd[5];
//   pathPlanning.path.qd[5] = pathPlanning.pathToAxis2.qd[5];
//   pathPlanning.path.qd[5] = pathPlanning.pathToAxis3.qd[5];
//   pathPlanning.path.qd[5] = pathPlanning.pathToAxis4.qd[5];
//   pathPlanning.path.qd[5] = pathPlanning.pathToAxis5.qd[5];
//   pathPlanning.path.qd[5] = pathPlanning.pathToAxis6.qd[5];
//   pathPlanning.path.qd[6] = pathPlanning.pathToAxis1.qd[6];
//   pathPlanning.path.qd[6] = pathPlanning.pathToAxis2.qd[6];
//   pathPlanning.path.qd[6] = pathPlanning.pathToAxis3.qd[6];
//   pathPlanning.path.qd[6] = pathPlanning.pathToAxis4.qd[6];
//   pathPlanning.path.qd[6] = pathPlanning.pathToAxis5.qd[6];
//   pathPlanning.path.qd[6] = pathPlanning.pathToAxis6.qd[6];
//   pathPlanning.path.q[1] = pathPlanning.pathToAxis1.q[1];
//   pathPlanning.path.q[1] = pathPlanning.pathToAxis2.q[1];
//   pathPlanning.path.q[1] = pathPlanning.pathToAxis3.q[1];
//   pathPlanning.path.q[1] = pathPlanning.pathToAxis4.q[1];
//   pathPlanning.path.q[1] = pathPlanning.pathToAxis5.q[1];
//   pathPlanning.path.q[1] = pathPlanning.pathToAxis6.q[1];
//   pathPlanning.path.q[2] = pathPlanning.pathToAxis1.q[2];
//   pathPlanning.path.q[2] = pathPlanning.pathToAxis2.q[2];
//   pathPlanning.path.q[2] = pathPlanning.pathToAxis3.q[2];
//   pathPlanning.path.q[2] = pathPlanning.pathToAxis4.q[2];
//   pathPlanning.path.q[2] = pathPlanning.pathToAxis5.q[2];
//   pathPlanning.path.q[2] = pathPlanning.pathToAxis6.q[2];
//   pathPlanning.path.q[3] = pathPlanning.pathToAxis1.q[3];
//   pathPlanning.path.q[3] = pathPlanning.pathToAxis2.q[3];
//   pathPlanning.path.q[3] = pathPlanning.pathToAxis3.q[3];
//   pathPlanning.path.q[3] = pathPlanning.pathToAxis4.q[3];
//   pathPlanning.path.q[3] = pathPlanning.pathToAxis5.q[3];
//   pathPlanning.path.q[3] = pathPlanning.pathToAxis6.q[3];
//   pathPlanning.path.q[4] = pathPlanning.pathToAxis1.q[4];
//   pathPlanning.path.q[4] = pathPlanning.pathToAxis2.q[4];
//   pathPlanning.path.q[4] = pathPlanning.pathToAxis3.q[4];
//   pathPlanning.path.q[4] = pathPlanning.pathToAxis4.q[4];
//   pathPlanning.path.q[4] = pathPlanning.pathToAxis5.q[4];
//   pathPlanning.path.q[4] = pathPlanning.pathToAxis6.q[4];
//   pathPlanning.path.q[5] = pathPlanning.pathToAxis1.q[5];
//   pathPlanning.path.q[5] = pathPlanning.pathToAxis2.q[5];
//   pathPlanning.path.q[5] = pathPlanning.pathToAxis3.q[5];
//   pathPlanning.path.q[5] = pathPlanning.pathToAxis4.q[5];
//   pathPlanning.path.q[5] = pathPlanning.pathToAxis5.q[5];
//   pathPlanning.path.q[5] = pathPlanning.pathToAxis6.q[5];
//   pathPlanning.path.q[6] = pathPlanning.pathToAxis1.q[6];
//   pathPlanning.path.q[6] = pathPlanning.pathToAxis2.q[6];
//   pathPlanning.path.q[6] = pathPlanning.pathToAxis3.q[6];
//   pathPlanning.path.q[6] = pathPlanning.pathToAxis4.q[6];
//   pathPlanning.path.q[6] = pathPlanning.pathToAxis5.q[6];
//   pathPlanning.path.q[6] = pathPlanning.pathToAxis6.q[6];
//   pathPlanning.pathToAxis6.axisControlBus.angle_ref = pathPlanning.pathToAxis6.q_axisUsed.y;
//   pathPlanning.pathToAxis6.axisControlBus.speed_ref = pathPlanning.pathToAxis6.qd_axisUsed.y;
//   pathPlanning.pathToAxis6.axisControlBus.acceleration_ref = pathPlanning.pathToAxis6.qdd_axisUsed.y;
//   pathPlanning.pathToAxis6.axisControlBus.motion_ref = pathPlanning.pathToAxis6.motion_ref_axisUsed.y;
//   pathPlanning.pathToAxis6.motion_ref_axisUsed.u = pathPlanning.pathToAxis6.moving[6];
//   pathPlanning.pathToAxis6.qdd[6] = pathPlanning.pathToAxis6.qdd_axisUsed.u;
//   pathPlanning.pathToAxis6.qd[6] = pathPlanning.pathToAxis6.qd_axisUsed.u;
//   pathPlanning.pathToAxis6.q[6] = pathPlanning.pathToAxis6.q_axisUsed.u;
//   pathPlanning.pathToAxis5.axisControlBus.angle_ref = pathPlanning.pathToAxis5.q_axisUsed.y;
//   pathPlanning.pathToAxis5.axisControlBus.speed_ref = pathPlanning.pathToAxis5.qd_axisUsed.y;
//   pathPlanning.pathToAxis5.axisControlBus.acceleration_ref = pathPlanning.pathToAxis5.qdd_axisUsed.y;
//   pathPlanning.pathToAxis5.axisControlBus.motion_ref = pathPlanning.pathToAxis5.motion_ref_axisUsed.y;
//   pathPlanning.pathToAxis5.motion_ref_axisUsed.u = pathPlanning.pathToAxis5.moving[5];
//   pathPlanning.pathToAxis5.qdd[5] = pathPlanning.pathToAxis5.qdd_axisUsed.u;
//   pathPlanning.pathToAxis5.qd[5] = pathPlanning.pathToAxis5.qd_axisUsed.u;
//   pathPlanning.pathToAxis5.q[5] = pathPlanning.pathToAxis5.q_axisUsed.u;
//   pathPlanning.pathToAxis4.axisControlBus.angle_ref = pathPlanning.pathToAxis4.q_axisUsed.y;
//   pathPlanning.pathToAxis4.axisControlBus.speed_ref = pathPlanning.pathToAxis4.qd_axisUsed.y;
//   pathPlanning.pathToAxis4.axisControlBus.acceleration_ref = pathPlanning.pathToAxis4.qdd_axisUsed.y;
//   pathPlanning.pathToAxis4.axisControlBus.motion_ref = pathPlanning.pathToAxis4.motion_ref_axisUsed.y;
//   pathPlanning.pathToAxis4.motion_ref_axisUsed.u = pathPlanning.pathToAxis4.moving[4];
//   pathPlanning.pathToAxis4.qdd[4] = pathPlanning.pathToAxis4.qdd_axisUsed.u;
//   pathPlanning.pathToAxis4.qd[4] = pathPlanning.pathToAxis4.qd_axisUsed.u;
//   pathPlanning.pathToAxis4.q[4] = pathPlanning.pathToAxis4.q_axisUsed.u;
//   pathPlanning.pathToAxis3.axisControlBus.angle_ref = pathPlanning.pathToAxis3.q_axisUsed.y;
//   pathPlanning.pathToAxis3.axisControlBus.speed_ref = pathPlanning.pathToAxis3.qd_axisUsed.y;
//   pathPlanning.pathToAxis3.axisControlBus.acceleration_ref = pathPlanning.pathToAxis3.qdd_axisUsed.y;
//   pathPlanning.pathToAxis3.axisControlBus.motion_ref = pathPlanning.pathToAxis3.motion_ref_axisUsed.y;
//   pathPlanning.pathToAxis3.motion_ref_axisUsed.u = pathPlanning.pathToAxis3.moving[3];
//   pathPlanning.pathToAxis3.qdd[3] = pathPlanning.pathToAxis3.qdd_axisUsed.u;
//   pathPlanning.pathToAxis3.qd[3] = pathPlanning.pathToAxis3.qd_axisUsed.u;
//   pathPlanning.pathToAxis3.q[3] = pathPlanning.pathToAxis3.q_axisUsed.u;
//   pathPlanning.pathToAxis2.axisControlBus.angle_ref = pathPlanning.pathToAxis2.q_axisUsed.y;
//   pathPlanning.pathToAxis2.axisControlBus.speed_ref = pathPlanning.pathToAxis2.qd_axisUsed.y;
//   pathPlanning.pathToAxis2.axisControlBus.acceleration_ref = pathPlanning.pathToAxis2.qdd_axisUsed.y;
//   pathPlanning.pathToAxis2.axisControlBus.motion_ref = pathPlanning.pathToAxis2.motion_ref_axisUsed.y;
//   pathPlanning.pathToAxis2.motion_ref_axisUsed.u = pathPlanning.pathToAxis2.moving[2];
//   pathPlanning.pathToAxis2.qdd[2] = pathPlanning.pathToAxis2.qdd_axisUsed.u;
//   pathPlanning.pathToAxis2.qd[2] = pathPlanning.pathToAxis2.qd_axisUsed.u;
//   pathPlanning.pathToAxis2.q[2] = pathPlanning.pathToAxis2.q_axisUsed.u;
//   pathPlanning.pathToAxis1.axisControlBus.angle_ref = pathPlanning.pathToAxis1.q_axisUsed.y;
//   pathPlanning.pathToAxis1.axisControlBus.speed_ref = pathPlanning.pathToAxis1.qd_axisUsed.y;
//   pathPlanning.pathToAxis1.axisControlBus.acceleration_ref = pathPlanning.pathToAxis1.qdd_axisUsed.y;
//   pathPlanning.pathToAxis1.axisControlBus.motion_ref = pathPlanning.pathToAxis1.motion_ref_axisUsed.y;
//   pathPlanning.pathToAxis1.motion_ref_axisUsed.u = pathPlanning.pathToAxis1.moving[1];
//   pathPlanning.pathToAxis1.qdd[1] = pathPlanning.pathToAxis1.qdd_axisUsed.u;
//   pathPlanning.pathToAxis1.qd[1] = pathPlanning.pathToAxis1.qd_axisUsed.u;
//   pathPlanning.pathToAxis1.q[1] = pathPlanning.pathToAxis1.q_axisUsed.u;
//   mechanics.r6.axis.tau + (-mechanics.axis6.tau) = 0.0;
//   mechanics.axis6.phi = mechanics.r6.axis.phi;
//   mechanics.b5.frame_b.t[1] + mechanics.r6.frame_a.t[1] = 0.0;
//   mechanics.b5.frame_b.t[2] + mechanics.r6.frame_a.t[2] = 0.0;
//   mechanics.b5.frame_b.t[3] + mechanics.r6.frame_a.t[3] = 0.0;
//   mechanics.b5.frame_b.f[1] + mechanics.r6.frame_a.f[1] = 0.0;
//   mechanics.b5.frame_b.f[2] + mechanics.r6.frame_a.f[2] = 0.0;
//   mechanics.b5.frame_b.f[3] + mechanics.r6.frame_a.f[3] = 0.0;
//   mechanics.b5.frame_b.R.w[1] = mechanics.r6.frame_a.R.w[1];
//   mechanics.b5.frame_b.R.w[2] = mechanics.r6.frame_a.R.w[2];
//   mechanics.b5.frame_b.R.w[3] = mechanics.r6.frame_a.R.w[3];
//   mechanics.b5.frame_b.R.T[1,1] = mechanics.r6.frame_a.R.T[1,1];
//   mechanics.b5.frame_b.R.T[1,2] = mechanics.r6.frame_a.R.T[1,2];
//   mechanics.b5.frame_b.R.T[1,3] = mechanics.r6.frame_a.R.T[1,3];
//   mechanics.b5.frame_b.R.T[2,1] = mechanics.r6.frame_a.R.T[2,1];
//   mechanics.b5.frame_b.R.T[2,2] = mechanics.r6.frame_a.R.T[2,2];
//   mechanics.b5.frame_b.R.T[2,3] = mechanics.r6.frame_a.R.T[2,3];
//   mechanics.b5.frame_b.R.T[3,1] = mechanics.r6.frame_a.R.T[3,1];
//   mechanics.b5.frame_b.R.T[3,2] = mechanics.r6.frame_a.R.T[3,2];
//   mechanics.b5.frame_b.R.T[3,3] = mechanics.r6.frame_a.R.T[3,3];
//   mechanics.b5.frame_b.r_0[1] = mechanics.r6.frame_a.r_0[1];
//   mechanics.b5.frame_b.r_0[2] = mechanics.r6.frame_a.r_0[2];
//   mechanics.b5.frame_b.r_0[3] = mechanics.r6.frame_a.r_0[3];
//   mechanics.r5.frame_b.t[1] + mechanics.b5.frame_a.t[1] = 0.0;
//   mechanics.r5.frame_b.t[2] + mechanics.b5.frame_a.t[2] = 0.0;
//   mechanics.r5.frame_b.t[3] + mechanics.b5.frame_a.t[3] = 0.0;
//   mechanics.r5.frame_b.f[1] + mechanics.b5.frame_a.f[1] = 0.0;
//   mechanics.r5.frame_b.f[2] + mechanics.b5.frame_a.f[2] = 0.0;
//   mechanics.r5.frame_b.f[3] + mechanics.b5.frame_a.f[3] = 0.0;
//   mechanics.b5.frame_a.R.w[1] = mechanics.r5.frame_b.R.w[1];
//   mechanics.b5.frame_a.R.w[2] = mechanics.r5.frame_b.R.w[2];
//   mechanics.b5.frame_a.R.w[3] = mechanics.r5.frame_b.R.w[3];
//   mechanics.b5.frame_a.R.T[1,1] = mechanics.r5.frame_b.R.T[1,1];
//   mechanics.b5.frame_a.R.T[1,2] = mechanics.r5.frame_b.R.T[1,2];
//   mechanics.b5.frame_a.R.T[1,3] = mechanics.r5.frame_b.R.T[1,3];
//   mechanics.b5.frame_a.R.T[2,1] = mechanics.r5.frame_b.R.T[2,1];
//   mechanics.b5.frame_a.R.T[2,2] = mechanics.r5.frame_b.R.T[2,2];
//   mechanics.b5.frame_a.R.T[2,3] = mechanics.r5.frame_b.R.T[2,3];
//   mechanics.b5.frame_a.R.T[3,1] = mechanics.r5.frame_b.R.T[3,1];
//   mechanics.b5.frame_a.R.T[3,2] = mechanics.r5.frame_b.R.T[3,2];
//   mechanics.b5.frame_a.R.T[3,3] = mechanics.r5.frame_b.R.T[3,3];
//   mechanics.b5.frame_a.r_0[1] = mechanics.r5.frame_b.r_0[1];
//   mechanics.b5.frame_a.r_0[2] = mechanics.r5.frame_b.r_0[2];
//   mechanics.b5.frame_a.r_0[3] = mechanics.r5.frame_b.r_0[3];
//   mechanics.r5.axis.tau + (-mechanics.axis5.tau) = 0.0;
//   mechanics.axis5.phi = mechanics.r5.axis.phi;
//   mechanics.b4.frame_b.t[1] + mechanics.r5.frame_a.t[1] = 0.0;
//   mechanics.b4.frame_b.t[2] + mechanics.r5.frame_a.t[2] = 0.0;
//   mechanics.b4.frame_b.t[3] + mechanics.r5.frame_a.t[3] = 0.0;
//   mechanics.b4.frame_b.f[1] + mechanics.r5.frame_a.f[1] = 0.0;
//   mechanics.b4.frame_b.f[2] + mechanics.r5.frame_a.f[2] = 0.0;
//   mechanics.b4.frame_b.f[3] + mechanics.r5.frame_a.f[3] = 0.0;
//   mechanics.b4.frame_b.R.w[1] = mechanics.r5.frame_a.R.w[1];
//   mechanics.b4.frame_b.R.w[2] = mechanics.r5.frame_a.R.w[2];
//   mechanics.b4.frame_b.R.w[3] = mechanics.r5.frame_a.R.w[3];
//   mechanics.b4.frame_b.R.T[1,1] = mechanics.r5.frame_a.R.T[1,1];
//   mechanics.b4.frame_b.R.T[1,2] = mechanics.r5.frame_a.R.T[1,2];
//   mechanics.b4.frame_b.R.T[1,3] = mechanics.r5.frame_a.R.T[1,3];
//   mechanics.b4.frame_b.R.T[2,1] = mechanics.r5.frame_a.R.T[2,1];
//   mechanics.b4.frame_b.R.T[2,2] = mechanics.r5.frame_a.R.T[2,2];
//   mechanics.b4.frame_b.R.T[2,3] = mechanics.r5.frame_a.R.T[2,3];
//   mechanics.b4.frame_b.R.T[3,1] = mechanics.r5.frame_a.R.T[3,1];
//   mechanics.b4.frame_b.R.T[3,2] = mechanics.r5.frame_a.R.T[3,2];
//   mechanics.b4.frame_b.R.T[3,3] = mechanics.r5.frame_a.R.T[3,3];
//   mechanics.b4.frame_b.r_0[1] = mechanics.r5.frame_a.r_0[1];
//   mechanics.b4.frame_b.r_0[2] = mechanics.r5.frame_a.r_0[2];
//   mechanics.b4.frame_b.r_0[3] = mechanics.r5.frame_a.r_0[3];
//   mechanics.r4.frame_b.t[1] + mechanics.b4.frame_a.t[1] = 0.0;
//   mechanics.r4.frame_b.t[2] + mechanics.b4.frame_a.t[2] = 0.0;
//   mechanics.r4.frame_b.t[3] + mechanics.b4.frame_a.t[3] = 0.0;
//   mechanics.r4.frame_b.f[1] + mechanics.b4.frame_a.f[1] = 0.0;
//   mechanics.r4.frame_b.f[2] + mechanics.b4.frame_a.f[2] = 0.0;
//   mechanics.r4.frame_b.f[3] + mechanics.b4.frame_a.f[3] = 0.0;
//   mechanics.b4.frame_a.R.w[1] = mechanics.r4.frame_b.R.w[1];
//   mechanics.b4.frame_a.R.w[2] = mechanics.r4.frame_b.R.w[2];
//   mechanics.b4.frame_a.R.w[3] = mechanics.r4.frame_b.R.w[3];
//   mechanics.b4.frame_a.R.T[1,1] = mechanics.r4.frame_b.R.T[1,1];
//   mechanics.b4.frame_a.R.T[1,2] = mechanics.r4.frame_b.R.T[1,2];
//   mechanics.b4.frame_a.R.T[1,3] = mechanics.r4.frame_b.R.T[1,3];
//   mechanics.b4.frame_a.R.T[2,1] = mechanics.r4.frame_b.R.T[2,1];
//   mechanics.b4.frame_a.R.T[2,2] = mechanics.r4.frame_b.R.T[2,2];
//   mechanics.b4.frame_a.R.T[2,3] = mechanics.r4.frame_b.R.T[2,3];
//   mechanics.b4.frame_a.R.T[3,1] = mechanics.r4.frame_b.R.T[3,1];
//   mechanics.b4.frame_a.R.T[3,2] = mechanics.r4.frame_b.R.T[3,2];
//   mechanics.b4.frame_a.R.T[3,3] = mechanics.r4.frame_b.R.T[3,3];
//   mechanics.b4.frame_a.r_0[1] = mechanics.r4.frame_b.r_0[1];
//   mechanics.b4.frame_a.r_0[2] = mechanics.r4.frame_b.r_0[2];
//   mechanics.b4.frame_a.r_0[3] = mechanics.r4.frame_b.r_0[3];
//   mechanics.r4.axis.tau + (-mechanics.axis4.tau) = 0.0;
//   mechanics.axis4.phi = mechanics.r4.axis.phi;
//   mechanics.r3.axis.tau + (-mechanics.axis3.tau) = 0.0;
//   mechanics.axis3.phi = mechanics.r3.axis.phi;
//   mechanics.b3.frame_b.t[1] + mechanics.r4.frame_a.t[1] = 0.0;
//   mechanics.b3.frame_b.t[2] + mechanics.r4.frame_a.t[2] = 0.0;
//   mechanics.b3.frame_b.t[3] + mechanics.r4.frame_a.t[3] = 0.0;
//   mechanics.b3.frame_b.f[1] + mechanics.r4.frame_a.f[1] = 0.0;
//   mechanics.b3.frame_b.f[2] + mechanics.r4.frame_a.f[2] = 0.0;
//   mechanics.b3.frame_b.f[3] + mechanics.r4.frame_a.f[3] = 0.0;
//   mechanics.b3.frame_b.R.w[1] = mechanics.r4.frame_a.R.w[1];
//   mechanics.b3.frame_b.R.w[2] = mechanics.r4.frame_a.R.w[2];
//   mechanics.b3.frame_b.R.w[3] = mechanics.r4.frame_a.R.w[3];
//   mechanics.b3.frame_b.R.T[1,1] = mechanics.r4.frame_a.R.T[1,1];
//   mechanics.b3.frame_b.R.T[1,2] = mechanics.r4.frame_a.R.T[1,2];
//   mechanics.b3.frame_b.R.T[1,3] = mechanics.r4.frame_a.R.T[1,3];
//   mechanics.b3.frame_b.R.T[2,1] = mechanics.r4.frame_a.R.T[2,1];
//   mechanics.b3.frame_b.R.T[2,2] = mechanics.r4.frame_a.R.T[2,2];
//   mechanics.b3.frame_b.R.T[2,3] = mechanics.r4.frame_a.R.T[2,3];
//   mechanics.b3.frame_b.R.T[3,1] = mechanics.r4.frame_a.R.T[3,1];
//   mechanics.b3.frame_b.R.T[3,2] = mechanics.r4.frame_a.R.T[3,2];
//   mechanics.b3.frame_b.R.T[3,3] = mechanics.r4.frame_a.R.T[3,3];
//   mechanics.b3.frame_b.r_0[1] = mechanics.r4.frame_a.r_0[1];
//   mechanics.b3.frame_b.r_0[2] = mechanics.r4.frame_a.r_0[2];
//   mechanics.b3.frame_b.r_0[3] = mechanics.r4.frame_a.r_0[3];
//   mechanics.r3.frame_b.t[1] + mechanics.b3.frame_a.t[1] = 0.0;
//   mechanics.r3.frame_b.t[2] + mechanics.b3.frame_a.t[2] = 0.0;
//   mechanics.r3.frame_b.t[3] + mechanics.b3.frame_a.t[3] = 0.0;
//   mechanics.r3.frame_b.f[1] + mechanics.b3.frame_a.f[1] = 0.0;
//   mechanics.r3.frame_b.f[2] + mechanics.b3.frame_a.f[2] = 0.0;
//   mechanics.r3.frame_b.f[3] + mechanics.b3.frame_a.f[3] = 0.0;
//   mechanics.b3.frame_a.R.w[1] = mechanics.r3.frame_b.R.w[1];
//   mechanics.b3.frame_a.R.w[2] = mechanics.r3.frame_b.R.w[2];
//   mechanics.b3.frame_a.R.w[3] = mechanics.r3.frame_b.R.w[3];
//   mechanics.b3.frame_a.R.T[1,1] = mechanics.r3.frame_b.R.T[1,1];
//   mechanics.b3.frame_a.R.T[1,2] = mechanics.r3.frame_b.R.T[1,2];
//   mechanics.b3.frame_a.R.T[1,3] = mechanics.r3.frame_b.R.T[1,3];
//   mechanics.b3.frame_a.R.T[2,1] = mechanics.r3.frame_b.R.T[2,1];
//   mechanics.b3.frame_a.R.T[2,2] = mechanics.r3.frame_b.R.T[2,2];
//   mechanics.b3.frame_a.R.T[2,3] = mechanics.r3.frame_b.R.T[2,3];
//   mechanics.b3.frame_a.R.T[3,1] = mechanics.r3.frame_b.R.T[3,1];
//   mechanics.b3.frame_a.R.T[3,2] = mechanics.r3.frame_b.R.T[3,2];
//   mechanics.b3.frame_a.R.T[3,3] = mechanics.r3.frame_b.R.T[3,3];
//   mechanics.b3.frame_a.r_0[1] = mechanics.r3.frame_b.r_0[1];
//   mechanics.b3.frame_a.r_0[2] = mechanics.r3.frame_b.r_0[2];
//   mechanics.b3.frame_a.r_0[3] = mechanics.r3.frame_b.r_0[3];
//   mechanics.r1.axis.tau + (-mechanics.axis1.tau) = 0.0;
//   mechanics.axis1.phi = mechanics.r1.axis.phi;
//   mechanics.r2.axis.tau + (-mechanics.axis2.tau) = 0.0;
//   mechanics.axis2.phi = mechanics.r2.axis.phi;
//   mechanics.b2.frame_b.t[1] + mechanics.r3.frame_a.t[1] = 0.0;
//   mechanics.b2.frame_b.t[2] + mechanics.r3.frame_a.t[2] = 0.0;
//   mechanics.b2.frame_b.t[3] + mechanics.r3.frame_a.t[3] = 0.0;
//   mechanics.b2.frame_b.f[1] + mechanics.r3.frame_a.f[1] = 0.0;
//   mechanics.b2.frame_b.f[2] + mechanics.r3.frame_a.f[2] = 0.0;
//   mechanics.b2.frame_b.f[3] + mechanics.r3.frame_a.f[3] = 0.0;
//   mechanics.b2.frame_b.R.w[1] = mechanics.r3.frame_a.R.w[1];
//   mechanics.b2.frame_b.R.w[2] = mechanics.r3.frame_a.R.w[2];
//   mechanics.b2.frame_b.R.w[3] = mechanics.r3.frame_a.R.w[3];
//   mechanics.b2.frame_b.R.T[1,1] = mechanics.r3.frame_a.R.T[1,1];
//   mechanics.b2.frame_b.R.T[1,2] = mechanics.r3.frame_a.R.T[1,2];
//   mechanics.b2.frame_b.R.T[1,3] = mechanics.r3.frame_a.R.T[1,3];
//   mechanics.b2.frame_b.R.T[2,1] = mechanics.r3.frame_a.R.T[2,1];
//   mechanics.b2.frame_b.R.T[2,2] = mechanics.r3.frame_a.R.T[2,2];
//   mechanics.b2.frame_b.R.T[2,3] = mechanics.r3.frame_a.R.T[2,3];
//   mechanics.b2.frame_b.R.T[3,1] = mechanics.r3.frame_a.R.T[3,1];
//   mechanics.b2.frame_b.R.T[3,2] = mechanics.r3.frame_a.R.T[3,2];
//   mechanics.b2.frame_b.R.T[3,3] = mechanics.r3.frame_a.R.T[3,3];
//   mechanics.b2.frame_b.r_0[1] = mechanics.r3.frame_a.r_0[1];
//   mechanics.b2.frame_b.r_0[2] = mechanics.r3.frame_a.r_0[2];
//   mechanics.b2.frame_b.r_0[3] = mechanics.r3.frame_a.r_0[3];
//   mechanics.r2.frame_b.t[1] + mechanics.b2.frame_a.t[1] = 0.0;
//   mechanics.r2.frame_b.t[2] + mechanics.b2.frame_a.t[2] = 0.0;
//   mechanics.r2.frame_b.t[3] + mechanics.b2.frame_a.t[3] = 0.0;
//   mechanics.r2.frame_b.f[1] + mechanics.b2.frame_a.f[1] = 0.0;
//   mechanics.r2.frame_b.f[2] + mechanics.b2.frame_a.f[2] = 0.0;
//   mechanics.r2.frame_b.f[3] + mechanics.b2.frame_a.f[3] = 0.0;
//   mechanics.b2.frame_a.R.w[1] = mechanics.r2.frame_b.R.w[1];
//   mechanics.b2.frame_a.R.w[2] = mechanics.r2.frame_b.R.w[2];
//   mechanics.b2.frame_a.R.w[3] = mechanics.r2.frame_b.R.w[3];
//   mechanics.b2.frame_a.R.T[1,1] = mechanics.r2.frame_b.R.T[1,1];
//   mechanics.b2.frame_a.R.T[1,2] = mechanics.r2.frame_b.R.T[1,2];
//   mechanics.b2.frame_a.R.T[1,3] = mechanics.r2.frame_b.R.T[1,3];
//   mechanics.b2.frame_a.R.T[2,1] = mechanics.r2.frame_b.R.T[2,1];
//   mechanics.b2.frame_a.R.T[2,2] = mechanics.r2.frame_b.R.T[2,2];
//   mechanics.b2.frame_a.R.T[2,3] = mechanics.r2.frame_b.R.T[2,3];
//   mechanics.b2.frame_a.R.T[3,1] = mechanics.r2.frame_b.R.T[3,1];
//   mechanics.b2.frame_a.R.T[3,2] = mechanics.r2.frame_b.R.T[3,2];
//   mechanics.b2.frame_a.R.T[3,3] = mechanics.r2.frame_b.R.T[3,3];
//   mechanics.b2.frame_a.r_0[1] = mechanics.r2.frame_b.r_0[1];
//   mechanics.b2.frame_a.r_0[2] = mechanics.r2.frame_b.r_0[2];
//   mechanics.b2.frame_a.r_0[3] = mechanics.r2.frame_b.r_0[3];
//   mechanics.r1.frame_b.t[1] + mechanics.b1.frame_a.t[1] = 0.0;
//   mechanics.r1.frame_b.t[2] + mechanics.b1.frame_a.t[2] = 0.0;
//   mechanics.r1.frame_b.t[3] + mechanics.b1.frame_a.t[3] = 0.0;
//   mechanics.r1.frame_b.f[1] + mechanics.b1.frame_a.f[1] = 0.0;
//   mechanics.r1.frame_b.f[2] + mechanics.b1.frame_a.f[2] = 0.0;
//   mechanics.r1.frame_b.f[3] + mechanics.b1.frame_a.f[3] = 0.0;
//   mechanics.b1.frame_a.R.w[1] = mechanics.r1.frame_b.R.w[1];
//   mechanics.b1.frame_a.R.w[2] = mechanics.r1.frame_b.R.w[2];
//   mechanics.b1.frame_a.R.w[3] = mechanics.r1.frame_b.R.w[3];
//   mechanics.b1.frame_a.R.T[1,1] = mechanics.r1.frame_b.R.T[1,1];
//   mechanics.b1.frame_a.R.T[1,2] = mechanics.r1.frame_b.R.T[1,2];
//   mechanics.b1.frame_a.R.T[1,3] = mechanics.r1.frame_b.R.T[1,3];
//   mechanics.b1.frame_a.R.T[2,1] = mechanics.r1.frame_b.R.T[2,1];
//   mechanics.b1.frame_a.R.T[2,2] = mechanics.r1.frame_b.R.T[2,2];
//   mechanics.b1.frame_a.R.T[2,3] = mechanics.r1.frame_b.R.T[2,3];
//   mechanics.b1.frame_a.R.T[3,1] = mechanics.r1.frame_b.R.T[3,1];
//   mechanics.b1.frame_a.R.T[3,2] = mechanics.r1.frame_b.R.T[3,2];
//   mechanics.b1.frame_a.R.T[3,3] = mechanics.r1.frame_b.R.T[3,3];
//   mechanics.b1.frame_a.r_0[1] = mechanics.r1.frame_b.r_0[1];
//   mechanics.b1.frame_a.r_0[2] = mechanics.r1.frame_b.r_0[2];
//   mechanics.b1.frame_a.r_0[3] = mechanics.r1.frame_b.r_0[3];
//   mechanics.b1.frame_b.t[1] + mechanics.r2.frame_a.t[1] = 0.0;
//   mechanics.b1.frame_b.t[2] + mechanics.r2.frame_a.t[2] = 0.0;
//   mechanics.b1.frame_b.t[3] + mechanics.r2.frame_a.t[3] = 0.0;
//   mechanics.b1.frame_b.f[1] + mechanics.r2.frame_a.f[1] = 0.0;
//   mechanics.b1.frame_b.f[2] + mechanics.r2.frame_a.f[2] = 0.0;
//   mechanics.b1.frame_b.f[3] + mechanics.r2.frame_a.f[3] = 0.0;
//   mechanics.b1.frame_b.R.w[1] = mechanics.r2.frame_a.R.w[1];
//   mechanics.b1.frame_b.R.w[2] = mechanics.r2.frame_a.R.w[2];
//   mechanics.b1.frame_b.R.w[3] = mechanics.r2.frame_a.R.w[3];
//   mechanics.b1.frame_b.R.T[1,1] = mechanics.r2.frame_a.R.T[1,1];
//   mechanics.b1.frame_b.R.T[1,2] = mechanics.r2.frame_a.R.T[1,2];
//   mechanics.b1.frame_b.R.T[1,3] = mechanics.r2.frame_a.R.T[1,3];
//   mechanics.b1.frame_b.R.T[2,1] = mechanics.r2.frame_a.R.T[2,1];
//   mechanics.b1.frame_b.R.T[2,2] = mechanics.r2.frame_a.R.T[2,2];
//   mechanics.b1.frame_b.R.T[2,3] = mechanics.r2.frame_a.R.T[2,3];
//   mechanics.b1.frame_b.R.T[3,1] = mechanics.r2.frame_a.R.T[3,1];
//   mechanics.b1.frame_b.R.T[3,2] = mechanics.r2.frame_a.R.T[3,2];
//   mechanics.b1.frame_b.R.T[3,3] = mechanics.r2.frame_a.R.T[3,3];
//   mechanics.b1.frame_b.r_0[1] = mechanics.r2.frame_a.r_0[1];
//   mechanics.b1.frame_b.r_0[2] = mechanics.r2.frame_a.r_0[2];
//   mechanics.b1.frame_b.r_0[3] = mechanics.r2.frame_a.r_0[3];
//   mechanics.b0.frame_b.t[1] + mechanics.r1.frame_a.t[1] = 0.0;
//   mechanics.b0.frame_b.t[2] + mechanics.r1.frame_a.t[2] = 0.0;
//   mechanics.b0.frame_b.t[3] + mechanics.r1.frame_a.t[3] = 0.0;
//   mechanics.b0.frame_b.f[1] + mechanics.r1.frame_a.f[1] = 0.0;
//   mechanics.b0.frame_b.f[2] + mechanics.r1.frame_a.f[2] = 0.0;
//   mechanics.b0.frame_b.f[3] + mechanics.r1.frame_a.f[3] = 0.0;
//   mechanics.b0.frame_b.R.w[1] = mechanics.r1.frame_a.R.w[1];
//   mechanics.b0.frame_b.R.w[2] = mechanics.r1.frame_a.R.w[2];
//   mechanics.b0.frame_b.R.w[3] = mechanics.r1.frame_a.R.w[3];
//   mechanics.b0.frame_b.R.T[1,1] = mechanics.r1.frame_a.R.T[1,1];
//   mechanics.b0.frame_b.R.T[1,2] = mechanics.r1.frame_a.R.T[1,2];
//   mechanics.b0.frame_b.R.T[1,3] = mechanics.r1.frame_a.R.T[1,3];
//   mechanics.b0.frame_b.R.T[2,1] = mechanics.r1.frame_a.R.T[2,1];
//   mechanics.b0.frame_b.R.T[2,2] = mechanics.r1.frame_a.R.T[2,2];
//   mechanics.b0.frame_b.R.T[2,3] = mechanics.r1.frame_a.R.T[2,3];
//   mechanics.b0.frame_b.R.T[3,1] = mechanics.r1.frame_a.R.T[3,1];
//   mechanics.b0.frame_b.R.T[3,2] = mechanics.r1.frame_a.R.T[3,2];
//   mechanics.b0.frame_b.R.T[3,3] = mechanics.r1.frame_a.R.T[3,3];
//   mechanics.b0.frame_b.r_0[1] = mechanics.r1.frame_a.r_0[1];
//   mechanics.b0.frame_b.r_0[2] = mechanics.r1.frame_a.r_0[2];
//   mechanics.b0.frame_b.r_0[3] = mechanics.r1.frame_a.r_0[3];
//   mechanics.world.frame_b.t[1] + mechanics.b0.frame_a.t[1] = 0.0;
//   mechanics.world.frame_b.t[2] + mechanics.b0.frame_a.t[2] = 0.0;
//   mechanics.world.frame_b.t[3] + mechanics.b0.frame_a.t[3] = 0.0;
//   mechanics.world.frame_b.f[1] + mechanics.b0.frame_a.f[1] = 0.0;
//   mechanics.world.frame_b.f[2] + mechanics.b0.frame_a.f[2] = 0.0;
//   mechanics.world.frame_b.f[3] + mechanics.b0.frame_a.f[3] = 0.0;
//   mechanics.b0.frame_a.R.w[1] = mechanics.world.frame_b.R.w[1];
//   mechanics.b0.frame_a.R.w[2] = mechanics.world.frame_b.R.w[2];
//   mechanics.b0.frame_a.R.w[3] = mechanics.world.frame_b.R.w[3];
//   mechanics.b0.frame_a.R.T[1,1] = mechanics.world.frame_b.R.T[1,1];
//   mechanics.b0.frame_a.R.T[1,2] = mechanics.world.frame_b.R.T[1,2];
//   mechanics.b0.frame_a.R.T[1,3] = mechanics.world.frame_b.R.T[1,3];
//   mechanics.b0.frame_a.R.T[2,1] = mechanics.world.frame_b.R.T[2,1];
//   mechanics.b0.frame_a.R.T[2,2] = mechanics.world.frame_b.R.T[2,2];
//   mechanics.b0.frame_a.R.T[2,3] = mechanics.world.frame_b.R.T[2,3];
//   mechanics.b0.frame_a.R.T[3,1] = mechanics.world.frame_b.R.T[3,1];
//   mechanics.b0.frame_a.R.T[3,2] = mechanics.world.frame_b.R.T[3,2];
//   mechanics.b0.frame_a.R.T[3,3] = mechanics.world.frame_b.R.T[3,3];
//   mechanics.b0.frame_a.r_0[1] = mechanics.world.frame_b.r_0[1];
//   mechanics.b0.frame_a.r_0[2] = mechanics.world.frame_b.r_0[2];
//   mechanics.b0.frame_a.r_0[3] = mechanics.world.frame_b.r_0[3];
//   mechanics.load.frame_a.t[1] + mechanics.b6.frame_b.t[1] = 0.0;
//   mechanics.load.frame_a.t[2] + mechanics.b6.frame_b.t[2] = 0.0;
//   mechanics.load.frame_a.t[3] + mechanics.b6.frame_b.t[3] = 0.0;
//   mechanics.load.frame_a.f[1] + mechanics.b6.frame_b.f[1] = 0.0;
//   mechanics.load.frame_a.f[2] + mechanics.b6.frame_b.f[2] = 0.0;
//   mechanics.load.frame_a.f[3] + mechanics.b6.frame_b.f[3] = 0.0;
//   mechanics.b6.frame_b.R.w[1] = mechanics.load.frame_a.R.w[1];
//   mechanics.b6.frame_b.R.w[2] = mechanics.load.frame_a.R.w[2];
//   mechanics.b6.frame_b.R.w[3] = mechanics.load.frame_a.R.w[3];
//   mechanics.b6.frame_b.R.T[1,1] = mechanics.load.frame_a.R.T[1,1];
//   mechanics.b6.frame_b.R.T[1,2] = mechanics.load.frame_a.R.T[1,2];
//   mechanics.b6.frame_b.R.T[1,3] = mechanics.load.frame_a.R.T[1,3];
//   mechanics.b6.frame_b.R.T[2,1] = mechanics.load.frame_a.R.T[2,1];
//   mechanics.b6.frame_b.R.T[2,2] = mechanics.load.frame_a.R.T[2,2];
//   mechanics.b6.frame_b.R.T[2,3] = mechanics.load.frame_a.R.T[2,3];
//   mechanics.b6.frame_b.R.T[3,1] = mechanics.load.frame_a.R.T[3,1];
//   mechanics.b6.frame_b.R.T[3,2] = mechanics.load.frame_a.R.T[3,2];
//   mechanics.b6.frame_b.R.T[3,3] = mechanics.load.frame_a.R.T[3,3];
//   mechanics.b6.frame_b.r_0[1] = mechanics.load.frame_a.r_0[1];
//   mechanics.b6.frame_b.r_0[2] = mechanics.load.frame_a.r_0[2];
//   mechanics.b6.frame_b.r_0[3] = mechanics.load.frame_a.r_0[3];
//   mechanics.r6.frame_b.t[1] + mechanics.b6.frame_a.t[1] = 0.0;
//   mechanics.r6.frame_b.t[2] + mechanics.b6.frame_a.t[2] = 0.0;
//   mechanics.r6.frame_b.t[3] + mechanics.b6.frame_a.t[3] = 0.0;
//   mechanics.r6.frame_b.f[1] + mechanics.b6.frame_a.f[1] = 0.0;
//   mechanics.r6.frame_b.f[2] + mechanics.b6.frame_a.f[2] = 0.0;
//   mechanics.r6.frame_b.f[3] + mechanics.b6.frame_a.f[3] = 0.0;
//   mechanics.b6.frame_a.R.w[1] = mechanics.r6.frame_b.R.w[1];
//   mechanics.b6.frame_a.R.w[2] = mechanics.r6.frame_b.R.w[2];
//   mechanics.b6.frame_a.R.w[3] = mechanics.r6.frame_b.R.w[3];
//   mechanics.b6.frame_a.R.T[1,1] = mechanics.r6.frame_b.R.T[1,1];
//   mechanics.b6.frame_a.R.T[1,2] = mechanics.r6.frame_b.R.T[1,2];
//   mechanics.b6.frame_a.R.T[1,3] = mechanics.r6.frame_b.R.T[1,3];
//   mechanics.b6.frame_a.R.T[2,1] = mechanics.r6.frame_b.R.T[2,1];
//   mechanics.b6.frame_a.R.T[2,2] = mechanics.r6.frame_b.R.T[2,2];
//   mechanics.b6.frame_a.R.T[2,3] = mechanics.r6.frame_b.R.T[2,3];
//   mechanics.b6.frame_a.R.T[3,1] = mechanics.r6.frame_b.R.T[3,1];
//   mechanics.b6.frame_a.R.T[3,2] = mechanics.r6.frame_b.R.T[3,2];
//   mechanics.b6.frame_a.R.T[3,3] = mechanics.r6.frame_b.R.T[3,3];
//   mechanics.b6.frame_a.r_0[1] = mechanics.r6.frame_b.r_0[1];
//   mechanics.b6.frame_a.r_0[2] = mechanics.r6.frame_b.r_0[2];
//   mechanics.b6.frame_a.r_0[3] = mechanics.r6.frame_b.r_0[3];
//   (-mechanics.load.frame_a.t[1]) + (mechanics.load.frameTranslation.frame_a.t[1] + mechanics.load.body.frame_a.t[1]) = 0.0;
//   (-mechanics.load.frame_a.t[2]) + (mechanics.load.frameTranslation.frame_a.t[2] + mechanics.load.body.frame_a.t[2]) = 0.0;
//   (-mechanics.load.frame_a.t[3]) + (mechanics.load.frameTranslation.frame_a.t[3] + mechanics.load.body.frame_a.t[3]) = 0.0;
//   (-mechanics.load.frame_a.f[1]) + (mechanics.load.frameTranslation.frame_a.f[1] + mechanics.load.body.frame_a.f[1]) = 0.0;
//   (-mechanics.load.frame_a.f[2]) + (mechanics.load.frameTranslation.frame_a.f[2] + mechanics.load.body.frame_a.f[2]) = 0.0;
//   (-mechanics.load.frame_a.f[3]) + (mechanics.load.frameTranslation.frame_a.f[3] + mechanics.load.body.frame_a.f[3]) = 0.0;
//   mechanics.load.body.frame_a.R.w[1] = mechanics.load.frameTranslation.frame_a.R.w[1];
//   mechanics.load.body.frame_a.R.w[1] = mechanics.load.frame_a.R.w[1];
//   mechanics.load.body.frame_a.R.w[2] = mechanics.load.frameTranslation.frame_a.R.w[2];
//   mechanics.load.body.frame_a.R.w[2] = mechanics.load.frame_a.R.w[2];
//   mechanics.load.body.frame_a.R.w[3] = mechanics.load.frameTranslation.frame_a.R.w[3];
//   mechanics.load.body.frame_a.R.w[3] = mechanics.load.frame_a.R.w[3];
//   mechanics.load.body.frame_a.R.T[1,1] = mechanics.load.frameTranslation.frame_a.R.T[1,1];
//   mechanics.load.body.frame_a.R.T[1,1] = mechanics.load.frame_a.R.T[1,1];
//   mechanics.load.body.frame_a.R.T[1,2] = mechanics.load.frameTranslation.frame_a.R.T[1,2];
//   mechanics.load.body.frame_a.R.T[1,2] = mechanics.load.frame_a.R.T[1,2];
//   mechanics.load.body.frame_a.R.T[1,3] = mechanics.load.frameTranslation.frame_a.R.T[1,3];
//   mechanics.load.body.frame_a.R.T[1,3] = mechanics.load.frame_a.R.T[1,3];
//   mechanics.load.body.frame_a.R.T[2,1] = mechanics.load.frameTranslation.frame_a.R.T[2,1];
//   mechanics.load.body.frame_a.R.T[2,1] = mechanics.load.frame_a.R.T[2,1];
//   mechanics.load.body.frame_a.R.T[2,2] = mechanics.load.frameTranslation.frame_a.R.T[2,2];
//   mechanics.load.body.frame_a.R.T[2,2] = mechanics.load.frame_a.R.T[2,2];
//   mechanics.load.body.frame_a.R.T[2,3] = mechanics.load.frameTranslation.frame_a.R.T[2,3];
//   mechanics.load.body.frame_a.R.T[2,3] = mechanics.load.frame_a.R.T[2,3];
//   mechanics.load.body.frame_a.R.T[3,1] = mechanics.load.frameTranslation.frame_a.R.T[3,1];
//   mechanics.load.body.frame_a.R.T[3,1] = mechanics.load.frame_a.R.T[3,1];
//   mechanics.load.body.frame_a.R.T[3,2] = mechanics.load.frameTranslation.frame_a.R.T[3,2];
//   mechanics.load.body.frame_a.R.T[3,2] = mechanics.load.frame_a.R.T[3,2];
//   mechanics.load.body.frame_a.R.T[3,3] = mechanics.load.frameTranslation.frame_a.R.T[3,3];
//   mechanics.load.body.frame_a.R.T[3,3] = mechanics.load.frame_a.R.T[3,3];
//   mechanics.load.body.frame_a.r_0[1] = mechanics.load.frameTranslation.frame_a.r_0[1];
//   mechanics.load.body.frame_a.r_0[1] = mechanics.load.frame_a.r_0[1];
//   mechanics.load.body.frame_a.r_0[2] = mechanics.load.frameTranslation.frame_a.r_0[2];
//   mechanics.load.body.frame_a.r_0[2] = mechanics.load.frame_a.r_0[2];
//   mechanics.load.body.frame_a.r_0[3] = mechanics.load.frameTranslation.frame_a.r_0[3];
//   mechanics.load.body.frame_a.r_0[3] = mechanics.load.frame_a.r_0[3];
//   (-mechanics.load.frame_b.t[1]) + mechanics.load.frameTranslation.frame_b.t[1] = 0.0;
//   (-mechanics.load.frame_b.t[2]) + mechanics.load.frameTranslation.frame_b.t[2] = 0.0;
//   (-mechanics.load.frame_b.t[3]) + mechanics.load.frameTranslation.frame_b.t[3] = 0.0;
//   (-mechanics.load.frame_b.f[1]) + mechanics.load.frameTranslation.frame_b.f[1] = 0.0;
//   (-mechanics.load.frame_b.f[2]) + mechanics.load.frameTranslation.frame_b.f[2] = 0.0;
//   (-mechanics.load.frame_b.f[3]) + mechanics.load.frameTranslation.frame_b.f[3] = 0.0;
//   mechanics.load.frameTranslation.frame_b.R.w[1] = mechanics.load.frame_b.R.w[1];
//   mechanics.load.frameTranslation.frame_b.R.w[2] = mechanics.load.frame_b.R.w[2];
//   mechanics.load.frameTranslation.frame_b.R.w[3] = mechanics.load.frame_b.R.w[3];
//   mechanics.load.frameTranslation.frame_b.R.T[1,1] = mechanics.load.frame_b.R.T[1,1];
//   mechanics.load.frameTranslation.frame_b.R.T[1,2] = mechanics.load.frame_b.R.T[1,2];
//   mechanics.load.frameTranslation.frame_b.R.T[1,3] = mechanics.load.frame_b.R.T[1,3];
//   mechanics.load.frameTranslation.frame_b.R.T[2,1] = mechanics.load.frame_b.R.T[2,1];
//   mechanics.load.frameTranslation.frame_b.R.T[2,2] = mechanics.load.frame_b.R.T[2,2];
//   mechanics.load.frameTranslation.frame_b.R.T[2,3] = mechanics.load.frame_b.R.T[2,3];
//   mechanics.load.frameTranslation.frame_b.R.T[3,1] = mechanics.load.frame_b.R.T[3,1];
//   mechanics.load.frameTranslation.frame_b.R.T[3,2] = mechanics.load.frame_b.R.T[3,2];
//   mechanics.load.frameTranslation.frame_b.R.T[3,3] = mechanics.load.frame_b.R.T[3,3];
//   mechanics.load.frameTranslation.frame_b.r_0[1] = mechanics.load.frame_b.r_0[1];
//   mechanics.load.frameTranslation.frame_b.r_0[2] = mechanics.load.frame_b.r_0[2];
//   mechanics.load.frameTranslation.frame_b.r_0[3] = mechanics.load.frame_b.r_0[3];
//   mechanics.load.frame_b.t[3] = 0.0;
//   mechanics.load.frame_b.t[2] = 0.0;
//   mechanics.load.frame_b.t[1] = 0.0;
//   mechanics.load.frame_b.f[3] = 0.0;
//   mechanics.load.frame_b.f[2] = 0.0;
//   mechanics.load.frame_b.f[1] = 0.0;
//   (-mechanics.b6.frame_a.t[1]) + (mechanics.b6.frameTranslation.frame_a.t[1] + mechanics.b6.body.frame_a.t[1]) = 0.0;
//   (-mechanics.b6.frame_a.t[2]) + (mechanics.b6.frameTranslation.frame_a.t[2] + mechanics.b6.body.frame_a.t[2]) = 0.0;
//   (-mechanics.b6.frame_a.t[3]) + (mechanics.b6.frameTranslation.frame_a.t[3] + mechanics.b6.body.frame_a.t[3]) = 0.0;
//   (-mechanics.b6.frame_a.f[1]) + (mechanics.b6.frameTranslation.frame_a.f[1] + mechanics.b6.body.frame_a.f[1]) = 0.0;
//   (-mechanics.b6.frame_a.f[2]) + (mechanics.b6.frameTranslation.frame_a.f[2] + mechanics.b6.body.frame_a.f[2]) = 0.0;
//   (-mechanics.b6.frame_a.f[3]) + (mechanics.b6.frameTranslation.frame_a.f[3] + mechanics.b6.body.frame_a.f[3]) = 0.0;
//   mechanics.b6.body.frame_a.R.w[1] = mechanics.b6.frameTranslation.frame_a.R.w[1];
//   mechanics.b6.body.frame_a.R.w[1] = mechanics.b6.frame_a.R.w[1];
//   mechanics.b6.body.frame_a.R.w[2] = mechanics.b6.frameTranslation.frame_a.R.w[2];
//   mechanics.b6.body.frame_a.R.w[2] = mechanics.b6.frame_a.R.w[2];
//   mechanics.b6.body.frame_a.R.w[3] = mechanics.b6.frameTranslation.frame_a.R.w[3];
//   mechanics.b6.body.frame_a.R.w[3] = mechanics.b6.frame_a.R.w[3];
//   mechanics.b6.body.frame_a.R.T[1,1] = mechanics.b6.frameTranslation.frame_a.R.T[1,1];
//   mechanics.b6.body.frame_a.R.T[1,1] = mechanics.b6.frame_a.R.T[1,1];
//   mechanics.b6.body.frame_a.R.T[1,2] = mechanics.b6.frameTranslation.frame_a.R.T[1,2];
//   mechanics.b6.body.frame_a.R.T[1,2] = mechanics.b6.frame_a.R.T[1,2];
//   mechanics.b6.body.frame_a.R.T[1,3] = mechanics.b6.frameTranslation.frame_a.R.T[1,3];
//   mechanics.b6.body.frame_a.R.T[1,3] = mechanics.b6.frame_a.R.T[1,3];
//   mechanics.b6.body.frame_a.R.T[2,1] = mechanics.b6.frameTranslation.frame_a.R.T[2,1];
//   mechanics.b6.body.frame_a.R.T[2,1] = mechanics.b6.frame_a.R.T[2,1];
//   mechanics.b6.body.frame_a.R.T[2,2] = mechanics.b6.frameTranslation.frame_a.R.T[2,2];
//   mechanics.b6.body.frame_a.R.T[2,2] = mechanics.b6.frame_a.R.T[2,2];
//   mechanics.b6.body.frame_a.R.T[2,3] = mechanics.b6.frameTranslation.frame_a.R.T[2,3];
//   mechanics.b6.body.frame_a.R.T[2,3] = mechanics.b6.frame_a.R.T[2,3];
//   mechanics.b6.body.frame_a.R.T[3,1] = mechanics.b6.frameTranslation.frame_a.R.T[3,1];
//   mechanics.b6.body.frame_a.R.T[3,1] = mechanics.b6.frame_a.R.T[3,1];
//   mechanics.b6.body.frame_a.R.T[3,2] = mechanics.b6.frameTranslation.frame_a.R.T[3,2];
//   mechanics.b6.body.frame_a.R.T[3,2] = mechanics.b6.frame_a.R.T[3,2];
//   mechanics.b6.body.frame_a.R.T[3,3] = mechanics.b6.frameTranslation.frame_a.R.T[3,3];
//   mechanics.b6.body.frame_a.R.T[3,3] = mechanics.b6.frame_a.R.T[3,3];
//   mechanics.b6.body.frame_a.r_0[1] = mechanics.b6.frameTranslation.frame_a.r_0[1];
//   mechanics.b6.body.frame_a.r_0[1] = mechanics.b6.frame_a.r_0[1];
//   mechanics.b6.body.frame_a.r_0[2] = mechanics.b6.frameTranslation.frame_a.r_0[2];
//   mechanics.b6.body.frame_a.r_0[2] = mechanics.b6.frame_a.r_0[2];
//   mechanics.b6.body.frame_a.r_0[3] = mechanics.b6.frameTranslation.frame_a.r_0[3];
//   mechanics.b6.body.frame_a.r_0[3] = mechanics.b6.frame_a.r_0[3];
//   (-mechanics.b6.frame_b.t[1]) + mechanics.b6.frameTranslation.frame_b.t[1] = 0.0;
//   (-mechanics.b6.frame_b.t[2]) + mechanics.b6.frameTranslation.frame_b.t[2] = 0.0;
//   (-mechanics.b6.frame_b.t[3]) + mechanics.b6.frameTranslation.frame_b.t[3] = 0.0;
//   (-mechanics.b6.frame_b.f[1]) + mechanics.b6.frameTranslation.frame_b.f[1] = 0.0;
//   (-mechanics.b6.frame_b.f[2]) + mechanics.b6.frameTranslation.frame_b.f[2] = 0.0;
//   (-mechanics.b6.frame_b.f[3]) + mechanics.b6.frameTranslation.frame_b.f[3] = 0.0;
//   mechanics.b6.frameTranslation.frame_b.R.w[1] = mechanics.b6.frame_b.R.w[1];
//   mechanics.b6.frameTranslation.frame_b.R.w[2] = mechanics.b6.frame_b.R.w[2];
//   mechanics.b6.frameTranslation.frame_b.R.w[3] = mechanics.b6.frame_b.R.w[3];
//   mechanics.b6.frameTranslation.frame_b.R.T[1,1] = mechanics.b6.frame_b.R.T[1,1];
//   mechanics.b6.frameTranslation.frame_b.R.T[1,2] = mechanics.b6.frame_b.R.T[1,2];
//   mechanics.b6.frameTranslation.frame_b.R.T[1,3] = mechanics.b6.frame_b.R.T[1,3];
//   mechanics.b6.frameTranslation.frame_b.R.T[2,1] = mechanics.b6.frame_b.R.T[2,1];
//   mechanics.b6.frameTranslation.frame_b.R.T[2,2] = mechanics.b6.frame_b.R.T[2,2];
//   mechanics.b6.frameTranslation.frame_b.R.T[2,3] = mechanics.b6.frame_b.R.T[2,3];
//   mechanics.b6.frameTranslation.frame_b.R.T[3,1] = mechanics.b6.frame_b.R.T[3,1];
//   mechanics.b6.frameTranslation.frame_b.R.T[3,2] = mechanics.b6.frame_b.R.T[3,2];
//   mechanics.b6.frameTranslation.frame_b.R.T[3,3] = mechanics.b6.frame_b.R.T[3,3];
//   mechanics.b6.frameTranslation.frame_b.r_0[1] = mechanics.b6.frame_b.r_0[1];
//   mechanics.b6.frameTranslation.frame_b.r_0[2] = mechanics.b6.frame_b.r_0[2];
//   mechanics.b6.frameTranslation.frame_b.r_0[3] = mechanics.b6.frame_b.r_0[3];
//   (-mechanics.b5.frame_a.t[1]) + (mechanics.b5.frameTranslation.frame_a.t[1] + mechanics.b5.body.frame_a.t[1]) = 0.0;
//   (-mechanics.b5.frame_a.t[2]) + (mechanics.b5.frameTranslation.frame_a.t[2] + mechanics.b5.body.frame_a.t[2]) = 0.0;
//   (-mechanics.b5.frame_a.t[3]) + (mechanics.b5.frameTranslation.frame_a.t[3] + mechanics.b5.body.frame_a.t[3]) = 0.0;
//   (-mechanics.b5.frame_a.f[1]) + (mechanics.b5.frameTranslation.frame_a.f[1] + mechanics.b5.body.frame_a.f[1]) = 0.0;
//   (-mechanics.b5.frame_a.f[2]) + (mechanics.b5.frameTranslation.frame_a.f[2] + mechanics.b5.body.frame_a.f[2]) = 0.0;
//   (-mechanics.b5.frame_a.f[3]) + (mechanics.b5.frameTranslation.frame_a.f[3] + mechanics.b5.body.frame_a.f[3]) = 0.0;
//   mechanics.b5.body.frame_a.R.w[1] = mechanics.b5.frameTranslation.frame_a.R.w[1];
//   mechanics.b5.body.frame_a.R.w[1] = mechanics.b5.frame_a.R.w[1];
//   mechanics.b5.body.frame_a.R.w[2] = mechanics.b5.frameTranslation.frame_a.R.w[2];
//   mechanics.b5.body.frame_a.R.w[2] = mechanics.b5.frame_a.R.w[2];
//   mechanics.b5.body.frame_a.R.w[3] = mechanics.b5.frameTranslation.frame_a.R.w[3];
//   mechanics.b5.body.frame_a.R.w[3] = mechanics.b5.frame_a.R.w[3];
//   mechanics.b5.body.frame_a.R.T[1,1] = mechanics.b5.frameTranslation.frame_a.R.T[1,1];
//   mechanics.b5.body.frame_a.R.T[1,1] = mechanics.b5.frame_a.R.T[1,1];
//   mechanics.b5.body.frame_a.R.T[1,2] = mechanics.b5.frameTranslation.frame_a.R.T[1,2];
//   mechanics.b5.body.frame_a.R.T[1,2] = mechanics.b5.frame_a.R.T[1,2];
//   mechanics.b5.body.frame_a.R.T[1,3] = mechanics.b5.frameTranslation.frame_a.R.T[1,3];
//   mechanics.b5.body.frame_a.R.T[1,3] = mechanics.b5.frame_a.R.T[1,3];
//   mechanics.b5.body.frame_a.R.T[2,1] = mechanics.b5.frameTranslation.frame_a.R.T[2,1];
//   mechanics.b5.body.frame_a.R.T[2,1] = mechanics.b5.frame_a.R.T[2,1];
//   mechanics.b5.body.frame_a.R.T[2,2] = mechanics.b5.frameTranslation.frame_a.R.T[2,2];
//   mechanics.b5.body.frame_a.R.T[2,2] = mechanics.b5.frame_a.R.T[2,2];
//   mechanics.b5.body.frame_a.R.T[2,3] = mechanics.b5.frameTranslation.frame_a.R.T[2,3];
//   mechanics.b5.body.frame_a.R.T[2,3] = mechanics.b5.frame_a.R.T[2,3];
//   mechanics.b5.body.frame_a.R.T[3,1] = mechanics.b5.frameTranslation.frame_a.R.T[3,1];
//   mechanics.b5.body.frame_a.R.T[3,1] = mechanics.b5.frame_a.R.T[3,1];
//   mechanics.b5.body.frame_a.R.T[3,2] = mechanics.b5.frameTranslation.frame_a.R.T[3,2];
//   mechanics.b5.body.frame_a.R.T[3,2] = mechanics.b5.frame_a.R.T[3,2];
//   mechanics.b5.body.frame_a.R.T[3,3] = mechanics.b5.frameTranslation.frame_a.R.T[3,3];
//   mechanics.b5.body.frame_a.R.T[3,3] = mechanics.b5.frame_a.R.T[3,3];
//   mechanics.b5.body.frame_a.r_0[1] = mechanics.b5.frameTranslation.frame_a.r_0[1];
//   mechanics.b5.body.frame_a.r_0[1] = mechanics.b5.frame_a.r_0[1];
//   mechanics.b5.body.frame_a.r_0[2] = mechanics.b5.frameTranslation.frame_a.r_0[2];
//   mechanics.b5.body.frame_a.r_0[2] = mechanics.b5.frame_a.r_0[2];
//   mechanics.b5.body.frame_a.r_0[3] = mechanics.b5.frameTranslation.frame_a.r_0[3];
//   mechanics.b5.body.frame_a.r_0[3] = mechanics.b5.frame_a.r_0[3];
//   (-mechanics.b5.frame_b.t[1]) + mechanics.b5.frameTranslation.frame_b.t[1] = 0.0;
//   (-mechanics.b5.frame_b.t[2]) + mechanics.b5.frameTranslation.frame_b.t[2] = 0.0;
//   (-mechanics.b5.frame_b.t[3]) + mechanics.b5.frameTranslation.frame_b.t[3] = 0.0;
//   (-mechanics.b5.frame_b.f[1]) + mechanics.b5.frameTranslation.frame_b.f[1] = 0.0;
//   (-mechanics.b5.frame_b.f[2]) + mechanics.b5.frameTranslation.frame_b.f[2] = 0.0;
//   (-mechanics.b5.frame_b.f[3]) + mechanics.b5.frameTranslation.frame_b.f[3] = 0.0;
//   mechanics.b5.frameTranslation.frame_b.R.w[1] = mechanics.b5.frame_b.R.w[1];
//   mechanics.b5.frameTranslation.frame_b.R.w[2] = mechanics.b5.frame_b.R.w[2];
//   mechanics.b5.frameTranslation.frame_b.R.w[3] = mechanics.b5.frame_b.R.w[3];
//   mechanics.b5.frameTranslation.frame_b.R.T[1,1] = mechanics.b5.frame_b.R.T[1,1];
//   mechanics.b5.frameTranslation.frame_b.R.T[1,2] = mechanics.b5.frame_b.R.T[1,2];
//   mechanics.b5.frameTranslation.frame_b.R.T[1,3] = mechanics.b5.frame_b.R.T[1,3];
//   mechanics.b5.frameTranslation.frame_b.R.T[2,1] = mechanics.b5.frame_b.R.T[2,1];
//   mechanics.b5.frameTranslation.frame_b.R.T[2,2] = mechanics.b5.frame_b.R.T[2,2];
//   mechanics.b5.frameTranslation.frame_b.R.T[2,3] = mechanics.b5.frame_b.R.T[2,3];
//   mechanics.b5.frameTranslation.frame_b.R.T[3,1] = mechanics.b5.frame_b.R.T[3,1];
//   mechanics.b5.frameTranslation.frame_b.R.T[3,2] = mechanics.b5.frame_b.R.T[3,2];
//   mechanics.b5.frameTranslation.frame_b.R.T[3,3] = mechanics.b5.frame_b.R.T[3,3];
//   mechanics.b5.frameTranslation.frame_b.r_0[1] = mechanics.b5.frame_b.r_0[1];
//   mechanics.b5.frameTranslation.frame_b.r_0[2] = mechanics.b5.frame_b.r_0[2];
//   mechanics.b5.frameTranslation.frame_b.r_0[3] = mechanics.b5.frame_b.r_0[3];
//   (-mechanics.b4.frame_a.t[1]) + (mechanics.b4.frameTranslation.frame_a.t[1] + mechanics.b4.body.frame_a.t[1]) = 0.0;
//   (-mechanics.b4.frame_a.t[2]) + (mechanics.b4.frameTranslation.frame_a.t[2] + mechanics.b4.body.frame_a.t[2]) = 0.0;
//   (-mechanics.b4.frame_a.t[3]) + (mechanics.b4.frameTranslation.frame_a.t[3] + mechanics.b4.body.frame_a.t[3]) = 0.0;
//   (-mechanics.b4.frame_a.f[1]) + (mechanics.b4.frameTranslation.frame_a.f[1] + mechanics.b4.body.frame_a.f[1]) = 0.0;
//   (-mechanics.b4.frame_a.f[2]) + (mechanics.b4.frameTranslation.frame_a.f[2] + mechanics.b4.body.frame_a.f[2]) = 0.0;
//   (-mechanics.b4.frame_a.f[3]) + (mechanics.b4.frameTranslation.frame_a.f[3] + mechanics.b4.body.frame_a.f[3]) = 0.0;
//   mechanics.b4.body.frame_a.R.w[1] = mechanics.b4.frameTranslation.frame_a.R.w[1];
//   mechanics.b4.body.frame_a.R.w[1] = mechanics.b4.frame_a.R.w[1];
//   mechanics.b4.body.frame_a.R.w[2] = mechanics.b4.frameTranslation.frame_a.R.w[2];
//   mechanics.b4.body.frame_a.R.w[2] = mechanics.b4.frame_a.R.w[2];
//   mechanics.b4.body.frame_a.R.w[3] = mechanics.b4.frameTranslation.frame_a.R.w[3];
//   mechanics.b4.body.frame_a.R.w[3] = mechanics.b4.frame_a.R.w[3];
//   mechanics.b4.body.frame_a.R.T[1,1] = mechanics.b4.frameTranslation.frame_a.R.T[1,1];
//   mechanics.b4.body.frame_a.R.T[1,1] = mechanics.b4.frame_a.R.T[1,1];
//   mechanics.b4.body.frame_a.R.T[1,2] = mechanics.b4.frameTranslation.frame_a.R.T[1,2];
//   mechanics.b4.body.frame_a.R.T[1,2] = mechanics.b4.frame_a.R.T[1,2];
//   mechanics.b4.body.frame_a.R.T[1,3] = mechanics.b4.frameTranslation.frame_a.R.T[1,3];
//   mechanics.b4.body.frame_a.R.T[1,3] = mechanics.b4.frame_a.R.T[1,3];
//   mechanics.b4.body.frame_a.R.T[2,1] = mechanics.b4.frameTranslation.frame_a.R.T[2,1];
//   mechanics.b4.body.frame_a.R.T[2,1] = mechanics.b4.frame_a.R.T[2,1];
//   mechanics.b4.body.frame_a.R.T[2,2] = mechanics.b4.frameTranslation.frame_a.R.T[2,2];
//   mechanics.b4.body.frame_a.R.T[2,2] = mechanics.b4.frame_a.R.T[2,2];
//   mechanics.b4.body.frame_a.R.T[2,3] = mechanics.b4.frameTranslation.frame_a.R.T[2,3];
//   mechanics.b4.body.frame_a.R.T[2,3] = mechanics.b4.frame_a.R.T[2,3];
//   mechanics.b4.body.frame_a.R.T[3,1] = mechanics.b4.frameTranslation.frame_a.R.T[3,1];
//   mechanics.b4.body.frame_a.R.T[3,1] = mechanics.b4.frame_a.R.T[3,1];
//   mechanics.b4.body.frame_a.R.T[3,2] = mechanics.b4.frameTranslation.frame_a.R.T[3,2];
//   mechanics.b4.body.frame_a.R.T[3,2] = mechanics.b4.frame_a.R.T[3,2];
//   mechanics.b4.body.frame_a.R.T[3,3] = mechanics.b4.frameTranslation.frame_a.R.T[3,3];
//   mechanics.b4.body.frame_a.R.T[3,3] = mechanics.b4.frame_a.R.T[3,3];
//   mechanics.b4.body.frame_a.r_0[1] = mechanics.b4.frameTranslation.frame_a.r_0[1];
//   mechanics.b4.body.frame_a.r_0[1] = mechanics.b4.frame_a.r_0[1];
//   mechanics.b4.body.frame_a.r_0[2] = mechanics.b4.frameTranslation.frame_a.r_0[2];
//   mechanics.b4.body.frame_a.r_0[2] = mechanics.b4.frame_a.r_0[2];
//   mechanics.b4.body.frame_a.r_0[3] = mechanics.b4.frameTranslation.frame_a.r_0[3];
//   mechanics.b4.body.frame_a.r_0[3] = mechanics.b4.frame_a.r_0[3];
//   (-mechanics.b4.frame_b.t[1]) + mechanics.b4.frameTranslation.frame_b.t[1] = 0.0;
//   (-mechanics.b4.frame_b.t[2]) + mechanics.b4.frameTranslation.frame_b.t[2] = 0.0;
//   (-mechanics.b4.frame_b.t[3]) + mechanics.b4.frameTranslation.frame_b.t[3] = 0.0;
//   (-mechanics.b4.frame_b.f[1]) + mechanics.b4.frameTranslation.frame_b.f[1] = 0.0;
//   (-mechanics.b4.frame_b.f[2]) + mechanics.b4.frameTranslation.frame_b.f[2] = 0.0;
//   (-mechanics.b4.frame_b.f[3]) + mechanics.b4.frameTranslation.frame_b.f[3] = 0.0;
//   mechanics.b4.frameTranslation.frame_b.R.w[1] = mechanics.b4.frame_b.R.w[1];
//   mechanics.b4.frameTranslation.frame_b.R.w[2] = mechanics.b4.frame_b.R.w[2];
//   mechanics.b4.frameTranslation.frame_b.R.w[3] = mechanics.b4.frame_b.R.w[3];
//   mechanics.b4.frameTranslation.frame_b.R.T[1,1] = mechanics.b4.frame_b.R.T[1,1];
//   mechanics.b4.frameTranslation.frame_b.R.T[1,2] = mechanics.b4.frame_b.R.T[1,2];
//   mechanics.b4.frameTranslation.frame_b.R.T[1,3] = mechanics.b4.frame_b.R.T[1,3];
//   mechanics.b4.frameTranslation.frame_b.R.T[2,1] = mechanics.b4.frame_b.R.T[2,1];
//   mechanics.b4.frameTranslation.frame_b.R.T[2,2] = mechanics.b4.frame_b.R.T[2,2];
//   mechanics.b4.frameTranslation.frame_b.R.T[2,3] = mechanics.b4.frame_b.R.T[2,3];
//   mechanics.b4.frameTranslation.frame_b.R.T[3,1] = mechanics.b4.frame_b.R.T[3,1];
//   mechanics.b4.frameTranslation.frame_b.R.T[3,2] = mechanics.b4.frame_b.R.T[3,2];
//   mechanics.b4.frameTranslation.frame_b.R.T[3,3] = mechanics.b4.frame_b.R.T[3,3];
//   mechanics.b4.frameTranslation.frame_b.r_0[1] = mechanics.b4.frame_b.r_0[1];
//   mechanics.b4.frameTranslation.frame_b.r_0[2] = mechanics.b4.frame_b.r_0[2];
//   mechanics.b4.frameTranslation.frame_b.r_0[3] = mechanics.b4.frame_b.r_0[3];
//   (-mechanics.b3.frame_a.t[1]) + (mechanics.b3.frameTranslation.frame_a.t[1] + mechanics.b3.body.frame_a.t[1]) = 0.0;
//   (-mechanics.b3.frame_a.t[2]) + (mechanics.b3.frameTranslation.frame_a.t[2] + mechanics.b3.body.frame_a.t[2]) = 0.0;
//   (-mechanics.b3.frame_a.t[3]) + (mechanics.b3.frameTranslation.frame_a.t[3] + mechanics.b3.body.frame_a.t[3]) = 0.0;
//   (-mechanics.b3.frame_a.f[1]) + (mechanics.b3.frameTranslation.frame_a.f[1] + mechanics.b3.body.frame_a.f[1]) = 0.0;
//   (-mechanics.b3.frame_a.f[2]) + (mechanics.b3.frameTranslation.frame_a.f[2] + mechanics.b3.body.frame_a.f[2]) = 0.0;
//   (-mechanics.b3.frame_a.f[3]) + (mechanics.b3.frameTranslation.frame_a.f[3] + mechanics.b3.body.frame_a.f[3]) = 0.0;
//   mechanics.b3.body.frame_a.R.w[1] = mechanics.b3.frameTranslation.frame_a.R.w[1];
//   mechanics.b3.body.frame_a.R.w[1] = mechanics.b3.frame_a.R.w[1];
//   mechanics.b3.body.frame_a.R.w[2] = mechanics.b3.frameTranslation.frame_a.R.w[2];
//   mechanics.b3.body.frame_a.R.w[2] = mechanics.b3.frame_a.R.w[2];
//   mechanics.b3.body.frame_a.R.w[3] = mechanics.b3.frameTranslation.frame_a.R.w[3];
//   mechanics.b3.body.frame_a.R.w[3] = mechanics.b3.frame_a.R.w[3];
//   mechanics.b3.body.frame_a.R.T[1,1] = mechanics.b3.frameTranslation.frame_a.R.T[1,1];
//   mechanics.b3.body.frame_a.R.T[1,1] = mechanics.b3.frame_a.R.T[1,1];
//   mechanics.b3.body.frame_a.R.T[1,2] = mechanics.b3.frameTranslation.frame_a.R.T[1,2];
//   mechanics.b3.body.frame_a.R.T[1,2] = mechanics.b3.frame_a.R.T[1,2];
//   mechanics.b3.body.frame_a.R.T[1,3] = mechanics.b3.frameTranslation.frame_a.R.T[1,3];
//   mechanics.b3.body.frame_a.R.T[1,3] = mechanics.b3.frame_a.R.T[1,3];
//   mechanics.b3.body.frame_a.R.T[2,1] = mechanics.b3.frameTranslation.frame_a.R.T[2,1];
//   mechanics.b3.body.frame_a.R.T[2,1] = mechanics.b3.frame_a.R.T[2,1];
//   mechanics.b3.body.frame_a.R.T[2,2] = mechanics.b3.frameTranslation.frame_a.R.T[2,2];
//   mechanics.b3.body.frame_a.R.T[2,2] = mechanics.b3.frame_a.R.T[2,2];
//   mechanics.b3.body.frame_a.R.T[2,3] = mechanics.b3.frameTranslation.frame_a.R.T[2,3];
//   mechanics.b3.body.frame_a.R.T[2,3] = mechanics.b3.frame_a.R.T[2,3];
//   mechanics.b3.body.frame_a.R.T[3,1] = mechanics.b3.frameTranslation.frame_a.R.T[3,1];
//   mechanics.b3.body.frame_a.R.T[3,1] = mechanics.b3.frame_a.R.T[3,1];
//   mechanics.b3.body.frame_a.R.T[3,2] = mechanics.b3.frameTranslation.frame_a.R.T[3,2];
//   mechanics.b3.body.frame_a.R.T[3,2] = mechanics.b3.frame_a.R.T[3,2];
//   mechanics.b3.body.frame_a.R.T[3,3] = mechanics.b3.frameTranslation.frame_a.R.T[3,3];
//   mechanics.b3.body.frame_a.R.T[3,3] = mechanics.b3.frame_a.R.T[3,3];
//   mechanics.b3.body.frame_a.r_0[1] = mechanics.b3.frameTranslation.frame_a.r_0[1];
//   mechanics.b3.body.frame_a.r_0[1] = mechanics.b3.frame_a.r_0[1];
//   mechanics.b3.body.frame_a.r_0[2] = mechanics.b3.frameTranslation.frame_a.r_0[2];
//   mechanics.b3.body.frame_a.r_0[2] = mechanics.b3.frame_a.r_0[2];
//   mechanics.b3.body.frame_a.r_0[3] = mechanics.b3.frameTranslation.frame_a.r_0[3];
//   mechanics.b3.body.frame_a.r_0[3] = mechanics.b3.frame_a.r_0[3];
//   (-mechanics.b3.frame_b.t[1]) + mechanics.b3.frameTranslation.frame_b.t[1] = 0.0;
//   (-mechanics.b3.frame_b.t[2]) + mechanics.b3.frameTranslation.frame_b.t[2] = 0.0;
//   (-mechanics.b3.frame_b.t[3]) + mechanics.b3.frameTranslation.frame_b.t[3] = 0.0;
//   (-mechanics.b3.frame_b.f[1]) + mechanics.b3.frameTranslation.frame_b.f[1] = 0.0;
//   (-mechanics.b3.frame_b.f[2]) + mechanics.b3.frameTranslation.frame_b.f[2] = 0.0;
//   (-mechanics.b3.frame_b.f[3]) + mechanics.b3.frameTranslation.frame_b.f[3] = 0.0;
//   mechanics.b3.frameTranslation.frame_b.R.w[1] = mechanics.b3.frame_b.R.w[1];
//   mechanics.b3.frameTranslation.frame_b.R.w[2] = mechanics.b3.frame_b.R.w[2];
//   mechanics.b3.frameTranslation.frame_b.R.w[3] = mechanics.b3.frame_b.R.w[3];
//   mechanics.b3.frameTranslation.frame_b.R.T[1,1] = mechanics.b3.frame_b.R.T[1,1];
//   mechanics.b3.frameTranslation.frame_b.R.T[1,2] = mechanics.b3.frame_b.R.T[1,2];
//   mechanics.b3.frameTranslation.frame_b.R.T[1,3] = mechanics.b3.frame_b.R.T[1,3];
//   mechanics.b3.frameTranslation.frame_b.R.T[2,1] = mechanics.b3.frame_b.R.T[2,1];
//   mechanics.b3.frameTranslation.frame_b.R.T[2,2] = mechanics.b3.frame_b.R.T[2,2];
//   mechanics.b3.frameTranslation.frame_b.R.T[2,3] = mechanics.b3.frame_b.R.T[2,3];
//   mechanics.b3.frameTranslation.frame_b.R.T[3,1] = mechanics.b3.frame_b.R.T[3,1];
//   mechanics.b3.frameTranslation.frame_b.R.T[3,2] = mechanics.b3.frame_b.R.T[3,2];
//   mechanics.b3.frameTranslation.frame_b.R.T[3,3] = mechanics.b3.frame_b.R.T[3,3];
//   mechanics.b3.frameTranslation.frame_b.r_0[1] = mechanics.b3.frame_b.r_0[1];
//   mechanics.b3.frameTranslation.frame_b.r_0[2] = mechanics.b3.frame_b.r_0[2];
//   mechanics.b3.frameTranslation.frame_b.r_0[3] = mechanics.b3.frame_b.r_0[3];
//   (-mechanics.b2.frame_a.t[1]) + (mechanics.b2.frameTranslation.frame_a.t[1] + mechanics.b2.body.frame_a.t[1]) = 0.0;
//   (-mechanics.b2.frame_a.t[2]) + (mechanics.b2.frameTranslation.frame_a.t[2] + mechanics.b2.body.frame_a.t[2]) = 0.0;
//   (-mechanics.b2.frame_a.t[3]) + (mechanics.b2.frameTranslation.frame_a.t[3] + mechanics.b2.body.frame_a.t[3]) = 0.0;
//   (-mechanics.b2.frame_a.f[1]) + (mechanics.b2.frameTranslation.frame_a.f[1] + mechanics.b2.body.frame_a.f[1]) = 0.0;
//   (-mechanics.b2.frame_a.f[2]) + (mechanics.b2.frameTranslation.frame_a.f[2] + mechanics.b2.body.frame_a.f[2]) = 0.0;
//   (-mechanics.b2.frame_a.f[3]) + (mechanics.b2.frameTranslation.frame_a.f[3] + mechanics.b2.body.frame_a.f[3]) = 0.0;
//   mechanics.b2.body.frame_a.R.w[1] = mechanics.b2.frameTranslation.frame_a.R.w[1];
//   mechanics.b2.body.frame_a.R.w[1] = mechanics.b2.frame_a.R.w[1];
//   mechanics.b2.body.frame_a.R.w[2] = mechanics.b2.frameTranslation.frame_a.R.w[2];
//   mechanics.b2.body.frame_a.R.w[2] = mechanics.b2.frame_a.R.w[2];
//   mechanics.b2.body.frame_a.R.w[3] = mechanics.b2.frameTranslation.frame_a.R.w[3];
//   mechanics.b2.body.frame_a.R.w[3] = mechanics.b2.frame_a.R.w[3];
//   mechanics.b2.body.frame_a.R.T[1,1] = mechanics.b2.frameTranslation.frame_a.R.T[1,1];
//   mechanics.b2.body.frame_a.R.T[1,1] = mechanics.b2.frame_a.R.T[1,1];
//   mechanics.b2.body.frame_a.R.T[1,2] = mechanics.b2.frameTranslation.frame_a.R.T[1,2];
//   mechanics.b2.body.frame_a.R.T[1,2] = mechanics.b2.frame_a.R.T[1,2];
//   mechanics.b2.body.frame_a.R.T[1,3] = mechanics.b2.frameTranslation.frame_a.R.T[1,3];
//   mechanics.b2.body.frame_a.R.T[1,3] = mechanics.b2.frame_a.R.T[1,3];
//   mechanics.b2.body.frame_a.R.T[2,1] = mechanics.b2.frameTranslation.frame_a.R.T[2,1];
//   mechanics.b2.body.frame_a.R.T[2,1] = mechanics.b2.frame_a.R.T[2,1];
//   mechanics.b2.body.frame_a.R.T[2,2] = mechanics.b2.frameTranslation.frame_a.R.T[2,2];
//   mechanics.b2.body.frame_a.R.T[2,2] = mechanics.b2.frame_a.R.T[2,2];
//   mechanics.b2.body.frame_a.R.T[2,3] = mechanics.b2.frameTranslation.frame_a.R.T[2,3];
//   mechanics.b2.body.frame_a.R.T[2,3] = mechanics.b2.frame_a.R.T[2,3];
//   mechanics.b2.body.frame_a.R.T[3,1] = mechanics.b2.frameTranslation.frame_a.R.T[3,1];
//   mechanics.b2.body.frame_a.R.T[3,1] = mechanics.b2.frame_a.R.T[3,1];
//   mechanics.b2.body.frame_a.R.T[3,2] = mechanics.b2.frameTranslation.frame_a.R.T[3,2];
//   mechanics.b2.body.frame_a.R.T[3,2] = mechanics.b2.frame_a.R.T[3,2];
//   mechanics.b2.body.frame_a.R.T[3,3] = mechanics.b2.frameTranslation.frame_a.R.T[3,3];
//   mechanics.b2.body.frame_a.R.T[3,3] = mechanics.b2.frame_a.R.T[3,3];
//   mechanics.b2.body.frame_a.r_0[1] = mechanics.b2.frameTranslation.frame_a.r_0[1];
//   mechanics.b2.body.frame_a.r_0[1] = mechanics.b2.frame_a.r_0[1];
//   mechanics.b2.body.frame_a.r_0[2] = mechanics.b2.frameTranslation.frame_a.r_0[2];
//   mechanics.b2.body.frame_a.r_0[2] = mechanics.b2.frame_a.r_0[2];
//   mechanics.b2.body.frame_a.r_0[3] = mechanics.b2.frameTranslation.frame_a.r_0[3];
//   mechanics.b2.body.frame_a.r_0[3] = mechanics.b2.frame_a.r_0[3];
//   (-mechanics.b2.frame_b.t[1]) + mechanics.b2.frameTranslation.frame_b.t[1] = 0.0;
//   (-mechanics.b2.frame_b.t[2]) + mechanics.b2.frameTranslation.frame_b.t[2] = 0.0;
//   (-mechanics.b2.frame_b.t[3]) + mechanics.b2.frameTranslation.frame_b.t[3] = 0.0;
//   (-mechanics.b2.frame_b.f[1]) + mechanics.b2.frameTranslation.frame_b.f[1] = 0.0;
//   (-mechanics.b2.frame_b.f[2]) + mechanics.b2.frameTranslation.frame_b.f[2] = 0.0;
//   (-mechanics.b2.frame_b.f[3]) + mechanics.b2.frameTranslation.frame_b.f[3] = 0.0;
//   mechanics.b2.frameTranslation.frame_b.R.w[1] = mechanics.b2.frame_b.R.w[1];
//   mechanics.b2.frameTranslation.frame_b.R.w[2] = mechanics.b2.frame_b.R.w[2];
//   mechanics.b2.frameTranslation.frame_b.R.w[3] = mechanics.b2.frame_b.R.w[3];
//   mechanics.b2.frameTranslation.frame_b.R.T[1,1] = mechanics.b2.frame_b.R.T[1,1];
//   mechanics.b2.frameTranslation.frame_b.R.T[1,2] = mechanics.b2.frame_b.R.T[1,2];
//   mechanics.b2.frameTranslation.frame_b.R.T[1,3] = mechanics.b2.frame_b.R.T[1,3];
//   mechanics.b2.frameTranslation.frame_b.R.T[2,1] = mechanics.b2.frame_b.R.T[2,1];
//   mechanics.b2.frameTranslation.frame_b.R.T[2,2] = mechanics.b2.frame_b.R.T[2,2];
//   mechanics.b2.frameTranslation.frame_b.R.T[2,3] = mechanics.b2.frame_b.R.T[2,3];
//   mechanics.b2.frameTranslation.frame_b.R.T[3,1] = mechanics.b2.frame_b.R.T[3,1];
//   mechanics.b2.frameTranslation.frame_b.R.T[3,2] = mechanics.b2.frame_b.R.T[3,2];
//   mechanics.b2.frameTranslation.frame_b.R.T[3,3] = mechanics.b2.frame_b.R.T[3,3];
//   mechanics.b2.frameTranslation.frame_b.r_0[1] = mechanics.b2.frame_b.r_0[1];
//   mechanics.b2.frameTranslation.frame_b.r_0[2] = mechanics.b2.frame_b.r_0[2];
//   mechanics.b2.frameTranslation.frame_b.r_0[3] = mechanics.b2.frame_b.r_0[3];
//   (-mechanics.b1.frame_a.t[1]) + (mechanics.b1.frameTranslation.frame_a.t[1] + mechanics.b1.body.frame_a.t[1]) = 0.0;
//   (-mechanics.b1.frame_a.t[2]) + (mechanics.b1.frameTranslation.frame_a.t[2] + mechanics.b1.body.frame_a.t[2]) = 0.0;
//   (-mechanics.b1.frame_a.t[3]) + (mechanics.b1.frameTranslation.frame_a.t[3] + mechanics.b1.body.frame_a.t[3]) = 0.0;
//   (-mechanics.b1.frame_a.f[1]) + (mechanics.b1.frameTranslation.frame_a.f[1] + mechanics.b1.body.frame_a.f[1]) = 0.0;
//   (-mechanics.b1.frame_a.f[2]) + (mechanics.b1.frameTranslation.frame_a.f[2] + mechanics.b1.body.frame_a.f[2]) = 0.0;
//   (-mechanics.b1.frame_a.f[3]) + (mechanics.b1.frameTranslation.frame_a.f[3] + mechanics.b1.body.frame_a.f[3]) = 0.0;
//   mechanics.b1.body.frame_a.R.w[1] = mechanics.b1.frameTranslation.frame_a.R.w[1];
//   mechanics.b1.body.frame_a.R.w[1] = mechanics.b1.frame_a.R.w[1];
//   mechanics.b1.body.frame_a.R.w[2] = mechanics.b1.frameTranslation.frame_a.R.w[2];
//   mechanics.b1.body.frame_a.R.w[2] = mechanics.b1.frame_a.R.w[2];
//   mechanics.b1.body.frame_a.R.w[3] = mechanics.b1.frameTranslation.frame_a.R.w[3];
//   mechanics.b1.body.frame_a.R.w[3] = mechanics.b1.frame_a.R.w[3];
//   mechanics.b1.body.frame_a.R.T[1,1] = mechanics.b1.frameTranslation.frame_a.R.T[1,1];
//   mechanics.b1.body.frame_a.R.T[1,1] = mechanics.b1.frame_a.R.T[1,1];
//   mechanics.b1.body.frame_a.R.T[1,2] = mechanics.b1.frameTranslation.frame_a.R.T[1,2];
//   mechanics.b1.body.frame_a.R.T[1,2] = mechanics.b1.frame_a.R.T[1,2];
//   mechanics.b1.body.frame_a.R.T[1,3] = mechanics.b1.frameTranslation.frame_a.R.T[1,3];
//   mechanics.b1.body.frame_a.R.T[1,3] = mechanics.b1.frame_a.R.T[1,3];
//   mechanics.b1.body.frame_a.R.T[2,1] = mechanics.b1.frameTranslation.frame_a.R.T[2,1];
//   mechanics.b1.body.frame_a.R.T[2,1] = mechanics.b1.frame_a.R.T[2,1];
//   mechanics.b1.body.frame_a.R.T[2,2] = mechanics.b1.frameTranslation.frame_a.R.T[2,2];
//   mechanics.b1.body.frame_a.R.T[2,2] = mechanics.b1.frame_a.R.T[2,2];
//   mechanics.b1.body.frame_a.R.T[2,3] = mechanics.b1.frameTranslation.frame_a.R.T[2,3];
//   mechanics.b1.body.frame_a.R.T[2,3] = mechanics.b1.frame_a.R.T[2,3];
//   mechanics.b1.body.frame_a.R.T[3,1] = mechanics.b1.frameTranslation.frame_a.R.T[3,1];
//   mechanics.b1.body.frame_a.R.T[3,1] = mechanics.b1.frame_a.R.T[3,1];
//   mechanics.b1.body.frame_a.R.T[3,2] = mechanics.b1.frameTranslation.frame_a.R.T[3,2];
//   mechanics.b1.body.frame_a.R.T[3,2] = mechanics.b1.frame_a.R.T[3,2];
//   mechanics.b1.body.frame_a.R.T[3,3] = mechanics.b1.frameTranslation.frame_a.R.T[3,3];
//   mechanics.b1.body.frame_a.R.T[3,3] = mechanics.b1.frame_a.R.T[3,3];
//   mechanics.b1.body.frame_a.r_0[1] = mechanics.b1.frameTranslation.frame_a.r_0[1];
//   mechanics.b1.body.frame_a.r_0[1] = mechanics.b1.frame_a.r_0[1];
//   mechanics.b1.body.frame_a.r_0[2] = mechanics.b1.frameTranslation.frame_a.r_0[2];
//   mechanics.b1.body.frame_a.r_0[2] = mechanics.b1.frame_a.r_0[2];
//   mechanics.b1.body.frame_a.r_0[3] = mechanics.b1.frameTranslation.frame_a.r_0[3];
//   mechanics.b1.body.frame_a.r_0[3] = mechanics.b1.frame_a.r_0[3];
//   (-mechanics.b1.frame_b.t[1]) + mechanics.b1.frameTranslation.frame_b.t[1] = 0.0;
//   (-mechanics.b1.frame_b.t[2]) + mechanics.b1.frameTranslation.frame_b.t[2] = 0.0;
//   (-mechanics.b1.frame_b.t[3]) + mechanics.b1.frameTranslation.frame_b.t[3] = 0.0;
//   (-mechanics.b1.frame_b.f[1]) + mechanics.b1.frameTranslation.frame_b.f[1] = 0.0;
//   (-mechanics.b1.frame_b.f[2]) + mechanics.b1.frameTranslation.frame_b.f[2] = 0.0;
//   (-mechanics.b1.frame_b.f[3]) + mechanics.b1.frameTranslation.frame_b.f[3] = 0.0;
//   mechanics.b1.frameTranslation.frame_b.R.w[1] = mechanics.b1.frame_b.R.w[1];
//   mechanics.b1.frameTranslation.frame_b.R.w[2] = mechanics.b1.frame_b.R.w[2];
//   mechanics.b1.frameTranslation.frame_b.R.w[3] = mechanics.b1.frame_b.R.w[3];
//   mechanics.b1.frameTranslation.frame_b.R.T[1,1] = mechanics.b1.frame_b.R.T[1,1];
//   mechanics.b1.frameTranslation.frame_b.R.T[1,2] = mechanics.b1.frame_b.R.T[1,2];
//   mechanics.b1.frameTranslation.frame_b.R.T[1,3] = mechanics.b1.frame_b.R.T[1,3];
//   mechanics.b1.frameTranslation.frame_b.R.T[2,1] = mechanics.b1.frame_b.R.T[2,1];
//   mechanics.b1.frameTranslation.frame_b.R.T[2,2] = mechanics.b1.frame_b.R.T[2,2];
//   mechanics.b1.frameTranslation.frame_b.R.T[2,3] = mechanics.b1.frame_b.R.T[2,3];
//   mechanics.b1.frameTranslation.frame_b.R.T[3,1] = mechanics.b1.frame_b.R.T[3,1];
//   mechanics.b1.frameTranslation.frame_b.R.T[3,2] = mechanics.b1.frame_b.R.T[3,2];
//   mechanics.b1.frameTranslation.frame_b.R.T[3,3] = mechanics.b1.frame_b.R.T[3,3];
//   mechanics.b1.frameTranslation.frame_b.r_0[1] = mechanics.b1.frame_b.r_0[1];
//   mechanics.b1.frameTranslation.frame_b.r_0[2] = mechanics.b1.frame_b.r_0[2];
//   mechanics.b1.frameTranslation.frame_b.r_0[3] = mechanics.b1.frame_b.r_0[3];
//   (-mechanics.b0.frame_a.t[1]) + (mechanics.b0.frameTranslation.frame_a.t[1] + mechanics.b0.body.frame_a.t[1]) = 0.0;
//   (-mechanics.b0.frame_a.t[2]) + (mechanics.b0.frameTranslation.frame_a.t[2] + mechanics.b0.body.frame_a.t[2]) = 0.0;
//   (-mechanics.b0.frame_a.t[3]) + (mechanics.b0.frameTranslation.frame_a.t[3] + mechanics.b0.body.frame_a.t[3]) = 0.0;
//   (-mechanics.b0.frame_a.f[1]) + (mechanics.b0.frameTranslation.frame_a.f[1] + mechanics.b0.body.frame_a.f[1]) = 0.0;
//   (-mechanics.b0.frame_a.f[2]) + (mechanics.b0.frameTranslation.frame_a.f[2] + mechanics.b0.body.frame_a.f[2]) = 0.0;
//   (-mechanics.b0.frame_a.f[3]) + (mechanics.b0.frameTranslation.frame_a.f[3] + mechanics.b0.body.frame_a.f[3]) = 0.0;
//   mechanics.b0.body.frame_a.R.w[1] = mechanics.b0.frameTranslation.frame_a.R.w[1];
//   mechanics.b0.body.frame_a.R.w[1] = mechanics.b0.frame_a.R.w[1];
//   mechanics.b0.body.frame_a.R.w[2] = mechanics.b0.frameTranslation.frame_a.R.w[2];
//   mechanics.b0.body.frame_a.R.w[2] = mechanics.b0.frame_a.R.w[2];
//   mechanics.b0.body.frame_a.R.w[3] = mechanics.b0.frameTranslation.frame_a.R.w[3];
//   mechanics.b0.body.frame_a.R.w[3] = mechanics.b0.frame_a.R.w[3];
//   mechanics.b0.body.frame_a.R.T[1,1] = mechanics.b0.frameTranslation.frame_a.R.T[1,1];
//   mechanics.b0.body.frame_a.R.T[1,1] = mechanics.b0.frame_a.R.T[1,1];
//   mechanics.b0.body.frame_a.R.T[1,2] = mechanics.b0.frameTranslation.frame_a.R.T[1,2];
//   mechanics.b0.body.frame_a.R.T[1,2] = mechanics.b0.frame_a.R.T[1,2];
//   mechanics.b0.body.frame_a.R.T[1,3] = mechanics.b0.frameTranslation.frame_a.R.T[1,3];
//   mechanics.b0.body.frame_a.R.T[1,3] = mechanics.b0.frame_a.R.T[1,3];
//   mechanics.b0.body.frame_a.R.T[2,1] = mechanics.b0.frameTranslation.frame_a.R.T[2,1];
//   mechanics.b0.body.frame_a.R.T[2,1] = mechanics.b0.frame_a.R.T[2,1];
//   mechanics.b0.body.frame_a.R.T[2,2] = mechanics.b0.frameTranslation.frame_a.R.T[2,2];
//   mechanics.b0.body.frame_a.R.T[2,2] = mechanics.b0.frame_a.R.T[2,2];
//   mechanics.b0.body.frame_a.R.T[2,3] = mechanics.b0.frameTranslation.frame_a.R.T[2,3];
//   mechanics.b0.body.frame_a.R.T[2,3] = mechanics.b0.frame_a.R.T[2,3];
//   mechanics.b0.body.frame_a.R.T[3,1] = mechanics.b0.frameTranslation.frame_a.R.T[3,1];
//   mechanics.b0.body.frame_a.R.T[3,1] = mechanics.b0.frame_a.R.T[3,1];
//   mechanics.b0.body.frame_a.R.T[3,2] = mechanics.b0.frameTranslation.frame_a.R.T[3,2];
//   mechanics.b0.body.frame_a.R.T[3,2] = mechanics.b0.frame_a.R.T[3,2];
//   mechanics.b0.body.frame_a.R.T[3,3] = mechanics.b0.frameTranslation.frame_a.R.T[3,3];
//   mechanics.b0.body.frame_a.R.T[3,3] = mechanics.b0.frame_a.R.T[3,3];
//   mechanics.b0.body.frame_a.r_0[1] = mechanics.b0.frameTranslation.frame_a.r_0[1];
//   mechanics.b0.body.frame_a.r_0[1] = mechanics.b0.frame_a.r_0[1];
//   mechanics.b0.body.frame_a.r_0[2] = mechanics.b0.frameTranslation.frame_a.r_0[2];
//   mechanics.b0.body.frame_a.r_0[2] = mechanics.b0.frame_a.r_0[2];
//   mechanics.b0.body.frame_a.r_0[3] = mechanics.b0.frameTranslation.frame_a.r_0[3];
//   mechanics.b0.body.frame_a.r_0[3] = mechanics.b0.frame_a.r_0[3];
//   (-mechanics.b0.frame_b.t[1]) + mechanics.b0.frameTranslation.frame_b.t[1] = 0.0;
//   (-mechanics.b0.frame_b.t[2]) + mechanics.b0.frameTranslation.frame_b.t[2] = 0.0;
//   (-mechanics.b0.frame_b.t[3]) + mechanics.b0.frameTranslation.frame_b.t[3] = 0.0;
//   (-mechanics.b0.frame_b.f[1]) + mechanics.b0.frameTranslation.frame_b.f[1] = 0.0;
//   (-mechanics.b0.frame_b.f[2]) + mechanics.b0.frameTranslation.frame_b.f[2] = 0.0;
//   (-mechanics.b0.frame_b.f[3]) + mechanics.b0.frameTranslation.frame_b.f[3] = 0.0;
//   mechanics.b0.frameTranslation.frame_b.R.w[1] = mechanics.b0.frame_b.R.w[1];
//   mechanics.b0.frameTranslation.frame_b.R.w[2] = mechanics.b0.frame_b.R.w[2];
//   mechanics.b0.frameTranslation.frame_b.R.w[3] = mechanics.b0.frame_b.R.w[3];
//   mechanics.b0.frameTranslation.frame_b.R.T[1,1] = mechanics.b0.frame_b.R.T[1,1];
//   mechanics.b0.frameTranslation.frame_b.R.T[1,2] = mechanics.b0.frame_b.R.T[1,2];
//   mechanics.b0.frameTranslation.frame_b.R.T[1,3] = mechanics.b0.frame_b.R.T[1,3];
//   mechanics.b0.frameTranslation.frame_b.R.T[2,1] = mechanics.b0.frame_b.R.T[2,1];
//   mechanics.b0.frameTranslation.frame_b.R.T[2,2] = mechanics.b0.frame_b.R.T[2,2];
//   mechanics.b0.frameTranslation.frame_b.R.T[2,3] = mechanics.b0.frame_b.R.T[2,3];
//   mechanics.b0.frameTranslation.frame_b.R.T[3,1] = mechanics.b0.frame_b.R.T[3,1];
//   mechanics.b0.frameTranslation.frame_b.R.T[3,2] = mechanics.b0.frame_b.R.T[3,2];
//   mechanics.b0.frameTranslation.frame_b.R.T[3,3] = mechanics.b0.frame_b.R.T[3,3];
//   mechanics.b0.frameTranslation.frame_b.r_0[1] = mechanics.b0.frame_b.r_0[1];
//   mechanics.b0.frameTranslation.frame_b.r_0[2] = mechanics.b0.frame_b.r_0[2];
//   mechanics.b0.frameTranslation.frame_b.r_0[3] = mechanics.b0.frame_b.r_0[3];
//   mechanics.r6.internalAxis.flange.tau + (-mechanics.r6.axis.tau) = 0.0;
//   mechanics.r6.axis.phi = mechanics.r6.internalAxis.flange.phi;
//   mechanics.r6.fixed.flange.tau + (-mechanics.r6.support.tau) = 0.0;
//   mechanics.r6.fixed.flange.phi = mechanics.r6.support.phi;
//   mechanics.r6.support.tau = 0.0;
//   mechanics.r5.internalAxis.flange.tau + (-mechanics.r5.axis.tau) = 0.0;
//   mechanics.r5.axis.phi = mechanics.r5.internalAxis.flange.phi;
//   mechanics.r5.fixed.flange.tau + (-mechanics.r5.support.tau) = 0.0;
//   mechanics.r5.fixed.flange.phi = mechanics.r5.support.phi;
//   mechanics.r5.support.tau = 0.0;
//   mechanics.r4.internalAxis.flange.tau + (-mechanics.r4.axis.tau) = 0.0;
//   mechanics.r4.axis.phi = mechanics.r4.internalAxis.flange.phi;
//   mechanics.r4.fixed.flange.tau + (-mechanics.r4.support.tau) = 0.0;
//   mechanics.r4.fixed.flange.phi = mechanics.r4.support.phi;
//   mechanics.r4.support.tau = 0.0;
//   mechanics.r3.internalAxis.flange.tau + (-mechanics.r3.axis.tau) = 0.0;
//   mechanics.r3.axis.phi = mechanics.r3.internalAxis.flange.phi;
//   mechanics.r3.fixed.flange.tau + (-mechanics.r3.support.tau) = 0.0;
//   mechanics.r3.fixed.flange.phi = mechanics.r3.support.phi;
//   mechanics.r3.support.tau = 0.0;
//   mechanics.r2.internalAxis.flange.tau + (-mechanics.r2.axis.tau) = 0.0;
//   mechanics.r2.axis.phi = mechanics.r2.internalAxis.flange.phi;
//   mechanics.r2.fixed.flange.tau + (-mechanics.r2.support.tau) = 0.0;
//   mechanics.r2.fixed.flange.phi = mechanics.r2.support.phi;
//   mechanics.r2.support.tau = 0.0;
//   mechanics.r1.internalAxis.flange.tau + (-mechanics.r1.axis.tau) = 0.0;
//   mechanics.r1.axis.phi = mechanics.r1.internalAxis.flange.phi;
//   mechanics.r1.fixed.flange.tau + (-mechanics.r1.support.tau) = 0.0;
//   mechanics.r1.fixed.flange.phi = mechanics.r1.support.phi;
//   mechanics.r1.support.tau = 0.0;
// end Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.fullRobot;
// "
// "[parts.mo:975:5-978:76:writable] Warning: Variable mechanics.b0.r_0: Non-array modification 'if mechanics.b0.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:979:5-982:76:writable] Warning: Variable mechanics.b0.v_0: Non-array modification 'if mechanics.b0.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:600:5-603:76:writable] Warning: Variable mechanics.b0.body.r_0: Non-array modification 'if mechanics.b0.body.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:604:5-607:76:writable] Warning: Variable mechanics.b0.body.v_0: Non-array modification 'if mechanics.b0.body.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:682:5-686:65:writable] Warning: Variable mechanics.b0.body.w_a: Non-array modification 'if mechanics.b0.body.enforceStates then if mechanics.b0.body.useQuaternions then StateSelect.always else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:697:5-700:119:writable] Warning: Variable mechanics.b0.body.Q: Non-array modification 'if mechanics.b0.body.enforceStates then if mechanics.b0.body.useQuaternions then StateSelect.prefer else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:708:5-711:69:writable] Warning: Variable mechanics.b0.body.phi: Non-array modification 'if mechanics.b0.body.enforceStates then if mechanics.b0.body.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:712:5-714:42:writable] Warning: Variable mechanics.b0.body.phi_d: Non-array modification 'if mechanics.b0.body.enforceStates then if mechanics.b0.body.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:975:5-978:76:writable] Warning: Variable mechanics.b1.r_0: Non-array modification 'if mechanics.b1.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:979:5-982:76:writable] Warning: Variable mechanics.b1.v_0: Non-array modification 'if mechanics.b1.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:600:5-603:76:writable] Warning: Variable mechanics.b1.body.r_0: Non-array modification 'if mechanics.b1.body.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:604:5-607:76:writable] Warning: Variable mechanics.b1.body.v_0: Non-array modification 'if mechanics.b1.body.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:682:5-686:65:writable] Warning: Variable mechanics.b1.body.w_a: Non-array modification 'if mechanics.b1.body.enforceStates then if mechanics.b1.body.useQuaternions then StateSelect.always else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:697:5-700:119:writable] Warning: Variable mechanics.b1.body.Q: Non-array modification 'if mechanics.b1.body.enforceStates then if mechanics.b1.body.useQuaternions then StateSelect.prefer else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:708:5-711:69:writable] Warning: Variable mechanics.b1.body.phi: Non-array modification 'if mechanics.b1.body.enforceStates then if mechanics.b1.body.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:712:5-714:42:writable] Warning: Variable mechanics.b1.body.phi_d: Non-array modification 'if mechanics.b1.body.enforceStates then if mechanics.b1.body.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:975:5-978:76:writable] Warning: Variable mechanics.b2.r_0: Non-array modification 'if mechanics.b2.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:979:5-982:76:writable] Warning: Variable mechanics.b2.v_0: Non-array modification 'if mechanics.b2.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:600:5-603:76:writable] Warning: Variable mechanics.b2.body.r_0: Non-array modification 'if mechanics.b2.body.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:604:5-607:76:writable] Warning: Variable mechanics.b2.body.v_0: Non-array modification 'if mechanics.b2.body.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:682:5-686:65:writable] Warning: Variable mechanics.b2.body.w_a: Non-array modification 'if mechanics.b2.body.enforceStates then if mechanics.b2.body.useQuaternions then StateSelect.always else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:697:5-700:119:writable] Warning: Variable mechanics.b2.body.Q: Non-array modification 'if mechanics.b2.body.enforceStates then if mechanics.b2.body.useQuaternions then StateSelect.prefer else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:708:5-711:69:writable] Warning: Variable mechanics.b2.body.phi: Non-array modification 'if mechanics.b2.body.enforceStates then if mechanics.b2.body.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:712:5-714:42:writable] Warning: Variable mechanics.b2.body.phi_d: Non-array modification 'if mechanics.b2.body.enforceStates then if mechanics.b2.body.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:975:5-978:76:writable] Warning: Variable mechanics.b3.r_0: Non-array modification 'if mechanics.b3.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:979:5-982:76:writable] Warning: Variable mechanics.b3.v_0: Non-array modification 'if mechanics.b3.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:600:5-603:76:writable] Warning: Variable mechanics.b3.body.r_0: Non-array modification 'if mechanics.b3.body.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:604:5-607:76:writable] Warning: Variable mechanics.b3.body.v_0: Non-array modification 'if mechanics.b3.body.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:682:5-686:65:writable] Warning: Variable mechanics.b3.body.w_a: Non-array modification 'if mechanics.b3.body.enforceStates then if mechanics.b3.body.useQuaternions then StateSelect.always else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:697:5-700:119:writable] Warning: Variable mechanics.b3.body.Q: Non-array modification 'if mechanics.b3.body.enforceStates then if mechanics.b3.body.useQuaternions then StateSelect.prefer else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:708:5-711:69:writable] Warning: Variable mechanics.b3.body.phi: Non-array modification 'if mechanics.b3.body.enforceStates then if mechanics.b3.body.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:712:5-714:42:writable] Warning: Variable mechanics.b3.body.phi_d: Non-array modification 'if mechanics.b3.body.enforceStates then if mechanics.b3.body.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:975:5-978:76:writable] Warning: Variable mechanics.b4.r_0: Non-array modification 'if mechanics.b4.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:979:5-982:76:writable] Warning: Variable mechanics.b4.v_0: Non-array modification 'if mechanics.b4.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:600:5-603:76:writable] Warning: Variable mechanics.b4.body.r_0: Non-array modification 'if mechanics.b4.body.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:604:5-607:76:writable] Warning: Variable mechanics.b4.body.v_0: Non-array modification 'if mechanics.b4.body.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:682:5-686:65:writable] Warning: Variable mechanics.b4.body.w_a: Non-array modification 'if mechanics.b4.body.enforceStates then if mechanics.b4.body.useQuaternions then StateSelect.always else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:697:5-700:119:writable] Warning: Variable mechanics.b4.body.Q: Non-array modification 'if mechanics.b4.body.enforceStates then if mechanics.b4.body.useQuaternions then StateSelect.prefer else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:708:5-711:69:writable] Warning: Variable mechanics.b4.body.phi: Non-array modification 'if mechanics.b4.body.enforceStates then if mechanics.b4.body.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:712:5-714:42:writable] Warning: Variable mechanics.b4.body.phi_d: Non-array modification 'if mechanics.b4.body.enforceStates then if mechanics.b4.body.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:975:5-978:76:writable] Warning: Variable mechanics.b5.r_0: Non-array modification 'if mechanics.b5.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:979:5-982:76:writable] Warning: Variable mechanics.b5.v_0: Non-array modification 'if mechanics.b5.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:600:5-603:76:writable] Warning: Variable mechanics.b5.body.r_0: Non-array modification 'if mechanics.b5.body.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:604:5-607:76:writable] Warning: Variable mechanics.b5.body.v_0: Non-array modification 'if mechanics.b5.body.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:682:5-686:65:writable] Warning: Variable mechanics.b5.body.w_a: Non-array modification 'if mechanics.b5.body.enforceStates then if mechanics.b5.body.useQuaternions then StateSelect.always else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:697:5-700:119:writable] Warning: Variable mechanics.b5.body.Q: Non-array modification 'if mechanics.b5.body.enforceStates then if mechanics.b5.body.useQuaternions then StateSelect.prefer else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:708:5-711:69:writable] Warning: Variable mechanics.b5.body.phi: Non-array modification 'if mechanics.b5.body.enforceStates then if mechanics.b5.body.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:712:5-714:42:writable] Warning: Variable mechanics.b5.body.phi_d: Non-array modification 'if mechanics.b5.body.enforceStates then if mechanics.b5.body.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:975:5-978:76:writable] Warning: Variable mechanics.b6.r_0: Non-array modification 'if mechanics.b6.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:979:5-982:76:writable] Warning: Variable mechanics.b6.v_0: Non-array modification 'if mechanics.b6.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:600:5-603:76:writable] Warning: Variable mechanics.b6.body.r_0: Non-array modification 'if mechanics.b6.body.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:604:5-607:76:writable] Warning: Variable mechanics.b6.body.v_0: Non-array modification 'if mechanics.b6.body.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:682:5-686:65:writable] Warning: Variable mechanics.b6.body.w_a: Non-array modification 'if mechanics.b6.body.enforceStates then if mechanics.b6.body.useQuaternions then StateSelect.always else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:697:5-700:119:writable] Warning: Variable mechanics.b6.body.Q: Non-array modification 'if mechanics.b6.body.enforceStates then if mechanics.b6.body.useQuaternions then StateSelect.prefer else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:708:5-711:69:writable] Warning: Variable mechanics.b6.body.phi: Non-array modification 'if mechanics.b6.body.enforceStates then if mechanics.b6.body.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:712:5-714:42:writable] Warning: Variable mechanics.b6.body.phi_d: Non-array modification 'if mechanics.b6.body.enforceStates then if mechanics.b6.body.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:975:5-978:76:writable] Warning: Variable mechanics.load.r_0: Non-array modification 'if mechanics.load.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:979:5-982:76:writable] Warning: Variable mechanics.load.v_0: Non-array modification 'if mechanics.load.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:600:5-603:76:writable] Warning: Variable mechanics.load.body.r_0: Non-array modification 'if mechanics.load.body.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:604:5-607:76:writable] Warning: Variable mechanics.load.body.v_0: Non-array modification 'if mechanics.load.body.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:682:5-686:65:writable] Warning: Variable mechanics.load.body.w_a: Non-array modification 'if mechanics.load.body.enforceStates then if mechanics.load.body.useQuaternions then StateSelect.always else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:697:5-700:119:writable] Warning: Variable mechanics.load.body.Q: Non-array modification 'if mechanics.load.body.enforceStates then if mechanics.load.body.useQuaternions then StateSelect.prefer else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:708:5-711:69:writable] Warning: Variable mechanics.load.body.phi: Non-array modification 'if mechanics.load.body.enforceStates then if mechanics.load.body.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:712:5-714:42:writable] Warning: Variable mechanics.load.body.phi_d: Non-array modification 'if mechanics.load.body.enforceStates then if mechanics.load.body.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [RobotR3.mo:577:7-577:79:writable] Warning: Variable pathPlanning.angleEndDeg: Non-array modification '"deg"' for array component, possibly due to missing 'each'.
// 
// [RobotR3.mo:575:7-576:23:writable] Warning: Variable pathPlanning.angleBegDeg: Non-array modification '"deg"' for array component, possibly due to missing 'each'.
// 
// [RobotR3.mo:577:7-577:79:writable] Warning: Variable pathPlanning.angleEndDeg: Non-array modification '"deg"' for array component, possibly due to missing 'each'.
// 
// [RobotR3.mo:1367:7-1369:21:writable] Warning: Component PI has the same name as its type Modelica.Blocks.Continuous.PI.
// 	This is forbidden by Modelica specification and may lead to lookup errors.
// "
// "Check of Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.fullRobot completed successfully.
// 
// [parts.mo:975:5-978:76:writable] Warning: Variable mechanics.b0.r_0: Non-array modification 'if mechanics.b0.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:979:5-982:76:writable] Warning: Variable mechanics.b0.v_0: Non-array modification 'if mechanics.b0.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:600:5-603:76:writable] Warning: Variable mechanics.b0.body.r_0: Non-array modification 'if mechanics.b0.body.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:604:5-607:76:writable] Warning: Variable mechanics.b0.body.v_0: Non-array modification 'if mechanics.b0.body.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:682:5-686:65:writable] Warning: Variable mechanics.b0.body.w_a: Non-array modification 'if mechanics.b0.body.enforceStates then if mechanics.b0.body.useQuaternions then StateSelect.always else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:697:5-700:119:writable] Warning: Variable mechanics.b0.body.Q: Non-array modification 'if mechanics.b0.body.enforceStates then if mechanics.b0.body.useQuaternions then StateSelect.prefer else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:708:5-711:69:writable] Warning: Variable mechanics.b0.body.phi: Non-array modification 'if mechanics.b0.body.enforceStates then if mechanics.b0.body.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:712:5-714:42:writable] Warning: Variable mechanics.b0.body.phi_d: Non-array modification 'if mechanics.b0.body.enforceStates then if mechanics.b0.body.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:975:5-978:76:writable] Warning: Variable mechanics.b1.r_0: Non-array modification 'if mechanics.b1.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:979:5-982:76:writable] Warning: Variable mechanics.b1.v_0: Non-array modification 'if mechanics.b1.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:600:5-603:76:writable] Warning: Variable mechanics.b1.body.r_0: Non-array modification 'if mechanics.b1.body.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:604:5-607:76:writable] Warning: Variable mechanics.b1.body.v_0: Non-array modification 'if mechanics.b1.body.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:682:5-686:65:writable] Warning: Variable mechanics.b1.body.w_a: Non-array modification 'if mechanics.b1.body.enforceStates then if mechanics.b1.body.useQuaternions then StateSelect.always else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:697:5-700:119:writable] Warning: Variable mechanics.b1.body.Q: Non-array modification 'if mechanics.b1.body.enforceStates then if mechanics.b1.body.useQuaternions then StateSelect.prefer else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:708:5-711:69:writable] Warning: Variable mechanics.b1.body.phi: Non-array modification 'if mechanics.b1.body.enforceStates then if mechanics.b1.body.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:712:5-714:42:writable] Warning: Variable mechanics.b1.body.phi_d: Non-array modification 'if mechanics.b1.body.enforceStates then if mechanics.b1.body.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:975:5-978:76:writable] Warning: Variable mechanics.b2.r_0: Non-array modification 'if mechanics.b2.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:979:5-982:76:writable] Warning: Variable mechanics.b2.v_0: Non-array modification 'if mechanics.b2.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:600:5-603:76:writable] Warning: Variable mechanics.b2.body.r_0: Non-array modification 'if mechanics.b2.body.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:604:5-607:76:writable] Warning: Variable mechanics.b2.body.v_0: Non-array modification 'if mechanics.b2.body.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:682:5-686:65:writable] Warning: Variable mechanics.b2.body.w_a: Non-array modification 'if mechanics.b2.body.enforceStates then if mechanics.b2.body.useQuaternions then StateSelect.always else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:697:5-700:119:writable] Warning: Variable mechanics.b2.body.Q: Non-array modification 'if mechanics.b2.body.enforceStates then if mechanics.b2.body.useQuaternions then StateSelect.prefer else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:708:5-711:69:writable] Warning: Variable mechanics.b2.body.phi: Non-array modification 'if mechanics.b2.body.enforceStates then if mechanics.b2.body.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:712:5-714:42:writable] Warning: Variable mechanics.b2.body.phi_d: Non-array modification 'if mechanics.b2.body.enforceStates then if mechanics.b2.body.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:975:5-978:76:writable] Warning: Variable mechanics.b3.r_0: Non-array modification 'if mechanics.b3.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:979:5-982:76:writable] Warning: Variable mechanics.b3.v_0: Non-array modification 'if mechanics.b3.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:600:5-603:76:writable] Warning: Variable mechanics.b3.body.r_0: Non-array modification 'if mechanics.b3.body.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:604:5-607:76:writable] Warning: Variable mechanics.b3.body.v_0: Non-array modification 'if mechanics.b3.body.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:682:5-686:65:writable] Warning: Variable mechanics.b3.body.w_a: Non-array modification 'if mechanics.b3.body.enforceStates then if mechanics.b3.body.useQuaternions then StateSelect.always else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:697:5-700:119:writable] Warning: Variable mechanics.b3.body.Q: Non-array modification 'if mechanics.b3.body.enforceStates then if mechanics.b3.body.useQuaternions then StateSelect.prefer else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:708:5-711:69:writable] Warning: Variable mechanics.b3.body.phi: Non-array modification 'if mechanics.b3.body.enforceStates then if mechanics.b3.body.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:712:5-714:42:writable] Warning: Variable mechanics.b3.body.phi_d: Non-array modification 'if mechanics.b3.body.enforceStates then if mechanics.b3.body.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:975:5-978:76:writable] Warning: Variable mechanics.b4.r_0: Non-array modification 'if mechanics.b4.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:979:5-982:76:writable] Warning: Variable mechanics.b4.v_0: Non-array modification 'if mechanics.b4.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:600:5-603:76:writable] Warning: Variable mechanics.b4.body.r_0: Non-array modification 'if mechanics.b4.body.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:604:5-607:76:writable] Warning: Variable mechanics.b4.body.v_0: Non-array modification 'if mechanics.b4.body.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:682:5-686:65:writable] Warning: Variable mechanics.b4.body.w_a: Non-array modification 'if mechanics.b4.body.enforceStates then if mechanics.b4.body.useQuaternions then StateSelect.always else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:697:5-700:119:writable] Warning: Variable mechanics.b4.body.Q: Non-array modification 'if mechanics.b4.body.enforceStates then if mechanics.b4.body.useQuaternions then StateSelect.prefer else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:708:5-711:69:writable] Warning: Variable mechanics.b4.body.phi: Non-array modification 'if mechanics.b4.body.enforceStates then if mechanics.b4.body.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:712:5-714:42:writable] Warning: Variable mechanics.b4.body.phi_d: Non-array modification 'if mechanics.b4.body.enforceStates then if mechanics.b4.body.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:975:5-978:76:writable] Warning: Variable mechanics.b5.r_0: Non-array modification 'if mechanics.b5.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:979:5-982:76:writable] Warning: Variable mechanics.b5.v_0: Non-array modification 'if mechanics.b5.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:600:5-603:76:writable] Warning: Variable mechanics.b5.body.r_0: Non-array modification 'if mechanics.b5.body.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:604:5-607:76:writable] Warning: Variable mechanics.b5.body.v_0: Non-array modification 'if mechanics.b5.body.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:682:5-686:65:writable] Warning: Variable mechanics.b5.body.w_a: Non-array modification 'if mechanics.b5.body.enforceStates then if mechanics.b5.body.useQuaternions then StateSelect.always else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:697:5-700:119:writable] Warning: Variable mechanics.b5.body.Q: Non-array modification 'if mechanics.b5.body.enforceStates then if mechanics.b5.body.useQuaternions then StateSelect.prefer else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:708:5-711:69:writable] Warning: Variable mechanics.b5.body.phi: Non-array modification 'if mechanics.b5.body.enforceStates then if mechanics.b5.body.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:712:5-714:42:writable] Warning: Variable mechanics.b5.body.phi_d: Non-array modification 'if mechanics.b5.body.enforceStates then if mechanics.b5.body.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:975:5-978:76:writable] Warning: Variable mechanics.b6.r_0: Non-array modification 'if mechanics.b6.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:979:5-982:76:writable] Warning: Variable mechanics.b6.v_0: Non-array modification 'if mechanics.b6.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:600:5-603:76:writable] Warning: Variable mechanics.b6.body.r_0: Non-array modification 'if mechanics.b6.body.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:604:5-607:76:writable] Warning: Variable mechanics.b6.body.v_0: Non-array modification 'if mechanics.b6.body.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:682:5-686:65:writable] Warning: Variable mechanics.b6.body.w_a: Non-array modification 'if mechanics.b6.body.enforceStates then if mechanics.b6.body.useQuaternions then StateSelect.always else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:697:5-700:119:writable] Warning: Variable mechanics.b6.body.Q: Non-array modification 'if mechanics.b6.body.enforceStates then if mechanics.b6.body.useQuaternions then StateSelect.prefer else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:708:5-711:69:writable] Warning: Variable mechanics.b6.body.phi: Non-array modification 'if mechanics.b6.body.enforceStates then if mechanics.b6.body.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:712:5-714:42:writable] Warning: Variable mechanics.b6.body.phi_d: Non-array modification 'if mechanics.b6.body.enforceStates then if mechanics.b6.body.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:975:5-978:76:writable] Warning: Variable mechanics.load.r_0: Non-array modification 'if mechanics.load.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:979:5-982:76:writable] Warning: Variable mechanics.load.v_0: Non-array modification 'if mechanics.load.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:600:5-603:76:writable] Warning: Variable mechanics.load.body.r_0: Non-array modification 'if mechanics.load.body.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:604:5-607:76:writable] Warning: Variable mechanics.load.body.v_0: Non-array modification 'if mechanics.load.body.enforceStates then StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:682:5-686:65:writable] Warning: Variable mechanics.load.body.w_a: Non-array modification 'if mechanics.load.body.enforceStates then if mechanics.load.body.useQuaternions then StateSelect.always else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:697:5-700:119:writable] Warning: Variable mechanics.load.body.Q: Non-array modification 'if mechanics.load.body.enforceStates then if mechanics.load.body.useQuaternions then StateSelect.prefer else StateSelect.never else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:708:5-711:69:writable] Warning: Variable mechanics.load.body.phi: Non-array modification 'if mechanics.load.body.enforceStates then if mechanics.load.body.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [parts.mo:712:5-714:42:writable] Warning: Variable mechanics.load.body.phi_d: Non-array modification 'if mechanics.load.body.enforceStates then if mechanics.load.body.useQuaternions then StateSelect.never else StateSelect.always else StateSelect.avoid' for array component, possibly due to missing 'each'.
// 
// [RobotR3.mo:577:7-577:79:writable] Warning: Variable pathPlanning.angleEndDeg: Non-array modification '\"deg\"' for array component, possibly due to missing 'each'.
// 
// [RobotR3.mo:575:7-576:23:writable] Warning: Variable pathPlanning.angleBegDeg: Non-array modification '\"deg\"' for array component, possibly due to missing 'each'.
// 
// [RobotR3.mo:577:7-577:79:writable] Warning: Variable pathPlanning.angleEndDeg: Non-array modification '\"deg\"' for array component, possibly due to missing 'each'.
// 
// [RobotR3.mo:1367:7-1369:21:writable] Warning: Component PI has the same name as its type Modelica.Blocks.Continuous.PI.
// 	This is forbidden by Modelica specification and may lead to lookup errors.
// 
// Class Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.fullRobot has 4828 equation(s) and 4828 variable(s).
// 3638 of these are trivial equation(s).
// "
// ""
// endResult
