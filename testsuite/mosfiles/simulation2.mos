// name:     Simulation2
// keywords: Simulation, Euler, Linear, Non-linear eqn systems.
// status:   correct
// 
//  Simulate models and read in data.
//
loadFile("TimeVaryingLinsys.mo");
simulate(TimeVaryingLinSys); 
val(x,0.0);
val(x,0.5);
val(x,1.0);
val(y,0.0);
val(y,0.5);
val(y,1.0);
val(z,0.0);
val(z,0.5);
val(z,1.0);
system("rm -f TimeVaryingLinSys_*");
system("rm -f TimeVaryingLinSys.cpp TimeVaryingLinSys.exe TimeVaryingLinSys.makefile TimeVaryingLinSys.log TimeVaryingLinSys.libs");

loadFile("NonLinSys.mo");
simulate(NonLinSys);
val(x,0.0);
val(x,0.5);
val(x,1.0);
system("rm -f NonLinSys_*");
system("rm -f NonLinSys.cpp NonLinSys.exe NonLinSys.makefile NonLinSys.log NonLinSys.libs");

/* TODO: Does not work since DASSL calls residual function for negative values when
it calculates numerical jacobian. 
loadFile("NonLinSys2.mo");
simulate(NonLinSys2); 
val(x,0.0);
val(x,0.5);
val(x,1.0);
val(y,0.0);
val(y,0.5);
val(y,1.0);
system("rm -f NonLinSys2_*");
system("rm -f NonLinSys2.cpp NonLinSys2.exe NonLinSys2.makefile NonLinSys2.log NonLinSys2.libs");
*/

loadFile("NonLinSys3.mo");
simulate(NonLinSys3); 
val(x,0.0);
val(x,0.5);
val(x,1.0);
val(y,0.0);
val(y,0.5);
val(y,1.0);
system("rm -f NonLinSys3_*");
system("rm -f NonLinSys3.cpp NonLinSys3.exe NonLinSys3.makefile NonLinSys3.log NonLinSys3.libs");


loadFile("Modelica.mo");
loadFile("Test3PhaseSystemTotal.mo");
simulate(Test3PhaseSystems.Test3PhaseSystem,stopTime=20);
val(LR1.I1.i,0.0);
val(LR1.I2.i,0.0);
val(LR1.I3.i,0.0);
system("rm -f Test3PhaseSystems.Test3PhaseSystem_*");
system("rm -f Test3Phasesystems.Test3PhaseSystem.cpp Test3PhaseSystems.Test3PhaseSystem.exe Test3PhaseSystems.Test3PhaseSystem.makefile Test3PhaseSystems.Test3PhaseSystem.log Test3PhaseSystems.Test3PhaseSystem.libs");

// Model that tests discrete equations that do not contain zero crossings, e.g n = 1;
loadFile("BooleanModel.mo");
simulate(BooleanModel);
val(startForward,0.0);
val(startForward,0.5);
val(startForward,0.9);
val(mode,0.0);
val(mode,0.5);
val(mode,0.9);
system("rm -f BooleanModel_*");
system("rm -f BooleanModel.cpp BooleanModel.exe BooleanModel.makefile BooleanModel.log BooleanModel.libs");


/*
loadFile("NonLinSys4.mo");
simulate(NonLinSys4,numberOfIntervals=5);
size:=readSimulationResultSize("NonLinSys4_res.plt");
readSimulationResult("NonLinSys4_res.plt",{psii,delta},size);
system("rm -f NonLinSys4_*");
system("rm -f NonLinSys4.cpp NonLinSys4.exe NonLinSys4.makefile NonLinSys4.log NonLinSys4.libs");
*/
loadFile("LargeSteps.mo");
simulate(LargeSteps,stopTime=200,numberOfIntervals=5);
val(x,0.0);
val(x,200.0);
system("rm -f LargeSteps_*");
system("rm -f LargeSteps.cpp LargeSteps.exe LargeSteps.makefile LargeSteps.log LargeSteps.libs"); 
// Result:
// true
// record
//     resultFile = "TimeVaryingLinSys_res.plt"
// end record
// 0.0
// 0.740874716990085
// 2.00000000000034
// 0.0
// 0.707300226407899
// 0.999999999999836
// 0.0
// 0.103650113203956
// -1.03219861644569e-13
// 0
// 0
// true
// record
//     resultFile = "NonLinSys_res.plt"
// end record
// 1.0
// 0.880880577258316
// 0.854031363938055
// 0
// 0
// true
// record
//     resultFile = "NonLinSys3_res.plt"
// end record
// 1.0
// 1.21473014902331
// 1.64262701824808
// 2.0
// 2.26876916716529
// 2.92573132658916
// 0
// 0
// true
// true
// record
//     resultFile = "Test3PhaseSystems.Test3PhaseSystem_res.plt"
// end record
// -0.00869273954826455
// -0.0218917584794523
// 0.0305844980277178
// 0
// 0
// true
// record
//     resultFile = "BooleanModel_res.plt"
// end record
// 1.0
// 1.0
// 0.0
// 2.0
// 2.0
// 0.0
// 0
// 0
// true
// record
//     resultFile = "LargeSteps_res.plt"
// end record
// 0.0
// -0.762648169337983
// 0
// 0
// endResult
