package ParseCodeModelica //  Generated by OMCC v0.9.2 (OpenModelica Compiler- Compiler) Copyright 2011 Open Souce Modelica Consorsium (OSMC) Fri May  4 16:09:39 2012

import Types;


import Absyn;
/* Type Declarations */
type AstTree = Absyn.Program;
type Token = OMCCTypes.Token;  
type Program = Absyn.Program;
type Within = Absyn.Within;
type lstClass = list<Absyn.Class>;
type Class = Absyn.Class;
type Ident = Absyn.Ident;
type Path = Absyn.Path;
type ClassDef  = Absyn.ClassDef;
type ClassPart = Absyn.ClassPart;
type ClassParts = list<ClassPart>;
type Import  = Absyn.Import;
type ElementItem = Absyn.ElementItem;
type ElementItems = list<Absyn.ElementItem>;
type Element = Absyn.Element;
type ElementSpec = Absyn.ElementSpec;
type ElementAttributes = Absyn.ElementAttributes;
type Comment = Absyn.Comment;
type Direction = Absyn.Direction;
type Exp = Absyn.Exp;
type Exps = list<Exp>;
type Matrix = list<list<Exp>>;
type Subscript = Absyn.Subscript;
type ArrayDim = list<Subscript>;
type Operator = Absyn.Operator;
type Case = Absyn.Case;
type Cases = list<Case>;
type MatchType = Absyn.MatchType;
type Restriction = Absyn.Restriction;
type InnerOuter = Absyn.InnerOuter;
type ComponentRef = Absyn.ComponentRef;
type Variability = Absyn.Variability;
type RedeclareKeywords = Absyn.RedeclareKeywords;
type NamedArg=Absyn.NamedArg;
type TypeSpec=Absyn.TypeSpec;
type TypeSpecs=list<TypeSpec>;
type ComponentItem=Absyn.ComponentItem;
type ComponentItems=list<ComponentItem>;
type Component=Absyn.Component;
type EquationItem = Absyn.EquationItem;
type EquationItems = list<EquationItem>;
type Equation = Absyn.Equation;
type Elseif = tuple<Exp, list<EquationItem>>;
type Elseifs = list<Elseif>;
type ForIterator= Absyn.ForIterator;
type ForIterators = list<ForIterator>; 
type Elsewhen = tuple<Exp, list<EquationItem>>;
type Elsewhens = list<Elsewhen>;
type FunctionArgs = Absyn.FunctionArgs;
type NamedArgs = list<NamedArg>;
type AlgorithmItem = Absyn.AlgorithmItem;
type AlgorithmItems = list<AlgorithmItem>;
type Algorithm = Absyn.Algorithm;
type AlgElseif = tuple<Exp, list<AlgorithmItem>>;
type AlgElseifs = list<AlgElseif>;
type AlgElsewhen = tuple<Exp, list<AlgorithmItem>>;
type AlgElsewhens = list<AlgElsewhen>;
type ExpElseif = tuple<Exp, Exp>;
type ExpElseifs = list<ExpElseif>;
type EnumDef = Absyn.EnumDef;
type EnumLiteral = Absyn.EnumLiteral;
type EnumLiterals = list<EnumLiteral>;
type Modification = Absyn.Modification;
type Boolean3 = tuple<Boolean,Boolean,Boolean>;
type Boolean2 = tuple<Boolean,Boolean>;
type ElementArg = Absyn.ElementArg;
type ElementArgs = list<ElementArg>;
type Each = Absyn.Each;
type EqMod=Absyn.EqMod;
type ComponentCondition = Absyn.ComponentCondition;
type ExternalDecl = Absyn.ExternalDecl;
type Annotation = Absyn.Annotation;
type ConstrainClass= Absyn.ConstrainClass;

constant list<String> lstSemValue3 = {};

constant list<String> lstSemValue = {
   "error", "$undefined", "ALGORITHM", "AND", "ANNOTATION",
  "BLOCK", "CLASS", "CONNECT", "CONNECTOR", "CONSTANT", "DISCRETE", "DER",
  "DEFINEUNIT", "EACH", "ELSE", "ELSEIF", "ELSEWHEN", "END",
  "ENUMERATION", "EQUATION", "ENCAPSULATED", "EXPANDABLE", "EXTENDS",
  "CONSTRAINEDBY", "EXTERNAL", "FALSE", "FINAL", "FLOW", "FOR",
  "FUNCTION", "IF", "IMPORT", "IN", "INITIAL", "INNER", "INPUT",
  "LOOP", "MODEL", "NOT", "OUTER", "OPERATOR", "OVERLOAD", "OR",
  "OUTPUT", "PACKAGE", "PARAMETER", "PARTIAL", "PROTECTED", "PUBLIC",
  "RECORD", "REDECLARE", "REPLACEABLE", "RESULTS", "THEN", "TRUE",
  "TYPE", "REAL", "WHEN", "WHILE", "WITHIN", "RETURN", "BREAK",
  ".", "(", ")", "[", "]", "{", "}", "=",
  "ASSIGN", "COMMA", "COLON", "SEMICOLON", "CODE", "CODE_NAME", "CODE_EXP",
  "CODE_VAR", "PURE", "IMPURE", "Identity", "DIGIT", "INTEGER",
  "*", "-", "+", "<=", "<>", "<", ">",
  ">=", "==", "^", "SLASH", "STRING", ".+", ".-",
  ".*", "./", ".*", "STREAM", "AS", "CASE", "EQUALITY",
  "FAILURE", "GUARD", "LOCAL", "MATCH", "MATCHCONTINUE", "UNIONTYPE",
  "ALLWILD", "WILD", "SUBTYPEOF", "COLONCOLON", "MOD", "ENDIF", "ENDFOR",
  "ENDWHILE", "ENDWHEN", "ENDCLASS", "ENDMATCHCONTINUE", "ENDMATCH",
   "$accept",
  "program", "within", "classes_list", "class", "classprefix",
  "encapsulated", "partial", "restriction", "classdef",
  "classdefenumeration", "classdefderived", "enumeration", "enumlist",
  "enumliteral", "classparts", "classpart", "restClass",
  "algorithmsection", "algorithmitem", "algorithm", "if_algorithm",
  "algelseifs", "algelseif", "when_algorithm", "algelsewhens",
  "algelsewhen", "equationsection", "equationitem", "equation",
  "when_equation", "elsewhens", "elsewhen", "foriterators", "foriterator",
  "if_equation", "elseifs", "elseif", "elementItems", "elementItem",
  "element", "componentclause", "componentitems", "componentitem",
  "component", "modification", "redeclarekeywords", "innerouter",
  "importelementspec", "classelementspec", "import", "elementspec",
  "elementAttr", "variability", "direction", "typespec", "arrayComplex",
  "typespecs", "arraySubscripts", "arrayDim", "functioncall",
  "functionargs", "namedargs", "namedarg", "exp", "matchcont", "if_exp",
  "expelseifs", "expelseif", "matchlocal", "cases", "case", "casearg",
  "simpleExp", "headtail", "rangeExp", "logicexp", "logicterm",
  "logfactor", "relterm", "addterm", "term", "factor", "expElement",
  "tuple", "explist", "explist2", "cref", "woperator", "soperator",
  "power", "relOperator", "path", "ident", "string", "comment"};


uniontype AstStack
  record ASTSTACK
    list<Token> stackToken;
    list<Matrix> stackMatrix;
    list<Operator> stackOperator;
    list<Case> stackCase;
    list<ExpElseif> stackExpElseif;
    list<ExpElseifs> stackExpElseifs;
    list<Cases> stackCases;
    list<NamedArg> stackNamedArg;
    list<Subscript> stackSubscript;
    list<TypeSpecs> stackTypeSpecs;
    list<Variability> stackVariability;
    list<Direction> stackDirection;
    list<Import> stackImport;
    list<Each> stackEach;
    list<ElementArg> stackElementArg;
    list<ArrayDim> stackArrayDim;
    list<Modification> stackModification;
    list<ComponentCondition> stackComponentCondition;
    list<Component> stackComponent;
    list<ComponentItems> stackComponentItems;
    list<ComponentItem> stackComponentItem;
    list<ConstrainClass> stackConstrainClass;
    list<RedeclareKeywords> stackRedeclareKeywords;
    list<InnerOuter> stackInnerOuter;
    list<NamedArgs> stackNamedArgs;
    list<ElementSpec> stackElementSpec;
    list<Element> stackElement;
    list<ElementItem> stackElementItem;
    list<Elseif> stackElseif;
    list<Elseifs> stackElseifs;
    list<ForIterator> stackForIterator;
    list<Elsewhen> stackElsewhen;
    list<Elsewhens> stackElsewhens;
    list<Equation> stackEquation;
    list<EquationItem> stackEquationItem;
    list<AlgElsewhen> stackAlgElsewhen;
    list<AlgElsewhens> stackAlgElsewhens;
    list<AlgElseif> stackAlgElseif;
    list<AlgElseifs> stackAlgElseifs;
    list<ForIterators> stackForIterators;
    list<FunctionArgs> stackFunctionArgs;
    list<Exp> stackExp;
    list<Algorithm> stackAlgorithm;
    list<AlgorithmItem> stackAlgorithmItem;
    list<ComponentRef> stackComponentRef;
    list<Exps> stackExps;
    list<Annotation> stackAnnotation;
    list<ExternalDecl> stackExternalDecl;
    list<AlgorithmItems> stackAlgorithmItems;
    list<EquationItems> stackEquationItems;
    list<ElementItems> stackElementItems;
    list<ClassPart> stackClassPart;
    list<Ident> stackIdent;
    list<EnumLiteral> stackEnumLiteral;
    list<EnumLiterals> stackEnumLiterals;
    list<ElementAttributes> stackElementAttributes;
    list<TypeSpec> stackTypeSpec;
    list<ElementArgs> stackElementArgs;
    list<EnumDef> stackEnumDef;
    list<Comment> stackComment;
    list<Boolean> stackBoolean;
    list<ClassParts> stackClassParts;
    list<Boolean2> stackBoolean2;
    list<Restriction> stackRestriction;
    list<ClassDef> stackClassDef;
    list<Class> stackClass;
    list<Path> stackPath;
    list<Within> stackWithin;
    list<Program> stackProgram;
    list<lstClass> stacklstClass;
    list<String> stackString;
    list<Integer> stackInteger;
  end ASTSTACK;
  record EMPTY end EMPTY;
end AstStack;

function initAstStack
  input AstStack astStack;
  output AstStack astStack2;
 algorithm 
   astStack2 := ASTSTACK({},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{});
end initAstStack;

function getAST "returns the AST built by the parsing"
  input AstStack astStk "MultiTypedStack used by the parser";
  output AstTree ast "returns the AST in the final type of the tree";
  protected
  list<Program> retStk;
  algorithm
    ASTSTACK(stackProgram=retStk) := astStk;
    ast::_ := retStk;
end getAST;  



function actionRed
  input Integer act;
  input AstStack astStk;
  input array<Integer> mm_r2;
  output AstStack astStk2;
  output Boolean error=false;
  output String errorMsg="";
  protected
  OMCCTypes.Info info;
  // env variables       
  // AstStack 
   list<Token> skToken;
   list<Matrix> skMatrix;
   list<Operator> skOperator;
   list<Case> skCase;
   list<ExpElseif> skExpElseif;
   list<ExpElseifs> skExpElseifs;
   list<Cases> skCases;
   list<NamedArg> skNamedArg;
   list<Subscript> skSubscript;
   list<TypeSpecs> skTypeSpecs;
   list<Variability> skVariability;
   list<Direction> skDirection;
   list<Import> skImport;
   list<Each> skEach;
   list<ElementArg> skElementArg;
   list<ArrayDim> skArrayDim;
   list<Modification> skModification;
   list<ComponentCondition> skComponentCondition;
   list<Component> skComponent;
   list<ComponentItems> skComponentItems;
   list<ComponentItem> skComponentItem;
   list<ConstrainClass> skConstrainClass;
   list<RedeclareKeywords> skRedeclareKeywords;
   list<InnerOuter> skInnerOuter;
   list<NamedArgs> skNamedArgs;
   list<ElementSpec> skElementSpec;
   list<Element> skElement;
   list<ElementItem> skElementItem;
   list<Elseif> skElseif;
   list<Elseifs> skElseifs;
   list<ForIterator> skForIterator;
   list<Elsewhen> skElsewhen;
   list<Elsewhens> skElsewhens;
   list<Equation> skEquation;
   list<EquationItem> skEquationItem;
   list<AlgElsewhen> skAlgElsewhen;
   list<AlgElsewhens> skAlgElsewhens;
   list<AlgElseif> skAlgElseif;
   list<AlgElseifs> skAlgElseifs;
   list<ForIterators> skForIterators;
   list<FunctionArgs> skFunctionArgs;
   list<Exp> skExp;
   list<Algorithm> skAlgorithm;
   list<AlgorithmItem> skAlgorithmItem;
   list<ComponentRef> skComponentRef;
   list<Exps> skExps;
   list<Annotation> skAnnotation;
   list<ExternalDecl> skExternalDecl;
   list<AlgorithmItems> skAlgorithmItems;
   list<EquationItems> skEquationItems;
   list<ElementItems> skElementItems;
   list<ClassPart> skClassPart;
   list<Ident> skIdent;
   list<EnumLiteral> skEnumLiteral;
   list<EnumLiterals> skEnumLiterals;
   list<ElementAttributes> skElementAttributes;
   list<TypeSpec> skTypeSpec;
   list<ElementArgs> skElementArgs;
   list<EnumDef> skEnumDef;
   list<Comment> skComment;
   list<Boolean> skBoolean;
   list<ClassParts> skClassParts;
   list<Boolean2> skBoolean2;
   list<Restriction> skRestriction;
   list<ClassDef> skClassDef;
   list<Class> skClass;
   list<Path> skPath;
   list<Within> skWithin;
   list<Program> skProgram;
   list<lstClass> sklstClass;
   list<String> skString;
   list<Integer> skInteger;


  
algorithm
   
  // printContentStack(astStk);
   //printAny(" rule:" + intString(act));
   ASTSTACK(stackToken=skToken,stackMatrix=skMatrix,stackOperator=skOperator,stackCase=skCase,stackExpElseif=skExpElseif,stackExpElseifs=skExpElseifs,stackCases=skCases,stackNamedArg=skNamedArg,stackSubscript=skSubscript,stackTypeSpecs=skTypeSpecs,stackVariability=skVariability,stackDirection=skDirection,stackImport=skImport,stackEach=skEach,stackElementArg=skElementArg,stackArrayDim=skArrayDim,stackModification=skModification,stackComponentCondition=skComponentCondition,stackComponent=skComponent,stackComponentItems=skComponentItems,stackComponentItem=skComponentItem,stackConstrainClass=skConstrainClass,stackRedeclareKeywords=skRedeclareKeywords,stackInnerOuter=skInnerOuter,stackNamedArgs=skNamedArgs,stackElementSpec=skElementSpec,stackElement=skElement,stackElementItem=skElementItem,stackElseif=skElseif,stackElseifs=skElseifs,stackForIterator=skForIterator,stackElsewhen=skElsewhen,stackElsewhens=skElsewhens,stackEquation=skEquation,stackEquationItem=skEquationItem,stackAlgElsewhen=skAlgElsewhen,stackAlgElsewhens=skAlgElsewhens,stackAlgElseif=skAlgElseif,stackAlgElseifs=skAlgElseifs,stackForIterators=skForIterators,stackFunctionArgs=skFunctionArgs,stackExp=skExp,stackAlgorithm=skAlgorithm,stackAlgorithmItem=skAlgorithmItem,stackComponentRef=skComponentRef,stackExps=skExps,stackAnnotation=skAnnotation,stackExternalDecl=skExternalDecl,stackAlgorithmItems=skAlgorithmItems,stackEquationItems=skEquationItems,stackElementItems=skElementItems,stackClassPart=skClassPart,stackIdent=skIdent,stackEnumLiteral=skEnumLiteral,stackEnumLiterals=skEnumLiterals,stackElementAttributes=skElementAttributes,stackTypeSpec=skTypeSpec,stackElementArgs=skElementArgs,stackEnumDef=skEnumDef,stackComment=skComment,stackBoolean=skBoolean,stackClassParts=skClassParts,stackBoolean2=skBoolean2,stackRestriction=skRestriction,stackClassDef=skClassDef,stackClass=skClass,stackPath=skPath,stackWithin=skWithin,stackProgram=skProgram,stacklstClass=sklstClass,stackString=skString,stackInteger=skInteger) := astStk;  
  (_) := matchcontinue(act,astStk)
    local
      //local variables
      Token vToken,  v1Token, v2Token, v3Token, v4Token, v5Token, v6Token, v7Token, v8Token;
      Matrix vMatrix,  v1Matrix, v2Matrix, v3Matrix, v4Matrix, v5Matrix, v6Matrix, v7Matrix, v8Matrix;
      Operator vOperator,  v1Operator, v2Operator, v3Operator, v4Operator, v5Operator, v6Operator, v7Operator, v8Operator;
      Case vCase,  v1Case, v2Case, v3Case, v4Case, v5Case, v6Case, v7Case, v8Case;
      ExpElseif vExpElseif,  v1ExpElseif, v2ExpElseif, v3ExpElseif, v4ExpElseif, v5ExpElseif, v6ExpElseif, v7ExpElseif, v8ExpElseif;
      ExpElseifs vExpElseifs,  v1ExpElseifs, v2ExpElseifs, v3ExpElseifs, v4ExpElseifs, v5ExpElseifs, v6ExpElseifs, v7ExpElseifs, v8ExpElseifs;
      Cases vCases,  v1Cases, v2Cases, v3Cases, v4Cases, v5Cases, v6Cases, v7Cases, v8Cases;
      NamedArg vNamedArg,  v1NamedArg, v2NamedArg, v3NamedArg, v4NamedArg, v5NamedArg, v6NamedArg, v7NamedArg, v8NamedArg;
      Subscript vSubscript,  v1Subscript, v2Subscript, v3Subscript, v4Subscript, v5Subscript, v6Subscript, v7Subscript, v8Subscript;
      TypeSpecs vTypeSpecs,  v1TypeSpecs, v2TypeSpecs, v3TypeSpecs, v4TypeSpecs, v5TypeSpecs, v6TypeSpecs, v7TypeSpecs, v8TypeSpecs;
      Variability vVariability,  v1Variability, v2Variability, v3Variability, v4Variability, v5Variability, v6Variability, v7Variability, v8Variability;
      Direction vDirection,  v1Direction, v2Direction, v3Direction, v4Direction, v5Direction, v6Direction, v7Direction, v8Direction;
      Import vImport,  v1Import, v2Import, v3Import, v4Import, v5Import, v6Import, v7Import, v8Import;
      Each vEach,  v1Each, v2Each, v3Each, v4Each, v5Each, v6Each, v7Each, v8Each;
      ElementArg vElementArg,  v1ElementArg, v2ElementArg, v3ElementArg, v4ElementArg, v5ElementArg, v6ElementArg, v7ElementArg, v8ElementArg;
      ArrayDim vArrayDim,  v1ArrayDim, v2ArrayDim, v3ArrayDim, v4ArrayDim, v5ArrayDim, v6ArrayDim, v7ArrayDim, v8ArrayDim;
      Modification vModification,  v1Modification, v2Modification, v3Modification, v4Modification, v5Modification, v6Modification, v7Modification, v8Modification;
      ComponentCondition vComponentCondition,  v1ComponentCondition, v2ComponentCondition, v3ComponentCondition, v4ComponentCondition, v5ComponentCondition, v6ComponentCondition, v7ComponentCondition, v8ComponentCondition;
      Component vComponent,  v1Component, v2Component, v3Component, v4Component, v5Component, v6Component, v7Component, v8Component;
      ComponentItems vComponentItems,  v1ComponentItems, v2ComponentItems, v3ComponentItems, v4ComponentItems, v5ComponentItems, v6ComponentItems, v7ComponentItems, v8ComponentItems;
      ComponentItem vComponentItem,  v1ComponentItem, v2ComponentItem, v3ComponentItem, v4ComponentItem, v5ComponentItem, v6ComponentItem, v7ComponentItem, v8ComponentItem;
      ConstrainClass vConstrainClass,  v1ConstrainClass, v2ConstrainClass, v3ConstrainClass, v4ConstrainClass, v5ConstrainClass, v6ConstrainClass, v7ConstrainClass, v8ConstrainClass;
      RedeclareKeywords vRedeclareKeywords,  v1RedeclareKeywords, v2RedeclareKeywords, v3RedeclareKeywords, v4RedeclareKeywords, v5RedeclareKeywords, v6RedeclareKeywords, v7RedeclareKeywords, v8RedeclareKeywords;
      InnerOuter vInnerOuter,  v1InnerOuter, v2InnerOuter, v3InnerOuter, v4InnerOuter, v5InnerOuter, v6InnerOuter, v7InnerOuter, v8InnerOuter;
      NamedArgs vNamedArgs,  v1NamedArgs, v2NamedArgs, v3NamedArgs, v4NamedArgs, v5NamedArgs, v6NamedArgs, v7NamedArgs, v8NamedArgs;
      ElementSpec vElementSpec,  v1ElementSpec, v2ElementSpec, v3ElementSpec, v4ElementSpec, v5ElementSpec, v6ElementSpec, v7ElementSpec, v8ElementSpec;
      Element vElement,  v1Element, v2Element, v3Element, v4Element, v5Element, v6Element, v7Element, v8Element;
      ElementItem vElementItem,  v1ElementItem, v2ElementItem, v3ElementItem, v4ElementItem, v5ElementItem, v6ElementItem, v7ElementItem, v8ElementItem;
      Elseif vElseif,  v1Elseif, v2Elseif, v3Elseif, v4Elseif, v5Elseif, v6Elseif, v7Elseif, v8Elseif;
      Elseifs vElseifs,  v1Elseifs, v2Elseifs, v3Elseifs, v4Elseifs, v5Elseifs, v6Elseifs, v7Elseifs, v8Elseifs;
      ForIterator vForIterator,  v1ForIterator, v2ForIterator, v3ForIterator, v4ForIterator, v5ForIterator, v6ForIterator, v7ForIterator, v8ForIterator;
      Elsewhen vElsewhen,  v1Elsewhen, v2Elsewhen, v3Elsewhen, v4Elsewhen, v5Elsewhen, v6Elsewhen, v7Elsewhen, v8Elsewhen;
      Elsewhens vElsewhens,  v1Elsewhens, v2Elsewhens, v3Elsewhens, v4Elsewhens, v5Elsewhens, v6Elsewhens, v7Elsewhens, v8Elsewhens;
      Equation vEquation,  v1Equation, v2Equation, v3Equation, v4Equation, v5Equation, v6Equation, v7Equation, v8Equation;
      EquationItem vEquationItem,  v1EquationItem, v2EquationItem, v3EquationItem, v4EquationItem, v5EquationItem, v6EquationItem, v7EquationItem, v8EquationItem;
      AlgElsewhen vAlgElsewhen,  v1AlgElsewhen, v2AlgElsewhen, v3AlgElsewhen, v4AlgElsewhen, v5AlgElsewhen, v6AlgElsewhen, v7AlgElsewhen, v8AlgElsewhen;
      AlgElsewhens vAlgElsewhens,  v1AlgElsewhens, v2AlgElsewhens, v3AlgElsewhens, v4AlgElsewhens, v5AlgElsewhens, v6AlgElsewhens, v7AlgElsewhens, v8AlgElsewhens;
      AlgElseif vAlgElseif,  v1AlgElseif, v2AlgElseif, v3AlgElseif, v4AlgElseif, v5AlgElseif, v6AlgElseif, v7AlgElseif, v8AlgElseif;
      AlgElseifs vAlgElseifs,  v1AlgElseifs, v2AlgElseifs, v3AlgElseifs, v4AlgElseifs, v5AlgElseifs, v6AlgElseifs, v7AlgElseifs, v8AlgElseifs;
      ForIterators vForIterators,  v1ForIterators, v2ForIterators, v3ForIterators, v4ForIterators, v5ForIterators, v6ForIterators, v7ForIterators, v8ForIterators;
      FunctionArgs vFunctionArgs,  v1FunctionArgs, v2FunctionArgs, v3FunctionArgs, v4FunctionArgs, v5FunctionArgs, v6FunctionArgs, v7FunctionArgs, v8FunctionArgs;
      Exp vExp,  v1Exp, v2Exp, v3Exp, v4Exp, v5Exp, v6Exp, v7Exp, v8Exp;
      Algorithm vAlgorithm,  v1Algorithm, v2Algorithm, v3Algorithm, v4Algorithm, v5Algorithm, v6Algorithm, v7Algorithm, v8Algorithm;
      AlgorithmItem vAlgorithmItem,  v1AlgorithmItem, v2AlgorithmItem, v3AlgorithmItem, v4AlgorithmItem, v5AlgorithmItem, v6AlgorithmItem, v7AlgorithmItem, v8AlgorithmItem;
      ComponentRef vComponentRef,  v1ComponentRef, v2ComponentRef, v3ComponentRef, v4ComponentRef, v5ComponentRef, v6ComponentRef, v7ComponentRef, v8ComponentRef;
      Exps vExps,  v1Exps, v2Exps, v3Exps, v4Exps, v5Exps, v6Exps, v7Exps, v8Exps;
      Annotation vAnnotation,  v1Annotation, v2Annotation, v3Annotation, v4Annotation, v5Annotation, v6Annotation, v7Annotation, v8Annotation;
      ExternalDecl vExternalDecl,  v1ExternalDecl, v2ExternalDecl, v3ExternalDecl, v4ExternalDecl, v5ExternalDecl, v6ExternalDecl, v7ExternalDecl, v8ExternalDecl;
      AlgorithmItems vAlgorithmItems,  v1AlgorithmItems, v2AlgorithmItems, v3AlgorithmItems, v4AlgorithmItems, v5AlgorithmItems, v6AlgorithmItems, v7AlgorithmItems, v8AlgorithmItems;
      EquationItems vEquationItems,  v1EquationItems, v2EquationItems, v3EquationItems, v4EquationItems, v5EquationItems, v6EquationItems, v7EquationItems, v8EquationItems;
      ElementItems vElementItems,  v1ElementItems, v2ElementItems, v3ElementItems, v4ElementItems, v5ElementItems, v6ElementItems, v7ElementItems, v8ElementItems;
      ClassPart vClassPart,  v1ClassPart, v2ClassPart, v3ClassPart, v4ClassPart, v5ClassPart, v6ClassPart, v7ClassPart, v8ClassPart;
      Ident vIdent,  v1Ident, v2Ident, v3Ident, v4Ident, v5Ident, v6Ident, v7Ident, v8Ident;
      EnumLiteral vEnumLiteral,  v1EnumLiteral, v2EnumLiteral, v3EnumLiteral, v4EnumLiteral, v5EnumLiteral, v6EnumLiteral, v7EnumLiteral, v8EnumLiteral;
      EnumLiterals vEnumLiterals,  v1EnumLiterals, v2EnumLiterals, v3EnumLiterals, v4EnumLiterals, v5EnumLiterals, v6EnumLiterals, v7EnumLiterals, v8EnumLiterals;
      ElementAttributes vElementAttributes,  v1ElementAttributes, v2ElementAttributes, v3ElementAttributes, v4ElementAttributes, v5ElementAttributes, v6ElementAttributes, v7ElementAttributes, v8ElementAttributes;
      TypeSpec vTypeSpec,  v1TypeSpec, v2TypeSpec, v3TypeSpec, v4TypeSpec, v5TypeSpec, v6TypeSpec, v7TypeSpec, v8TypeSpec;
      ElementArgs vElementArgs,  v1ElementArgs, v2ElementArgs, v3ElementArgs, v4ElementArgs, v5ElementArgs, v6ElementArgs, v7ElementArgs, v8ElementArgs;
      EnumDef vEnumDef,  v1EnumDef, v2EnumDef, v3EnumDef, v4EnumDef, v5EnumDef, v6EnumDef, v7EnumDef, v8EnumDef;
      Comment vComment,  v1Comment, v2Comment, v3Comment, v4Comment, v5Comment, v6Comment, v7Comment, v8Comment;
      Boolean vBoolean,  v1Boolean, v2Boolean, v3Boolean, v4Boolean, v5Boolean, v6Boolean, v7Boolean, v8Boolean;
      ClassParts vClassParts,  v1ClassParts, v2ClassParts, v3ClassParts, v4ClassParts, v5ClassParts, v6ClassParts, v7ClassParts, v8ClassParts;
      Boolean2 vBoolean2,  v1Boolean2, v2Boolean2, v3Boolean2, v4Boolean2, v5Boolean2, v6Boolean2, v7Boolean2, v8Boolean2;
      Restriction vRestriction,  v1Restriction, v2Restriction, v3Restriction, v4Restriction, v5Restriction, v6Restriction, v7Restriction, v8Restriction;
      ClassDef vClassDef,  v1ClassDef, v2ClassDef, v3ClassDef, v4ClassDef, v5ClassDef, v6ClassDef, v7ClassDef, v8ClassDef;
      Class vClass,  v1Class, v2Class, v3Class, v4Class, v5Class, v6Class, v7Class, v8Class;
      Path vPath,  v1Path, v2Path, v3Path, v4Path, v5Path, v6Path, v7Path, v8Path;
      Within vWithin,  v1Within, v2Within, v3Within, v4Within, v5Within, v6Within, v7Within, v8Within;
      Program vProgram,  v1Program, v2Program, v3Program, v4Program, v5Program, v6Program, v7Program, v8Program;
      lstClass vlstClass,  v1lstClass, v2lstClass, v3lstClass, v4lstClass, v5lstClass, v6lstClass, v7lstClass, v8lstClass;
      String vString,  v1String, v2String, v3String, v4String, v5String, v6String, v7String, v8String;
      Integer vInteger,  v1Integer, v2Integer, v3Integer, v4Integer, v5Integer, v6Integer, v7Integer, v8Integer;

       case (2,_) // #line 258 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1lstClass::sklstClass = sklstClass; 
           // build 
           vProgram = Absyn.PROGRAM((v1lstClass),Absyn.TOP(),Absyn.TIMESTAMP(System.getCurrentTime(),System.getCurrentTime())); 
           // push Result 
           skProgram= vProgram::skProgram; 

           then ();
 
       case (3,_) // #line 260 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2lstClass::sklstClass = sklstClass; 
           v1Within::skWithin = skWithin; 
           // build 
           vProgram = Absyn.PROGRAM((v2lstClass),(v1Within),Absyn.TIMESTAMP(System.getCurrentTime(),System.getCurrentTime())); 
           // push Result 
           skProgram= vProgram::skProgram; 

           then ();
 
       case (4,_) // #line 263 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3String::skString = skString; 
           v2Path::skPath = skPath; 
           v1String::skString = skString; 
           // build 
           vWithin = Absyn.WITHIN((v2Path)); 
           // push Result 
           skWithin= vWithin::skWithin; 

           then ();
 
       case (5,_) // #line 267 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2String::skString = skString; 
           v1Class::skClass = skClass; 
           // build 
           vlstClass = (v1Class)::{}; 
           // push Result 
           sklstClass= vlstClass::sklstClass; 

           then ();
 
       case (6,_) // #line 268 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3String::skString = skString; 
           v2lstClass::sklstClass = sklstClass; 
           v1Class::skClass = skClass; 
           // build 
           vlstClass = (v1Class)::(v2lstClass); 
           // push Result 
           sklstClass= vlstClass::sklstClass; 

           then ();
 
       case (7,_) // #line 275 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v5ClassDef::skClassDef = skClassDef; 
           v4String::skString = skString; 
           v3Restriction::skRestriction = skRestriction; 
           v2Boolean2::skBoolean2 = skBoolean2; 
           v1String::skString = skString; 
           // build 
           (v1Boolean,v2Boolean) = (v2Boolean2); 
                                 vClass = Absyn.CLASS((v4String),v2Boolean,true,v1Boolean,(v3Restriction),(v5ClassDef),info); 
           // push Result 
           skClass= vClass::skClass; 

           then ();
 
       case (8,_) // #line 278 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v4ClassDef::skClassDef = skClassDef; 
           v3String::skString = skString; 
           v2Restriction::skRestriction = skRestriction; 
           v1String::skString = skString; 
           // build 
            vClass = Absyn.CLASS((v3String),false,true,false,(v2Restriction),(v4ClassDef),info); 
           // push Result 
           skClass= vClass::skClass; 

           then ();
 
       case (9,_) // #line 279 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Class::skClass = skClass; 
           // build 
           vClass = (v1Class); 
           // push Result 
           skClass= vClass::skClass; 

           then ();
 
       case (10,_) // #line 282 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3ClassDef::skClassDef = skClassDef; 
           v2String::skString = skString; 
           v1Restriction::skRestriction = skRestriction; 
           // build 
           vClass = Absyn.CLASS((v2String),false,false,false,(v1Restriction),(v3ClassDef),info); 
           // push Result 
           skClass= vClass::skClass; 

           then ();
 
       case (11,_) // #line 284 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v4ClassDef::skClassDef = skClassDef; 
           v3String::skString = skString; 
           v2Restriction::skRestriction = skRestriction; 
           v1Boolean2::skBoolean2 = skBoolean2; 
           // build 
           (v1Boolean,v2Boolean) = (v1Boolean2); 
                                 vClass = Absyn.CLASS((v3String),v2Boolean,false,v1Boolean,(v2Restriction),(v4ClassDef),info); 
           // push Result 
           skClass= vClass::skClass; 

           then ();
 
       case (12,_) // #line 288 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2String::skString = skString; 
           v1String::skString = skString; 
           // build 
           vClassDef = Absyn.PARTS({},{},SOME((v1String))); 
           // push Result 
           skClassDef= vClassDef::skClassDef; 

           then ();
 
       case (13,_) // #line 290 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vClassDef = Absyn.PARTS({},{},NONE()); 
           // push Result 
           skClassDef= vClassDef::skClassDef; 

           then ();
 
       case (14,_) // #line 292 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2String::skString = skString; 
           v1ClassParts::skClassParts = skClassParts; 
           // build 
           vClassDef = Absyn.PARTS({},(v1ClassParts),NONE()); 
           // push Result 
           skClassDef= vClassDef::skClassDef; 

           then ();
 
       case (15,_) // #line 294 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3String::skString = skString; 
           v2ClassParts::skClassParts = skClassParts; 
           v1String::skString = skString; 
           // build 
           vClassDef = Absyn.PARTS({},(v2ClassParts),SOME((v1String))); 
           // push Result 
           skClassDef= vClassDef::skClassDef; 

           then ();
 
       case (16,_) // #line 296 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1ClassDef::skClassDef = skClassDef; 
           // build 
           vClassDef = (v1ClassDef); 
           // push Result 
           skClassDef= vClassDef::skClassDef; 

           then ();
 
       case (17,_) // #line 298 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1ClassDef::skClassDef = skClassDef; 
           // build 
           vClassDef = (v1ClassDef); 
           // push Result 
           skClassDef= vClassDef::skClassDef; 

           then ();
 
       case (18,_) // #line 301 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2Boolean::skBoolean = skBoolean; 
           v1String::skString = skString; 
           // build 
           vBoolean2 = (true,(v2Boolean)); 
           // push Result 
           skBoolean2= vBoolean2::skBoolean2; 

           then ();
 
       case (19,_) // #line 303 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vBoolean2 = (false,true); 
           // push Result 
           skBoolean2= vBoolean2::skBoolean2; 

           then ();
 
       case (20,_) // #line 309 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vBoolean = true;   
           // push Result 
           skBoolean= vBoolean::skBoolean; 

           then ();
 
       case (21,_) // #line 310 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vBoolean = false; 
           // push Result 
           skBoolean= vBoolean::skBoolean; 

           then ();
 
       case (22,_) // #line 312 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vBoolean = true;   
           // push Result 
           skBoolean= vBoolean::skBoolean; 

           then ();
 
       case (23,_) // #line 313 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vBoolean = false; 
           // push Result 
           skBoolean= vBoolean::skBoolean; 

           then ();
 
       case (24,_) // #line 315 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vRestriction = Absyn.R_CLASS(); 
           // push Result 
           skRestriction= vRestriction::skRestriction; 

           then ();
 
       case (25,_) // #line 316 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vRestriction = Absyn.R_MODEL(); 
           // push Result 
           skRestriction= vRestriction::skRestriction; 

           then ();
 
       case (26,_) // #line 317 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vRestriction = Absyn.R_RECORD(); 
           // push Result 
           skRestriction= vRestriction::skRestriction; 

           then ();
 
       case (27,_) // #line 318 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vRestriction = Absyn.R_PACKAGE(); 
           // push Result 
           skRestriction= vRestriction::skRestriction; 

           then ();
 
       case (28,_) // #line 319 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vRestriction = Absyn.R_TYPE(); 
           // push Result 
           skRestriction= vRestriction::skRestriction; 

           then ();
 
       case (29,_) // #line 320 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vRestriction = Absyn.R_FUNCTION(Absyn.FR_NORMAL_FUNCTION()); 
           // push Result 
           skRestriction= vRestriction::skRestriction; 

           then ();
 
       case (30,_) // #line 321 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vRestriction = Absyn.R_UNIONTYPE(); 
           // push Result 
           skRestriction= vRestriction::skRestriction; 

           then ();
 
       case (31,_) // #line 322 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vRestriction = Absyn.R_BLOCK(); 
           // push Result 
           skRestriction= vRestriction::skRestriction; 

           then ();
 
       case (32,_) // #line 323 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vRestriction = Absyn.R_CONNECTOR(); 
           // push Result 
           skRestriction= vRestriction::skRestriction; 

           then ();
 
       case (33,_) // #line 324 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vRestriction = Absyn.R_EXP_CONNECTOR(); 
           // push Result 
           skRestriction= vRestriction::skRestriction; 

           then ();
 
       case (34,_) // #line 325 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vRestriction = Absyn.R_ENUMERATION(); 
           // push Result 
           skRestriction= vRestriction::skRestriction; 

           then ();
 
       case (35,_) // #line 326 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vRestriction = Absyn.R_OPERATOR_RECORD(); 
           // push Result 
           skRestriction= vRestriction::skRestriction; 

           then ();
 
       case (36,_) // #line 327 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vRestriction = Absyn.R_OPERATOR(); 
           // push Result 
           skRestriction= vRestriction::skRestriction; 

           then ();
 
       case (37,_) // #line 332 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v6Comment::skComment = skComment; 
           v5String::skString = skString; 
           v4EnumDef::skEnumDef = skEnumDef; 
           v3String::skString = skString; 
           v2String::skString = skString; 
           v1String::skString = skString; 
           // build 
           vClassDef = Absyn.ENUMERATION((v4EnumDef),SOME((v6Comment))); 
           // push Result 
           skClassDef= vClassDef::skClassDef; 

           then ();
 
       case (38,_) // #line 335 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v4Comment::skComment = skComment; 
           v3ElementArgs::skElementArgs = skElementArgs; 
           v2TypeSpec::skTypeSpec = skTypeSpec; 
           v1String::skString = skString; 
           // build 
           vClassDef = Absyn.DERIVED((v2TypeSpec),Absyn.ATTR(false,false,Absyn.NON_PARALLEL(),Absyn.VAR(), Absyn.BIDIR(),{}),(v3ElementArgs),SOME((v4Comment))); 
           // push Result 
           skClassDef= vClassDef::skClassDef; 

           then ();
 
       case (39,_) // #line 337 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v5Comment::skComment = skComment; 
           v4ElementArgs::skElementArgs = skElementArgs; 
           v3TypeSpec::skTypeSpec = skTypeSpec; 
           v2ElementAttributes::skElementAttributes = skElementAttributes; 
           v1String::skString = skString; 
           // build 
           vClassDef = Absyn.DERIVED((v3TypeSpec),(v2ElementAttributes),(v4ElementArgs),SOME((v5Comment))); 
           // push Result 
           skClassDef= vClassDef::skClassDef; 

           then ();
 
       case (40,_) // #line 339 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1EnumLiterals::skEnumLiterals = skEnumLiterals; 
           // build 
           vEnumDef = Absyn.ENUMLITERALS((v1EnumLiterals)); 
           // push Result 
           skEnumDef= vEnumDef::skEnumDef; 

           then ();
 
       case (41,_) // #line 340 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vEnumDef = Absyn.ENUM_COLON(); 
           // push Result 
           skEnumDef= vEnumDef::skEnumDef; 

           then ();
 
       case (42,_) // #line 342 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1EnumLiteral::skEnumLiteral = skEnumLiteral; 
           // build 
           vEnumLiterals = (v1EnumLiteral)::{}; 
           // push Result 
           skEnumLiterals= vEnumLiterals::skEnumLiterals; 

           then ();
 
       case (43,_) // #line 343 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3EnumLiterals::skEnumLiterals = skEnumLiterals; 
           v2String::skString = skString; 
           v1EnumLiteral::skEnumLiteral = skEnumLiteral; 
           // build 
           vEnumLiterals = (v1EnumLiteral)::(v3EnumLiterals); 
           // push Result 
           skEnumLiterals= vEnumLiterals::skEnumLiterals; 

           then ();
 
       case (44,_) // #line 345 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2Comment::skComment = skComment; 
           v1Ident::skIdent = skIdent; 
           // build 
           vEnumLiteral = Absyn.ENUMLITERAL((v1Ident),SOME((v2Comment))); 
           // push Result 
           skEnumLiteral= vEnumLiteral::skEnumLiteral; 

           then ();
 
       case (45,_) // #line 347 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1ClassPart::skClassPart = skClassPart; 
           // build 
           vClassParts = (v1ClassPart)::{}; 
           // push Result 
           skClassParts= vClassParts::skClassParts; 

           then ();
 
       case (46,_) // #line 348 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2ClassParts::skClassParts = skClassParts; 
           v1ClassPart::skClassPart = skClassPart; 
           // build 
           vClassParts = (v1ClassPart)::(v2ClassParts); 
           // push Result 
           skClassParts= vClassParts::skClassParts; 

           then ();
 
       case (47,_) // #line 350 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1ElementItems::skElementItems = skElementItems; 
           // build 
           vClassPart = Absyn.PUBLIC((v1ElementItems)); 
           // push Result 
           skClassPart= vClassPart::skClassPart; 

           then ();
 
       case (48,_) // #line 351 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1ClassPart::skClassPart = skClassPart; 
           // build 
           vClassPart = (v1ClassPart); 
           // push Result 
           skClassPart= vClassPart::skClassPart; 

           then ();
 
       case (49,_) // #line 355 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2String::skString = skString; 
           v1ElementItems::skElementItems = skElementItems; 
           // build 
           vClassPart = Absyn.PUBLIC((v1ElementItems)); 
           // push Result 
           skClassPart= vClassPart::skClassPart; 

           then ();
 
       case (50,_) // #line 356 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2String::skString = skString; 
           v1ElementItems::skElementItems = skElementItems; 
           // build 
           vClassPart = Absyn.PROTECTED((v1ElementItems)); 
           // push Result 
           skClassPart= vClassPart::skClassPart; 

           then ();
 
       case (51,_) // #line 357 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2String::skString = skString; 
           v1EquationItems::skEquationItems = skEquationItems; 
           // build 
           vClassPart = Absyn.EQUATIONS((v1EquationItems)); 
           // push Result 
           skClassPart= vClassPart::skClassPart; 

           then ();
 
       case (52,_) // #line 358 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2String::skString = skString; 
           v1AlgorithmItems::skAlgorithmItems = skAlgorithmItems; 
           // build 
           vClassPart = Absyn.ALGORITHMS((v1AlgorithmItems)); 
           // push Result 
           skClassPart= vClassPart::skClassPart; 

           then ();
 
       case (53,_) // #line 359 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1ClassPart::skClassPart = skClassPart; 
           // build 
           vClassPart=(v1ClassPart); 
           // push Result 
           skClassPart= vClassPart::skClassPart; 

           then ();
 
       case (54,_) // #line 360 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1ClassPart::skClassPart = skClassPart; 
           // build 
           vClassPart=(v1ClassPart); 
           // push Result 
           skClassPart= vClassPart::skClassPart; 

           then ();
 
       case (55,_) // #line 362 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3String::skString = skString; 
           v2String::skString = skString; 
           v1EquationItems::skEquationItems = skEquationItems; 
           // build 
           vClassPart = Absyn.INITIALEQUATIONS((v1EquationItems)); 
           // push Result 
           skClassPart= vClassPart::skClassPart; 

           then ();
 
       case (56,_) // #line 363 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3String::skString = skString; 
           v2String::skString = skString; 
           v1AlgorithmItems::skAlgorithmItems = skAlgorithmItems; 
           // build 
           vClassPart = Absyn.INITIALALGORITHMS((v1AlgorithmItems)); 
           // push Result 
           skClassPart= vClassPart::skClassPart; 

           then ();
 
       case (57,_) // #line 365 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1ElementItems::skElementItems = skElementItems; 
           // build 
           vElementItems=(v1ElementItems); 
           // push Result 
           skElementItems= vElementItems::skElementItems; 

           then ();
 
       case (58,_) // #line 366 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vElementItems={}; 
           // push Result 
           skElementItems= vElementItems::skElementItems; 

           then ();
 
       case (59,_) // #line 368 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1EquationItems::skEquationItems = skEquationItems; 
           // build 
           vEquationItems=(v1EquationItems); 
           // push Result 
           skEquationItems= vEquationItems::skEquationItems; 

           then ();
 
       case (60,_) // #line 369 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vEquationItems={}; 
           // push Result 
           skEquationItems= vEquationItems::skEquationItems; 

           then ();
 
       case (61,_) // #line 371 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1AlgorithmItems::skAlgorithmItems = skAlgorithmItems; 
           // build 
           vAlgorithmItems=(v1AlgorithmItems); 
           // push Result 
           skAlgorithmItems= vAlgorithmItems::skAlgorithmItems; 

           then ();
 
       case (62,_) // #line 372 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vAlgorithmItems={}; 
           // push Result 
           skAlgorithmItems= vAlgorithmItems::skAlgorithmItems; 

           then ();
 
       case (63,_) // #line 374 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vClassPart = Absyn.EXTERNAL(Absyn.EXTERNALDECL(NONE(),NONE(),NONE(),{},NONE()),NONE()); 
           // push Result 
           skClassPart= vClassPart::skClassPart; 

           then ();
 
       case (64,_) // #line 375 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3String::skString = skString; 
           v2ExternalDecl::skExternalDecl = skExternalDecl; 
           v1String::skString = skString; 
           // build 
           vClassPart = Absyn.EXTERNAL((v2ExternalDecl),NONE()); 
           // push Result 
           skClassPart= vClassPart::skClassPart; 

           then ();
 
       case (65,_) // #line 376 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v5String::skString = skString; 
           v4String::skString = skString; 
           v3Annotation::skAnnotation = skAnnotation; 
           v2ExternalDecl::skExternalDecl = skExternalDecl; 
           v1String::skString = skString; 
           // build 
           vClassPart = Absyn.EXTERNAL((v2ExternalDecl),SOME((v3Annotation))); 
           // push Result 
           skClassPart= vClassPart::skClassPart; 

           then ();
 
       case (66,_) // #line 379 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1String::skString = skString; 
           // build 
           vExternalDecl = Absyn.EXTERNALDECL(NONE(),SOME((v1String)),NONE(),{},NONE()); 
           // push Result 
           skExternalDecl= vExternalDecl::skExternalDecl; 

           then ();
 
       case (67,_) // #line 380 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2Annotation::skAnnotation = skAnnotation; 
           v1String::skString = skString; 
           // build 
           vExternalDecl = Absyn.EXTERNALDECL(NONE(),SOME((v1String)),NONE(),{},SOME((v2Annotation))); 
           // push Result 
           skExternalDecl= vExternalDecl::skExternalDecl; 

           then ();
 
       case (68,_) // #line 381 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v7String::skString = skString; 
           v6Exps::skExps = skExps; 
           v5String::skString = skString; 
           v4Ident::skIdent = skIdent; 
           v3String::skString = skString; 
           v2ComponentRef::skComponentRef = skComponentRef; 
           v1String::skString = skString; 
           // build 
           vExternalDecl = Absyn.EXTERNALDECL(SOME((v4Ident)),SOME((v1String)),SOME((v2ComponentRef)),(v6Exps),NONE()); 
           // push Result 
           skExternalDecl= vExternalDecl::skExternalDecl; 

           then ();
 
       case (69,_) // #line 382 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v8Annotation::skAnnotation = skAnnotation; 
           v7String::skString = skString; 
           v6Exps::skExps = skExps; 
           v5String::skString = skString; 
           v4Ident::skIdent = skIdent; 
           v3String::skString = skString; 
           v2ComponentRef::skComponentRef = skComponentRef; 
           v1String::skString = skString; 
           // build 
           vExternalDecl = Absyn.EXTERNALDECL(SOME((v4Ident)),SOME((v1String)),SOME((v2ComponentRef)),(v6Exps),SOME((v8Annotation))); 
           // push Result 
           skExternalDecl= vExternalDecl::skExternalDecl; 

           then ();
 
       case (70,_) // #line 383 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v6Annotation::skAnnotation = skAnnotation; 
           v5String::skString = skString; 
           v4Exps::skExps = skExps; 
           v3String::skString = skString; 
           v2Ident::skIdent = skIdent; 
           v1String::skString = skString; 
           // build 
           vExternalDecl = Absyn.EXTERNALDECL(SOME((v2Ident)),SOME((v1String)),NONE(),(v4Exps),SOME((v6Annotation))); 
           // push Result 
           skExternalDecl= vExternalDecl::skExternalDecl; 

           then ();
 
       case (71,_) // #line 384 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v5String::skString = skString; 
           v4Exps::skExps = skExps; 
           v3String::skString = skString; 
           v2Ident::skIdent = skIdent; 
           v1String::skString = skString; 
           // build 
           vExternalDecl = Absyn.EXTERNALDECL(SOME((v2Ident)),SOME((v1String)),NONE(),(v4Exps),NONE()); 
           // push Result 
           skExternalDecl= vExternalDecl::skExternalDecl; 

           then ();
 
       case (72,_) // #line 385 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v6String::skString = skString; 
           v5Exps::skExps = skExps; 
           v4String::skString = skString; 
           v3Ident::skIdent = skIdent; 
           v2String::skString = skString; 
           v1ComponentRef::skComponentRef = skComponentRef; 
           // build 
           vExternalDecl = Absyn.EXTERNALDECL(SOME((v3Ident)),NONE(),SOME((v1ComponentRef)),(v5Exps),NONE()); 
           // push Result 
           skExternalDecl= vExternalDecl::skExternalDecl; 

           then ();
 
       case (73,_) // #line 386 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v7Annotation::skAnnotation = skAnnotation; 
           v6String::skString = skString; 
           v5Exps::skExps = skExps; 
           v4String::skString = skString; 
           v3Ident::skIdent = skIdent; 
           v2String::skString = skString; 
           v1ComponentRef::skComponentRef = skComponentRef; 
           // build 
           vExternalDecl = Absyn.EXTERNALDECL(SOME((v3Ident)),NONE(),SOME((v1ComponentRef)),(v5Exps),SOME((v7Annotation))); 
           // push Result 
           skExternalDecl= vExternalDecl::skExternalDecl; 

           then ();
 
       case (74,_) // #line 387 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v5Annotation::skAnnotation = skAnnotation; 
           v4String::skString = skString; 
           v3Exps::skExps = skExps; 
           v2String::skString = skString; 
           v1Ident::skIdent = skIdent; 
           // build 
           vExternalDecl = Absyn.EXTERNALDECL(SOME((v1Ident)),NONE(),NONE(),(v3Exps),SOME((v5Annotation))); 
           // push Result 
           skExternalDecl= vExternalDecl::skExternalDecl; 

           then ();
 
       case (75,_) // #line 388 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v4String::skString = skString; 
           v3Exps::skExps = skExps; 
           v2String::skString = skString; 
           v1Ident::skIdent = skIdent; 
           // build 
           vExternalDecl = Absyn.EXTERNALDECL(SOME((v1Ident)),NONE(),NONE(),(v3Exps),NONE()); 
           // push Result 
           skExternalDecl= vExternalDecl::skExternalDecl; 

           then ();
 
       case (76,_) // #line 393 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2String::skString = skString; 
           v1AlgorithmItem::skAlgorithmItem = skAlgorithmItem; 
           // build 
           vAlgorithmItems = (v1AlgorithmItem)::{}; 
           // push Result 
           skAlgorithmItems= vAlgorithmItems::skAlgorithmItems; 

           then ();
 
       case (77,_) // #line 394 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3String::skString = skString; 
           v2AlgorithmItems::skAlgorithmItems = skAlgorithmItems; 
           v1AlgorithmItem::skAlgorithmItem = skAlgorithmItem; 
           // build 
           vAlgorithmItems = (v1AlgorithmItem)::(v2AlgorithmItems); 
           // push Result 
           skAlgorithmItems= vAlgorithmItems::skAlgorithmItems; 

           then ();
 
       case (78,_) // #line 397 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2Comment::skComment = skComment; 
           v1Algorithm::skAlgorithm = skAlgorithm; 
           // build 
           vAlgorithmItem = Absyn.ALGORITHMITEM((v1Algorithm),SOME((v2Comment)),info); 
           // push Result 
           skAlgorithmItem= vAlgorithmItem::skAlgorithmItem; 

           then ();
 
       case (79,_) // #line 400 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3Exp::skExp = skExp; 
           v2String::skString = skString; 
           v1Exp::skExp = skExp; 
           // build 
           vAlgorithm = Absyn.ALG_ASSIGN((v1Exp),(v3Exp)); 
           // push Result 
           skAlgorithm= vAlgorithm::skAlgorithm; 

           then ();
 
       case (80,_) // #line 402 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2FunctionArgs::skFunctionArgs = skFunctionArgs; 
           v1ComponentRef::skComponentRef = skComponentRef; 
           // build 
           vAlgorithm = Absyn.ALG_NORETCALL((v1ComponentRef),(v2FunctionArgs)); 
           // push Result 
           skAlgorithm= vAlgorithm::skAlgorithm; 

           then ();
 
       case (81,_) // #line 404 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vAlgorithm = Absyn.ALG_RETURN(); 
           // push Result 
           skAlgorithm= vAlgorithm::skAlgorithm; 

           then ();
 
       case (82,_) // #line 406 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vAlgorithm = Absyn.ALG_BREAK(); 
           // push Result 
           skAlgorithm= vAlgorithm::skAlgorithm; 

           then ();
 
       case (83,_) // #line 408 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Algorithm::skAlgorithm = skAlgorithm; 
           // build 
           vAlgorithm = (v1Algorithm); 
           // push Result 
           skAlgorithm= vAlgorithm::skAlgorithm; 

           then ();
 
       case (84,_) // #line 410 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Algorithm::skAlgorithm = skAlgorithm; 
           // build 
           vAlgorithm = (v1Algorithm); 
           // push Result 
           skAlgorithm= vAlgorithm::skAlgorithm; 

           then ();
 
       case (85,_) // #line 412 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v5AlgorithmItems::skAlgorithmItems = skAlgorithmItems; 
           v4String::skString = skString; 
           v3ForIterators::skForIterators = skForIterators; 
           v2String::skString = skString; 
           v1String::skString = skString; 
           // build 
           vAlgorithm = Absyn.ALG_FOR((v3ForIterators),(v5AlgorithmItems)); 
           // push Result 
           skAlgorithm= vAlgorithm::skAlgorithm; 

           then ();
 
       case (86,_) // #line 414 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v5AlgorithmItems::skAlgorithmItems = skAlgorithmItems; 
           v4String::skString = skString; 
           v3Exp::skExp = skExp; 
           v2String::skString = skString; 
           v1String::skString = skString; 
           // build 
           vAlgorithm = Absyn.ALG_WHILE((v3Exp),(v5AlgorithmItems)); 
           // push Result 
           skAlgorithm= vAlgorithm::skAlgorithm; 

           then ();
 
       case (87,_) // #line 416 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v4String::skString = skString; 
           v3String::skString = skString; 
           v2Exp::skExp = skExp; 
           v1String::skString = skString; 
           // build 
           vAlgorithm = Absyn.ALG_IF((v2Exp),{},{},{}); 
           // push Result 
           skAlgorithm= vAlgorithm::skAlgorithm; 

           then ();
 
       case (88,_) // #line 417 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v5String::skString = skString; 
           v4AlgorithmItems::skAlgorithmItems = skAlgorithmItems; 
           v3String::skString = skString; 
           v2Exp::skExp = skExp; 
           v1String::skString = skString; 
           // build 
           vAlgorithm = Absyn.ALG_IF((v2Exp),(v4AlgorithmItems),{},{}); 
           // push Result 
           skAlgorithm= vAlgorithm::skAlgorithm; 

           then ();
 
       case (89,_) // #line 418 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v7String::skString = skString; 
           v6AlgorithmItems::skAlgorithmItems = skAlgorithmItems; 
           v5String::skString = skString; 
           v4AlgorithmItems::skAlgorithmItems = skAlgorithmItems; 
           v3String::skString = skString; 
           v2Exp::skExp = skExp; 
           v1String::skString = skString; 
           // build 
           vAlgorithm = Absyn.ALG_IF((v2Exp),(v4AlgorithmItems),{},(v6AlgorithmItems)); 
           // push Result 
           skAlgorithm= vAlgorithm::skAlgorithm; 

           then ();
 
       case (90,_) // #line 419 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v6String::skString = skString; 
           v5AlgElseifs::skAlgElseifs = skAlgElseifs; 
           v4AlgorithmItems::skAlgorithmItems = skAlgorithmItems; 
           v3String::skString = skString; 
           v2Exp::skExp = skExp; 
           v1String::skString = skString; 
           // build 
           vAlgorithm = Absyn.ALG_IF((v2Exp),(v4AlgorithmItems),(v5AlgElseifs),{}); 
           // push Result 
           skAlgorithm= vAlgorithm::skAlgorithm; 

           then ();
 
       case (91,_) // #line 420 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v8String::skString = skString; 
           v7AlgorithmItems::skAlgorithmItems = skAlgorithmItems; 
           v6String::skString = skString; 
           v5AlgElseifs::skAlgElseifs = skAlgElseifs; 
           v4AlgorithmItems::skAlgorithmItems = skAlgorithmItems; 
           v3String::skString = skString; 
           v2Exp::skExp = skExp; 
           v1String::skString = skString; 
           // build 
           vAlgorithm = Absyn.ALG_IF((v2Exp),(v4AlgorithmItems),(v5AlgElseifs),(v7AlgorithmItems)); 
           // push Result 
           skAlgorithm= vAlgorithm::skAlgorithm; 

           then ();
 
       case (92,_) // #line 422 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1AlgElseif::skAlgElseif = skAlgElseif; 
           // build 
           vAlgElseifs = (v1AlgElseif)::{}; 
           // push Result 
           skAlgElseifs= vAlgElseifs::skAlgElseifs; 

           then ();
 
       case (93,_) // #line 423 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2AlgElseifs::skAlgElseifs = skAlgElseifs; 
           v1AlgElseif::skAlgElseif = skAlgElseif; 
           // build 
           vAlgElseifs = (v1AlgElseif)::(v2AlgElseifs); 
           // push Result 
           skAlgElseifs= vAlgElseifs::skAlgElseifs; 

           then ();
 
       case (94,_) // #line 425 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v4AlgorithmItems::skAlgorithmItems = skAlgorithmItems; 
           v3String::skString = skString; 
           v2Exp::skExp = skExp; 
           v1String::skString = skString; 
           // build 
           vAlgElseif = ((v2Exp),(v4AlgorithmItems)); 
           // push Result 
           skAlgElseif= vAlgElseif::skAlgElseif; 

           then ();
 
       case (95,_) // #line 428 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v5String::skString = skString; 
           v4AlgorithmItems::skAlgorithmItems = skAlgorithmItems; 
           v3String::skString = skString; 
           v2Exp::skExp = skExp; 
           v1String::skString = skString; 
           // build 
           vAlgorithm = Absyn.ALG_WHEN_A((v2Exp),(v4AlgorithmItems),{}); 
           // push Result 
           skAlgorithm= vAlgorithm::skAlgorithm; 

           then ();
 
       case (96,_) // #line 430 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v6String::skString = skString; 
           v5AlgElsewhens::skAlgElsewhens = skAlgElsewhens; 
           v4AlgorithmItems::skAlgorithmItems = skAlgorithmItems; 
           v3String::skString = skString; 
           v2Exp::skExp = skExp; 
           v1String::skString = skString; 
           // build 
           vAlgorithm = Absyn.ALG_WHEN_A((v2Exp),(v4AlgorithmItems),(v5AlgElsewhens)); 
           // push Result 
           skAlgorithm= vAlgorithm::skAlgorithm; 

           then ();
 
       case (97,_) // #line 432 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1AlgElsewhen::skAlgElsewhen = skAlgElsewhen; 
           // build 
           vAlgElsewhens = (v1AlgElsewhen)::{}; 
           // push Result 
           skAlgElsewhens= vAlgElsewhens::skAlgElsewhens; 

           then ();
 
       case (98,_) // #line 433 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2AlgElsewhens::skAlgElsewhens = skAlgElsewhens; 
           v1AlgElsewhen::skAlgElsewhen = skAlgElsewhen; 
           // build 
           vAlgElsewhens = (v1AlgElsewhen)::(v2AlgElsewhens); 
           // push Result 
           skAlgElsewhens= vAlgElsewhens::skAlgElsewhens; 

           then ();
 
       case (99,_) // #line 435 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v4AlgorithmItems::skAlgorithmItems = skAlgorithmItems; 
           v3String::skString = skString; 
           v2Exp::skExp = skExp; 
           v1String::skString = skString; 
           // build 
           vAlgElsewhen = ((v2Exp),(v4AlgorithmItems)); 
           // push Result 
           skAlgElsewhen= vAlgElsewhen::skAlgElsewhen; 

           then ();
 
       case (100,_) // #line 439 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2String::skString = skString; 
           v1EquationItem::skEquationItem = skEquationItem; 
           // build 
           vEquationItems = (v1EquationItem)::{}; 
           // push Result 
           skEquationItems= vEquationItems::skEquationItems; 

           then ();
 
       case (101,_) // #line 440 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3String::skString = skString; 
           v2EquationItems::skEquationItems = skEquationItems; 
           v1EquationItem::skEquationItem = skEquationItem; 
           // build 
           vEquationItems = (v1EquationItem)::(v2EquationItems); 
           // push Result 
           skEquationItems= vEquationItems::skEquationItems; 

           then ();
 
       case (102,_) // #line 443 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2Comment::skComment = skComment; 
           v1Equation::skEquation = skEquation; 
           // build 
           vEquationItem = Absyn.EQUATIONITEM((v1Equation),SOME((v2Comment)),info); 
           // push Result 
           skEquationItem= vEquationItem::skEquationItem; 

           then ();
 
       case (103,_) // #line 446 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3Exp::skExp = skExp; 
           v2String::skString = skString; 
           v1Exp::skExp = skExp; 
           // build 
           vEquation = Absyn.EQ_EQUALS((v1Exp),(v3Exp)); 
           // push Result 
           skEquation= vEquation::skEquation; 

           then ();
 
       case (104,_) // #line 448 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Equation::skEquation = skEquation; 
           // build 
           vEquation = (v1Equation); 
           // push Result 
           skEquation= vEquation::skEquation; 

           then ();
 
       case (105,_) // #line 450 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Equation::skEquation = skEquation; 
           // build 
           vEquation = (v1Equation); 
           // push Result 
           skEquation= vEquation::skEquation; 

           then ();
 
       case (106,_) // #line 452 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v6String::skString = skString; 
           v5ComponentRef::skComponentRef = skComponentRef; 
           v4String::skString = skString; 
           v3ComponentRef::skComponentRef = skComponentRef; 
           v2String::skString = skString; 
           v1String::skString = skString; 
           // build 
           vEquation = Absyn.EQ_CONNECT((v3ComponentRef),(v5ComponentRef)); 
           // push Result 
           skEquation= vEquation::skEquation; 

           then ();
 
       case (107,_) // #line 454 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v5EquationItems::skEquationItems = skEquationItems; 
           v4String::skString = skString; 
           v3ForIterators::skForIterators = skForIterators; 
           v2String::skString = skString; 
           v1String::skString = skString; 
           // build 
           vEquation = Absyn.EQ_FOR((v3ForIterators),(v5EquationItems)); 
           // push Result 
           skEquation= vEquation::skEquation; 

           then ();
 
       case (108,_) // #line 455 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2FunctionArgs::skFunctionArgs = skFunctionArgs; 
           v1ComponentRef::skComponentRef = skComponentRef; 
           // build 
           vEquation = Absyn.EQ_NORETCALL((v1ComponentRef),(v2FunctionArgs)); 
           // push Result 
           skEquation= vEquation::skEquation; 

           then ();
 
       case (109,_) // #line 458 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v5String::skString = skString; 
           v4EquationItems::skEquationItems = skEquationItems; 
           v3String::skString = skString; 
           v2Exp::skExp = skExp; 
           v1String::skString = skString; 
           // build 
           vEquation = Absyn.EQ_WHEN_E((v2Exp),(v4EquationItems),{}); 
           // push Result 
           skEquation= vEquation::skEquation; 

           then ();
 
       case (110,_) // #line 460 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v6String::skString = skString; 
           v5Elsewhens::skElsewhens = skElsewhens; 
           v4EquationItems::skEquationItems = skEquationItems; 
           v3String::skString = skString; 
           v2Exp::skExp = skExp; 
           v1String::skString = skString; 
           // build 
           vEquation = Absyn.EQ_WHEN_E((v2Exp),(v4EquationItems),(v5Elsewhens)); 
           // push Result 
           skEquation= vEquation::skEquation; 

           then ();
 
       case (111,_) // #line 462 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Elsewhen::skElsewhen = skElsewhen; 
           // build 
           vElsewhens = (v1Elsewhen)::{}; 
           // push Result 
           skElsewhens= vElsewhens::skElsewhens; 

           then ();
 
       case (112,_) // #line 463 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2Elsewhens::skElsewhens = skElsewhens; 
           v1Elsewhen::skElsewhen = skElsewhen; 
           // build 
           vElsewhens = (v1Elsewhen)::(v2Elsewhens); 
           // push Result 
           skElsewhens= vElsewhens::skElsewhens; 

           then ();
 
       case (113,_) // #line 465 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v4EquationItems::skEquationItems = skEquationItems; 
           v3String::skString = skString; 
           v2Exp::skExp = skExp; 
           v1String::skString = skString; 
           // build 
           vElsewhen = ((v2Exp),(v4EquationItems)); 
           // push Result 
           skElsewhen= vElsewhen::skElsewhen; 

           then ();
 
       case (114,_) // #line 467 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1ForIterator::skForIterator = skForIterator; 
           // build 
           vForIterators = (v1ForIterator)::{}; 
           // push Result 
           skForIterators= vForIterators::skForIterators; 

           then ();
 
       case (115,_) // #line 468 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3String::skString = skString; 
           v2ForIterators::skForIterators = skForIterators; 
           v1ForIterator::skForIterator = skForIterator; 
           // build 
           vForIterators = (v1ForIterator)::(v2ForIterators); 
           // push Result 
           skForIterators= vForIterators::skForIterators; 

           then ();
 
       case (116,_) // #line 470 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1String::skString = skString; 
           // build 
           vForIterator = Absyn.ITERATOR((v1String),NONE(),NONE()); 
           // push Result 
           skForIterator= vForIterator::skForIterator; 

           then ();
 
       case (117,_) // #line 471 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3Exp::skExp = skExp; 
           v2String::skString = skString; 
           v1String::skString = skString; 
           // build 
           vForIterator = Absyn.ITERATOR((v1String),NONE(),SOME((v3Exp))); 
           // push Result 
           skForIterator= vForIterator::skForIterator; 

           then ();
 
       case (118,_) // #line 474 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v5String::skString = skString; 
           v4EquationItems::skEquationItems = skEquationItems; 
           v3String::skString = skString; 
           v2Exp::skExp = skExp; 
           v1String::skString = skString; 
           // build 
           vEquation = Absyn.EQ_IF((v2Exp),(v4EquationItems),{},{}); 
           // push Result 
           skEquation= vEquation::skEquation; 

           then ();
 
       case (119,_) // #line 476 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v7String::skString = skString; 
           v6EquationItems::skEquationItems = skEquationItems; 
           v5String::skString = skString; 
           v4EquationItems::skEquationItems = skEquationItems; 
           v3String::skString = skString; 
           v2Exp::skExp = skExp; 
           v1String::skString = skString; 
           // build 
           vEquation = Absyn.EQ_IF((v2Exp),(v4EquationItems),{},(v6EquationItems)); 
           // push Result 
           skEquation= vEquation::skEquation; 

           then ();
 
       case (120,_) // #line 478 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v6String::skString = skString; 
           v5String::skString = skString; 
           v4EquationItems::skEquationItems = skEquationItems; 
           v3String::skString = skString; 
           v2Exp::skExp = skExp; 
           v1String::skString = skString; 
           // build 
           vEquation = Absyn.EQ_IF((v2Exp),(v4EquationItems),{},{}); 
           // push Result 
           skEquation= vEquation::skEquation; 

           then ();
 
       case (121,_) // #line 480 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v6String::skString = skString; 
           v5Elseifs::skElseifs = skElseifs; 
           v4EquationItems::skEquationItems = skEquationItems; 
           v3String::skString = skString; 
           v2Exp::skExp = skExp; 
           v1String::skString = skString; 
           // build 
           vEquation = Absyn.EQ_IF((v2Exp),(v4EquationItems),(v5Elseifs),{}); 
           // push Result 
           skEquation= vEquation::skEquation; 

           then ();
 
       case (122,_) // #line 482 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v8String::skString = skString; 
           v7EquationItems::skEquationItems = skEquationItems; 
           v6String::skString = skString; 
           v5Elseifs::skElseifs = skElseifs; 
           v4EquationItems::skEquationItems = skEquationItems; 
           v3String::skString = skString; 
           v2Exp::skExp = skExp; 
           v1String::skString = skString; 
           // build 
           vEquation = Absyn.EQ_IF((v2Exp),(v4EquationItems),(v5Elseifs),(v7EquationItems)); 
           // push Result 
           skEquation= vEquation::skEquation; 

           then ();
 
       case (123,_) // #line 484 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v7String::skString = skString; 
           v6String::skString = skString; 
           v5Elseifs::skElseifs = skElseifs; 
           v4EquationItems::skEquationItems = skEquationItems; 
           v3String::skString = skString; 
           v2Exp::skExp = skExp; 
           v1String::skString = skString; 
           // build 
           vEquation = Absyn.EQ_IF((v2Exp),(v4EquationItems),(v5Elseifs),{}); 
           // push Result 
           skEquation= vEquation::skEquation; 

           then ();
 
       case (124,_) // #line 486 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Elseif::skElseif = skElseif; 
           // build 
           vElseifs = (v1Elseif)::{}; 
           // push Result 
           skElseifs= vElseifs::skElseifs; 

           then ();
 
       case (125,_) // #line 487 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2Elseifs::skElseifs = skElseifs; 
           v1Elseif::skElseif = skElseif; 
           // build 
           vElseifs = (v1Elseif)::(v2Elseifs); 
           // push Result 
           skElseifs= vElseifs::skElseifs; 

           then ();
 
       case (126,_) // #line 489 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v4EquationItems::skEquationItems = skEquationItems; 
           v3String::skString = skString; 
           v2Exp::skExp = skExp; 
           v1String::skString = skString; 
           // build 
           vElseif = ((v2Exp),(v4EquationItems)); 
           // push Result 
           skElseif= vElseif::skElseif; 

           then ();
 
       case (127,_) // #line 493 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1ElementItem::skElementItem = skElementItem; 
           // build 
           vElementItems = (v1ElementItem)::{}; 
           // push Result 
           skElementItems= vElementItems::skElementItems; 

           then ();
 
       case (128,_) // #line 494 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2ElementItems::skElementItems = skElementItems; 
           v1ElementItem::skElementItem = skElementItem; 
           // build 
           vElementItems = (v1ElementItem)::(v2ElementItems); 
           // push Result 
           skElementItems= vElementItems::skElementItems; 

           then ();
 
       case (129,_) // #line 497 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2String::skString = skString; 
           v1Element::skElement = skElement; 
           // build 
           vElementItem = Absyn.ELEMENTITEM((v1Element)); 
           // push Result 
           skElementItem= vElementItem::skElementItem; 

           then ();
 
       case (130,_) // #line 498 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2String::skString = skString; 
           v1Annotation::skAnnotation = skAnnotation; 
           // build 
           vElementItem = Absyn.ANNOTATIONITEM((v1Annotation)); 
           // push Result 
           skElementItem= vElementItem::skElementItem; 

           then ();
 
       case (131,_) // #line 501 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Element::skElement = skElement; 
           // build 
           vElement = (v1Element); 
           // push Result 
           skElement= vElement::skElement; 

           then ();
 
       case (132,_) // #line 503 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Element::skElement = skElement; 
           // build 
           vElement = (v1Element); 
           // push Result 
           skElement= vElement::skElement; 

           then ();
 
       case (133,_) // #line 505 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1ElementSpec::skElementSpec = skElementSpec; 
           // build 
           vElement = Absyn.ELEMENT(false,NONE(),Absyn.NOT_INNER_OUTER(),"IMPORT",(v1ElementSpec),info,NONE()); 
           // push Result 
           skElement= vElement::skElement; 

           then ();
 
       case (134,_) // #line 507 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1ElementSpec::skElementSpec = skElementSpec; 
           // build 
           vElement = Absyn.ELEMENT(false,NONE(),Absyn.NOT_INNER_OUTER(),"EXTENDS",(v1ElementSpec),info,NONE()); 
           // push Result 
           skElement= vElement::skElement; 

           then ();
 
       case (135,_) // #line 509 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Element::skElement = skElement; 
           // build 
           vElement = (v1Element); 
           // push Result 
           skElement= vElement::skElement; 

           then ();
 
       case (136,_) // #line 511 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2Ident::skIdent = skIdent; 
           v1String::skString = skString; 
           // build 
           vElement = Absyn.DEFINEUNIT((v2Ident),{}); 
           // push Result 
           skElement= vElement::skElement; 

           then ();
 
       case (137,_) // #line 512 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v5String::skString = skString; 
           v4NamedArgs::skNamedArgs = skNamedArgs; 
           v3String::skString = skString; 
           v2Ident::skIdent = skIdent; 
           v1String::skString = skString; 
           // build 
           vElement = Absyn.DEFINEUNIT((v2Ident),(v4NamedArgs)); 
           // push Result 
           skElement= vElement::skElement; 

           then ();
 
       case (138,_) // #line 516 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1ElementSpec::skElementSpec = skElementSpec; 
           // build 
           vElement = Absyn.ELEMENT(false,NONE(),Absyn.NOT_INNER_OUTER(),"??",(v1ElementSpec),info,NONE()); 
           // push Result 
           skElement= vElement::skElement; 

           then ();
 
       case (139,_) // #line 518 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2String::skString = skString; 
           v1ElementSpec::skElementSpec = skElementSpec; 
           // build 
           vElement = Absyn.ELEMENT(false,SOME(Absyn.REDECLARE()),Absyn.NOT_INNER_OUTER(),"CLASS",(v1ElementSpec),info,NONE()); 
           // push Result 
           skElement= vElement::skElement; 

           then ();
 
       case (140,_) // #line 524 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1ElementSpec::skElementSpec = skElementSpec; 
           // build 
           vElement = Absyn.ELEMENT(false,NONE(),Absyn.NOT_INNER_OUTER(),"component",(v1ElementSpec),info,NONE()); 
           // push Result 
           skElement= vElement::skElement; 

           then ();
 
       case (141,_) // #line 526 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2ElementSpec::skElementSpec = skElementSpec; 
           v1InnerOuter::skInnerOuter = skInnerOuter; 
           // build 
           vElement = Absyn.ELEMENT(false,NONE(),(v1InnerOuter),"INNEROUTTER ELEMENTSPEC",(v2ElementSpec),info,NONE()); 
           // push Result 
           skElement= vElement::skElement; 

           then ();
 
       case (142,_) // #line 528 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v4ElementSpec::skElementSpec = skElementSpec; 
           v3InnerOuter::skInnerOuter = skInnerOuter; 
           v2Boolean::skBoolean = skBoolean; 
           v1RedeclareKeywords::skRedeclareKeywords = skRedeclareKeywords; 
           // build 
           vElement = Absyn.ELEMENT((v2Boolean),SOME((v1RedeclareKeywords)),(v3InnerOuter),"REDE ELEMENTSPEC",(v4ElementSpec),info,NONE()); 
           // push Result 
           skElement= vElement::skElement; 

           then ();
 
       case (143,_) // #line 530 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3ElementSpec::skElementSpec = skElementSpec; 
           v2Boolean::skBoolean = skBoolean; 
           v1RedeclareKeywords::skRedeclareKeywords = skRedeclareKeywords; 
           // build 
           vElement = Absyn.ELEMENT((v2Boolean),SOME((v1RedeclareKeywords)),Absyn.NOT_INNER_OUTER(),"REDE ELEMENTSPEC",(v3ElementSpec),info,NONE()); 
           // push Result 
           skElement= vElement::skElement; 

           then ();
 
       case (144,_) // #line 532 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v4ConstrainClass::skConstrainClass = skConstrainClass; 
           v3ElementSpec::skElementSpec = skElementSpec; 
           v2Boolean::skBoolean = skBoolean; 
           v1RedeclareKeywords::skRedeclareKeywords = skRedeclareKeywords; 
           // build 
           vElement = Absyn.ELEMENT((v2Boolean),SOME((v1RedeclareKeywords)),Absyn.NOT_INNER_OUTER(),"REDE ELEMENTSPEC",(v3ElementSpec),info,SOME((v4ConstrainClass))); 
           // push Result 
           skElement= vElement::skElement; 

           then ();
 
       case (145,_) // #line 534 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2ElementSpec::skElementSpec = skElementSpec; 
           v1String::skString = skString; 
           // build 
           vElement = Absyn.ELEMENT(true,NONE(),Absyn.NOT_INNER_OUTER(),"FINAL ELEMENTSPEC",(v2ElementSpec),info,NONE()); 
           // push Result 
           skElement= vElement::skElement; 

           then ();
 
       case (146,_) // #line 536 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3ElementSpec::skElementSpec = skElementSpec; 
           v2InnerOuter::skInnerOuter = skInnerOuter; 
           v1String::skString = skString; 
           // build 
           vElement = Absyn.ELEMENT(true,NONE(),(v2InnerOuter),"FINAL INNEROUTER ELEMENTSPEC",(v3ElementSpec),info,NONE()); 
           // push Result 
           skElement= vElement::skElement; 

           then ();
 
       case (147,_) // #line 538 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1ComponentItem::skComponentItem = skComponentItem; 
           // build 
           vComponentItems = (v1ComponentItem)::{}; 
           // push Result 
           skComponentItems= vComponentItems::skComponentItems; 

           then ();
 
       case (148,_) // #line 539 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3String::skString = skString; 
           v2ComponentItems::skComponentItems = skComponentItems; 
           v1ComponentItem::skComponentItem = skComponentItem; 
           // build 
           vComponentItems = (v1ComponentItem)::(v2ComponentItems); 
           // push Result 
           skComponentItems= vComponentItems::skComponentItems; 

           then ();
 
       case (149,_) // #line 541 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2Comment::skComment = skComment; 
           v1Component::skComponent = skComponent; 
           // build 
           vComponentItem = Absyn.COMPONENTITEM((v1Component),NONE(),SOME((v2Comment))); 
           // push Result 
           skComponentItem= vComponentItem::skComponentItem; 

           then ();
 
       case (150,_) // #line 542 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3Comment::skComment = skComment; 
           v2ComponentCondition::skComponentCondition = skComponentCondition; 
           v1Component::skComponent = skComponent; 
           // build 
           vComponentItem = Absyn.COMPONENTITEM((v1Component),SOME((v2ComponentCondition)),SOME((v3Comment))); 
           // push Result 
           skComponentItem= vComponentItem::skComponentItem; 

           then ();
 
       case (151,_) // #line 544 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2String::skString = skString; 
           v1Exp::skExp = skExp; 
           // build 
           vComponentCondition = (v1Exp); 
           // push Result 
           skComponentCondition= vComponentCondition::skComponentCondition; 

           then ();
 
       case (152,_) // #line 546 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3Modification::skModification = skModification; 
           v2ArrayDim::skArrayDim = skArrayDim; 
           v1Ident::skIdent = skIdent; 
           // build 
           vComponent = Absyn.COMPONENT((v1Ident),(v2ArrayDim),SOME((v3Modification))); 
           // push Result 
           skComponent= vComponent::skComponent; 

           then ();
 
       case (153,_) // #line 547 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2ArrayDim::skArrayDim = skArrayDim; 
           v1Ident::skIdent = skIdent; 
           // build 
           vComponent = Absyn.COMPONENT((v1Ident),(v2ArrayDim),NONE()); 
           // push Result 
           skComponent= vComponent::skComponent; 

           then ();
 
       case (154,_) // #line 549 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2Exp::skExp = skExp; 
           v1String::skString = skString; 
           // build 
           vModification = Absyn.CLASSMOD({},Absyn.EQMOD((v2Exp),info)); 
           // push Result 
           skModification= vModification::skModification; 

           then ();
 
       case (155,_) // #line 550 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2Exp::skExp = skExp; 
           v1String::skString = skString; 
           // build 
           vModification = Absyn.CLASSMOD({},Absyn.EQMOD((v2Exp),info)); 
           // push Result 
           skModification= vModification::skModification; 

           then ();
 
       case (156,_) // #line 551 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Modification::skModification = skModification; 
           // build 
           vModification = (v1Modification); 
           // push Result 
           skModification= vModification::skModification; 

           then ();
 
       case (157,_) // #line 554 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1ElementArgs::skElementArgs = skElementArgs; 
           // build 
           vModification = Absyn.CLASSMOD((v1ElementArgs),Absyn.NOMOD()); 
           // push Result 
           skModification= vModification::skModification; 

           then ();
 
       case (158,_) // #line 556 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3Exp::skExp = skExp; 
           v2String::skString = skString; 
           v1ElementArgs::skElementArgs = skElementArgs; 
           // build 
           vModification = Absyn.CLASSMOD((v1ElementArgs),Absyn.EQMOD((v3Exp),info)); 
           // push Result 
           skModification= vModification::skModification; 

           then ();
 
       case (159,_) // #line 558 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2String::skString = skString; 
           v1ElementArgs::skElementArgs = skElementArgs; 
           // build 
           vAnnotation= Absyn.ANNOTATION((v1ElementArgs)); 
           // push Result 
           skAnnotation= vAnnotation::skAnnotation; 

           then ();
 
       case (160,_) // #line 560 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3String::skString = skString; 
           v2String::skString = skString; 
           v1ElementArgs::skElementArgs = skElementArgs; 
           // build 
           vElementArgs = (v1ElementArgs); 
           // push Result 
           skElementArgs= vElementArgs::skElementArgs; 

           then ();
 
       case (161,_) // #line 562 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3String::skString = skString; 
           v2String::skString = skString; 
           v1ElementArgs::skElementArgs = skElementArgs; 
           // build 
           vElementArgs = (v1ElementArgs); 
           // push Result 
           skElementArgs= vElementArgs::skElementArgs; 

           then ();
 
       case (162,_) // #line 563 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vElementArgs = {}; 
           // push Result 
           skElementArgs= vElementArgs::skElementArgs; 

           then ();
 
       case (163,_) // #line 565 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1ElementArg::skElementArg = skElementArg; 
           // build 
           vElementArgs = {(v1ElementArg)}; 
           // push Result 
           skElementArgs= vElementArgs::skElementArgs; 

           then ();
 
       case (164,_) // #line 566 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3String::skString = skString; 
           v2ElementArgs::skElementArgs = skElementArgs; 
           v1ElementArg::skElementArg = skElementArg; 
           // build 
           vElementArgs = (v1ElementArg)::(v2ElementArgs); 
           // push Result 
           skElementArgs= vElementArgs::skElementArgs; 

           then ();
 
       case (165,_) // #line 568 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1ElementArg::skElementArg = skElementArg; 
           // build 
           vElementArg = (v1ElementArg); 
           // push Result 
           skElementArg= vElementArg::skElementArg; 

           then ();
 
       case (166,_) // #line 569 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1ElementArg::skElementArg = skElementArg; 
           // build 
           vElementArg = (v1ElementArg); 
           // push Result 
           skElementArg= vElementArg::skElementArg; 

           then ();
 
       case (167,_) // #line 571 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1ElementArg::skElementArg = skElementArg; 
           // build 
           vElementArg = (v1ElementArg); 
           // push Result 
           skElementArg= vElementArg::skElementArg; 

           then ();
 
       case (168,_) // #line 572 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1ElementArg::skElementArg = skElementArg; 
           // build 
           vElementArg = (v1ElementArg); 
           // push Result 
           skElementArg= vElementArg::skElementArg; 

           then ();
 
       case (169,_) // #line 575 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3ComponentRef::skComponentRef = skComponentRef; 
           v2Boolean::skBoolean = skBoolean; 
           v1Each::skEach = skEach; 
           // build 
           vElementArg = Absyn.MODIFICATION((v2Boolean),(v1Each),(v3ComponentRef),NONE(),NONE(),info); 
           // push Result 
           skElementArg= vElementArg::skElementArg; 

           then ();
 
       case (170,_) // #line 577 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v4Modification::skModification = skModification; 
           v3ComponentRef::skComponentRef = skComponentRef; 
           v2Boolean::skBoolean = skBoolean; 
           v1Each::skEach = skEach; 
           // build 
           vElementArg = Absyn.MODIFICATION((v2Boolean),(v1Each),(v3ComponentRef),SOME((v4Modification)),NONE(),info); 
           // push Result 
           skElementArg= vElementArg::skElementArg; 

           then ();
 
       case (171,_) // #line 579 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v4String::skString = skString; 
           v3ComponentRef::skComponentRef = skComponentRef; 
           v2Boolean::skBoolean = skBoolean; 
           v1Each::skEach = skEach; 
           // build 
           vElementArg = Absyn.MODIFICATION((v2Boolean),(v1Each),(v3ComponentRef),NONE(),SOME((v4String)),info); 
           // push Result 
           skElementArg= vElementArg::skElementArg; 

           then ();
 
       case (172,_) // #line 581 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v5String::skString = skString; 
           v4Modification::skModification = skModification; 
           v3ComponentRef::skComponentRef = skComponentRef; 
           v2Boolean::skBoolean = skBoolean; 
           v1Each::skEach = skEach; 
           // build 
           vElementArg = Absyn.MODIFICATION((v2Boolean),(v1Each),(v3ComponentRef),SOME((v4Modification)),SOME((v5String)),info); 
           // push Result 
           skElementArg= vElementArg::skElementArg; 

           then ();
 
       case (173,_) // #line 585 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v4ElementSpec::skElementSpec = skElementSpec; 
           v3Boolean::skBoolean = skBoolean; 
           v2Each::skEach = skEach; 
           v1String::skString = skString; 
           // build 
           vElementArg = Absyn.REDECLARATION((v3Boolean),Absyn.REPLACEABLE(),(v2Each),(v4ElementSpec),NONE(),info); 
           // push Result 
           skElementArg= vElementArg::skElementArg; 

           then ();
 
       case (174,_) // #line 587 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v4ElementSpec::skElementSpec = skElementSpec; 
           v3Boolean::skBoolean = skBoolean; 
           v2Each::skEach = skEach; 
           v1String::skString = skString; 
           // build 
           vElementArg = Absyn.REDECLARATION((v3Boolean),Absyn.REPLACEABLE(),(v2Each),(v4ElementSpec),NONE(),info); 
           // push Result 
           skElementArg= vElementArg::skElementArg; 

           then ();
 
       case (175,_) // #line 589 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v5ConstrainClass::skConstrainClass = skConstrainClass; 
           v4ElementSpec::skElementSpec = skElementSpec; 
           v3Boolean::skBoolean = skBoolean; 
           v2Each::skEach = skEach; 
           v1String::skString = skString; 
           // build 
           vElementArg = Absyn.REDECLARATION((v3Boolean),Absyn.REDECLARE(),(v2Each),(v4ElementSpec),SOME((v5ConstrainClass)),info); 
           // push Result 
           skElementArg= vElementArg::skElementArg; 

           then ();
 
       case (176,_) // #line 591 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v5ConstrainClass::skConstrainClass = skConstrainClass; 
           v4ElementSpec::skElementSpec = skElementSpec; 
           v3Boolean::skBoolean = skBoolean; 
           v2Each::skEach = skEach; 
           v1String::skString = skString; 
           // build 
           vElementArg = Absyn.REDECLARATION((v3Boolean),Absyn.REDECLARE(),(v2Each),(v4ElementSpec),SOME((v5ConstrainClass)),info); 
           // push Result 
           skElementArg= vElementArg::skElementArg; 

           then ();
 
       case (177,_) // #line 595 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v4ElementSpec::skElementSpec = skElementSpec; 
           v3Boolean::skBoolean = skBoolean; 
           v2Each::skEach = skEach; 
           v1String::skString = skString; 
           // build 
           vElementArg = Absyn.REDECLARATION((v3Boolean),Absyn.REDECLARE(),(v2Each),(v4ElementSpec),NONE(),info); 
           // push Result 
           skElementArg= vElementArg::skElementArg; 

           then ();
 
       case (178,_) // #line 597 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v4ElementSpec::skElementSpec = skElementSpec; 
           v3Boolean::skBoolean = skBoolean; 
           v2Each::skEach = skEach; 
           v1String::skString = skString; 
           // build 
           vElementArg = Absyn.REDECLARATION((v3Boolean),Absyn.REDECLARE(),(v2Each),(v4ElementSpec),NONE(),info); 
           // push Result 
           skElementArg= vElementArg::skElementArg; 

           then ();
 
       case (179,_) // #line 601 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3ComponentItems::skComponentItems = skComponentItems; 
           v2TypeSpec::skTypeSpec = skTypeSpec; 
           v1ElementAttributes::skElementAttributes = skElementAttributes; 
           // build 
           ((v1ElementAttributes),(v2TypeSpec)) = fixArray((v1ElementAttributes),(v2TypeSpec));
                          vElementSpec = Absyn.COMPONENTS((v1ElementAttributes),(v2TypeSpec),(v3ComponentItems)); 
           // push Result 
           skElementSpec= vElementSpec::skElementSpec; 

           then ();
 
       case (180,_) // #line 604 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2ComponentItems::skComponentItems = skComponentItems; 
           v1TypeSpec::skTypeSpec = skTypeSpec; 
           // build 
           (v1ElementAttributes,(v1TypeSpec)) = fixArray(Absyn.ATTR(false,false,Absyn.NON_PARALLEL(),Absyn.VAR(), Absyn.BIDIR(),{}),(v1TypeSpec)); 
                         vElementSpec = Absyn.COMPONENTS(v1ElementAttributes,(v1TypeSpec),(v2ComponentItems)); 
           // push Result 
           skElementSpec= vElementSpec::skElementSpec; 

           then ();
 
       case (181,_) // #line 607 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2Comment::skComment = skComment; 
           v1Component::skComponent = skComponent; 
           // build 
           vComponentItems = {Absyn.COMPONENTITEM((v1Component),NONE(),SOME((v2Comment)))}; 
           // push Result 
           skComponentItems= vComponentItems::skComponentItems; 

           then ();
 
       case (182,_) // #line 609 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vEach= Absyn.EACH(); 
           // push Result 
           skEach= vEach::skEach; 

           then ();
 
       case (183,_) // #line 610 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vEach= Absyn.NON_EACH(); 
           // push Result 
           skEach= vEach::skEach; 

           then ();
 
       case (184,_) // #line 612 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vRedeclareKeywords = Absyn.REDECLARE(); 
           // push Result 
           skRedeclareKeywords= vRedeclareKeywords::skRedeclareKeywords; 

           then ();
 
       case (185,_) // #line 613 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vRedeclareKeywords = Absyn.REPLACEABLE(); 
           // push Result 
           skRedeclareKeywords= vRedeclareKeywords::skRedeclareKeywords; 

           then ();
 
       case (186,_) // #line 614 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vRedeclareKeywords = Absyn.REDECLARE_REPLACEABLE(); 
           // push Result 
           skRedeclareKeywords= vRedeclareKeywords::skRedeclareKeywords; 

           then ();
 
       case (187,_) // #line 616 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vInnerOuter = Absyn.INNER(); 
           // push Result 
           skInnerOuter= vInnerOuter::skInnerOuter; 

           then ();
 
       case (188,_) // #line 617 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vInnerOuter = Absyn.OUTER(); 
           // push Result 
           skInnerOuter= vInnerOuter::skInnerOuter; 

           then ();
 
       case (189,_) // #line 618 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vInnerOuter = Absyn.INNER_OUTER(); 
           // push Result 
           skInnerOuter= vInnerOuter::skInnerOuter; 

           then ();
 
       case (190,_) // #line 622 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2Comment::skComment = skComment; 
           v1Import::skImport = skImport; 
           // build 
           vElementSpec = Absyn.IMPORT((v1Import),SOME((v2Comment)),info); 
           // push Result 
           skElementSpec= vElementSpec::skElementSpec; 

           then ();
 
       case (191,_) // #line 624 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Class::skClass = skClass; 
           // build 
           vElementSpec = Absyn.CLASSDEF(false,(v1Class)); 
           // push Result 
           skElementSpec= vElementSpec::skElementSpec; 

           then ();
 
       case (192,_) // #line 625 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2Class::skClass = skClass; 
           v1String::skString = skString; 
           // build 
           vElementSpec = Absyn.CLASSDEF(true,(v2Class)); 
           // push Result 
           skElementSpec= vElementSpec::skElementSpec; 

           then ();
 
       case (193,_) // #line 627 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2Path::skPath = skPath; 
           v1String::skString = skString; 
           // build 
           vImport = Absyn.QUAL_IMPORT((v2Path)); 
           // push Result 
           skImport= vImport::skImport; 

           then ();
 
       case (194,_) // #line 628 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3String::skString = skString; 
           v2Path::skPath = skPath; 
           v1String::skString = skString; 
           // build 
           vImport = Absyn.UNQUAL_IMPORT((v2Path)); 
           // push Result 
           skImport= vImport::skImport; 

           then ();
 
       case (195,_) // #line 629 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v4Path::skPath = skPath; 
           v3String::skString = skString; 
           v2Ident::skIdent = skIdent; 
           v1String::skString = skString; 
           // build 
           vImport = Absyn.NAMED_IMPORT((v2Ident),(v4Path)); 
           // push Result 
           skImport= vImport::skImport; 

           then ();
 
       case (196,_) // #line 632 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3ElementArgs::skElementArgs = skElementArgs; 
           v2Path::skPath = skPath; 
           v1String::skString = skString; 
           // build 
           vElementSpec = Absyn.EXTENDS((v2Path),(v3ElementArgs),NONE()); 
           // push Result 
           skElementSpec= vElementSpec::skElementSpec; 

           then ();
 
       case (197,_) // #line 634 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v4Annotation::skAnnotation = skAnnotation; 
           v3ElementArgs::skElementArgs = skElementArgs; 
           v2Path::skPath = skPath; 
           v1String::skString = skString; 
           // build 
           vElementSpec = Absyn.EXTENDS((v2Path),(v3ElementArgs),SOME((v4Annotation))); 
           // push Result 
           skElementSpec= vElementSpec::skElementSpec; 

           then ();
 
       case (198,_) // #line 636 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1ElementSpec::skElementSpec = skElementSpec; 
           // build 
           vConstrainClass= Absyn.CONSTRAINCLASS((v1ElementSpec),NONE()); 
           // push Result 
           skConstrainClass= vConstrainClass::skConstrainClass; 

           then ();
 
       case (199,_) // #line 637 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3ElementArgs::skElementArgs = skElementArgs; 
           v2Path::skPath = skPath; 
           v1String::skString = skString; 
           // build 
           vConstrainClass= Absyn.CONSTRAINCLASS(Absyn.EXTENDS((v2Path),(v3ElementArgs),NONE()),NONE()); 
           // push Result 
           skConstrainClass= vConstrainClass::skConstrainClass; 

           then ();
 
       case (200,_) // #line 640 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3ComponentItems::skComponentItems = skComponentItems; 
           v2TypeSpec::skTypeSpec = skTypeSpec; 
           v1ElementAttributes::skElementAttributes = skElementAttributes; 
           // build 
           ((v1ElementAttributes),(v2TypeSpec)) = fixArray((v1ElementAttributes),(v2TypeSpec));
                          vElementSpec = Absyn.COMPONENTS((v1ElementAttributes),(v2TypeSpec),(v3ComponentItems)); 
           // push Result 
           skElementSpec= vElementSpec::skElementSpec; 

           then ();
 
       case (201,_) // #line 643 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2ComponentItems::skComponentItems = skComponentItems; 
           v1TypeSpec::skTypeSpec = skTypeSpec; 
           // build 
           (v1ElementAttributes,(v1TypeSpec)) = fixArray(Absyn.ATTR(false,false,Absyn.NON_PARALLEL(),Absyn.VAR(), Absyn.BIDIR(),{}),(v1TypeSpec)); 
                         vElementSpec = Absyn.COMPONENTS(v1ElementAttributes,(v1TypeSpec),(v2ComponentItems)); 
           // push Result 
           skElementSpec= vElementSpec::skElementSpec; 

           then ();
 
       case (202,_) // #line 647 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Direction::skDirection = skDirection; 
           // build 
           vElementAttributes = Absyn.ATTR(false,false,Absyn.NON_PARALLEL(),Absyn.VAR(), (v1Direction),{}); 
           // push Result 
           skElementAttributes= vElementAttributes::skElementAttributes; 

           then ();
 
       case (203,_) // #line 649 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Variability::skVariability = skVariability; 
           // build 
           vElementAttributes = Absyn.ATTR(false,false,Absyn.NON_PARALLEL(),(v1Variability), Absyn.BIDIR(),{}); 
           // push Result 
           skElementAttributes= vElementAttributes::skElementAttributes; 

           then ();
 
       case (204,_) // #line 652 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2Direction::skDirection = skDirection; 
           v1Variability::skVariability = skVariability; 
           // build 
           vElementAttributes = Absyn.ATTR(false,false,Absyn.NON_PARALLEL(),(v1Variability), (v2Direction),{}); 
           // push Result 
           skElementAttributes= vElementAttributes::skElementAttributes; 

           then ();
 
       case (205,_) // #line 655 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3Direction::skDirection = skDirection; 
           v2Variability::skVariability = skVariability; 
           v1String::skString = skString; 
           // build 
           vElementAttributes = Absyn.ATTR(false,true,Absyn.NON_PARALLEL(),(v2Variability), (v3Direction),{}); 
           // push Result 
           skElementAttributes= vElementAttributes::skElementAttributes; 

           then ();
 
       case (206,_) // #line 657 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3Direction::skDirection = skDirection; 
           v2Variability::skVariability = skVariability; 
           v1String::skString = skString; 
           // build 
           vElementAttributes = Absyn.ATTR(true,false,Absyn.NON_PARALLEL(),(v2Variability), (v3Direction),{}); 
           // push Result 
           skElementAttributes= vElementAttributes::skElementAttributes; 

           then ();
 
       case (207,_) // #line 659 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2Direction::skDirection = skDirection; 
           v1String::skString = skString; 
           // build 
           vElementAttributes = Absyn.ATTR(true,false,Absyn.NON_PARALLEL(),Absyn.VAR(), (v2Direction),{}); 
           // push Result 
           skElementAttributes= vElementAttributes::skElementAttributes; 

           then ();
 
       case (208,_) // #line 661 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vElementAttributes = Absyn.ATTR(true,false,Absyn.NON_PARALLEL(),Absyn.VAR(),Absyn.BIDIR(),{}); 
           // push Result 
           skElementAttributes= vElementAttributes::skElementAttributes; 

           then ();
 
       case (209,_) // #line 664 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vVariability = Absyn.PARAM(); 
           // push Result 
           skVariability= vVariability::skVariability; 

           then ();
 
       case (210,_) // #line 665 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vVariability = Absyn.CONST(); 
           // push Result 
           skVariability= vVariability::skVariability; 

           then ();
 
       case (211,_) // #line 666 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vVariability = Absyn.DISCRETE(); 
           // push Result 
           skVariability= vVariability::skVariability; 

           then ();
 
       case (212,_) // #line 669 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vDirection = Absyn.INPUT(); 
           // push Result 
           skDirection= vDirection::skDirection; 

           then ();
 
       case (213,_) // #line 670 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vDirection = Absyn.OUTPUT(); 
           // push Result 
           skDirection= vDirection::skDirection; 

           then ();
 
       case (214,_) // #line 675 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2ArrayDim::skArrayDim = skArrayDim; 
           v1Path::skPath = skPath; 
           // build 
           vTypeSpec = Absyn.TPATH((v1Path),SOME((v2ArrayDim))); 
           // push Result 
           skTypeSpec= vTypeSpec::skTypeSpec; 

           then ();
 
       case (215,_) // #line 676 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2TypeSpecs::skTypeSpecs = skTypeSpecs; 
           v1Path::skPath = skPath; 
           // build 
           vTypeSpec = Absyn.TCOMPLEX((v1Path),(v2TypeSpecs),NONE()); 
           // push Result 
           skTypeSpec= vTypeSpec::skTypeSpec; 

           then ();
 
       case (216,_) // #line 678 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3String::skString = skString; 
           v2String::skString = skString; 
           v1TypeSpecs::skTypeSpecs = skTypeSpecs; 
           // build 
           vTypeSpecs = (v1TypeSpecs); 
           // push Result 
           skTypeSpecs= vTypeSpecs::skTypeSpecs; 

           then ();
 
       case (217,_) // #line 680 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1TypeSpec::skTypeSpec = skTypeSpec; 
           // build 
           vTypeSpecs = (v1TypeSpec)::{}; 
           // push Result 
           skTypeSpecs= vTypeSpecs::skTypeSpecs; 

           then ();
 
       case (218,_) // #line 681 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3String::skString = skString; 
           v2TypeSpecs::skTypeSpecs = skTypeSpecs; 
           v1TypeSpec::skTypeSpec = skTypeSpec; 
           // build 
           vTypeSpecs = (v1TypeSpec)::(v2TypeSpecs); 
           // push Result 
           skTypeSpecs= vTypeSpecs::skTypeSpecs; 

           then ();
 
       case (219,_) // #line 683 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3String::skString = skString; 
           v2String::skString = skString; 
           v1ArrayDim::skArrayDim = skArrayDim; 
           // build 
           vArrayDim = (v1ArrayDim); 
           // push Result 
           skArrayDim= vArrayDim::skArrayDim; 

           then ();
 
       case (220,_) // #line 684 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vArrayDim = {}; 
           // push Result 
           skArrayDim= vArrayDim::skArrayDim; 

           then ();
 
       case (221,_) // #line 686 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Subscript::skSubscript = skSubscript; 
           // build 
           vArrayDim = (v1Subscript)::{}; 
           // push Result 
           skArrayDim= vArrayDim::skArrayDim; 

           then ();
 
       case (222,_) // #line 687 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3String::skString = skString; 
           v2ArrayDim::skArrayDim = skArrayDim; 
           v1Subscript::skSubscript = skSubscript; 
           // build 
           vArrayDim = (v1Subscript)::(v2ArrayDim); 
           // push Result 
           skArrayDim= vArrayDim::skArrayDim; 

           then ();
 
       case (223,_) // #line 689 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Exp::skExp = skExp; 
           // build 
           vSubscript = Absyn.SUBSCRIPT((v1Exp)); 
           // push Result 
           skSubscript= vSubscript::skSubscript; 

           then ();
 
       case (224,_) // #line 690 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vSubscript = Absyn.NOSUB(); 
           // push Result 
           skSubscript= vSubscript::skSubscript; 

           then ();
 
       case (225,_) // #line 694 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3String::skString = skString; 
           v2String::skString = skString; 
           v1FunctionArgs::skFunctionArgs = skFunctionArgs; 
           // build 
           vFunctionArgs = (v1FunctionArgs); 
           // push Result 
           skFunctionArgs= vFunctionArgs::skFunctionArgs; 

           then ();
 
       case (226,_) // #line 697 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1NamedArgs::skNamedArgs = skNamedArgs; 
           // build 
           vFunctionArgs = Absyn.FUNCTIONARGS({},(v1NamedArgs)); 
           // push Result 
           skFunctionArgs= vFunctionArgs::skFunctionArgs; 

           then ();
 
       case (227,_) // #line 698 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1FunctionArgs::skFunctionArgs = skFunctionArgs; 
           // build 
           vFunctionArgs= (v1FunctionArgs); 
           // push Result 
           skFunctionArgs= vFunctionArgs::skFunctionArgs; 

           then ();
 
       case (228,_) // #line 699 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1FunctionArgs::skFunctionArgs = skFunctionArgs; 
           // build 
           vFunctionArgs= (v1FunctionArgs); 
           // push Result 
           skFunctionArgs= vFunctionArgs::skFunctionArgs; 

           then ();
 
       case (229,_) // #line 704 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Exps::skExps = skExps; 
           // build 
           vFunctionArgs = Absyn.FUNCTIONARGS((v1Exps),{}); 
           // push Result 
           skFunctionArgs= vFunctionArgs::skFunctionArgs; 

           then ();
 
       case (230,_) // #line 706 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3NamedArgs::skNamedArgs = skNamedArgs; 
           v2String::skString = skString; 
           v1Exps::skExps = skExps; 
           // build 
           vFunctionArgs = Absyn.FUNCTIONARGS((v1Exps),(v3NamedArgs)); 
           // push Result 
           skFunctionArgs= vFunctionArgs::skFunctionArgs; 

           then ();
 
       case (231,_) // #line 711 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3ForIterators::skForIterators = skForIterators; 
           v2String::skString = skString; 
           v1Exp::skExp = skExp; 
           // build 
           vFunctionArgs = Absyn.FOR_ITER_FARG((v1Exp),(v3ForIterators)); 
           // push Result 
           skFunctionArgs= vFunctionArgs::skFunctionArgs; 

           then ();
 
       case (232,_) // #line 714 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1NamedArg::skNamedArg = skNamedArg; 
           // build 
           vNamedArgs = (v1NamedArg)::{}; 
           // push Result 
           skNamedArgs= vNamedArgs::skNamedArgs; 

           then ();
 
       case (233,_) // #line 715 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3String::skString = skString; 
           v2NamedArgs::skNamedArgs = skNamedArgs; 
           v1NamedArg::skNamedArg = skNamedArg; 
           // build 
           vNamedArgs = (v1NamedArg)::(v2NamedArgs); 
           // push Result 
           skNamedArgs= vNamedArgs::skNamedArgs; 

           then ();
 
       case (234,_) // #line 718 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3String::skString = skString; 
           v2Exp::skExp = skExp; 
           v1Ident::skIdent = skIdent; 
           // build 
           vNamedArg = Absyn.NAMEDARG((v1Ident),(v2Exp));  
           // push Result 
           skNamedArg= vNamedArg::skNamedArg; 

           then ();
 
       case (235,_) // #line 722 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Exp::skExp = skExp; 
           // build 
           vExp = (v1Exp); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (236,_) // #line 723 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Exp::skExp = skExp; 
           // build 
           vExp = (v1Exp); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (237,_) // #line 724 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Exp::skExp = skExp; 
           // build 
           vExp = (v1Exp); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (238,_) // #line 726 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v4String::skString = skString; 
           v3Cases::skCases = skCases; 
           v2Exp::skExp = skExp; 
           v1String::skString = skString; 
           // build 
           vExp = Absyn.MATCHEXP(Absyn.MATCH(),(v2Exp),{},(v3Cases),NONE()); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (239,_) // #line 727 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v5String::skString = skString; 
           v4Cases::skCases = skCases; 
           v3ElementItems::skElementItems = skElementItems; 
           v2Exp::skExp = skExp; 
           v1String::skString = skString; 
           // build 
           vExp = Absyn.MATCHEXP(Absyn.MATCH(),(v2Exp),(v3ElementItems),(v4Cases),NONE()); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (240,_) // #line 728 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v4String::skString = skString; 
           v3Cases::skCases = skCases; 
           v2Exp::skExp = skExp; 
           v1String::skString = skString; 
           // build 
           vExp = Absyn.MATCHEXP(Absyn.MATCHCONTINUE(),(v2Exp),{},(v3Cases),NONE()); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (241,_) // #line 729 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v5String::skString = skString; 
           v4Cases::skCases = skCases; 
           v3ElementItems::skElementItems = skElementItems; 
           v2Exp::skExp = skExp; 
           v1String::skString = skString; 
           // build 
           vExp = Absyn.MATCHEXP(Absyn.MATCHCONTINUE(),(v2Exp),(v3ElementItems),(v4Cases),NONE()); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (242,_) // #line 732 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v6Exp::skExp = skExp; 
           v5String::skString = skString; 
           v4Exp::skExp = skExp; 
           v3String::skString = skString; 
           v2Exp::skExp = skExp; 
           v1String::skString = skString; 
           // build 
           vExp = Absyn.IFEXP((v2Exp),(v4Exp),(v6Exp),{}); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (243,_) // #line 733 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v7Exp::skExp = skExp; 
           v6String::skString = skString; 
           v5ExpElseifs::skExpElseifs = skExpElseifs; 
           v4Exp::skExp = skExp; 
           v3String::skString = skString; 
           v2Exp::skExp = skExp; 
           v1String::skString = skString; 
           // build 
           vExp = Absyn.IFEXP((v2Exp),(v4Exp),(v7Exp),(v5ExpElseifs)); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (244,_) // #line 735 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1ExpElseif::skExpElseif = skExpElseif; 
           // build 
           vExpElseifs = (v1ExpElseif)::{}; 
           // push Result 
           skExpElseifs= vExpElseifs::skExpElseifs; 

           then ();
 
       case (245,_) // #line 736 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2ExpElseifs::skExpElseifs = skExpElseifs; 
           v1ExpElseif::skExpElseif = skExpElseif; 
           // build 
           vExpElseifs = (v1ExpElseif)::(v2ExpElseifs); 
           // push Result 
           skExpElseifs= vExpElseifs::skExpElseifs; 

           then ();
 
       case (246,_) // #line 738 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v4Exp::skExp = skExp; 
           v3String::skString = skString; 
           v2Exp::skExp = skExp; 
           v1String::skString = skString; 
           // build 
           vExpElseif = ((v2Exp),(v4Exp)); 
           // push Result 
           skExpElseif= vExpElseif::skExpElseif; 

           then ();
 
       case (247,_) // #line 741 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2String::skString = skString; 
           v1ElementItems::skElementItems = skElementItems; 
           // build 
           vElementItems = (v1ElementItems); 
           // push Result 
           skElementItems= vElementItems::skElementItems; 

           then ();
 
       case (248,_) // #line 743 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Case::skCase = skCase; 
           // build 
           vCases = (v1Case)::{}; 
           // push Result 
           skCases= vCases::skCases; 

           then ();
 
       case (249,_) // #line 744 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2Cases::skCases = skCases; 
           v1Case::skCase = skCase; 
           // build 
           vCases = (v1Case)::(v2Cases); 
           // push Result 
           skCases= vCases::skCases; 

           then ();
 
       case (250,_) // #line 747 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v5String::skString = skString; 
           v4Exp::skExp = skExp; 
           v3String::skString = skString; 
           v2Exp::skExp = skExp; 
           v1String::skString = skString; 
           // build 
           vCase = Absyn.CASE((v2Exp),info,{},{},(v4Exp),info,NONE(),info); 
           // push Result 
           skCase= vCase::skCase; 

           then ();
 
       case (251,_) // #line 749 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v6String::skString = skString; 
           v5String::skString = skString; 
           v4Exp::skExp = skExp; 
           v3String::skString = skString; 
           v2Exp::skExp = skExp; 
           v1String::skString = skString; 
           // build 
           vCase = Absyn.CASE((v2Exp),info,{},{},(v4Exp),info,NONE(),info);  
           // push Result 
           skCase= vCase::skCase; 

           then ();
 
       case (252,_) // #line 751 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v7String::skString = skString; 
           v6Exp::skExp = skExp; 
           v5String::skString = skString; 
           v4EquationItems::skEquationItems = skEquationItems; 
           v3String::skString = skString; 
           v2Exp::skExp = skExp; 
           v1String::skString = skString; 
           // build 
           vCase = Absyn.CASE((v2Exp),info,{},(v4EquationItems),(v6Exp),info,NONE(),info); 
           // push Result 
           skCase= vCase::skCase; 

           then ();
 
       case (253,_) // #line 753 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v4String::skString = skString; 
           v3Exp::skExp = skExp; 
           v2String::skString = skString; 
           v1String::skString = skString; 
           // build 
           vCase = Absyn.ELSE({},{},(v3Exp),info,NONE(),info); 
           // push Result 
           skCase= vCase::skCase; 

           then ();
 
       case (254,_) // #line 755 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v6String::skString = skString; 
           v5Exp::skExp = skExp; 
           v4String::skString = skString; 
           v3EquationItems::skEquationItems = skEquationItems; 
           v2String::skString = skString; 
           v1String::skString = skString; 
           // build 
           vCase = Absyn.ELSE({},(v3EquationItems),(v5Exp),info,NONE(),info); 
           // push Result 
           skCase= vCase::skCase; 

           then ();
 
       case (255,_) // #line 757 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Exp::skExp = skExp; 
           // build 
           vExp = (v1Exp); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (256,_) // #line 760 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Exp::skExp = skExp; 
           // build 
           vExp = (v1Exp); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (257,_) // #line 761 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Exp::skExp = skExp; 
           // build 
           vExp = (v1Exp); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (258,_) // #line 762 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Exp::skExp = skExp; 
           // build 
           vExp = (v1Exp); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (259,_) // #line 763 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3String::skString = skString; 
           v2Exp::skExp = skExp; 
           v1Ident::skIdent = skIdent; 
           // build 
           vExp = Absyn.AS((v1Ident),(v2Exp)); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (260,_) // #line 765 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3Exp::skExp = skExp; 
           v2String::skString = skString; 
           v1Exp::skExp = skExp; 
           // build 
           vExp = Absyn.CONS((v1Exp),(v3Exp)); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (261,_) // #line 766 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3Exp::skExp = skExp; 
           v2String::skString = skString; 
           v1Exp::skExp = skExp; 
           // build 
           vExp = Absyn.CONS((v1Exp),(v3Exp)); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (262,_) // #line 768 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3Exp::skExp = skExp; 
           v2String::skString = skString; 
           v1Exp::skExp = skExp; 
           // build 
           vExp = Absyn.RANGE((v1Exp),NONE(),(v3Exp)); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (263,_) // #line 769 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v5Exp::skExp = skExp; 
           v4String::skString = skString; 
           v3Exp::skExp = skExp; 
           v2String::skString = skString; 
           v1Exp::skExp = skExp; 
           // build 
           vExp = Absyn.RANGE((v1Exp),SOME((v3Exp)),(v5Exp)); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (264,_) // #line 771 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Exp::skExp = skExp; 
           // build 
           vExp = (v1Exp); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (265,_) // #line 772 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3String::skString = skString; 
           v2Exp::skExp = skExp; 
           v1Exp::skExp = skExp; 
           // build 
           vExp = Absyn.LBINARY((v1Exp),Absyn.OR(),(v2Exp)); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (266,_) // #line 774 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Exp::skExp = skExp; 
           // build 
           vExp = (v1Exp); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (267,_) // #line 775 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3String::skString = skString; 
           v2Exp::skExp = skExp; 
           v1Exp::skExp = skExp; 
           // build 
           vExp = Absyn.LBINARY((v1Exp),Absyn.AND(),(v2Exp)); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (268,_) // #line 777 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Exp::skExp = skExp; 
           // build 
           vExp = (v1Exp); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (269,_) // #line 778 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2String::skString = skString; 
           v1Exp::skExp = skExp; 
           // build 
           vExp = Absyn.LUNARY(Absyn.NOT(),(v1Exp)); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (270,_) // #line 780 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Exp::skExp = skExp; 
           // build 
           vExp = (v1Exp); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (271,_) // #line 781 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3Exp::skExp = skExp; 
           v2Operator::skOperator = skOperator; 
           v1Exp::skExp = skExp; 
           // build 
           vExp = Absyn.RELATION((v1Exp),(v2Operator),(v3Exp)); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (272,_) // #line 783 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Exp::skExp = skExp; 
           // build 
           vExp = (v1Exp); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (273,_) // #line 784 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2Exp::skExp = skExp; 
           v1Operator::skOperator = skOperator; 
           // build 
           vExp = Absyn.UNARY((v1Operator),(v2Exp)); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (274,_) // #line 785 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3Exp::skExp = skExp; 
           v2Operator::skOperator = skOperator; 
           v1Exp::skExp = skExp; 
           // build 
           vExp = Absyn.BINARY((v1Exp),(v2Operator),(v3Exp)); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (275,_) // #line 787 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Exp::skExp = skExp; 
           // build 
           vExp = (v1Exp); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (276,_) // #line 788 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3Exp::skExp = skExp; 
           v2Operator::skOperator = skOperator; 
           v1Exp::skExp = skExp; 
           // build 
           vExp = Absyn.BINARY((v1Exp),(v2Operator),(v3Exp)); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (277,_) // #line 790 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Exp::skExp = skExp; 
           // build 
           vExp = (v1Exp); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (278,_) // #line 791 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3Exp::skExp = skExp; 
           v2Operator::skOperator = skOperator; 
           v1Exp::skExp = skExp; 
           // build 
           vExp = Absyn.BINARY((v1Exp),(v2Operator),(v3Exp)); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (279,_) // #line 793 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Exp::skExp = skExp; 
           // build 
           vExp = (v1Exp); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (280,_) // #line 794 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1ComponentRef::skComponentRef = skComponentRef; 
           // build 
           vExp = Absyn.CREF((v1ComponentRef)); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (281,_) // #line 795 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vExp = Absyn.BOOL(false); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (282,_) // #line 796 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vExp = Absyn.BOOL(true); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (283,_) // #line 797 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1String::skString = skString; 
           // build 
           vExp = Absyn.STRING((v1String)); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (284,_) // #line 798 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Exp::skExp = skExp; 
           // build 
           vExp = (v1Exp); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (285,_) // #line 799 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3String::skString = skString; 
           v2Exps::skExps = skExps; 
           v1String::skString = skString; 
           // build 
           vExp = Absyn.ARRAY((v2Exps)); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (286,_) // #line 800 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3String::skString = skString; 
           v2FunctionArgs::skFunctionArgs = skFunctionArgs; 
           v1String::skString = skString; 
           // build 
           vExp = Absyn.CALL(Absyn.CREF_IDENT("array",{}),(v2FunctionArgs)); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (287,_) // #line 801 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3String::skString = skString; 
           v2Matrix::skMatrix = skMatrix; 
           v1String::skString = skString; 
           // build 
           vExp = Absyn.MATRIX((v2Matrix)); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (288,_) // #line 802 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2FunctionArgs::skFunctionArgs = skFunctionArgs; 
           v1ComponentRef::skComponentRef = skComponentRef; 
           // build 
           vExp = Absyn.CALL((v1ComponentRef),(v2FunctionArgs)); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (289,_) // #line 803 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2FunctionArgs::skFunctionArgs = skFunctionArgs; 
           v1String::skString = skString; 
           // build 
           vExp = Absyn.CALL(Absyn.CREF_IDENT("der",{}),(v2FunctionArgs)); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (290,_) // #line 804 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2FunctionArgs::skFunctionArgs = skFunctionArgs; 
           v1String::skString = skString; 
           // build 
           vExp = Absyn.CALL(Absyn.CREF_IDENT("initial",{}),(v2FunctionArgs)); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (291,_) // #line 805 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3String::skString = skString; 
           v2Exp::skExp = skExp; 
           v1String::skString = skString; 
           // build 
           vExp = (v2Exp); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (292,_) // #line 806 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vExp = Absyn.END(); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (293,_) // #line 808 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1String::skString = skString; 
           // build 
           vExp = Absyn.INTEGER(stringInt((v1String))); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (294,_) // #line 809 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1String::skString = skString; 
           // build 
           vExp = Absyn.REAL(stringReal((v1String))); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (295,_) // #line 811 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Exps::skExps = skExps; 
           // build 
           vMatrix = {(v1Exps)}; 
           // push Result 
           skMatrix= vMatrix::skMatrix; 

           then ();
 
       case (296,_) // #line 812 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3Matrix::skMatrix = skMatrix; 
           v2String::skString = skString; 
           v1Exps::skExps = skExps; 
           // build 
           vMatrix = (v1Exps)::(v3Matrix); 
           // push Result 
           skMatrix= vMatrix::skMatrix; 

           then ();
 
       case (297,_) // #line 814 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3String::skString = skString; 
           v2Exps::skExps = skExps; 
           v1String::skString = skString; 
           // build 
           vExp = Absyn.TUPLE((v2Exps)); 
           // push Result 
           skExp= vExp::skExp; 

           then ();
 
       case (298,_) // #line 816 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3Exp::skExp = skExp; 
           v2String::skString = skString; 
           v1Exp::skExp = skExp; 
           // build 
           vExps = {(v1Exp),(v3Exp)};  
           // push Result 
           skExps= vExps::skExps; 

           then ();
 
       case (299,_) // #line 817 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3Exps::skExps = skExps; 
           v2String::skString = skString; 
           v1Exp::skExp = skExp; 
           // build 
           vExps = (v1Exp)::(v3Exps); 
           // push Result 
           skExps= vExps::skExps; 

           then ();
 
       case (300,_) // #line 818 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vExps = {}; 
           // push Result 
           skExps= vExps::skExps; 

           then ();
 
       case (301,_) // #line 820 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Exp::skExp = skExp; 
           // build 
           vExps = {(v1Exp)};  
           // push Result 
           skExps= vExps::skExps; 

           then ();
 
       case (302,_) // #line 821 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3Exp::skExp = skExp; 
           v2String::skString = skString; 
           v1Exps::skExps = skExps; 
           // build 
           vExps = listReverse((v3Exp)::listReverse((v1Exps))); 
           // push Result 
           skExps= vExps::skExps; 

           then ();
 
       case (303,_) // #line 822 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vExps = {}; 
           // push Result 
           skExps= vExps::skExps; 

           then ();
 
       case (304,_) // #line 824 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2ArrayDim::skArrayDim = skArrayDim; 
           v1Ident::skIdent = skIdent; 
           // build 
           vComponentRef = Absyn.CREF_IDENT((v1Ident),(v2ArrayDim)); 
           // push Result 
           skComponentRef= vComponentRef::skComponentRef; 

           then ();
 
       case (305,_) // #line 825 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v4ComponentRef::skComponentRef = skComponentRef; 
           v3String::skString = skString; 
           v2ArrayDim::skArrayDim = skArrayDim; 
           v1Ident::skIdent = skIdent; 
           // build 
           vComponentRef = Absyn.CREF_QUAL((v1Ident),(v2ArrayDim),(v4ComponentRef)); 
           // push Result 
           skComponentRef= vComponentRef::skComponentRef; 

           then ();
 
       case (306,_) // #line 826 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2ComponentRef::skComponentRef = skComponentRef; 
           v1String::skString = skString; 
           // build 
           vComponentRef = Absyn.CREF_FULLYQUALIFIED((v2ComponentRef)); 
           // push Result 
           skComponentRef= vComponentRef::skComponentRef; 

           then ();
 
       case (307,_) // #line 827 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vComponentRef = Absyn.WILD();
           // push Result 
           skComponentRef= vComponentRef::skComponentRef; 

           then ();
 
       case (308,_) // #line 828 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vComponentRef = Absyn.ALLWILD();
           // push Result 
           skComponentRef= vComponentRef::skComponentRef; 

           then ();
 
       case (309,_) // #line 830 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vOperator = Absyn.UPLUS(); 
           // push Result 
           skOperator= vOperator::skOperator; 

           then ();
 
       case (310,_) // #line 831 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vOperator = Absyn.UMINUS(); 
           // push Result 
           skOperator= vOperator::skOperator; 

           then ();
 
       case (311,_) // #line 832 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vOperator = Absyn.UPLUS_EW(); 
           // push Result 
           skOperator= vOperator::skOperator; 

           then ();
 
       case (312,_) // #line 833 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vOperator = Absyn.UMINUS_EW(); 
           // push Result 
           skOperator= vOperator::skOperator; 

           then ();
 
       case (313,_) // #line 836 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vOperator = Absyn.ADD(); 
           // push Result 
           skOperator= vOperator::skOperator; 

           then ();
 
       case (314,_) // #line 837 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vOperator = Absyn.SUB(); 
           // push Result 
           skOperator= vOperator::skOperator; 

           then ();
 
       case (315,_) // #line 838 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vOperator = Absyn.ADD_EW(); 
           // push Result 
           skOperator= vOperator::skOperator; 

           then ();
 
       case (316,_) // #line 839 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vOperator = Absyn.SUB_EW(); 
           // push Result 
           skOperator= vOperator::skOperator; 

           then ();
 
       case (317,_) // #line 842 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vOperator = Absyn.MUL(); 
           // push Result 
           skOperator= vOperator::skOperator; 

           then ();
 
       case (318,_) // #line 843 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vOperator = Absyn.DIV(); 
           // push Result 
           skOperator= vOperator::skOperator; 

           then ();
 
       case (319,_) // #line 844 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vOperator = Absyn.MUL_EW(); 
           // push Result 
           skOperator= vOperator::skOperator; 

           then ();
 
       case (320,_) // #line 845 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vOperator = Absyn.DIV_EW(); 
           // push Result 
           skOperator= vOperator::skOperator; 

           then ();
 
       case (321,_) // #line 847 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vOperator = Absyn.POW(); 
           // push Result 
           skOperator= vOperator::skOperator; 

           then ();
 
       case (322,_) // #line 848 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vOperator = Absyn.POW_EW(); 
           // push Result 
           skOperator= vOperator::skOperator; 

           then ();
 
       case (323,_) // #line 850 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vOperator = Absyn.LESS(); 
           // push Result 
           skOperator= vOperator::skOperator; 

           then ();
 
       case (324,_) // #line 851 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vOperator = Absyn.LESSEQ(); 
           // push Result 
           skOperator= vOperator::skOperator; 

           then ();
 
       case (325,_) // #line 852 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vOperator = Absyn.GREATER(); 
           // push Result 
           skOperator= vOperator::skOperator; 

           then ();
 
       case (326,_) // #line 853 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vOperator = Absyn.GREATEREQ(); 
           // push Result 
           skOperator= vOperator::skOperator; 

           then ();
 
       case (327,_) // #line 854 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vOperator = Absyn.EQUAL(); 
           // push Result 
           skOperator= vOperator::skOperator; 

           then ();
 
       case (328,_) // #line 855 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vOperator = Absyn.NEQUAL(); 
           // push Result 
           skOperator= vOperator::skOperator; 

           then ();
 
       case (329,_) // #line 857 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Ident::skIdent = skIdent; 
           // build 
           vPath = Absyn.IDENT((v1Ident)); 
           // push Result 
           skPath= vPath::skPath; 

           then ();
 
       case (330,_) // #line 858 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v3String::skString = skString; 
           v2Path::skPath = skPath; 
           v1Ident::skIdent = skIdent; 
           // build 
           vPath = Absyn.QUALIFIED((v1Ident),(v2Path)); 
           // push Result 
           skPath= vPath::skPath; 

           then ();
 
       case (331,_) // #line 859 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2Path::skPath = skPath; 
           v1String::skString = skString; 
           // build 
           vPath = Absyn.FULLYQUALIFIED((v2Path)); 
           // push Result 
           skPath= vPath::skPath; 

           then ();
 
       case (332,_) // #line 861 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1String::skString = skString; 
           // build 
           vIdent = (v1String); 
           // push Result 
           skIdent= vIdent::skIdent; 

           then ();
 
       case (333,_) // #line 863 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1String::skString = skString; 
           // build 
           vString = trimquotes((v1String)); 
           // push Result 
           skString= vString::skString; 

           then ();
 
       case (334,_) // #line 865 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1String::skString = skString; 
           // build 
           vComment = Absyn.COMMENT(NONE(),SOME((v1String))); 
           // push Result 
           skComment= vComment::skComment; 

           then ();
 
       case (335,_) // #line 866 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v2Annotation::skAnnotation = skAnnotation; 
           v1String::skString = skString; 
           // build 
           vComment = Absyn.COMMENT(SOME((v2Annotation)),SOME((v1String))); 
           // push Result 
           skComment= vComment::skComment; 

           then ();
 
       case (336,_) // #line 867 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           v1Annotation::skAnnotation = skAnnotation; 
           // build 
           vComment = Absyn.COMMENT(SOME((v1Annotation)),NONE()); 
           // push Result 
           skComment= vComment::skComment; 

           then ();
 
       case (337,_) // #line 868 "parserModelica.y"
         equation 
           // reduce 
           (info,skToken) = getInfo(skToken,mm_r2[act]); 
           skString = reduceStringStack(skString,mm_r2[act]); 
           // build 
           vComment = Absyn.COMMENT(NONE(),NONE()); 
           // push Result 
           skComment= vComment::skComment; 

           then ();
     
    case (_,_) 
      equation
        //lAST = intString(act);
        errorMsg = "\n" + OMCCTypes.printInfoError(info) + " : Ilegal action case " + intString(act);
        error = true;
      then ();
  end matchcontinue;
    astStk2 := ASTSTACK(skToken,skMatrix,skOperator,skCase,skExpElseif,skExpElseifs,skCases,skNamedArg,skSubscript,skTypeSpecs,skVariability,skDirection,skImport,skEach,skElementArg,skArrayDim,skModification,skComponentCondition,skComponent,skComponentItems,skComponentItem,skConstrainClass,skRedeclareKeywords,skInnerOuter,skNamedArgs,skElementSpec,skElement,skElementItem,skElseif,skElseifs,skForIterator,skElsewhen,skElsewhens,skEquation,skEquationItem,skAlgElsewhen,skAlgElsewhens,skAlgElseif,skAlgElseifs,skForIterators,skFunctionArgs,skExp,skAlgorithm,skAlgorithmItem,skComponentRef,skExps,skAnnotation,skExternalDecl,skAlgorithmItems,skEquationItems,skElementItems,skClassPart,skIdent,skEnumLiteral,skEnumLiterals,skElementAttributes,skTypeSpec,skElementArgs,skEnumDef,skComment,skBoolean,skClassParts,skBoolean2,skRestriction,skClassDef,skClass,skPath,skWithin,skProgram,sklstClass,skString,skInteger); 
 /* astStk2 := ASTSTACK(idStk,inStk,boStk,roStk,exStk,ilStk,stStk); */
  
end actionRed;  

function reduceStringStack
  input list<String> skString;
  input Integer nTokens;
  output list<String> skStringRes;
  protected
  list<String> skString1:=skString;
  String strReduce;
  Integer i;
 algorithm 
  for i in 1:nTokens loop 
    strReduce::skString1 := skString1; 
  end for;
  skStringRes := skString1;
end reduceStringStack;

function getInfo
  input list<Token> skToken;
  input Integer nTokens;
  output OMCCTypes.Info info;
  output list<Token> skTokenRes;
  protected
  list<Token> skToken1:=skToken;
  Token token;
  OMCCTypes.Info tmpInfo;
  Integer lns,cns,lne,cne,i;
  String fn;
algorithm  
  for i in 1:nTokens loop
     token::skToken1 := skToken1;
     OMCCTypes.TOKEN(loc=info) := token;
     if (i==nTokens) then
        OMCCTypes.INFO(fileName=fn,lineNumberStart=lns,columnNumberStart=cns) := info;
     end if;
     if (i==1) then
        OMCCTypes.INFO(lineNumberEnd=lne,columnNumberEnd=cne) := info;
     end if;
  end for;
  if (nTokens==0) then
     token::_ := skToken1;
     OMCCTypes.TOKEN(loc=info) := token;  
     OMCCTypes.INFO(fileName=fn,lineNumberStart=lns,columnNumberStart=cns,lineNumberEnd=lne,columnNumberEnd=cne) := info;
  end if;
  info := OMCCTypes.INFO(fn,false,lns,cns,lne,cne,OMCCTypes.getTimeStamp()); 
  token := OMCCTypes.TOKEN("grupped",0,{},info);
  skTokenRes := token::skToken1; 
end getInfo;

function push
  input AstStack astStk;
  input String inVal;
  input OMCCTypes.Token token;
  output AstStack astStk2;
  protected
  // AstStack 
   list<Token> skToken;
   list<Matrix> skMatrix;
   list<Operator> skOperator;
   list<Case> skCase;
   list<ExpElseif> skExpElseif;
   list<ExpElseifs> skExpElseifs;
   list<Cases> skCases;
   list<NamedArg> skNamedArg;
   list<Subscript> skSubscript;
   list<TypeSpecs> skTypeSpecs;
   list<Variability> skVariability;
   list<Direction> skDirection;
   list<Import> skImport;
   list<Each> skEach;
   list<ElementArg> skElementArg;
   list<ArrayDim> skArrayDim;
   list<Modification> skModification;
   list<ComponentCondition> skComponentCondition;
   list<Component> skComponent;
   list<ComponentItems> skComponentItems;
   list<ComponentItem> skComponentItem;
   list<ConstrainClass> skConstrainClass;
   list<RedeclareKeywords> skRedeclareKeywords;
   list<InnerOuter> skInnerOuter;
   list<NamedArgs> skNamedArgs;
   list<ElementSpec> skElementSpec;
   list<Element> skElement;
   list<ElementItem> skElementItem;
   list<Elseif> skElseif;
   list<Elseifs> skElseifs;
   list<ForIterator> skForIterator;
   list<Elsewhen> skElsewhen;
   list<Elsewhens> skElsewhens;
   list<Equation> skEquation;
   list<EquationItem> skEquationItem;
   list<AlgElsewhen> skAlgElsewhen;
   list<AlgElsewhens> skAlgElsewhens;
   list<AlgElseif> skAlgElseif;
   list<AlgElseifs> skAlgElseifs;
   list<ForIterators> skForIterators;
   list<FunctionArgs> skFunctionArgs;
   list<Exp> skExp;
   list<Algorithm> skAlgorithm;
   list<AlgorithmItem> skAlgorithmItem;
   list<ComponentRef> skComponentRef;
   list<Exps> skExps;
   list<Annotation> skAnnotation;
   list<ExternalDecl> skExternalDecl;
   list<AlgorithmItems> skAlgorithmItems;
   list<EquationItems> skEquationItems;
   list<ElementItems> skElementItems;
   list<ClassPart> skClassPart;
   list<Ident> skIdent;
   list<EnumLiteral> skEnumLiteral;
   list<EnumLiterals> skEnumLiterals;
   list<ElementAttributes> skElementAttributes;
   list<TypeSpec> skTypeSpec;
   list<ElementArgs> skElementArgs;
   list<EnumDef> skEnumDef;
   list<Comment> skComment;
   list<Boolean> skBoolean;
   list<ClassParts> skClassParts;
   list<Boolean2> skBoolean2;
   list<Restriction> skRestriction;
   list<ClassDef> skClassDef;
   list<Class> skClass;
   list<Path> skPath;
   list<Within> skWithin;
   list<Program> skProgram;
   list<lstClass> sklstClass;
   list<String> skString;
   list<Integer> skInteger;

algorithm
 ASTSTACK(stackToken=skToken,stackMatrix=skMatrix,stackOperator=skOperator,stackCase=skCase,stackExpElseif=skExpElseif,stackExpElseifs=skExpElseifs,stackCases=skCases,stackNamedArg=skNamedArg,stackSubscript=skSubscript,stackTypeSpecs=skTypeSpecs,stackVariability=skVariability,stackDirection=skDirection,stackImport=skImport,stackEach=skEach,stackElementArg=skElementArg,stackArrayDim=skArrayDim,stackModification=skModification,stackComponentCondition=skComponentCondition,stackComponent=skComponent,stackComponentItems=skComponentItems,stackComponentItem=skComponentItem,stackConstrainClass=skConstrainClass,stackRedeclareKeywords=skRedeclareKeywords,stackInnerOuter=skInnerOuter,stackNamedArgs=skNamedArgs,stackElementSpec=skElementSpec,stackElement=skElement,stackElementItem=skElementItem,stackElseif=skElseif,stackElseifs=skElseifs,stackForIterator=skForIterator,stackElsewhen=skElsewhen,stackElsewhens=skElsewhens,stackEquation=skEquation,stackEquationItem=skEquationItem,stackAlgElsewhen=skAlgElsewhen,stackAlgElsewhens=skAlgElsewhens,stackAlgElseif=skAlgElseif,stackAlgElseifs=skAlgElseifs,stackForIterators=skForIterators,stackFunctionArgs=skFunctionArgs,stackExp=skExp,stackAlgorithm=skAlgorithm,stackAlgorithmItem=skAlgorithmItem,stackComponentRef=skComponentRef,stackExps=skExps,stackAnnotation=skAnnotation,stackExternalDecl=skExternalDecl,stackAlgorithmItems=skAlgorithmItems,stackEquationItems=skEquationItems,stackElementItems=skElementItems,stackClassPart=skClassPart,stackIdent=skIdent,stackEnumLiteral=skEnumLiteral,stackEnumLiterals=skEnumLiterals,stackElementAttributes=skElementAttributes,stackTypeSpec=skTypeSpec,stackElementArgs=skElementArgs,stackEnumDef=skEnumDef,stackComment=skComment,stackBoolean=skBoolean,stackClassParts=skClassParts,stackBoolean2=skBoolean2,stackRestriction=skRestriction,stackClassDef=skClassDef,stackClass=skClass,stackPath=skPath,stackWithin=skWithin,stackProgram=skProgram,stacklstClass=sklstClass,stackString=skString,stackInteger=skInteger) := astStk;
  skString := inVal::skString;
  skToken := token::skToken;
  astStk2 := ASTSTACK(skToken,skMatrix,skOperator,skCase,skExpElseif,skExpElseifs,skCases,skNamedArg,skSubscript,skTypeSpecs,skVariability,skDirection,skImport,skEach,skElementArg,skArrayDim,skModification,skComponentCondition,skComponent,skComponentItems,skComponentItem,skConstrainClass,skRedeclareKeywords,skInnerOuter,skNamedArgs,skElementSpec,skElement,skElementItem,skElseif,skElseifs,skForIterator,skElsewhen,skElsewhens,skEquation,skEquationItem,skAlgElsewhen,skAlgElsewhens,skAlgElseif,skAlgElseifs,skForIterators,skFunctionArgs,skExp,skAlgorithm,skAlgorithmItem,skComponentRef,skExps,skAnnotation,skExternalDecl,skAlgorithmItems,skEquationItems,skElementItems,skClassPart,skIdent,skEnumLiteral,skEnumLiterals,skElementAttributes,skTypeSpec,skElementArgs,skEnumDef,skComment,skBoolean,skClassParts,skBoolean2,skRestriction,skClassDef,skClass,skPath,skWithin,skProgram,sklstClass,skString,skInteger);
end push;



public function trimquotes
"removes chars in charsToRemove from inString"
  input String inString;
  output String outString;
 algorithm
  if (stringLength(inString)>2) then
    outString := System.substring(inString,2,stringLength(inString)-1);
  else
    outString := "";
  end if;
end trimquotes;

function fixArray
  input ElementAttributes v1ElementAttributes;
  input TypeSpec v2TypeSpec;
  output ElementAttributes v1ElementAttributes2;
  output TypeSpec v2TypeSpec2;
  protected
   Boolean flowPrefix,b1,b2 "flow" ;
    Boolean streamPrefix "stream" ;
//    Boolean inner_ "inner";
//    Boolean outer_ "outer";
    Variability variability,v1 "variability ; parameter, constant etc." ;
    Direction direction,d1 "direction" ;
    Absyn.Parallelism parallelism;
    ArrayDim arrayDim,a1 "arrayDim" ;
    Path path,p1;
    Option<ArrayDim> oa1;
 algorithm 
   Absyn.ATTR(flowPrefix=b1,streamPrefix=b2,parallelism=Absyn.NON_PARALLEL(),variability=v1,direction=d1,arrayDim=a1) := v1ElementAttributes;
   
   Absyn.TPATH(path=p1,arrayDim=oa1) :=v2TypeSpec;
   
   a1 := match oa1 
     local ArrayDim l1;
      case SOME(l1)
       then (l1);
      case NONE() then ({});
    end match;    
        
   v1ElementAttributes2 := Absyn.ATTR(b1,b2,parallelism,v1,d1,a1);
   v2TypeSpec2 := Absyn.TPATH(p1,NONE());
   
end fixArray;

function printContentStack
  input AstStack astStk;
   protected
   list<Token> skToken;
  list<Path> skPath;
   list<ClassDef> skClassDef;
   list<Ident> skIdent;
   list<Class> skClass;
   list<Program> skProgram;
   list<lstClass> sklstClass;
   list<String> skString;
   list<Integer> skInteger;
algorithm
 ASTSTACK(stackToken=skToken,stackPath=skPath,stackClassDef=skClassDef,stackIdent=skIdent,stackClass=skClass,stackProgram=skProgram,stacklstClass=sklstClass,stackString=skString,stackInteger=skInteger) := astStk;
  
  print("\n Stack content:");
  print(" skToken:");
  print(intString(listLength(skToken)));
  print(" skPath:");
  print(intString(listLength(skPath)));
  print(" skClassDef:");
  print(intString(listLength(skClassDef)));
  print(" skIdent:");
  print(intString(listLength(skIdent)));
  print(" skClass:");
  print(intString(listLength(skClass)));
  print(" skProgram:");
  print(intString(listLength(skProgram)));
  print(" sklstClass:");
  print(intString(listLength(sklstClass)));
  print(" skString:");
  print(intString(listLength(skString)));
  print(" skInteger:");
  print(intString(listLength(skInteger)));
end printContentStack;


end ParseCodeModelica;