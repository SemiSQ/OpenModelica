// name:     CantileverBeam
// keywords: uncertainty, OpenTURNS, example
// teardown_command: rm -f *.bat *.log *.dtd *.xml *.c *.h *.exe *.a *.o *.mat OpenTURNSTests.CantileverBeam *.dll *.makefile *.libs
// status:   correct
// 
// The CantileverBeam example for OpenTURNS connectivity.
// 
loadModel(Modelica, {"3.1"}); getErrorString();
loadFile("TestModels/ThermoSysPro/package.mo");
loadFile("TestModels/OpenTURNSTests.mo");
pyscript := buildOpenTURNSInterface(OpenTURNSTests.CantileverBeam,"CantileverBeam_MC-template.py"); getErrorString();
//"read Python file";
//readFile("CantileverBeam_MC_dummy-OpenTURNSTests.CantileverBeam.py");
//"read XML file";
//readFile("CantileverBeam_wrapper.xml");
//"read Model_wrapper.c";
//readFile("CantileverBeam_wrapper.c");
//"read Model_wrapper.makefile";
//readFile("CantileverBeam_wrapper.makefile");
//"read Model_wrapper.log";
//readFile("CantileverBeam_wrapper.log"); getErrorString();
"run python script";
otlog := runOpenTURNSPythonScript(pyscript); getErrorString();
"read OpenTurns output log";
readFile(otlog); getErrorString();

// Result:
// true
// ""
// true
// true
// running: C:\msys\1.0\bin\sh.exe --login -c "cd \"c:/bin/cygwin/home/adrpo/dev/OpenModelica/testsuite/uncertainties\"; pwd; make -f CantileverBeam_wrapper.makefile" > CantileverBeam_wrapper.log 2>&1
// "CantileverBeam_MC_dummy-OpenTURNSTests.CantileverBeam.py"
// "read Python file"
// "

// from openturns import *

// from math import * 

// 

// # 4 distributions from Modelica model
// 
// distributionI = Beta(2.5,4.0,310.0,450.0)
// 
// distributionL = Uniform(250.0,260.0)
// 
// distributionE = Beta(0.93,3.2,28000000.0,48000000.0)
// 
// distributionF = LogNormal(30000.0,9000.0,15000.0, LogNormal.MUSIGMA)
// 

// RS = CorrelationMatrix(4)
// RS[0,1] = -0.2

// # Initialization of the distribution collection:
// collectionMarginals = DistributionCollection()
// collectionMarginals.add(Distribution(distributionI,\"I\"))
// collectionMarginals.add(Distribution(distributionL,\"L\"))
// collectionMarginals.add(Distribution(distributionE,\"E\"))
// collectionMarginals.add(Distribution(distributionF,\"F\"))

// # input descriptions currently not used, set above

// 

// # Use that function defined in the wrapper

// # Create a NumericalMathFunction from wrapper

// deviation = NumericalMathFunction(\"CantileverBeam_wrapper\")

// 

// dim = deviation.getInputDimension()

// print 'Dimension of input to modelica model: '

// print dim

// print '\\n'

// x = NumericalPoint (dim)

// x[0] = 10.

// x[1] = 20.

// x[2] = 30.

// x[3] = 30.

// print x

// y = deviation (x)

// print y

// "
// "read XML file"
// "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>
// <!--
// CantileverBeam.xml
// -->
// <!DOCTYPE wrapper SYSTEM \"wrapper.dtd\">
// <wrapper>
// <library>
// 
//  <!-- The path of the shared object -->
//  <path>CantileverBeam_wrapper.dll</path>
// 
//  <!-- This section describes all exchanges data between the wrapper and the platform -->
//  <description>
// 
//    <!-- Those variables are substituted in the files above -->
//    <!-- The order of variables is the order of the arguments of the function -->
//    <variable-list>
//     <variable id=\"F\" type=\"in\" />
//     <variable id=\"E\" type=\"in\" />
//     <variable id=\"L\" type=\"in\" />
//     <variable id=\"I\" type=\"in\" />
//     <variable id=\"y\" type=\"out\" />
//    </variable-list>
// 
//     <!-- The function that we try to execute through the wrapper -->
//    <function provided=\"yes\">CantileverBeam_wrapper</function>
//    <!-- the gradient is  defined  -->
//    <gradient provided=\"no\"></gradient>
//    <!--  the hessian is  defined  -->
//    <hessian provided=\"no\"></hessian>
//  </description>
// 
// </library>
// <external-code>
//   <!-- Those data are external to the platform (input files, etc.)-->
//   <data></data>
// 
//   <wrap-mode type=\"static-link\" >
//     <in-data-transfer mode=\"arguments\" />
//     <out-data-transfer mode=\"arguments\" />
//   </wrap-mode>
// 
//   <command># no command</command>
// </external-code>
// </wrapper>"
// "read Model_wrapper.c"
// "/* 
//  * OpenTurns wrapper code generated by OpenModelica 
//  * for model: OpenTURNSTests.CantileverBeam
//  */
// /**
//  *  @file  wrapper.c
//  *  @brief The wrapper adapts the interface of OpenTURNS and of the wrapped code
//  * 
//  */
// 
// #include \"Wrapper.h\"
// 
// #define WRAPPERNAME CantileverBeam_wrapper
// #define MODELNAMESTR \"OpenTURNSTests.CantileverBeam\"
// #include <stdio.h>
// #include <stdlib.h>
// #include <stdint.h>
// #include <errno.h>
// #include <string.h>
// #include <assert.h>
// 
// 
// 
// #ifndef OMC_READ_MATLAB4_H
// #define OMC_READ_MATLAB4_H
// 
// #include <stdio.h>
// #include <stdint.h>
// 
// extern const char *omc_mat_Aclass;
// 
// typedef struct {
//   uint32_t type;
//   uint32_t mrows;
//   uint32_t ncols;
//   uint32_t imagf;
//   uint32_t namelen;
// } MHeader_t;
// 
// typedef struct {
//   char *name,*descr;
//   int isParam;
//   /* Parameters are stored in data_1, variables in data_2; parameters are defined at any time, variables only within the simulation start/stop interval */
//   int index;
// } ModelicaMatVariable_t;
// 
// typedef struct {
//   FILE *file;
//   char *fileName;
//   uint32_t nall;
//   ModelicaMatVariable_t *allInfo; /* Sorted array of variables and their associated information */
//   uint32_t nparam;
//   double *params; /* This has size 2*nparam; the first parameter has row0=startTime,row1=stopTime. Other variables are stored as row0=row1 */
//   uint32_t nvar,nrows;
//   size_t var_offset; /* This is the offset in the file */
//   double **vars;
// } ModelicaMatReader;
// 
// /* Returns 0 on success; the error message on error.
//  * The internal data is free'd by omc_free_matlab4_reader.
//  * The data persists until free'd, and is safe to use in your own data-structures
//  */
// #ifdef __cplusplus
// extern \"C\" {
// #endif
// const char* omc_new_matlab4_reader(const char *filename, ModelicaMatReader *reader);
// 
// void omc_free_matlab4_reader(ModelicaMatReader *reader);
// 
// /* Returns a variable or NULL */
// ModelicaMatVariable_t *omc_matlab4_find_var(ModelicaMatReader *reader, const char *varName);
// 
// /* Writes the number of values in the returned array if nvals is non-NULL
//  * Returns all values that the given variable may have.
//  * Note: This function is _not_ defined for parameters; check var->isParam and then send the index
//  * No bounds checking is performed. The returned data persists until the reader is closed.
//  */
// double* omc_matlab4_read_vals(ModelicaMatReader *reader, int varIndex);
// 
// /* Returns 0 on success */
// int omc_matlab4_val(double *res, ModelicaMatReader *reader, ModelicaMatVariable_t *var, double time);
// 
// /* For debugging */
// void omc_matlab4_print_all_vars(FILE *stream, ModelicaMatReader *reader);
// 
// double omc_matlab4_startTime(ModelicaMatReader *reader);
// 
// double omc_matlab4_stopTime(ModelicaMatReader *reader);
// #ifdef __cplusplus
// } /* extern \"C\" */
// #endif
// 
// #endif
// 
// 
// int callOpenModelicaModel(STATE p_state, INPOINT inPoint, OUTPOINT outPoint, EXCHANGEDDATA p_exchangedData, ERROR p_error)
// {
//     int idx = 0;
//     int rc;
//     int exitCode = 0;
//     char *openModelicaHome = getenv(\"OPENMODELICAHOME\");
//     char systemCommand[5000] = {0};
//     char *variableName = NULL;
//     unsigned long variableType = 0;
//     /* read the model name from the included model_name.h file */
//     char *modelName = MODELNAMESTR;
//     char *modelInitFileName = NULL;
//     char *newModelInitFileNameTmp = \"OpenTurns_init.xml_tmp\";
//     char *newModelInitFileName = \"OpenTurns_init.xml\";
//     char *errorMsg = 0;
//     double variableValue = 0, stopTime = 0;
//     struct WrapperVariableList   *varLst = p_exchangedData->variableList_;
//     ModelicaMatReader matReader = {0};
//     modelInitFileName = (char*)malloc(strlen(modelName)+strlen(\"_init.xml\")+2);
//     sprintf(modelInitFileName, \"%s_init.xml\", modelName);
//     fprintf(stderr, \"Wrapper execution for model: %s\\n\", MODELNAMESTR); fflush(NULL);
//     if (!openModelicaHome)
//     {
//       SETERROR( \"Error: OPENMODELICAHOME is not set!\" );
//       return WRAPPER_EXECUTION_ERROR;
//     }
//     /* for each of the input variables change the start in the OpenModelica_init.xml file */
//     SETERROR( \"Creating OpenTurns_init.xml file with start values from OpenTurns and the rest from OpenModelica_init.xml file\" );
//     while (varLst != NULL)
//     {
//       if (varLst->variable_ == NULL)
//       {
//           SETERROR(\"The input variables structure is NULL\");
//           return WRAPPER_EXECUTION_ERROR;
//       }
//       variableName = varLst->variable_->id_;
//       variableType = varLst->variable_->type_;
// 
//       /* copy the _init.xml file to OpenTurns_init.xml */
//       sprintf(systemCommand, \"cp.exe %s %s\", modelInitFileName, newModelInitFileName);
//       exitCode = system(systemCommand);
//       if (exitCode)
//       {
//         SETERROR( \"Error writing input values in OpenTurns_init.xml file, command %s returned %d\", systemCommand, exitCode );
//         return WRAPPER_EXECUTION_ERROR;
//       }
// 
//       /* filter the output variables */
//       if (variableType == 0)
//       {
//         variableValue = inPoint->data_[idx];
//         /* update the variable in OpenModelica_init.xml */
//         sprintf(systemCommand, \"%s/share/omc/scripts/replace-startValue %s %g %s > %s\", openModelicaHome, variableName, variableValue, newModelInitFileName, newModelInitFileNameTmp);
//         exitCode = system(systemCommand);
//         if (exitCode)
//         {
//           SETERROR( \"Error writing input values in OpenTurns_init.xml file, command %s returned %d\", systemCommand, exitCode );
//           return WRAPPER_EXECUTION_ERROR;
//         }
// 
//         /* copy the OpenTurns_init.xml_tmp file to OpenTurns_init.xml */
//         sprintf(systemCommand, \"mv.exe -f %s %s\", newModelInitFileNameTmp, newModelInitFileName);
//         exitCode = system(systemCommand);
//         if (exitCode)
//         {
//           SETERROR( \"Error writing input values in OpenTurns_init.xml file, command %s returned %d\", systemCommand, exitCode );
//           return WRAPPER_EXECUTION_ERROR;
//         }
// 
//         idx++;
//       }
//       /* move to next */
//       varLst = varLst->next_;
//     }
//     SETERROR( \"Running the simulation executable with OpenTurns_init.xml file as input\" );
//     sprintf(systemCommand, \"%s -f %s\", MODELNAMESTR, newModelInitFileName);
//     exitCode = system(systemCommand);
//     if (exitCode)
//     {
//       SETERROR( \"Error executing the modelica model, command %s returned %d\", systemCommand, exitCode );
//       return WRAPPER_EXECUTION_ERROR;
//     }
//     sprintf(systemCommand, \"%s_res.mat\", MODELNAMESTR);
//     //fprintf(stderr, \"Reading the output values from %s Matlab file\\n\", systemCommand); fflush(NULL);
//     errorMsg = (char*)omc_new_matlab4_reader(systemCommand, &matReader);
//     if (errorMsg)
//     {
//       SETERROR( \"Error in calling the OpenModelica simulation code\" );
//       return WRAPPER_EXECUTION_ERROR;
//     }
//     stopTime = omc_matlab4_stopTime(&matReader);
// 
//     // reset values
//     idx = 0;
//     varLst = p_exchangedData->variableList_;
//     /* populate the outPoint! */
//     while (varLst)
//     {
//       variableName = varLst->variable_->id_;
//       variableType = varLst->variable_->type_;
//       /* filter the output variables */
//       if (variableType == 1)
//       {
//         /* read the variable at stop time */
//         ModelicaMatVariable_t *matVar = omc_matlab4_find_var(&matReader, variableName);
//         omc_matlab4_val(&variableValue, &matReader, matVar, stopTime);
//         // fprintf(stderr, \"10_: reading value from matlab %s:%g\\n\", variableName, variableValue); fflush(NULL);
//         outPoint->data_[idx] = variableValue;
//         idx++;
//       }
//       /* move to next */
//       varLst = varLst->next_;
//     }    
//     omc_free_matlab4_reader(&matReader);
//     return rc;
// }
// 
// BEGIN_C_DECLS
// WRAPPER_BEGIN
// 
// /*
//  *  This is the declaration of function named 'myWrapper' into the wrapper.
//  */
//   
// 
// 
// /*
// *********************************************************************************
// *                                                                               *
// *                             myWrapper function                                *
// *                                                                               *
// *********************************************************************************
// */
// 
//   /* The wrapper information informs the NumericalMathFunction object that loads the wrapper of the
//    * signatures of the wrapper functions. In particular, it hold the size of the input
//    * NumericalPoint (inSize_) and of the output NumericalPoint (outSize_).
//    * Those information are also used by the gradient and hessian functions to set the correct size
//    * of the returned matrix and tensor.
//    */
//   
//   /* The getInfo function is optional. Except if you alter the description of the wrapper, you'd better
//    * use the standard one automatically provided by the platform. Uncomment the following definition if
//    * you want to provide yours instead. */
//   /* FUNC_INFO( WRAPPERNAME , { } ) */
//     
//   /* The state creation/deletion functions allow the wrapper to create or delete a memory location
//    * that it will manage itself. It can save in this location any information it needs. The OpenTURNS
//    * platform only ensures that the wrapper will receive the state (= the memory location) it works
//    * with. If many wrappers are working simultaneously or if the same wrapper is called concurrently,
//    * this mechanism will avoid any collision or confusion.
//    * The consequence is that NO STATIC DATA should be used in the wrapper OR THE WRAPPER WILL BREAKE
//    * one day. You may think that you can't do without static data, but in general this is the case
//    * of a poor design. But if you persist to use static data, do your work correctly and make use
//    * of mutex (for instance) to protect your data against concurrent access. But don't complain about
//    * difficulties or poor computational performance! 
//    */
//     
//     
//   /* The createState function is optional. If you need to manage an internal state, uncomment the following
//    * definitions and adapt the source code to your needs. By default Open TURNS provides default ones. */
//   /* FUNC_CREATESTATE( WRAPPERNAME , {
//      CHECK_WRAPPER_MODE( WRAPPER_STATICLINK );
//      CHECK_WRAPPER_IN(   WRAPPER_ARGUMENTS  );
//      CHECK_WRAPPER_OUT(  WRAPPER_ARGUMENTS  );
//      
//      COPY_EXCHANGED_DATA_TO( p_p_state );
//      
//      PRINT( \"My message is here\" );
//      } ) */
//   
//   /* The deleteState function is optional. See FUNC_CREATESTATE for explanation. */
//   /* FUNC_DELETESTATE( WRAPPERNAME , {
//      DELETE_EXCHANGED_DATA_FROM( p_state );
//      } ) */
// 
//   /* Any function declared into the wrapper may declare three actual functions prefixed with
//    * 'init_', 'exec_' and 'finalize_' followed by the name of the function, here 'myWrapper'.
//    *
//    * The 'init_' function is only called once when the NumericalMathFunction object is created.
//    * It allows the wrapper to set some internal state, read some external file, prepare the function
//    * to run, etc.
//    *
//    * The 'exec_' function is intended to execute what the wrapper is done for: compute an mathematical
//    * function or anything else. It takes the internal state pointer as its first argument, the input
//    * NumericalPoint pointer as the second and the output NumericalPoint pointer as the third.
//    *
//    * The 'finalize_' function is only called once when the NumericalMathFunction object is destroyed.
//    * It allows the wrapper to flush anything before unloading.
//    *
//    * Only the 'exec_' function is mandatory because the other ones are automatically provided by the platform.
//    */
//     
//     
//   /**
//    * Initialization function
//    * This function is called once just before the wrapper first called to initialize
//    * it, ie create a temparary subdirectory (remember that the wrapper may be called
//    * concurrently), store exchanged data in some internal repository, do some
//    * pre-computational operation, etc. Uncomment the following definition if you want to
//    * do some pre-computation work.
//    */
//    FUNC_INIT( WRAPPERNAME , {
//        //struct WrapperVariableList   *varLst = p_exchangedData->variableList_;
//        //fprintf(stderr, \"CRAP_: %p\\n\", varLst->variable_); fflush(NULL);
//    } )
//       
// 
//   /**
//    * Execution function
//    * This function is called by the platform to do the real work of the wrapper. It may be
//    * called concurrently, so be aware of not using shared or global data not protected by
//    * a critical section.
//    * This function has a mathematical meaning. It operates on one vector (aka point) and
//    * returns another vector.
//    *
//    * This definition is MANDATORY.
//    */
//   FUNC_EXEC( WRAPPERNAME , 
//     {
//       //fprintf(stderr, \"executing wrapper for OpenModelica model: %s\\n\", MODELNAMESTR); fflush(NULL);
//       //fprintf(stderr, \"CRAP_1: %s\\n\", p_exchangedData->variableList_->variable_->id_); fflush(NULL);
// 
//       int rc = callOpenModelicaModel(p_state, inPoint, outPoint, p_exchangedData, p_error);
//       if (rc) 
//       {
//         PRINT( \"Error in calling the OpenModelica simulation code\" );
//         return WRAPPER_EXECUTION_ERROR;
//       }
//     })
//   
//   /**
//    * Finalization function
//    * This function is called once just before the wrapper is unloaded. It is the place to flush
//    * any output file or free any allocated memory. When this function returns, the wrapper is supposed
//    * to have all its work done, so it is not possible to get anymore information from it after that.
//    * Uncomment the following definition if you need to do some post-computation work. See FUNC_INIT. */
//   /* FUNC_FINALIZE( WRAPPERNAME , {} ) */
// 
// 
// WRAPPER_END
// END_C_DECLS
// 
// 
// #define size_omc_mat_Aclass 45
// const char *omc_mat_Aclass = \"A1 bt. ir1 na  Tj  re  ac  nt  so   r   y   \";
// const char *dymola_mat_Aclass = \"A1 bt.\\0ir1 na\\0 Nj  oe  rc  mt  ao  lr  \\0y\\0\\0\\0\";
// 
// int omc_matlab4_comp_var(const void *a, const void *b)
// {
//   char *as = ((ModelicaMatVariable_t*)a)->name;
//   char *bs = ((ModelicaMatVariable_t*)b)->name;
//   return strcmp(as,bs);
// }
// 
// int mat_element_length(int type)
// {
//   int m = (type/1000);
//   int o = (type%1000)/100;
//   int p = (type%100)/10;
//   int t = (type%10);
//   if (m) return -1; /* We require IEEE Little Endian for now */
//   if (o) return -1; /* Reserved number; forced 0 */
//   if (t == 1 && p != 5) return -1; /* Text matrix? Force element length=1 */
//   if (t == 2) return -1; /* Sparse matrix fails */
//   switch (p) {
//     case 0: return 8;
//     case 1: return 4;
//     case 2: return 4;
//     case 3: return 2;
//     case 4: return 2;
//     case 5: return 1;
//     default: return -1;
//   }
// }
// 
// /* Do not double-free this :) */
// void omc_free_matlab4_reader(ModelicaMatReader *reader)
// {
//   unsigned int i;
//   fclose(reader->file);
//   free(reader->fileName); reader->fileName=NULL;
//   for (i=0; i<reader->nall; i++) {
//     free(reader->allInfo[i].name);
//     free(reader->allInfo[i].descr);
//   }
//   free(reader->allInfo); reader->allInfo=NULL;
//   free(reader->params); reader->params=NULL;
//   for (i=0; i<reader->nvar*2; i++)
//     if (reader->vars[i]) free(reader->vars[i]);
//   free(reader->vars); reader->vars=NULL;
// }
// 
// /* Returns 0 on success; the error message on error */
// const char* omc_new_matlab4_reader(const char *filename, ModelicaMatReader *reader)
// {
//   typedef const char *_string;
//   const int nMatrix=6;
//   _string matrixNames[6]={\"Aclass\",\"name\",\"description\",\"dataInfo\",\"data_1\",\"data_2\"};
//   const int matrixTypes[6]={51,51,51,20,0,0};
//   int i;
//   char binTrans = 1;
//   reader->file = fopen(filename, \"rb\");
//   if (!reader->file) return strerror(errno);
//   reader->fileName = strdup(filename);
//   for (i=0; i<nMatrix;i++) {
//     MHeader_t hdr;
//     int nr = fread(&hdr,sizeof(MHeader_t),1,reader->file);
//     int matrix_length,element_length;
//     char *name;
//     if (nr != 1) return \"Corrupt header (1)\";
//     /* fprintf(stderr, \"Found matrix type=%04d mrows=%d ncols=%d imagf=%d namelen=%d\\n\", hdr.type, hdr.mrows, hdr.ncols, hdr.imagf, hdr.namelen); */
//     if (hdr.type != matrixTypes[i]) return \"Matrix type mismatch\";
//     if (hdr.imagf > 1) return \"Matrix uses imaginary numbers\";
//     if ((element_length = mat_element_length(hdr.type)) == -1) return \"Could not determine size of matrix elements\";
//     name = (char*) malloc(hdr.namelen);
//     nr = fread(name,hdr.namelen,1,reader->file);
//     if (nr != 1) return \"Corrupt header (2)\";
//     if (name[hdr.namelen-1]) return \"Corrupt header (3)\";
//     /* fprintf(stderr, \"  Name of matrix: %s\\n\", name); */
//     matrix_length = hdr.mrows*hdr.ncols*(1+hdr.imagf)*element_length;
//     if (0 != strcmp(name,matrixNames[i])) return \"Matrix name mismatch\";
//     free(name); name=NULL;
//     switch (i) {
//     case 0: {
//       char tmp[size_omc_mat_Aclass];
//       if (fread(tmp,size_omc_mat_Aclass-1,1,reader->file) != 1) return \"Corrupt header: Aclass matrix\";
//       tmp[size_omc_mat_Aclass-1] = '\\0';
//      /* binTrans */
//      if (0 == strncmp(tmp,omc_mat_Aclass,size_omc_mat_Aclass))  {
//         /* fprintf(stderr, \"use binTrans format\\n\"); */
//         binTrans = 1;
//       } else if (0 == strncmp(tmp,dymola_mat_Aclass,size_omc_mat_Aclass))  {
//         /* binNormal */
//         /* fprintf(stderr, \"use binNormal format\\n\"); */
//         binTrans = 0;
//       } 
//       else return \"Aclass matrix does not match the magic number\";
//       break;
//     }
//     case 1: { /* \"names\" */
//       unsigned int i;
//       if (binTrans==0)
//          reader->nall = hdr.mrows;
//       else
//         reader->nall = hdr.ncols;
//       reader->allInfo = (ModelicaMatVariable_t*) malloc(sizeof(ModelicaMatVariable_t)*reader->nall);
//       if (binTrans==1) {
//         for (i=0; i<hdr.ncols; i++) {
//           reader->allInfo[i].name = (char*) malloc(hdr.mrows+1);
//           if (fread(reader->allInfo[i].name,hdr.mrows,1,reader->file) != 1) return \"Corrupt header: names matrix\";
//           reader->allInfo[i].name[hdr.mrows] = '\\0';
//           reader->allInfo[i].isParam = -1;
//           reader->allInfo[i].index = -1;
//           /* fprintf(stderr, \"    Adding variable %s\\n\", reader->allInfo[i].name); */
//          }
//       }
//       if (binTrans==0) {
//       uint32_t j;
//       char* tmp = (char*) malloc(hdr.ncols*hdr.mrows+1);
//         if (fread(tmp,hdr.ncols*hdr.mrows,1,reader->file) != 1)  {
//           free(tmp);
//           return \"Corrupt header: names matrix\";
//         }
//         for (i=0; i<hdr.mrows; i++) {
//           reader->allInfo[i].name = (char*) malloc(hdr.ncols+1);
//           for(j=0; j<hdr.ncols; j++) {
//             reader->allInfo[i].name[j] = tmp[j*hdr.mrows+i];   
//           }
//           reader->allInfo[i].name[hdr.ncols] = '\\0';
//           reader->allInfo[i].isParam = -1;
//           reader->allInfo[i].index = -1;
//           /* fprintf(stderr, \"    Adding variable %s\\n\", reader->allInfo[i].name); */
//         }
//         free(tmp);
//       }
//       break;
//     }
//     case 2: { /* description */
//       unsigned int i;
//       if (binTrans==1) {
//         for (i=0; i<hdr.ncols; i++) {
//           reader->allInfo[i].descr = (char*) malloc(hdr.mrows+1);
//           if (fread(reader->allInfo[i].descr,hdr.mrows,1,reader->file) != 1) return \"Corrupt header: names matrix\";
//           reader->allInfo[i].descr[hdr.mrows] = '\\0';
//          }
//       } else if (binTrans==0) {
//         uint32_t j;
//         char* tmp = (char*) malloc(hdr.ncols*hdr.mrows+1);
//         if (fread(tmp,hdr.ncols*hdr.mrows,1,reader->file) != 1)  {
//           free(tmp);
//           return \"Corrupt header: names matrix\";
//         }
//         for (i=0; i<hdr.mrows; i++) {
//           reader->allInfo[i].descr = (char*) malloc(hdr.ncols+1);
//           for(j=0; j<hdr.ncols; j++) {
//             reader->allInfo[i].descr[j] = tmp[j*hdr.mrows+i];   
//           }
//           reader->allInfo[i].descr[hdr.ncols] = '\\0';
//           /* fprintf(stderr, \"    Adding variable %s\\n\", reader->allInfo[i].name); */
//         }
//         free(tmp);
//       }
//       break;
//     }
//     case 3: { /* \"dataInfo\" */
//       unsigned int i;
//       int32_t *tmp = (int32_t*) malloc(sizeof(int32_t)*hdr.ncols*hdr.mrows);
//       if (1 != fread(tmp,sizeof(int32_t)*hdr.ncols*hdr.mrows,1,reader->file)) {
//         free(tmp); tmp=NULL;
//         return \"Corrupt header: dataInfo matrix\";
//       }
//       if (binTrans==1) {
//         for (i=0; i<hdr.ncols; i++) {
//           reader->allInfo[i].isParam = tmp[i*hdr.mrows] == 1;
//           reader->allInfo[i].index = tmp[i*hdr.mrows+1];
//           /* fprintf(stderr, \"    Variable %s isParam=%d index=%d\\n\", reader->allInfo[i].name, reader->allInfo[i].isParam, reader->allInfo[i].index); */
//         }
//       }
//       if (binTrans==0) {
//         for (i=0; i<hdr.mrows; i++) {
//           reader->allInfo[i].isParam = tmp[i] == 1;
//           reader->allInfo[i].index =  tmp[i + hdr.mrows];
//           /* fprintf(stderr, \"    Variable %s isParam=%d index=%d\\n\", reader->allInfo[i].name, reader->allInfo[i].isParam, reader->allInfo[i].index); */
//         }
//       }
//       free(tmp); tmp=NULL;
//       /* Sort the variables so we can do faster lookup */
//       qsort(reader->allInfo,reader->nall,sizeof(ModelicaMatVariable_t),omc_matlab4_comp_var);
//       break;
//     }
//     case 4: { /* \"data_1\" */
//       if (binTrans==1) {
//         unsigned int i;
//         if (hdr.mrows == 0) return \"data_1 matrix does not contain at least 1 variable\";
//         if (hdr.ncols != 2) return \"data_1 matrix does not have 2 rows\";
//         reader->nparam = hdr.mrows;
//         reader->params = (double*) malloc(hdr.mrows*hdr.ncols*sizeof(double));
//         if (1 != fread(reader->params,matrix_length,1,reader->file)) return \"Corrupt header: data_1 matrix\";
//         /* fprintf(stderr, \"    startTime = %.6g\\n\", reader->params[0]);
//         * fprintf(stderr, \"    stopTime = %.6g\\n\", reader->params[1]); */
//         for (i=1; i<reader->nparam; i++) {
//           if (reader->params[i] != reader->params[i+reader->nparam]) return \"data_1 matrix contained parameter that changed between start and stop-time\";
//           /* fprintf(stderr, \"    Parameter[%d] = %.6g\\n\", i, reader->params[i]); */
//         }
//       }
//       if (binTrans==0) {
//         unsigned int i,j;
//         double *tmp=NULL;
//         if (hdr.ncols == 0) return \"data_1 matrix does not contain at least 1 variable\";
//         if (hdr.mrows != 2) return \"data_1 matrix does not have 2 rows\";
//         reader->nparam = hdr.ncols;
//         tmp = (double*) malloc(hdr.mrows*hdr.ncols*sizeof(double));
//         reader->params = (double*) malloc(hdr.mrows*hdr.ncols*sizeof(double));
//         if (1 != fread(tmp,matrix_length,1,reader->file)) return \"Corrupt header: data_1 matrix\";
//         for (i=0; i<hdr.mrows; i++) {
//           for (j=0; j<hdr.ncols; j++) {
//             reader->params[i*hdr.ncols+j] = tmp[i +j*hdr.mrows];
//           }
//         }
//         free(tmp);
//         for (i=1; i<reader->nparam; i++) {
//           if (reader->params[i] != reader->params[i+reader->nparam]) return \"data_1 matrix contained parameter that changed between start and stop-time\";
//         }
//       }
//       break;
//     }
//     case 5: { /* \"data_2\" */
//       if (binTrans==1) {
//         reader->nrows = hdr.ncols;
//         reader->nvar = hdr.mrows;
//         if (reader->nrows < 2) return \"Too few rows in data_2 matrix\";
//         reader->var_offset = ftell(reader->file);
//         reader->vars = (double**) calloc(reader->nvar*2,sizeof(double*));
//         if (-1==fseek(reader->file,matrix_length,SEEK_CUR)) return \"Corrupt header: data_2 matrix\";
//       }
//       if (binTrans==0) {
//         unsigned int i,j;
//         double *tmp=NULL;
//         reader->nrows = hdr.mrows;
//         reader->nvar = hdr.ncols;
//         if (reader->nrows < 2) return \"Too few rows in data_2 matrix\";
//         reader->var_offset = ftell(reader->file);
//         reader->vars = (double**) calloc(reader->nvar*2,sizeof(double*));
//         tmp = (double*) malloc(hdr.mrows*hdr.ncols*sizeof(double));
//         if (1 != fread(tmp,matrix_length,1,reader->file)) return \"Corrupt header: data_2 matrix\";
//         for (i=0; i<hdr.ncols; i++) {
//           reader->vars[i] = (double*) malloc(hdr.mrows*sizeof(double));
//           for (j=0; j<hdr.mrows; j++) {
//             reader->vars[i][j] = tmp[j+i*hdr.mrows];
//           }
//         }
//         for (i=reader->nvar; i<reader->nvar*2; i++) {
//           reader->vars[i] = (double*) malloc(hdr.mrows*sizeof(double));
//           for (j=0; j<hdr.mrows; j++) {
//             reader->vars[i][j] = -reader->vars[i-reader->nvar][j];
//           }
//         }
//         free(tmp);
//         if (-1==fseek(reader->file,matrix_length,SEEK_CUR)) return \"Corrupt header: data_2 matrix\";
//       }
//       break;
//     }
//     default:
//       return \"Implementation error: Unknown case\";
//     }
//   };
//   return 0;
// }
// 
// ModelicaMatVariable_t *omc_matlab4_find_var(ModelicaMatReader *reader, const char *varName)
// {
//   ModelicaMatVariable_t key;
//   key.name = (char*) varName;
//   return (ModelicaMatVariable_t*)bsearch(&key,reader->allInfo,reader->nall,sizeof(ModelicaMatVariable_t),omc_matlab4_comp_var);
// }
// 
// /* Writes the number of values in the returned array if nvals is non-NULL */
// double* omc_matlab4_read_vals(ModelicaMatReader *reader, int varIndex)
// {
//   size_t absVarIndex = abs(varIndex);
//   size_t ix = (varIndex < 0 ? absVarIndex + reader->nvar : absVarIndex) -1;
//   assert(absVarIndex > 0 && absVarIndex <= reader->nvar);
//   if (!reader->vars[ix]) {
//     unsigned int i;
//     double *tmp = (double*) malloc(reader->nrows*sizeof(double));
//     for (i=0; i<reader->nrows; i++) {
//       fseek(reader->file,reader->var_offset + sizeof(double)*(i*reader->nvar + absVarIndex-1), SEEK_SET);
//       if (1 != fread(&tmp[i], sizeof(double), 1, reader->file)) {
//         /* fprintf(stderr, \"Corrupt file at %d of %d? nvar %d\\n\", i, reader->nrows, reader->nvar); */
//         free(tmp);
//         tmp=NULL;
//         return NULL;
//       }
//       if (varIndex < 0) tmp[i] = -tmp[i];
//       /* fprintf(stderr, \"tmp[%d]=%g\\n\", i, tmp[i]); */
//     }
//     reader->vars[ix] = tmp;
//   }
//   return reader->vars[ix];
// }
// 
// double omc_matlab4_read_single_val(double *res, ModelicaMatReader *reader, int varIndex, int timeIndex)
// {
//   size_t absVarIndex = abs(varIndex);
//   size_t ix = (varIndex < 0 ? absVarIndex + reader->nvar : absVarIndex) -1;
//   assert(absVarIndex > 0 && absVarIndex <= reader->nvar);
//   if (reader->vars[ix]) {
//     *res = reader->vars[ix][timeIndex];
//     return 0;
//   }
//   fseek(reader->file,reader->var_offset + sizeof(double)*(timeIndex*reader->nvar + absVarIndex-1), SEEK_SET);
//   if (1 != fread(res, sizeof(double), 1, reader->file))
//     return 1;
//   if (varIndex < 0)
//     *res = -(*res);
//   return 0;
// }
// 
// void find_closest_points(double key, double *vec, int nelem, int *index1, double *weight1, int *index2, double *weight2)
// {
//   int min = 0;
//   int max = nelem-1;
//   int mid;
//   /* fprintf(stderr, \"search closest: %g in %d elem\\n\", key, nelem); */
//   do {
//     mid = min + (max-min)/2;
//     if (key == vec[mid]) {
//       /* If we have events (multiple identical time stamps), use the right limit */
//       while (mid < max && vec[mid] == vec[mid+1]) mid++;
//       *index1 = mid;
//       *weight1 = 1.0;
//       *index2 = -1;
//       *weight2 = 0.0;
//       return;
//     } else if (key > vec[mid]) {
//       min = mid + 1;
//     } else {
//       max = mid - 1;
//     }
//   } while (max > min);
//   if (max == min) {
//     if (key > vec[max])
//       max++;
//     else
//       min--;
//   }
//   *index1 = max;
//   *index2 = min;
//   /* fprintf(stderr, \"closest: %g = (%d,%g),(%d,%g)\\n\", key, min, vec[min], max, vec[max]); */
//   *weight1 = (key - vec[min]) / (vec[max]-vec[min]);
//   *weight2 = 1.0 - *weight1;
// }
// 
// double omc_matlab4_startTime(ModelicaMatReader *reader)
// {
//   return reader->params[0];
// }
// 
// double omc_matlab4_stopTime(ModelicaMatReader *reader)
// {
//   return reader->params[reader->nparam];
// }
// 
// /* Returns 0 on success */
// int omc_matlab4_val(double *res, ModelicaMatReader *reader, ModelicaMatVariable_t *var, double time)
// {
//   if (var->isParam) {
//     if (var->index < 0)
//       *res = -reader->params[abs(var->index)-1];
//     else
//       *res = reader->params[var->index-1];
//   } else {
//     double w1,w2,y1,y2;
//     int i1,i2;
//     if (time > omc_matlab4_stopTime(reader)) return 1;
//     if (time < omc_matlab4_startTime(reader)) return 1;
//     if (!omc_matlab4_read_vals(reader,1)) return 1;
//     find_closest_points(time, reader->vars[0], reader->nrows, &i1, &w1, &i2, &w2);
//     if (i2 == -1) {
//       return (int)omc_matlab4_read_single_val(res,reader,var->index,i1);
//     } else if (i1 == -1) {
//       return (int)omc_matlab4_read_single_val(res,reader,var->index,i2);
//     } else {
//       if (omc_matlab4_read_single_val(&y1,reader,var->index,i1)) return 1;
//       if (omc_matlab4_read_single_val(&y2,reader,var->index,i2)) return 1;
//       *res = w1*y1 + w2*y2;
//       return 0;
//     }
//   }
//   return 0;
// }
// 
// void omc_matlab4_print_all_vars(FILE *stream, ModelicaMatReader *reader)
// {
//   unsigned int i;
//   fprintf(stream, \"allSortedVars(\\\"%s\\\") => {\", reader->fileName);
//   for (i=0; i<reader->nall; i++)
//     fprintf(stream, \"\\\"%s\\\",\", reader->allInfo[i].name);
//   fprintf(stream, \"}\\n\");
// }
// 
// #if 0
// int main(int argc, char** argv)
// {
//   ModelicaMatReader reader;
//   const char *msg;
//   int i;
//   double r;
//   ModelicaMatVariable_t *var;
//   if (argc < 2) {
//     fprintf(stderr, \"Usage: %s filename.mat var0 ... varn\\n\", *argv);
//     exit(1);
//   }
//   if (0 != (msg=omc_new_matlab4_reader(argv[1],&reader))) {
//     fprintf(stderr, \"%s is not in the MATLAB4 subset accepted by OpenModelica: %s\\n\", argv[1], msg);
//     exit(1);
//   }
//   omc_matlab4_print_all_vars(stderr, &reader);
//   for (i=2; i<argc; i++) {
//     int printAll = *argv[i] == '.';
//     char *name = argv[i] + printAll;
//     var = omc_matlab4_find_var(&reader, name);
//     if (!var) {
//       fprintf(stderr, \"%s not found\\n\", name);
//     } else if (printAll) {
//       int n,j;
//       if (var->isParam) {
//         fprintf(stderr, \"%s is param, but tried to read all values\", name);
//         continue;
//       }
//       double *vals = omc_matlab4_read_vals(&n,&reader,var->index);
//       if (!vals) {
//         fprintf(stderr, \"%s = #FAILED TO READ VALS\", name);
//       } else {
//         fprintf(stderr, \"  allValues(%s) => {\", name);
//         for (j=0; j<n; j++)
//           fprintf(stderr, \"%g,\", vals[j]);
//         fprintf(stderr, \"}\\n\");
//       }
//     } else {
//       int j;
//       double ts[4] = {-1.0,0.0,0.1,1.0};
//       for (j=0; j<4; j++)
//         if (0==omc_matlab4_val(&r,&reader,var,ts[j]))
//           fprintf(stderr, \"  val(\\\"%s\\\",%4g) => %g\\n\", name, ts[j], r);
//         else
//           fprintf(stderr, \"  val(\\\"%s\\\",%4g) => fail()\\n\", name, ts[j]);
//     }
//   }
//   omc_free_matlab4_reader(&reader);
//   return 0;
// }
// #endif
// "
// "read Model_wrapper.makefile"
// "#
// #  Makefile generated by OpenModelica for OpenTURNS
// #  for model: OpenTURNSTests.CantileverBeam
// #
// 
// # the wrapper name has the name of the model
// WRAPPER_NAME=CantileverBeam_wrapper
// 
// DEFINES=-DPACKAGE_NAME=\\\"\\\" -DPACKAGE_TARNAME=\\\"\\\" -DPACKAGE_VERSION=\\\"\\\" -DPACKAGE_STRING=\\\"\\\" -DPACKAGE_BUGREPORT=\\\"\\\" -DPACKAGE=\\\"${WRAPPER_NAME}\\\" \\
// -DVERSION=\\\"0.0\\\" -DSTDC_HEADERS=1 -DHAVE_SYS_TYPES_H=1 -DHAVE_SYS_STAT_H=1 -DHAVE_STDLIB_H=1 -DHAVE_STRING_H=1 -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1 \\
// -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1 -DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_UNISTD_H=1 -DHAVE_DLFCN_H=1 -DHAVE_PTHREAD_H=1
// 
// CFLAGS = -g -O2 -I. -Ic:/openturns/include/openturns -I/cluster/opt/mingw-3.4.5/opt/libxml2/include/libxml2 -I/cluster/opt/mingw-3.4.5/opt/regex/include
// LDFLAGS = -L/c/mingw/lib -L/c/MinGW/lib \\
// -Lc:/openturns/lib/bin -L/cluster/opt/mingw-3.4.5/opt/libxml2/lib \\
// -L/cluster/opt/mingw-3.4.5/opt/regex/lib -L/c/openturns/bin \\
// /c/OpenTURNS/lib/openturns/libOT.dll.a -lOTbind-0 \\
// /c/mingw/lib/libxml2.dll.a /c/mingw/lib/libgnurx.dll.a \\
// /c/mingw/lib/libpthreadGC2.dll.a -Wl,--image-base=0x10000000 -Wl,--out-implib,${WRAPPER_NAME}.dll.a
// 
// all: ${WRAPPER_NAME}.dll
// 
// ${WRAPPER_NAME}.o: ${WRAPPER_NAME}.c
// 	gcc -o ${WRAPPER_NAME}.o -c ${WRAPPER_NAME}.c $(DEFINES) $(CFLAGS) 
// 
// ${WRAPPER_NAME}.dll: ${WRAPPER_NAME}.o 
// 	gcc $(DEFINES) -shared  ${WRAPPER_NAME}.o -o ${WRAPPER_NAME}.dll $(LDFLAGS)
// 
// clean: 
// 	rm -f ${WRAPPER_NAME}.o ${WRAPPER_NAME}.dll ${WRAPPER_NAME}.dll.a
// "
// "read Model_wrapper.log"
// "/c/bin/cygwin/home/adrpo/dev/OpenModelica/testsuite/uncertainties
// gcc -o CantileverBeam_wrapper.o -c CantileverBeam_wrapper.c -DPACKAGE_NAME=\\\"\\\" -DPACKAGE_TARNAME=\\\"\\\" -DPACKAGE_VERSION=\\\"\\\" -DPACKAGE_STRING=\\\"\\\" -DPACKAGE_BUGREPORT=\\\"\\\" -DPACKAGE=\\\"CantileverBeam_wrapper\\\" -DVERSION=\\\"0.0\\\" -DSTDC_HEADERS=1 -DHAVE_SYS_TYPES_H=1 -DHAVE_SYS_STAT_H=1 -DHAVE_STDLIB_H=1 -DHAVE_STRING_H=1 -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1 -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1 -DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_UNISTD_H=1 -DHAVE_DLFCN_H=1 -DHAVE_PTHREAD_H=1 -g -O2 -I. -Ic:/openturns/include/openturns -I/cluster/opt/mingw-3.4.5/opt/libxml2/include/libxml2 -I/cluster/opt/mingw-3.4.5/opt/regex/include 
// gcc -DPACKAGE_NAME=\\\"\\\" -DPACKAGE_TARNAME=\\\"\\\" -DPACKAGE_VERSION=\\\"\\\" -DPACKAGE_STRING=\\\"\\\" -DPACKAGE_BUGREPORT=\\\"\\\" -DPACKAGE=\\\"CantileverBeam_wrapper\\\" -DVERSION=\\\"0.0\\\" -DSTDC_HEADERS=1 -DHAVE_SYS_TYPES_H=1 -DHAVE_SYS_STAT_H=1 -DHAVE_STDLIB_H=1 -DHAVE_STRING_H=1 -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1 -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1 -DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_UNISTD_H=1 -DHAVE_DLFCN_H=1 -DHAVE_PTHREAD_H=1 -shared  CantileverBeam_wrapper.o -o CantileverBeam_wrapper.dll -L/c/mingw/lib -L/c/MinGW/lib -Lc:/openturns/lib/bin -L/cluster/opt/mingw-3.4.5/opt/libxml2/lib -L/cluster/opt/mingw-3.4.5/opt/regex/lib -L/c/openturns/bin /c/OpenTURNS/lib/openturns/libOT.dll.a -lOTbind-0 /c/mingw/lib/libxml2.dll.a /c/mingw/lib/libgnurx.dll.a /c/mingw/lib/libpthreadGC2.dll.a -Wl,--image-base=0x10000000 -Wl,--out-implib,CantileverBeam_wrapper.dll.a
// Info: resolving _setError by linking to __imp__setError (auto-import)
// Info: resolving _printUserMessage by linking to __imp__printUserMessage (auto-import)
// Creating library file: CantileverBeam_wrapper.dll.a
// c:\\MinGW\\bin\\..\\lib\\gcc\\mingw32\\3.4.5\\..\\..\\..\\..\\mingw32\\bin\\ld.exe: warning: auto-importing has been activated without --enable-auto-import specified on the command line.
// This should work unless it involves constant data structures referencing symbols from auto-imported DLLs.
// "
// ""
// "run python script"
// running: CantileverBeam_MC_dummy-OpenTURNSTests.CantileverBeam.py.bat > CantileverBeam_MC_dummy-OpenTURNSTests.CantileverBeam.py.log 2>&1
// "CantileverBeam_MC_dummy-OpenTURNSTests.CantileverBeam.py.log"
// "read OpenTurns output log"
// "
// c:\\bin\\cygwin\\home\\adrpo\\dev\\OpenModelica\\testsuite\\uncertainties>rem @echo off 
// 
// c:\\bin\\cygwin\\home\\adrpo\\dev\\OpenModelica\\testsuite\\uncertainties>rem .bat file generated by OpenModelica for calling OpenTURNS 
// 
// c:\\bin\\cygwin\\home\\adrpo\\dev\\OpenModelica\\testsuite\\uncertainties>echo \"set wrapper path so OpenTRUNS finds our wrapper\" 
// \"set wrapper path so OpenTRUNS finds our wrapper\"
// 
// c:\\bin\\cygwin\\home\\adrpo\\dev\\OpenModelica\\testsuite\\uncertainties>set OPENTURNS_WRAPPER_PATH=c:\\bin\\cygwin\\home\\adrpo\\dev\\OpenModelica\\testsuite\\uncertainties 
// 
// c:\\bin\\cygwin\\home\\adrpo\\dev\\OpenModelica\\testsuite\\uncertainties>echo \"copy the wrapper.dtd to the current directory\" 
// \"copy the wrapper.dtd to the current directory\"
// 
// c:\\bin\\cygwin\\home\\adrpo\\dev\\OpenModelica\\testsuite\\uncertainties>copy C:\\OpenTURNS\\lib\\openturns\\wrappers\\wrapper*.dtd .\\ 
// C:\\OpenTURNS\\lib\\openturns\\wrappers\\wrapper-v2.dtd
// C:\\OpenTURNS\\lib\\openturns\\wrappers\\wrapper.dtd
//         2 file(s) copied.
// 
// c:\\bin\\cygwin\\home\\adrpo\\dev\\OpenModelica\\testsuite\\uncertainties>echo \"remove the pause from pyot!\" 
// \"remove the pause from pyot!\"
// 
// c:\\bin\\cygwin\\home\\adrpo\\dev\\OpenModelica\\testsuite\\uncertainties>cat.exe C:\\OpenTURNS\\bin\\pyot.bat   | grep.exe -v pause  1>pyot.bat 
// 
// c:\\bin\\cygwin\\home\\adrpo\\dev\\OpenModelica\\testsuite\\uncertainties>echo \"call pyot from openturns\" 
// \"call pyot from openturns\"
// 
// c:\\bin\\cygwin\\home\\adrpo\\dev\\OpenModelica\\testsuite\\uncertainties>.\\pyot.bat CantileverBeam_MC_dummy-OpenTURNSTests.CantileverBeam.py 
// Wrapper execution for model: OpenTURNSTests.CantileverBeam
// Dimension of input to modelica model: 
// 4
// 
// 
// [10,20,30,30]
// [130208]
// Welcome to OpenTURNS version 1.0
// "
// ""
// endResult
