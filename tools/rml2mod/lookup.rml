(*
   Copyright 2005, Adrian Pop, adrpo@ida.liu.se
*)

(**
 ** file:	 lookup.rml
 ** module:      Lookup
 ** description: population of a dictionary with some stuff
 **
 **)

module Lookup:

  with "absyn.rml"
  with "dictionary.rml"
  with "moddump.rml"

  (* dictionary for anything in a package *)
  datatype data =  FUNC  of  string list * 				(* input  *)
                             string list  				(* output *)
			    |  CTOR  of  string list  				(* constructor *)
 			    |  TYPE  of  Absyn.Ident *
			    		     Absyn.ClassDef *
			    		     Absyn.Restriction          (* types *)

  (* dictionary for the packages *)
  datatype pkg = D of data Dictionary.dict

  relation traverseProgram: (pkg Dictionary.dict, Absyn.Program) => pkg Dictionary.dict

  relation fixType: (data Dictionary.dict, Absyn.ClassDef) => Absyn.ClassDef

  relation fixTypeSpec:(Absyn.TypeSpec, data Dictionary.dict) => Absyn.TypeSpec

end

with "util.rml"

datatype holder = I of string list (* input  *)
                | O of string list (* output *)
				| R of string list (* record *)

(* Relations *)

relation traverseProgram =

  		(* a program should contain just a package in MetaModelica *)
  rule	traverseParts(Dictionary.emptyDict, parts) => dataDict &
  		(* fixTypesInDataDictionary("eh",dataDict) => dataDict & *)
		Dictionary.insert(dict, n, D(dataDict)) => pkgDict
		------------------------------------------------------------------------
		traverseProgram(dict,
			Absyn.PROGRAM(
				[Absyn.CLASS(n,p,f,e,Absyn.R_PACKAGE,Absyn.PARTS(parts,optcmt))],
				w)) => pkgDict

  rule print "This is not MetaModelica!\nShould be just one package at the top level!\n"
       ---------------------------------
       traverseProgram(dict, _) => fail

end


relation traverseClass =

  		(* uniontypes with parts *)
  rule	traverseParts(dict, parts) => dataDict
        ---------------------------------------------
		traverseClass(true, dict,
		Absyn.CLASS(n,p,f,e,r as Absyn.R_UNIONTYPE,
			Absyn.PARTS(parts,optcmt))) => dataDict

  		(* records with parts *)
  rule	getComponentNames(parts) => lst &
		getRecordNames(lst) => names &
		list_length(names) => len &
		int_gt(len, 0) => true & (* put it inside only if it has parts *)
        Dictionary.insert(dict, n, CTOR(names)) => dataDict &
        -----------------------------------------------------------------
		traverseClass(false, dict,
		Absyn.CLASS(n,p,f,e,r as Absyn.R_RECORD, Absyn.PARTS(parts,optcmt))) => dataDict

  rule	(* print "RECORD-traverseParts:" & print n & print "\n"& *)
		traverseParts(dict, parts) => dataDict &
        -----------------------------------------------------------------
		traverseClass(true, dict,
		Absyn.CLASS(n,p,f,e,r as Absyn.R_RECORD, Absyn.PARTS(parts,optcmt))) => dataDict

(*
  rule	getComponentNames(parts) => lst &
		getInputNames(lst) => inNames &
		getOutputNames(lst) => outNames &
        Dictionary.insert(dict, n, FUNC(inNames,outNames)) => dataDict &
        --------------------------------------------------------------------------
		traverseClass(false, dict,
		Absyn.CLASS(n,false,f,e,r as Absyn.R_FUNCTION,Absyn.PARTS(parts,optcmt))) => dataDict
*)

  rule	(* traverse only no-partial functions *)
  		(* print "FUNCTION-traverseParts:" & print n & print "\n"&	*)
		traverseParts(dict, parts) => dataDict &
        --------------------------------------------------------------------------
		traverseClass(true, dict,
		Absyn.CLASS(n,false,f,e,r as Absyn.R_FUNCTION,Absyn.PARTS(parts,optcmt))) => dataDict


  rule	(* search dictionary for eveything in cdef and update cdef *)
  		Dictionary.search(dict, n) => NONE &
  		fixType(dict, cdef) => newCDef &
  		Dictionary.insert(dict, n, TYPE(n,newCDef,r)) => dataDict
        --------------------------------------------------------------
		traverseClass(true, dict, Absyn.CLASS(n,p,f,e,r as Absyn.R_TYPE, cdef)) => dataDict

  rule	(* search dictionary for eveything in cdef and update cdef *)
  		Dictionary.search(dict, n) => SOME(_) &
  		fixType(dict, cdef) => newCDef &
  		Dictionary.update(dict, n, TYPE(n,newCDef,r)) => dataDict
        --------------------------------------------------------------
		traverseClass(true, dict, Absyn.CLASS(n,p,f,e,r as Absyn.R_TYPE, cdef)) => dataDict

  rule	(* search dictionary for eveything in cdef and update cdef *)
  		Dictionary.search(dict, n) => NONE &
  		(*
		print "Inserting type:" & print n & print " = " &
		ModDump.print_type_spec(typeSpec) &
		*)
  		fixType(dict, cdef) => newCDef &
  		(* insert the newCDef in dictionary *)
  		Dictionary.insert(dict, n, TYPE(n,newCDef,r)) => newDict &
  		(* search for all the types that has n in them and replace n with newCDef *)
  		fixTypesInDataDictionary(n, newDict) => dataDict &
  		(*
  		Dictionary.search(dataDict, n) => SOME(TYPE(_,Absyn.DERIVED(typeSpec2,_,_,_),_)) &
		print "[" & ModDump.print_type_spec(typeSpec2) & print "]\n"
		*)
        --------------------------------------------------------------
		traverseClass(true, dict, Absyn.CLASS(n,p,f,e,r as Absyn.R_TYPE_GENERATED,
			cdef as Absyn.DERIVED(typeSpec, _, _, _))) => dataDict

  rule	(* search dictionary for eveything in cdef and update cdef *)
  		Dictionary.search(dict, n) => SOME(_) &
  		fixType(dict, cdef) => newCDef &
  		(* insert the newCDef in dictionary *)
  		Dictionary.update(dict, n, TYPE(n,newCDef,r)) => newDict &
  		(* search for all the types that has n in them and replace n with newCDef *)
  		fixTypesInDataDictionary(n, newDict) => dataDict
        --------------------------------------------------------------
		traverseClass(true, dict, Absyn.CLASS(n,p,f,e,r as Absyn.R_TYPE_GENERATED, cdef)) => dataDict

  (* don't care about others *)
  axiom	traverseClass(_, dict, _) => dict

end

relation getRecordNames =

  axiom getRecordNames([]) => []

  rule	getRecordNames(rest) => names2 &
		list_append(names1, names2) => names
        ---------------------------------------
		getRecordNames(R(names1)::rest) => names

  rule	getRecordNames(rest) => names
        --------------------------------
		getRecordNames(_::rest) => names


end

relation getInputNames =

  axiom getInputNames([]) => []

  rule	getInputNames(rest) => names2 &
		list_append(names1, names2) => names
        ---------------------------------------
		getInputNames(I(names1)::rest) => names

  rule	getInputNames(rest) => names
        -------------------------------------
		getInputNames(_::rest) => names

end

relation getOutputNames =

  axiom getOutputNames([]) => []

  rule	getOutputNames(rest) => names2 &
		list_append(names1, names2) => names
        ---------------------------------------
		getOutputNames(O(names1)::rest) => names

  rule	getOutputNames(rest) => names
        -------------------------------------
		getOutputNames(_::rest) => names

end


relation traverseParts =

  axiom	traverseParts (dict,[]) => dict

  rule	traversePart(dict, hd) => newDict &
		traverseParts(newDict,rest) => dataDict
		----------------------------------------
		traverseParts(dict,hd::rest) => dataDict
end

relation traversePart =

  axiom	traversePart(dict, Absyn.PUBLIC([])) => dict
  axiom	traversePart(dict, Absyn.PROTECTED([])) => dict

  rule	traverseElements(dict, els) => newDict
		------------------------------------------------
		traversePart(dict, Absyn.PUBLIC(els)) => newDict

  rule	traverseElements(dict, els) => newDict
		------------------------------------------------
		traversePart(dict, Absyn.PROTECTED(els)) => newDict

  rule	traverseAlgorithmItems(dict, algsItems) => newDict
		----------------------------------------------------------
		traversePart(dict, Absyn.ALGORITHMS(algsItems)) => newDict

  (* don't care about the rest *)
  axiom	traversePart(dict, _) => dict

end

relation traverseElements =

  axiom	traverseElements(dict, []) => dict

  rule	traverseElementItem(dict, hd) => newDict &
		traverseElements(newDict, rest) => dataDict
		----------------
		traverseElements(dict, hd::rest) => dataDict
end

relation traverseElementItem =

  rule	traverseElement(dict, e) => newDict
		----------------------------------------------------------
		traverseElementItem(dict, Absyn.ELEMENTITEM(e)) => newDict

  axiom traverseElementItem(dict, _) => dict

end

relation traverseElement =

		(* only no-replaceable elements please *)
  rule	traverseClass(true, dict, cls) => newDict &
  		traverseClass(false, newDict, cls) => newDict
        ----------------------------------------------------------------------------------------
		traverseElement(dict, Absyn.ELEMENT(_,false,_,_,Absyn.CLASSDEF(_, cls), _, _, _)) => newDict



  axiom traverseElement(dict, _) => dict

end

relation getComponentNames =

  axiom	getComponentNames([]) => []

  rule	getComponentName(hd) => names1 &
		getComponentNames(rest) => names2 &
		list_append(names1, names2) => names
		------------------------------------
		getComponentNames(hd::rest) => names
end

relation getComponentName =

  rule	sweepElements(els) => names
		-----------------------------------------
		getComponentName(Absyn.PUBLIC(els)) => names

  rule
		-----------------------------------------
		getComponentName(_) => []

end

relation sweepElements =

  axiom	sweepElements([]) => []

  rule	sweepElementItem(hd) => names1 &
		sweepElements(rest) => names2 &
		list_append(names1, names2) => names
		-----------------------------------------
		sweepElements(hd::rest) => names
end

relation sweepElementItem =

  rule	sweepElement(e) => names
		-----------------------------------------------
		sweepElementItem(Absyn.ELEMENTITEM(e)) => names

  axiom sweepElementItem(_) => []

end

relation sweepElement =

  rule	sweepComponents(components) => names
        ------------------------------------------------------------------------------------
		sweepElement(Absyn.ELEMENT(_,_,_,_,
		Absyn.COMPONENTS(Absyn.ATTR(_,_,Absyn.BIDIR),_,components), _, _, _)) => [R(names)]

  rule	sweepComponents(components) => names
        ------------------------------------------------------------------------------------
		sweepElement(Absyn.ELEMENT(_,_,_,_,
		Absyn.COMPONENTS(Absyn.ATTR(_,_,Absyn.INPUT),_,components), _, _, _)) => [I(names)]

  rule	sweepComponents(components) => names
        ------------------------------------------------------------------------------------
		sweepElement(Absyn.ELEMENT(_,_,_,_,
		Absyn.COMPONENTS(Absyn.ATTR(_,_,Absyn.OUTPUT),_,components), _, _, _)) => [O(names)]

  axiom sweepElement(_) => []

end

relation sweepComponents =

  axiom	sweepComponents([]) => []

  rule	sweepComponentItem(hd) => names1 &
		sweepComponents(rest) => names2 &
		list_append(names1, names2) => names
		-----------------------------------------
		sweepComponents(hd::rest) => names
end

relation sweepComponentItem =

  rule	sweepComponent(e) => names
		------------------------------------------------------
		sweepComponentItem(Absyn.COMPONENTITEM(e, _)) => names

  axiom sweepComponentItem(_) => []

end

relation sweepComponent =

  axiom sweepComponent(Absyn.COMPONENT(name, _, _)) => [name]

end


relation fixTypeSpec:(Absyn.TypeSpec, data Dictionary.dict) => Absyn.TypeSpec =

	rule Dictionary.search(dict, x) =>
		 SOME(TYPE(_,Absyn.DERIVED(tspec,_,_,_),Absyn.R_TYPE_GENERATED)) &
		 fixTypeSpec(tspec, dict) => tspec &
		 --------------------------------------------------------------------
		 fixTypeSpec(ts as Absyn.TPATH(Absyn.IDENT(x)), dict) => tspec

	rule Dictionary.search(dict, x) => NONE
		 ------------------------------------------------------------------
		 fixTypeSpec(y as Absyn.TPATH(Absyn.IDENT(x)), dict) => y

	rule Util.list_map1(fixTypeSpec, typeSpecLst, dict) => newTypeSpecLst
		 ----------------------------------------------------------------------
		 fixTypeSpec(Absyn.TCOMPLEX(x, typeSpecLst), dict) =>
		 Absyn.TCOMPLEX(x, newTypeSpecLst)

	axiom fixTypeSpec(ts, dict) => ts

end

relation fixType: (data Dictionary.dict, Absyn.ClassDef) => Absyn.ClassDef =

	rule fixTypeSpec(typeSpec, dict) => newTypeSpec
		 --------------------------------------------------------------------------------
		 fixType(dict, Absyn.DERIVED(typeSpec,x,y,z)) => Absyn.DERIVED(newTypeSpec,x,y,z)

	axiom fixType(dict, x) => x

end


relation fixTypesInDataDictionaryLst =


	axiom fixTypesInDataDictionaryLst(n, dict, []) => dict

	rule fixType(dict, cdef) => newCdef &
		 Dictionary.update(dict, nm, TYPE(nm, newCdef, r)) => newDict &
		 fixTypesInDataDictionaryLst(n, newDict, rest) => newerDict
		 ----------------------------------------------------------------------------------
		 fixTypesInDataDictionaryLst(n, dict, (x,SOME(TYPE(nm,cdef,r)))::rest) => newerDict

	rule fixTypesInDataDictionaryLst(n, dict, rest) => newDict
		 ----------------------------------------------------------------------------------
		 fixTypesInDataDictionaryLst(n, dict, x::rest) => newDict

end

(* try to reach a fixpoint here *)
relation fixTypesInDataDictionary =

	rule Dictionary.toList(dict) => lstDict &
		 fixTypesInDataDictionaryLst(n, dict, lstDict) => dict &
		 (*
		 Dictionary.toList(dict) => lstDict &
		 fixTypesInDataDictionaryLst(n, dict, lstDict) => dict &
		 *)
		 ----------------------------------------------------------
		 fixTypesInDataDictionary(n, dict) => dict

end

relation traverseAlgorithmItems =

  axiom	traverseAlgorithmItems(dict, []) => dict

  rule	traverseAlgorithmItem(dict, first) => dict &
		traverseAlgorithmItems(dict, rest) => dict &
		--------------------------------------------------
		traverseAlgorithmItems(dict, first::rest) => dict

end

relation traverseAlgorithmItem =

  rule	traverseAlgorithm(dict, alg) => dict
		-----------------------------------------------------------------
		traverseAlgorithmItem(dict, Absyn.ALGORITHMITEM(alg, c)) => dict

  axiom traverseAlgorithmItem(dict, x) => dict

end

(* Algorithm clauses *)
relation traverseAlgorithm =

  rule	traverseElements(dict, eilist) =>  dict &
        traverseCases(dict, clist) => dict
		--------------------------------------------------------------------
		traverseAlgorithm(dict, Absyn.ALG_MATCH(x,exp,eilist,clist)) => dict

  axiom traverseAlgorithm(dict, x) => dict

end

relation traverseCase =

  rule	traverseElements(dict, el) =>  dict
		---------------------------------------------------------
		traverseCase(dict, Absyn.CASE(pl,el,cp,exp,com,endcom)) => dict

end

relation traverseCases =

  axiom	traverseCases(dict, []) => dict

  rule	traverseCase(dict, first) => dict &
		traverseCases(dict, rest) => dict &
		----------------------------------------
		traverseCases(dict, first::rest) => dict

end
