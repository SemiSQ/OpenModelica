(*
   Copyright 2006, Adrian Pop, adrpo@ida.liu.se
*)

(**
 ** file:	 modrefactortypes.rml
 ** module:      ModRefactorTypes
 ** description: refactoring of MetaModelica code
 **
 ** adrpo@ida
 **
 **)

module ModRefactorTypes:

  with "absyn.rml"
  with "dictionary.rml"
  with "lookup.rml"
  with "external.rml"
  with "modrefactor.rml"

  datatype carry = C of Absyn.Transformed list *
  						string list *
  						Lookup.pkg Dictionary.dict * (* global dictionary *)
  						string *                     (* current package   *)
  						string *					 (* current function  *)
  						Lookup.data Dictionary.dict  (* local dictionary used in functions *)

  relation transformFiles:
  	(Absyn.Transformed list, ModRefactor.carry) => Absyn.Transformed list

end

with "util.rml"
with "moddump.rml"
(* Relations *)

relation transformFiles =

	axiom transformFiles([], _) => []

	rule transformProgram(program, C(x,y,dict,n,z,Dictionary.emptyDict)) => transProgram &
		 transformFiles(rest, ModRefactor.C(x,y,dict,n,z)) => transformedFiles &
		 list_append([Absyn.TRANSFORMED(file, transProgram)], transformedFiles) => res
		 -----------------------------------------------------------------------------
		 transformFiles(
		 	Absyn.TRANSFORMED(file, program)::rest,
		 	ModRefactor.C(x,y,dict,n,z)) => res

end

relation transformProgram =

	axiom transformProgram(Absyn.PROGRAM([],x), junk) => Absyn.PROGRAM([],x)

	rule transformPackage(pkg, junk) => trPkg
		 -------------------------------------------------------------------------------
		 transformProgram(Absyn.PROGRAM([pkg],w), junk) => Absyn.PROGRAM([trPkg], w)

	rule print "MetaModelica accepts only a top package that includes everything!\n"
		 ---------------------------------------------------------------------------
		 transformProgram(_, _) => fail
end


(*
 * We're intrested only in CLASS, MODEL, PACKAGE, FUNCTION, TYPE
 *)
relation filter: Absyn.Restriction => bool =
  axiom filter (R_CLASS)     		=> true
  axiom filter (R_MODEL)     		=> true
  axiom filter (R_PACKAGE)   		=> true
  axiom filter (R_FUNCTION)  		=> true
  axiom filter (R_UNIONTYPE)  		=> true
  axiom filter (R_RECORD)	  		=> true
  axiom filter (_) 					=> false
end

relation transformPackage =

rule	(* print "Transforming the package\n" & *)
		Util.list_map1(transformPart, parts, C(x,y,dict,n,z,local)) => trParts
		----------------------------------------------------------------------------------
		transformPackage(
		Absyn.CLASS(n,p,f,e,r as Absyn.R_PACKAGE,Absyn.PARTS(parts,optcmt)),
		C(x,y,dict,_,z,local)) =>
		Absyn.CLASS(n,p,f,e,r,Absyn.PARTS(trParts, optcmt))

  axiom transformPackage(x, junk) => x

end

relation transformClass =

rule	filter(r) => true &
        (* print "Transforming parts\n" & *)
		Util.list_map1(transformPart, parts, C(x,y,d,z,n,local)) => trParts
		----------------------------------------------------------------------------------
		transformClass(Absyn.CLASS(n,p,f,e,r,Absyn.PARTS(parts,optcmt)), C(x,y,d,z,w,local)) =>
		[Absyn.CLASS(n,p,f,e,r,Absyn.PARTS(trParts, optcmt))]


  rule
  		Dictionary.search(pkgDict,  currentPkg) => SOME(Lookup.D(dataDict)) &
		Lookup.fixType(dataDict,x) => newCDef &
		(*
		print "\nModRefactorTypes-R_TYPE_GENERATED:" & print n &
		*)
		----------------------------------------------------------------------------------
		transformClass(
			Absyn.CLASS(n,p,f,e,
				r as Absyn.R_TYPE_GENERATED,
				x as Absyn.DERIVED(typeSpec,_,_,_)),
				C(_,_,pkgDict,currentPkg,_,_)) => [] (* [Absyn.CLASS(n,p,f,e,r,newCDef)] *)

  rule	Dictionary.search(pkgDict,  currentPkg) => SOME(Lookup.D(dataDict)) &
		Lookup.fixType(dataDict,x) => newCDef &
		(*
		print "\nModRefactorTypes-R_TYPE:" & print n &
		*)
		----------------------------------------------------------------------------------
		transformClass(
			Absyn.CLASS(n,p,f,e,
				r as Absyn.R_TYPE,
				x as Absyn.DERIVED(typeSpec,_,_,_)),
				C(_,_,pkgDict,currentPkg,_,_)) =>
			[Absyn.CLASS(n,p,f,e,r,newCDef)]

  axiom transformClass(x, junk) => [x]

end

relation transformPart =

  rule  transformElementItemLst(els, junk) =>  trEls
        --------------------------------------------------------------
		transformPart(Absyn.PUBLIC(els), junk) => Absyn.PUBLIC(trEls)

  rule  transformElementItemLst(els, junk) => trEls
        --------------------------------------------------------------------
		transformPart(Absyn.PROTECTED(els), junk) => Absyn.PROTECTED(trEls)

  rule  Util.list_map1(transformEquationItem, eqs, junk) => trEqs
		--------------------------------------------------------------------
		transformPart(Absyn.EQUATIONS(eqs), junk) => Absyn.EQUATIONS(trEqs)

  rule	Util.list_map1(transformEquationItem, eqs, junk) => trEqs
		----------------------------------------------------------------------------------
		transformPart(Absyn.INITIALEQUATIONS(eqs), junk) => Absyn.INITIALEQUATIONS(trEqs)

  rule	Util.list_map1(transformAlgorithmItem, algs, junk) => trAlgs
		-----------------------------------------------------------------------
		transformPart(Absyn.ALGORITHMS(algs), junk) => Absyn.ALGORITHMS(trAlgs)

  rule	Util.list_map1(transformAlgorithmItem, algs, junk) => trAlgs
		--------------------------------------------------------------------------------------
		transformPart(Absyn.INITIALALGORITHMS(algs), junk) => Absyn.INITIALALGORITHMS(trAlgs)

  axiom transformPart(x, junk) => x

end

relation transformElementItemLst =

  axiom transformElementItemLst([], _) => []

  rule	transformElementItem(x, junk) => [el] &
  		transformElementItemLst(rest, junk) => elList
		-----------------------------------------------------------------------------------
		transformElementItemLst(x::rest, junk) => el::elList

  rule	transformElementItem(x, junk) => [] &
  		transformElementItemLst(rest, junk) => elList
		-----------------------------------------------------------------------------------
		transformElementItemLst(x::rest, junk) => elList

end

relation transformElementItem =

  rule	transformElement(e, junk) => []
		-----------------------------------------------------------------------------------
		transformElementItem(Absyn.ELEMENTITEM(e), junk) => []

  rule	transformElement(e, junk) => [newElement]
		-----------------------------------------------------------------------------------
		transformElementItem(Absyn.ELEMENTITEM(e), junk) => [Absyn.ELEMENTITEM(newElement)]

  axiom transformElementItem(x, _) => [x]

end


relation transformElement =

  rule	transformClass(cls, junk) => []
        ----------------------------------------------------------------------------------------
		transformElement(Absyn.ELEMENT(a,false,c,d,Absyn.CLASSDEF(e, cls), f, g, h), junk) => []

  rule	transformClass(cls, junk) => [newClass]
        ----------------------------------------------------------------------------------------
		transformElement(Absyn.ELEMENT(a,b as false,c,d,Absyn.CLASSDEF(e, cls), f, g, h), junk) =>
		[Absyn.ELEMENT(a,b,c,d,Absyn.CLASSDEF(e, newClass), f, g, h)]

  rule	Dictionary.search(pkgDict,  currentPkg) => SOME(Lookup.D(dataDict)) &
		(* print "\nModRefactorTypes-COMPONENTS:" & *)
		(* print "Lookup type:" & ModDump.print_type_spec(typeSpec) & print "\n" & *)
		Lookup.fixTypeSpec(typeSpec,dataDict) => newTypeSpec &
		Lookup.fixTypeSpec(newTypeSpec,dataDict) => newTypeSpec	&
		(* print "Changed type:" & ModDump.print_type_spec(newTypeSpec) & print "\n" & *)
        ----------------------------------------------------------------------------------------
		transformElement(Absyn.ELEMENT(a,b,c,d,Absyn.COMPONENTS(x, typeSpec, clst), f, g, h),
		C(_,_,pkgDict,currentPkg,_,local)) =>
		[Absyn.ELEMENT(a,b,c,d,Absyn.COMPONENTS(x, newTypeSpec, clst), f, g, h)]

  axiom transformElement(x, junk) => [x]

end

(* Equations & Algorithms *)

relation transformEquationItem =

  axiom transformEquationItem(x, junk) => x

end

relation transformAlgorithmItem =

  rule	(* print "Transforming algorithms\n" & *)
        transformAlgorithm(alg, junk) => algTr
		------------------------------------------------------------------------------------------
		transformAlgorithmItem(Absyn.ALGORITHMITEM(alg, c), junk) => Absyn.ALGORITHMITEM(algTr, c)

  axiom transformAlgorithmItem(x, junk) => x

end

relation transformEquation =

  axiom transformEquation(x, junk) => x

end

(* Algorithm clauses *)
relation transformAlgorithm =

  rule	transformElementItemLst(eilist, junk) =>  trEls &
        transformCases(clist, junk) => newCases
		----------------------------------------------------------------
		transformAlgorithm(Absyn.ALG_MATCH(x,exp,eilist,clist), junk) =>
		Absyn.ALG_MATCH(x,exp,trEls,newCases)

  axiom transformAlgorithm(x, junk) => x

end

relation transformCase =

  rule	transformElementItemLst(el, junk) =>  trEls
		---------------------------------------------------------
		transformCase(Absyn.CASE(pl,el,cp,exp,com,endcom),
			junk as C(_,_,d,pkg,currentScopeName,_)) =>
		Absyn.CASE(pl,trEls,cp,exp,com,endcom)

end

relation transformCases =

  axiom	transformCases([], junk) => []

  rule	transformCase(first, junk) => newCase &
		transformCases(rest, junk) => newCases &
		list_append([newCase],newCases) => res
		--------------------------------------
		transformCases(first::rest, junk) => res

end
